//
// Generated by swagger-codegen
// https://github.com/swagger-api/swagger-codegen
//

import Foundation



public class AcceleratorList: Codable {





















    public var entities: [AcceleratorMetadata]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var previousUri: String?
    public var nextUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [AcceleratorMetadata]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, previousUri: String?, nextUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.previousUri = previousUri
        self.nextUri = nextUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class AcknowledgeScreenRecordingRequest: Codable {







    public var participantJid: String?
    public var roomId: String?
    public var conversationId: String?

    public init(participantJid: String?, roomId: String?, conversationId: String?) {
        self.participantJid = participantJid
        self.roomId = roomId
        self.conversationId = conversationId
    }


}




public class ActionAggregateQueryFilter: Codable {

    public enum ModelType: String, Codable { 
        case and = "and"
        case or = "or"
    }





    /** Boolean operation to apply to the provided predicates and clauses */
    public var type: ModelType?
    /** Boolean 'and/or' logic with up to two-levels of nesting */
    public var clauses: [ActionAggregateQueryClause]?
    /** Like a three-word sentence: (attribute-name) (operator) (target-value). */
    public var predicates: [ActionAggregateQueryPredicate]?

    public init(type: ModelType?, clauses: [ActionAggregateQueryClause]?, predicates: [ActionAggregateQueryPredicate]?) {
        self.type = type
        self.clauses = clauses
        self.predicates = predicates
    }


}




public class ActionEventActionMap: Codable {









    /** The ID of the action map. */
    public var _id: String?
    public var selfUri: String?
    /** The version of the action map. */
    public var version: Int?
    /** Display name of the action map. */
    public var displayName: String?

    public init(_id: String?, selfUri: String?, version: Int?, displayName: String?) {
        self._id = _id
        self.selfUri = selfUri
        self.version = version
        self.displayName = displayName
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
        case version
        case displayName
    }


}




public class ActionMap: Codable {









































    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The version of the action map. */
    public var version: Int?
    /** Whether the action map is active. */
    public var isActive: Bool?
    /** Display name of the action map. */
    public var displayName: String?
    /** Trigger action map if any segment in the list is assigned to a given customer. */
    public var triggerWithSegments: [String]?
    /** List of event conditions that must be satisfied to trigger the action map. */
    public var triggerWithEventConditions: [EventCondition]?
    /** (deprecated - use triggerWithOutcomeQuantileConditions instead) Probability conditions for outcomes that must be satisfied to trigger the action map. */
    public var triggerWithOutcomeProbabilityConditions: [OutcomeProbabilityCondition]?
    /** (deprecated - use triggerWithOutcomeQuantileConditions instead) Percentile conditions for outcomes that must be satisfied to trigger the action map. */
    public var triggerWithOutcomePercentileConditions: [OutcomePercentileCondition]?
    /** Quantile conditions for outcomes that must be satisfied to trigger the action map. */
    public var triggerWithOutcomeQuantileConditions: [OutcomeQuantileCondition]?
    /** URL conditions that a page must match for web actions to be displayable. */
    public var pageUrlConditions: [UrlCondition]?
    /** Type of activation. */
    public var activation: Activation?
    /** Weight of the action map with higher number denoting higher weight. */
    public var weight: Int?
    /** The action that will be executed if this action map is triggered. */
    public var action: ActionMapAction?
    /** The action map's associated schedule groups. */
    public var actionMapScheduleGroups: ActionMapScheduleGroups?
    /** Override organization-level frequency cap and always offer web engagements from this action map. */
    public var ignoreFrequencyCap: Bool?
    /** The URI for this object */
    public var selfUri: String?
    /** Timestamp indicating when the action map was created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var createdDate: Date?
    /** Timestamp indicating when the action map was last updated. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var modifiedDate: Date?
    /** Timestamp at which the action map is scheduled to start firing. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var startDate: Date?
    /** Timestamp at which the action map is scheduled to stop firing. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var endDate: Date?

    public init(_id: String?, version: Int?, isActive: Bool?, displayName: String?, triggerWithSegments: [String]?, triggerWithEventConditions: [EventCondition]?, triggerWithOutcomeProbabilityConditions: [OutcomeProbabilityCondition]?, triggerWithOutcomePercentileConditions: [OutcomePercentileCondition]?, triggerWithOutcomeQuantileConditions: [OutcomeQuantileCondition]?, pageUrlConditions: [UrlCondition]?, activation: Activation?, weight: Int?, action: ActionMapAction?, actionMapScheduleGroups: ActionMapScheduleGroups?, ignoreFrequencyCap: Bool?, selfUri: String?, createdDate: Date?, modifiedDate: Date?, startDate: Date?, endDate: Date?) {
        self._id = _id
        self.version = version
        self.isActive = isActive
        self.displayName = displayName
        self.triggerWithSegments = triggerWithSegments
        self.triggerWithEventConditions = triggerWithEventConditions
        self.triggerWithOutcomeProbabilityConditions = triggerWithOutcomeProbabilityConditions
        self.triggerWithOutcomePercentileConditions = triggerWithOutcomePercentileConditions
        self.triggerWithOutcomeQuantileConditions = triggerWithOutcomeQuantileConditions
        self.pageUrlConditions = pageUrlConditions
        self.activation = activation
        self.weight = weight
        self.action = action
        self.actionMapScheduleGroups = actionMapScheduleGroups
        self.ignoreFrequencyCap = ignoreFrequencyCap
        self.selfUri = selfUri
        self.createdDate = createdDate
        self.modifiedDate = modifiedDate
        self.startDate = startDate
        self.endDate = endDate
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case version
        case isActive
        case displayName
        case triggerWithSegments
        case triggerWithEventConditions
        case triggerWithOutcomeProbabilityConditions
        case triggerWithOutcomePercentileConditions
        case triggerWithOutcomeQuantileConditions
        case pageUrlConditions
        case activation
        case weight
        case action
        case actionMapScheduleGroups
        case ignoreFrequencyCap
        case selfUri
        case createdDate
        case modifiedDate
        case startDate
        case endDate
    }


}




public class ActionMapListing: Codable {





















    public var entities: [ActionMap]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var previousUri: String?
    public var nextUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [ActionMap]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, previousUri: String?, nextUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.previousUri = previousUri
        self.nextUri = nextUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class Activation: Codable {





    /** Type of activation. */
    public var type: String?
    /** Activation delay time amount. */
    public var delayInSeconds: Int?

    public init(type: String?, delayInSeconds: Int?) {
        self.type = type
        self.delayInSeconds = delayInSeconds
    }


}




public class ActivityPlanResponse: Codable {











    public enum ModelType: String, Codable { 
        case individual = "Individual"
        case group = "Group"
    }



















    public enum OptimizationObjective: String, Codable { 
        case favorServiceGoals = "FavorServiceGoals"
        case favorSchedulingAll = "FavorSchedulingAll"
    }



    public enum State: String, Codable { 
        case active = "Active"
        case inactive = "Inactive"
    }

















    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The name of the activity plan */
    public var name: String?
    /** The management units to which this activity plan applies. Empty list or null means this activity plan applies to the entire business unit */
    public var managementUnits: [ManagementUnitReference]?
    /** The description of this activity plan */
    public var _description: String?
    /** The activity code associated with this activity plan. It is recommended to load and cache the entire list of activity codes rather than look up individual codes */
    public var activityCode: ActivityCodeReference?
    /** The type of the activity plan */
    public var type: ModelType?
    /** The initial schedule period of the activity plan */
    public var initialSchedulePeriod: SchedulingPeriod?
    /** The length of the activity in minutes */
    public var lengthMinutes: Int?
    /** Group settings for this activity plan */
    public var groupSettings: GroupSettings?
    /** Recurrence settings for this activity plan */
    public var recurrenceSettings: RecurrenceSettings?
    /** Attendee search rule for this activity plan */
    public var attendeesSearchRule: UserSearchRule?
    /** Whether the sessions created by this activity plan should be facilitated */
    public var facilitated: Bool?
    /** Facilitator search rule for this activity plan */
    public var facilitatorsSearchRule: UserSearchRule?
    /** Transition time in minutes between facilitated sessions */
    public var transitionTimeMinutes: Int?
    /** Allowable service goal impact override settings for this activity plan */
    public var serviceGoalImpactOverrides: ActivityPlanServiceGoalImpactOverrides?
    /** The optimization objective of this activity plan */
    public var optimizationObjective: OptimizationObjective?
    /** Fixed availability configuration for this activity plan */
    public var fixedAvailability: [FixedAvailability]?
    /** The state of this activity plan */
    public var state: State?
    /** Whether the activity should count as paid time */
    public var countsAsPaidTime: Bool?
    /** The date the activity plan was created, in ISO-8601 format */
    public var createdDate: Date?
    /** The user who created this activity plan */
    public var createdBy: UserReference?
    /** The date the activity plan was modified, in ISO-8601 format */
    public var modifiedDate: Date?
    /** The last user to modify this activity plan. The id may be 'System' if it was an automated process */
    public var modifiedBy: UserReference?
    /** The date on which the activity plan was last manually run, in ISO-8601 format */
    public var lastRunDate: Date?
    /** The last user to run this activity plan */
    public var lastRunBy: UserReference?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, managementUnits: [ManagementUnitReference]?, _description: String?, activityCode: ActivityCodeReference?, type: ModelType?, initialSchedulePeriod: SchedulingPeriod?, lengthMinutes: Int?, groupSettings: GroupSettings?, recurrenceSettings: RecurrenceSettings?, attendeesSearchRule: UserSearchRule?, facilitated: Bool?, facilitatorsSearchRule: UserSearchRule?, transitionTimeMinutes: Int?, serviceGoalImpactOverrides: ActivityPlanServiceGoalImpactOverrides?, optimizationObjective: OptimizationObjective?, fixedAvailability: [FixedAvailability]?, state: State?, countsAsPaidTime: Bool?, createdDate: Date?, createdBy: UserReference?, modifiedDate: Date?, modifiedBy: UserReference?, lastRunDate: Date?, lastRunBy: UserReference?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.managementUnits = managementUnits
        self._description = _description
        self.activityCode = activityCode
        self.type = type
        self.initialSchedulePeriod = initialSchedulePeriod
        self.lengthMinutes = lengthMinutes
        self.groupSettings = groupSettings
        self.recurrenceSettings = recurrenceSettings
        self.attendeesSearchRule = attendeesSearchRule
        self.facilitated = facilitated
        self.facilitatorsSearchRule = facilitatorsSearchRule
        self.transitionTimeMinutes = transitionTimeMinutes
        self.serviceGoalImpactOverrides = serviceGoalImpactOverrides
        self.optimizationObjective = optimizationObjective
        self.fixedAvailability = fixedAvailability
        self.state = state
        self.countsAsPaidTime = countsAsPaidTime
        self.createdDate = createdDate
        self.createdBy = createdBy
        self.modifiedDate = modifiedDate
        self.modifiedBy = modifiedBy
        self.lastRunDate = lastRunDate
        self.lastRunBy = lastRunBy
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case managementUnits
        case _description = "description"
        case activityCode
        case type
        case initialSchedulePeriod
        case lengthMinutes
        case groupSettings
        case recurrenceSettings
        case attendeesSearchRule
        case facilitated
        case facilitatorsSearchRule
        case transitionTimeMinutes
        case serviceGoalImpactOverrides
        case optimizationObjective
        case fixedAvailability
        case state
        case countsAsPaidTime
        case createdDate
        case createdBy
        case modifiedDate
        case modifiedBy
        case lastRunDate
        case lastRunBy
        case selfUri
    }


}




public class AcwSettings: Codable {

    public enum WrapupPrompt: String, Codable { 
        case mandatory = "MANDATORY"
        case _optional = "OPTIONAL"
        case mandatoryTimeout = "MANDATORY_TIMEOUT"
        case mandatoryForcedTimeout = "MANDATORY_FORCED_TIMEOUT"
        case agentRequested = "AGENT_REQUESTED"
    }



    /** This field controls how the UI prompts the agent for a wrapup. */
    public var wrapupPrompt: WrapupPrompt?
    /** The amount of time the agent can stay in ACW (Min: 1 sec, Max: 60 min).  Can only be used when ACW is AGENT_REQUESTED, MANDATORY_TIMEOUT or MANDATORY_FORCED_TIMEOUT. */
    public var timeoutMs: Int?

    public init(wrapupPrompt: WrapupPrompt?, timeoutMs: Int?) {
        self.wrapupPrompt = wrapupPrompt
        self.timeoutMs = timeoutMs
    }


}




public class AddConversationResponse: Codable {





    /** The conversation reference */
    public var conversation: ConversationReference?
    /** The appointment reference */
    public var appointment: CoachingAppointmentReference?

    public init(conversation: ConversationReference?, appointment: CoachingAppointmentReference?) {
        self.conversation = conversation
        self.appointment = appointment
    }


}




public class AddWorkPlanRotationAgentRequest: Codable {







    /** The ID of an agent in this work plan rotation */
    public var userId: String?
    /** The date range to which this agent is effective in the work plan rotation */
    public var dateRange: DateRangeWithOptionalEnd?
    /** Start position of the work plan in the pattern for this agent in the work plan rotation. Position value starts from 0 */
    public var position: Int?

    public init(userId: String?, dateRange: DateRangeWithOptionalEnd?, position: Int?) {
        self.userId = userId
        self.dateRange = dateRange
        self.position = position
    }


}




public class AddWorkPlanRotationRequest: Codable {









    /** Name of this work plan rotation */
    public var name: String?
    /** The date range to which this work plan rotation applies */
    public var dateRange: DateRangeWithOptionalEnd?
    /** Agents in this work plan rotation */
    public var agents: [AddWorkPlanRotationAgentRequest]?
    /** Pattern with list of work plan IDs that rotate on a weekly basis */
    public var pattern: WorkPlanPatternRequest?

    public init(name: String?, dateRange: DateRangeWithOptionalEnd?, agents: [AddWorkPlanRotationAgentRequest]?, pattern: WorkPlanPatternRequest?) {
        self.name = name
        self.dateRange = dateRange
        self.agents = agents
        self.pattern = pattern
    }


}




public class AdditionalLanguagesIntent: Codable {





    /** ID of the intent for respective additional language */
    public var _id: String?
    /** Utterances list for additional language */
    public var utterances: [NluUtterance]?

    public init(_id: String?, utterances: [NluUtterance]?) {
        self._id = _id
        self.utterances = utterances
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case utterances
    }


}




public class AdherenceExplanationAsyncResponse: Codable {



    /** A reference to the job that was started by the request */
    public var job: AdherenceExplanationJobReference?

    public init(job: AdherenceExplanationJobReference?) {
        self.job = job
    }


}




public class AdherenceExplanationResponse: Codable {









    public enum ModelType: String, Codable { 
        case late = "Late"
    }

    public enum Status: String, Codable { 
        case pending = "Pending"
        case approved = "Approved"
        case denied = "Denied"
    }













    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The agent to whom this adherence explanation applies */
    public var agent: UserReference?
    /** The management unit to which the agent belonged at the time the adherence explanation was submitted */
    public var managementUnit: ManagementUnitReference?
    /** The business unit to which the agent belonged at the time the adherence explanation was submitted */
    public var businessUnit: BusinessUnitReference?
    /** The type of the adherence explanation */
    public var type: ModelType?
    /** The status of the adherence explanation */
    public var status: Status?
    /** The start timestamp of the adherence explanation in ISO-8601 format */
    public var startDate: Date?
    /** The length of the adherence explanation in minutes */
    public var lengthMinutes: Int?
    /** Notes about the adherence explanation */
    public var notes: String?
    /** The user who reviewed the adherence explanation, if applicable. The id may be 'System' if it was an automated process */
    public var reviewedBy: UserReference?
    /** The timestamp for when the adherence explanation was reviewed, if applicable. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var reviewedDate: Date?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, agent: UserReference?, managementUnit: ManagementUnitReference?, businessUnit: BusinessUnitReference?, type: ModelType?, status: Status?, startDate: Date?, lengthMinutes: Int?, notes: String?, reviewedBy: UserReference?, reviewedDate: Date?, selfUri: String?) {
        self._id = _id
        self.agent = agent
        self.managementUnit = managementUnit
        self.businessUnit = businessUnit
        self.type = type
        self.status = status
        self.startDate = startDate
        self.lengthMinutes = lengthMinutes
        self.notes = notes
        self.reviewedBy = reviewedBy
        self.reviewedDate = reviewedDate
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case agent
        case managementUnit
        case businessUnit
        case type
        case status
        case startDate
        case lengthMinutes
        case notes
        case reviewedBy
        case reviewedDate
        case selfUri
    }


}




public class AdminTimeOffRequestPatch: Codable {

    public enum Status: String, Codable { 
        case pending = "PENDING"
        case approved = "APPROVED"
        case denied = "DENIED"
    }



















    /** The status of this time off request */
    public var status: Status?
    /** The ID of the activity code associated with this time off request. Activity code must be of the TimeOff category */
    public var activityCodeId: String?
    /** Whether this is a paid time off request */
    public var paid: Bool?
    /** Notes about the time off request */
    public var notes: String?
    /** A set of dates in yyyy-MM-dd format. Should be interpreted in the management unit's configured time zone. */
    public var fullDayManagementUnitDates: [String]?
    /** A set of start date-times in ISO-8601 format for partial day requests. */
    public var partialDayStartDateTimes: [Date]?
    /** The daily duration of this time off request in minutes */
    public var dailyDurationMinutes: Int?
    /** Daily durations for each day of this time off request in minutes */
    public var durationMinutes: [Int]?
    /** Payable minutes for each day of this time off request */
    public var payableMinutes: [Int]?
    /** Version metadata for the time off request */
    public var metadata: WfmVersionedEntityMetadata?

    public init(status: Status?, activityCodeId: String?, paid: Bool?, notes: String?, fullDayManagementUnitDates: [String]?, partialDayStartDateTimes: [Date]?, dailyDurationMinutes: Int?, durationMinutes: [Int]?, payableMinutes: [Int]?, metadata: WfmVersionedEntityMetadata?) {
        self.status = status
        self.activityCodeId = activityCodeId
        self.paid = paid
        self.notes = notes
        self.fullDayManagementUnitDates = fullDayManagementUnitDates
        self.partialDayStartDateTimes = partialDayStartDateTimes
        self.dailyDurationMinutes = dailyDurationMinutes
        self.durationMinutes = durationMinutes
        self.payableMinutes = payableMinutes
        self.metadata = metadata
    }


}




public class AfterCallWork: Codable {





    public enum State: String, Codable { 
        case unknown = "unknown"
        case notapplicable = "notApplicable"
        case skipped = "skipped"
        case pending = "pending"
        case complete = "complete"
    }

    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var startTime: Date?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var endTime: Date?
    public var state: State?

    public init(startTime: Date?, endTime: Date?, state: State?) {
        self.startTime = startTime
        self.endTime = endTime
        self.state = state
    }


}




public class AgentActivityEntityListing: Codable {





















    public var entities: [AgentActivity]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var previousUri: String?
    public var nextUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [AgentActivity]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, previousUri: String?, nextUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.previousUri = previousUri
        self.nextUri = nextUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class AgentBidWorkPlanOverrideRequest: Codable {





    public enum OverrideReason: String, Codable { 
        case unableToBid = "UnableToBid"
        case changeOfCircumstance = "ChangeOfCircumstance"
        case newHire = "NewHire"
        case employeeMove = "EmployeeMove"
    }

    /** The ID of agent */
    public var agentId: String?
    /** The ID of the work plan that overrides the assigned work plan for the agent */
    public var overrideWorkPlanId: String?
    /** The reason for overriding the assigned work plan. This must be null if overrideWorkPlanId is not specified */
    public var overrideReason: OverrideReason?

    public init(agentId: String?, overrideWorkPlanId: String?, overrideReason: OverrideReason?) {
        self.agentId = agentId
        self.overrideWorkPlanId = overrideWorkPlanId
        self.overrideReason = overrideReason
    }


}




public class AgentChecklist: Codable {



















    /** Agent Checklist ID. */
    public var _id: String?
    /** Agent Checklist Name. */
    public var name: String?
    /** Agent Checklist Language. */
    public var language: String?
    /** Agent Checklist Items. */
    public var checklistItems: [AgentChecklistItem]?
    /** The user who created the agent checklist. */
    public var createdBy: UserReference?
    /** The user who last modified the agent checklist. */
    public var modifiedBy: UserReference?
    /** Date when the agent checklist was created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** Date when the agent checklist was last modified. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, language: String?, checklistItems: [AgentChecklistItem]?, createdBy: UserReference?, modifiedBy: UserReference?, dateCreated: Date?, dateModified: Date?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.language = language
        self.checklistItems = checklistItems
        self.createdBy = createdBy
        self.modifiedBy = modifiedBy
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case language
        case checklistItems
        case createdBy
        case modifiedBy
        case dateCreated
        case dateModified
        case selfUri
    }


}




public class AgentChecklistListing: Codable {









    public var entities: [AgentChecklist]?
    public var nextUri: String?
    public var selfUri: String?
    public var previousUri: String?

    public init(entities: [AgentChecklist]?, nextUri: String?, selfUri: String?, previousUri: String?) {
        self.entities = entities
        self.nextUri = nextUri
        self.selfUri = selfUri
        self.previousUri = previousUri
    }


}




public class AgentCopilotAggregateDataContainer: Codable {





    /** A mapping from dimension to value */
    public var group: [String:String]?
    public var data: [StatisticalResponse]?

    public init(group: [String:String]?, data: [StatisticalResponse]?) {
        self.group = group
        self.data = data
    }


}




public class AgentCopilotAggregateQueryClause: Codable {

    public enum ModelType: String, Codable { 
        case and = "and"
        case or = "or"
    }



    /** Boolean operation to apply to the provided predicates */
    public var type: ModelType?
    /** Like a three-word sentence: (attribute-name) (operator) (target-value). */
    public var predicates: [AgentCopilotAggregateQueryPredicate]?

    public init(type: ModelType?, predicates: [AgentCopilotAggregateQueryPredicate]?) {
        self.type = type
        self.predicates = predicates
    }


}




public class AgentCopilotAggregationQuery: Codable {







    public enum GroupBy: String, Codable { 
        case agentassistantid = "agentAssistantId"
        case cannedresponseid = "cannedResponseId"
        case cannedresponselibraryid = "cannedResponseLibraryId"
        case chunkcount = "chunkCount"
        case conversationid = "conversationId"
        case engagementtype = "engagementType"
        case externalcontactid = "externalContactId"
        case feedbackrating = "feedbackRating"
        case hasanswerhighlight = "hasAnswerHighlight"
        case hasgeneratedanswer = "hasGeneratedAnswer"
        case knowledgebasedocumentid = "knowledgeBaseDocumentId"
        case knowledgebasedocumentversionid = "knowledgeBaseDocumentVersionId"
        case mediatype = "mediaType"
        case messageid = "messageId"
        case queueid = "queueId"
        case scriptid = "scriptId"
        case scriptpageid = "scriptPageId"
        case searchid = "searchId"
        case state = "state"
        case suggestionid = "suggestionId"
        case suggestiontype = "suggestionType"
        case triggertype = "triggerType"
        case userid = "userId"
        case utteranceid = "utteranceId"
    }



    public enum Metrics: String, Codable { 
        case ncannedresponsesuggestions = "nCannedResponseSuggestions"
        case ndistinctsuggestions = "nDistinctSuggestions"
        case nknowledgeanswersuggestions = "nKnowledgeAnswerSuggestions"
        case nknowledgearticlesuggestions = "nKnowledgeArticleSuggestions"
        case nknowledgesearchsuggestions = "nKnowledgeSearchSuggestions"
        case nscriptsuggestions = "nScriptSuggestions"
    }





    public enum AlternateTimeDimension: String, Codable { 
        case eventtime = "eventTime"
    }

    public enum QueryType: String, Codable { 
        case bottomn = "bottomN"
        case groupby = "groupBy"
        case topn = "topN"
    }





    /** Behaves like one clause in a SQL WHERE. Specifies the date and time range of data being queried. Intervals are represented as an ISO-8601 string. For example: YYYY-MM-DDThh:mm:ss/YYYY-MM-DDThh:mm:ss */
    public var interval: String?
    /** Granularity aggregates metrics into subpartitions within the time interval specified. The default granularity is the same duration as the interval. Periods are represented as an ISO-8601 string. For example: P1D or P1DT12H */
    public var granularity: String?
    /** Time zone context used to calculate response intervals (this allows resolving DST changes). The interval offset is used even when timeZone is specified. Default is UTC. Time zones are represented as a string of the zone name as found in the IANA time zone database. For example: UTC, Etc/UTC, or Europe/London */
    public var timeZone: String?
    /** Behaves like a SQL GROUPBY. Allows for multiple levels of grouping as a list of dimensions. Partitions resulting aggregate computations into distinct named subgroups rather than across the entire result set as if it were one group. */
    public var groupBy: [GroupBy]?
    /** Behaves like a SQL WHERE clause. This is ANDed with the interval parameter. Expresses boolean logical predicates as well as dimensional filters */
    public var filter: AgentCopilotAggregateQueryFilter?
    /** Behaves like a SQL SELECT clause. Only named metrics will be retrieved. */
    public var metrics: [Metrics]?
    /** Flattens any multivalued dimensions used in response groups (e.g. ['a','b','c']->'a,b,c') */
    public var flattenMultivaluedDimensions: Bool?
    /** Custom derived metric views */
    public var views: [AgentCopilotAggregationView]?
    /** Dimension to use as the alternative timestamp for data in the aggregate.  Choosing \"eventTime\" uses the actual time of the data event. */
    public var alternateTimeDimension: AlternateTimeDimension?
    /** Query type to use. Use groupBy for all matching results, and topN/bottomN for N results ordered by the sortMetric. Default is groupBy. */
    public var queryType: QueryType?
    /** Required when requesting multiple metrics. Only applicable for topN/bottomN query type. */
    public var sortMetric: AgentCopilotAggregationSort?
    /** How many results you want in an ordered list. Only applicable for topN/bottomN query type. */
    public var limit: Int?

    public init(interval: String?, granularity: String?, timeZone: String?, groupBy: [GroupBy]?, filter: AgentCopilotAggregateQueryFilter?, metrics: [Metrics]?, flattenMultivaluedDimensions: Bool?, views: [AgentCopilotAggregationView]?, alternateTimeDimension: AlternateTimeDimension?, queryType: QueryType?, sortMetric: AgentCopilotAggregationSort?, limit: Int?) {
        self.interval = interval
        self.granularity = granularity
        self.timeZone = timeZone
        self.groupBy = groupBy
        self.filter = filter
        self.metrics = metrics
        self.flattenMultivaluedDimensions = flattenMultivaluedDimensions
        self.views = views
        self.alternateTimeDimension = alternateTimeDimension
        self.queryType = queryType
        self.sortMetric = sortMetric
        self.limit = limit
    }


}




public class AgentCopilotAggregationSort: Codable {

    public enum Name: String, Codable { 
        case ncannedresponsesuggestions = "nCannedResponseSuggestions"
        case ndistinctsuggestions = "nDistinctSuggestions"
        case nknowledgeanswersuggestions = "nKnowledgeAnswerSuggestions"
        case nknowledgearticlesuggestions = "nKnowledgeArticleSuggestions"
        case nknowledgesearchsuggestions = "nKnowledgeSearchSuggestions"
        case nscriptsuggestions = "nScriptSuggestions"
    }

    public enum Function: String, Codable { 
        case average = "average"
        case count = "count"
        case max = "max"
        case min = "min"
        case sum = "sum"
    }

    /** Name of the metric used for sorting values. */
    public var name: Name?
    /** Aggregation function used for the sort metric. */
    public var function: Function?

    public init(name: Name?, function: Function?) {
        self.name = name
        self.function = function
    }


}




public class AgentEvaluatorActivity: Codable {

















    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    public var agent: User?
    public var evaluator: User?
    public var numEvaluations: Int?
    public var averageEvaluationScore: Int?
    public var numEvaluationsWithoutViewPermission: Int?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, agent: User?, evaluator: User?, numEvaluations: Int?, averageEvaluationScore: Int?, numEvaluationsWithoutViewPermission: Int?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.agent = agent
        self.evaluator = evaluator
        self.numEvaluations = numEvaluations
        self.averageEvaluationScore = averageEvaluationScore
        self.numEvaluationsWithoutViewPermission = numEvaluationsWithoutViewPermission
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case agent
        case evaluator
        case numEvaluations
        case averageEvaluationScore
        case numEvaluationsWithoutViewPermission
        case selfUri
    }


}




public class AgentIntegrationAssociationResponse: Codable {







    /** ID of the agent in external system */
    public var agentExternalId: String?
    /** The integration associated with the agent */
    public var integration: WfmIntegrationReference?
    /** Whether agentExternalId should be protected from update by automatic processes */
    public var locked: Bool?

    public init(agentExternalId: String?, integration: WfmIntegrationReference?, locked: Bool?) {
        self.agentExternalId = agentExternalId
        self.integration = integration
        self.locked = locked
    }


}




public class AgentMuScheduleShift: Codable {







    /** The start offset of the shift, relative to referenceStartDate at the top level */
    public var startOffsetMinutes: Int?
    /** The length of the shift in minutes */
    public var lengthMinutes: Int?
    /** The activities associated with this shift */
    public var activities: [AgentScheduleShiftActivity]?

    public init(startOffsetMinutes: Int?, lengthMinutes: Int?, activities: [AgentScheduleShiftActivity]?) {
        self.startOffsetMinutes = startOffsetMinutes
        self.lengthMinutes = lengthMinutes
        self.activities = activities
    }


}




public class AgentPossibleWorkShiftsRequest: Codable {





    /** Start date of requested effective work plan, day of week will be in line with business unit start day of week. Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd */
    public var weekStartDate: Date?
    /** Number of weeks for which to return possible work shifts */
    public var weekCount: Int?

    public init(weekStartDate: Date?, weekCount: Int?) {
        self.weekStartDate = weekStartDate
        self.weekCount = weekCount
    }


}




public class AgentStateAgentQueryClause: Codable {

    public enum ModelType: String, Codable { 
        case and = "and"
        case or = "or"
    }



    /** Boolean operation to apply to the provided predicates */
    public var type: ModelType?
    /** Describes a <dimension> = <value> filter used to perform matching */
    public var predicates: [AgentStateAgentQueryPredicate]?

    public init(type: ModelType?, predicates: [AgentStateAgentQueryPredicate]?) {
        self.type = type
        self.predicates = predicates
    }


}




public class AgentStateQueryRequest: Codable {





    public enum UserOrderBy: String, Codable { 
        case username = "userName"
        case segmentstart = "segmentStart"
        case sessionstart = "sessionStart"
        case presencedate = "presenceDate"
        case routingstatusdate = "routingStatusDate"
        case systempresence = "systemPresence"
        case routingstatus = "routingStatus"
        case organizationpresenceid = "organizationPresenceId"
    }

    public enum UserOrder: String, Codable { 
        case asc = "asc"
        case desc = "desc"
    }

    public enum SessionOrderBy: String, Codable { 
        case segmentstart = "segmentStart"
        case sessionstart = "sessionStart"
    }

    public enum SessionOrder: String, Codable { 
        case asc = "asc"
        case desc = "desc"
    }

    /** Filters that target user-level data */
    public var userFilter: AgentStateUserFilter?
    /** Filters that target session-level data */
    public var sessionFilter: AgentStateSessionFilter?
    /** Search user order dimension names; default to userName */
    public var userOrderBy: UserOrderBy?
    /** Search user order direction; default to asc */
    public var userOrder: UserOrder?
    /** Search session order dimension names; default to segmentStart */
    public var sessionOrderBy: SessionOrderBy?
    /** Search session order direction; default to asc */
    public var sessionOrder: SessionOrder?

    public init(userFilter: AgentStateUserFilter?, sessionFilter: AgentStateSessionFilter?, userOrderBy: UserOrderBy?, userOrder: UserOrder?, sessionOrderBy: SessionOrderBy?, sessionOrder: SessionOrder?) {
        self.userFilter = userFilter
        self.sessionFilter = sessionFilter
        self.userOrderBy = userOrderBy
        self.userOrder = userOrder
        self.sessionOrderBy = sessionOrderBy
        self.sessionOrder = sessionOrder
    }


}




public class AgentStateRoutingStatusCount: Codable {

    public enum RoutingStatus: String, Codable { 
        case unknown = "UNKNOWN"
        case offQueue = "OFF_QUEUE"
        case idle = "IDLE"
        case interacting = "INTERACTING"
        case notResponding = "NOT_RESPONDING"
        case communicating = "COMMUNICATING"
    }



    /** Routing status */
    public var routingStatus: RoutingStatus?
    /** Count of users with this routing status */
    public var count: Int?

    public init(routingStatus: RoutingStatus?, count: Int?) {
        self.routingStatus = routingStatus
        self.count = count
    }


}




public class AgentStateSessionFilter: Codable {

    public enum ModelType: String, Codable { 
        case and = "and"
        case or = "or"
    }





    /** Boolean operation to apply to the provided predicates and clauses */
    public var type: ModelType?
    /** Boolean 'and/or' logic with up to two-levels of nesting */
    public var clauses: [AgentStateSessionQueryClause]?
    /** Describes a <dimension> = <value> filter used to perform matching */
    public var predicates: [AgentStateSessionQueryPredicate]?

    public init(type: ModelType?, clauses: [AgentStateSessionQueryClause]?, predicates: [AgentStateSessionQueryPredicate]?) {
        self.type = type
        self.clauses = clauses
        self.predicates = predicates
    }


}




public class AgentStateSessionQueryClause: Codable {

    public enum ModelType: String, Codable { 
        case and = "and"
        case or = "or"
    }



    /** Boolean operation to apply to the provided predicates */
    public var type: ModelType?
    /** Describes a <dimension> = <value> filter used to perform matching */
    public var predicates: [AgentStateSessionQueryPredicate]?

    public init(type: ModelType?, predicates: [AgentStateSessionQueryPredicate]?) {
        self.type = type
        self.predicates = predicates
    }


}




public class AgentStateUserFilter: Codable {

    public enum ModelType: String, Codable { 
        case and = "and"
        case or = "or"
    }





    /** Boolean operation to apply to the provided predicates and clauses */
    public var type: ModelType?
    /** Boolean 'and/or' logic with up to two-levels of nesting */
    public var clauses: [AgentStateAgentQueryClause]?
    /** Describes a <dimension> = <value> filter used to perform matching */
    public var predicates: [AgentStateAgentQueryPredicate]?

    public init(type: ModelType?, clauses: [AgentStateAgentQueryClause]?, predicates: [AgentStateAgentQueryPredicate]?) {
        self.type = type
        self.clauses = clauses
        self.predicates = predicates
    }


}



/** The settings for Agent Video */

public class AgentVideoSettings: Codable {







    public enum Background: String, Codable { 
        case blur = "BLUR"
        case _none = "NONE"
        case image = "IMAGE"
    }



    /** whether or not agent camera is allowed */
    public var allowCamera: Bool?
    /** whether or not agent screen share is allowed */
    public var allowScreenShare: Bool?
    /** whether or not agent microphone is allowed */
    public var allowMicrophone: Bool?
    /** background for agent */
    public var background: Background?
    /** background image settings for agent */
    public var backgroundImage: BackgroundImageSettings?

    public init(allowCamera: Bool?, allowScreenShare: Bool?, allowMicrophone: Bool?, background: Background?, backgroundImage: BackgroundImageSettings?) {
        self.allowCamera = allowCamera
        self.allowScreenShare = allowScreenShare
        self.allowMicrophone = allowMicrophone
        self.background = background
        self.backgroundImage = backgroundImage
    }


}




public class AggregateViewData: Codable {





    public var name: String?
    public var stats: StatisticalSummary?

    public init(name: String?, stats: StatisticalSummary?) {
        self.name = name
        self.stats = stats
    }


}




public class AggregationResult: Codable {

    public enum ModelType: String, Codable { 
        case termfrequency = "termFrequency"
        case numericrange = "numericRange"
    }









    public var type: ModelType?
    /** For termFrequency aggregations */
    public var dimension: String?
    /** For numericRange aggregations */
    public var metric: String?
    public var count: Int64?
    public var results: [AggregationResultEntry]?

    public init(type: ModelType?, dimension: String?, metric: String?, count: Int64?, results: [AggregationResultEntry]?) {
        self.type = type
        self.dimension = dimension
        self.metric = metric
        self.count = count
        self.results = results
    }


}




public class AggregationResultEntry: Codable {









    public var count: Int64?
    /** For termFrequency aggregations */
    public var value: String?
    /** For numericRange aggregations */
    public var gte: Double?
    /** For numericRange aggregations */
    public var lt: Double?

    public init(count: Int64?, value: String?, gte: Double?, lt: Double?) {
        self.count = count
        self.value = value
        self.gte = gte
        self.lt = lt
    }


}




public class AllTimePoints: Codable {







    /** Queried user */
    public var user: UserReference?
    /** Queried end workday for all time points to be collected. Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd */
    public var dateEndWorkday: Date?
    /** All time point collected bt the user */
    public var allTimePoints: Int64?

    public init(user: UserReference?, dateEndWorkday: Date?, allTimePoints: Int64?) {
        self.user = user
        self.dateEndWorkday = dateEndWorkday
        self.allTimePoints = allTimePoints
    }


}




public class AlternativeShiftSearchOffersRequest: Codable {









    /** The existing schedule being used to find alternative shift offers */
    public var schedule: AlternativeShiftScheduleLookup?
    /** The start date for the week in this schedule in yyyy-MM-dd format. Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd */
    public var queryWeekDate: Date?
    /** The shift a user puts up for alternative shift offers */
    public var initiatingShift: InitiatingAlternativeShift?
    /** The acceptable intervals in offers. Intervals are represented as an ISO-8601 string. For example: YYYY-MM-DDThh:mm:ss/YYYY-MM-DDThh:mm:ss */
    public var acceptableIntervals: [String]?

    public init(schedule: AlternativeShiftScheduleLookup?, queryWeekDate: Date?, initiatingShift: InitiatingAlternativeShift?, acceptableIntervals: [String]?) {
        self.schedule = schedule
        self.queryWeekDate = queryWeekDate
        self.initiatingShift = initiatingShift
        self.acceptableIntervals = acceptableIntervals
    }


}




public class AlternativeShiftTradeListing: Codable {



    public var entities: [AlternativeShiftTradeResponse]?

    public init(entities: [AlternativeShiftTradeResponse]?) {
        self.entities = entities
    }


}




public class AnalyticsAgentStateCountsResponse: Codable {



    /** List of count by segment types */
    public var segmentCounts: [AgentStateSegmentTypeCount]?

    public init(segmentCounts: [AgentStateSegmentTypeCount]?) {
        self.segmentCounts = segmentCounts
    }


}




public class AnalyticsConversationAsyncQueryResponse: Codable {







    public var conversations: [AnalyticsConversation]?
    /** Optional cursor to indicate where to resume the results */
    public var cursor: String?
    /** Data available up to at least this datetime. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dataAvailabilityDate: Date?

    public init(conversations: [AnalyticsConversation]?, cursor: String?, dataAvailabilityDate: Date?) {
        self.conversations = conversations
        self.cursor = cursor
        self.dataAvailabilityDate = dataAvailabilityDate
    }


}




public class AnalyticsConversationQueryResponse: Codable {







    public var conversations: [AnalyticsConversationWithoutAttributes]?
    public var aggregations: [AggregationResult]?
    public var totalHits: Int?

    public init(conversations: [AnalyticsConversationWithoutAttributes]?, aggregations: [AggregationResult]?, totalHits: Int?) {
        self.conversations = conversations
        self.aggregations = aggregations
        self.totalHits = totalHits
    }


}




public class AnalyticsParticipant: Codable {





    public enum FlaggedReason: String, Codable { 
        case general = "general"
    }





    public enum Purpose: String, Codable { 
        case acd = "acd"
        case agent = "agent"
        case api = "api"
        case botflow = "botflow"
        case campaign = "campaign"
        case customer = "customer"
        case dialer = "dialer"
        case external = "external"
        case fax = "fax"
        case group = "group"
        case inbound = "inbound"
        case ivr = "ivr"
        case manual = "manual"
        case outbound = "outbound"
        case station = "station"
        case user = "user"
        case voicemail = "voicemail"
        case voicesurveyflow = "voicesurveyflow"
        case workflow = "workflow"
    }











    /** External contact identifier */
    public var externalContactId: String?
    /** External organization identifier */
    public var externalOrganizationId: String?
    /** Reason for which participant flagged conversation */
    public var flaggedReason: FlaggedReason?
    /** Unique identifier for the participant */
    public var participantId: String?
    /** A human readable name identifying the participant */
    public var participantName: String?
    /** The participant's purpose */
    public var purpose: Purpose?
    /** Flag determining if a screen recording was started or not */
    public var screenRecording: Bool?
    /** The team ID the user is a member of */
    public var teamId: String?
    /** Unique identifier for the user */
    public var userId: String?
    /** List of sessions associated to this participant */
    public var sessions: [AnalyticsSession]?
    /** List of attributes associated to this participant */
    public var attributes: [String:String]?

    public init(externalContactId: String?, externalOrganizationId: String?, flaggedReason: FlaggedReason?, participantId: String?, participantName: String?, purpose: Purpose?, screenRecording: Bool?, teamId: String?, userId: String?, sessions: [AnalyticsSession]?, attributes: [String:String]?) {
        self.externalContactId = externalContactId
        self.externalOrganizationId = externalOrganizationId
        self.flaggedReason = flaggedReason
        self.participantId = participantId
        self.participantName = participantName
        self.purpose = purpose
        self.screenRecording = screenRecording
        self.teamId = teamId
        self.userId = userId
        self.sessions = sessions
        self.attributes = attributes
    }


}




public class AnalyticsResolution: Codable {









    /** Specifies when an event occurred. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var eventTime: Date?
    /** The ID of the last queue on which the conversation was handled. */
    public var queueId: String?
    /** The ID of the last user who handled the conversation. */
    public var userId: String?
    public var nNextContactAvoided: Int64?

    public init(eventTime: Date?, queueId: String?, userId: String?, nNextContactAvoided: Int64?) {
        self.eventTime = eventTime
        self.queueId = queueId
        self.userId = userId
        self.nNextContactAvoided = nNextContactAvoided
    }


}




public class AnalyticsUserDetailsAsyncQueryResponse: Codable {







    public var userDetails: [AnalyticsUserDetail]?
    /** Optional cursor to indicate where to resume the results */
    public var cursor: String?
    /** Data available up to at least this datetime. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dataAvailabilityDate: Date?

    public init(userDetails: [AnalyticsUserDetail]?, cursor: String?, dataAvailabilityDate: Date?) {
        self.userDetails = userDetails
        self.cursor = cursor
        self.dataAvailabilityDate = dataAvailabilityDate
    }


}




public class AnalyticsUserDetailsQueryResponse: Codable {







    public var userDetails: [AnalyticsUserDetail]?
    public var aggregations: [AggregationResult]?
    public var totalHits: Int?

    public init(userDetails: [AnalyticsUserDetail]?, aggregations: [AggregationResult]?, totalHits: Int?) {
        self.userDetails = userDetails
        self.aggregations = aggregations
        self.totalHits = totalHits
    }


}




public class AnswerOption: Codable {





    public enum BuiltInType: String, Codable { 
        case selected = "Selected"
        case unselected = "Unselected"
    }







    public var _id: String?
    /** An identifier for this answer that stays the same across versions of the form. */
    public var contextId: String?
    /** The built-in type of this answer option. Only used for built-in answer options such as selection states for Multiple Select answer options. Possible values include: Selected, Unselected */
    public var builtInType: BuiltInType?
    public var text: String?
    public var value: Int?
    /** List of assistance conditions which are combined together with a logical AND operator. Eg ( assistanceCondtion1 && assistanceCondition2 ) wherein assistanceCondition could be ( EXISTS topic1 || topic2 || ... ) or (NOTEXISTS topic3 || topic4 || ...). */
    public var assistanceConditions: [AssistanceCondition]?

    public init(_id: String?, contextId: String?, builtInType: BuiltInType?, text: String?, value: Int?, assistanceConditions: [AssistanceCondition]?) {
        self._id = _id
        self.contextId = contextId
        self.builtInType = builtInType
        self.text = text
        self.value = value
        self.assistanceConditions = assistanceConditions
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case contextId
        case builtInType
        case text
        case value
        case assistanceConditions
    }


}




public class AppendToDncActionSettings: Codable {





    public enum ListType: String, Codable { 
        case rds = "Rds"
        case rdsCustom = "RdsCustom"
    }

    /** Whether to expire the record appended to the DNC list. */
    public var expire: Bool?
    /** If 'expire' is set to true, how long to keep the record. */
    public var expirationDuration: String?
    /** The Dnc List Type to append entries to */
    public var listType: ListType?

    public init(expire: Bool?, expirationDuration: String?, listType: ListType?) {
        self.expire = expire
        self.expirationDuration = expirationDuration
        self.listType = listType
    }


}



/** The user who initiated the change. */

public class ArchitectDependencyTrackingBuildNotificationUser: Codable {







    /** The ID of the user. */
    public var _id: String?
    /** The name of the user, if available. */
    public var name: String?
    public var homeOrg: ArchitectDependencyTrackingBuildNotificationHomeOrganization?

    public init(_id: String?, name: String?, homeOrg: ArchitectDependencyTrackingBuildNotificationHomeOrganization?) {
        self._id = _id
        self.name = name
        self.homeOrg = homeOrg
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case homeOrg
    }


}



/** A bare-bones flow version object */

public class ArchitectFlowNotificationFlowVersion: Codable {



    /** The version ID */
    public var _id: String?

    public init(_id: String?) {
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
    }


}



/** The user who initiated the change. */

public class ArchitectFlowNotificationUser: Codable {







    /** The ID of the user. */
    public var _id: String?
    /** The name of the user, if available. */
    public var name: String?
    public var homeOrg: ArchitectFlowNotificationHomeOrganization?

    public init(_id: String?, name: String?, homeOrg: ArchitectFlowNotificationHomeOrganization?) {
        self._id = _id
        self.name = name
        self.homeOrg = homeOrg
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case homeOrg
    }


}



/** The error message params, if the action failed */

public class ArchitectFlowOutcomeNotificationErrorMessageParams: Codable {





    public var additionalProperties: [String:String]?
    public var getAdditionalProperties: [String:String]?

    public init(additionalProperties: [String:String]?, getAdditionalProperties: [String:String]?) {
        self.additionalProperties = additionalProperties
        self.getAdditionalProperties = getAdditionalProperties
    }


}




public class ArchitectJobStateResponse: Codable {





    public enum Status: String, Codable { 
        case registered = "Registered"
        case started = "Started"
        case success = "Success"
        case failure = "Failure"
    }

    public enum Command: String, Codable { 
        case publish = "Publish"
        case create = "Create"
        case update = "Update"
        case export = "Export"
    }





    /** The globally unique identifier for the object. */
    public var _id: String?
    /** Flow created from the Architect Job */
    public var flow: AddressableEntityRef?
    /** Status of the Architect Job */
    public var status: Status?
    /** The command executed by the Architect Job */
    public var command: Command?
    /** Warnings and Errors messages of the Architect Job */
    public var messages: [ArchitectJobMessage]?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, flow: AddressableEntityRef?, status: Status?, command: Command?, messages: [ArchitectJobMessage]?, selfUri: String?) {
        self._id = _id
        self.flow = flow
        self.status = status
        self.command = command
        self.messages = messages
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case flow
        case status
        case command
        case messages
        case selfUri
    }


}




public class ArticlesFilter: Codable {





    /** The labels filter. */
    public var labels: LabelsFilter?
    /** The categories filter. */
    public var categories: CategoriesFilter?

    public init(labels: LabelsFilter?, categories: CategoriesFilter?) {
        self.labels = labels
        self.categories = categories
    }


}




public class AssessmentFormQuestion: Codable {





    public enum ModelType: String, Codable { 
        case multiplechoicequestion = "multipleChoiceQuestion"
        case freetextquestion = "freeTextQuestion"
        case npsquestion = "npsQuestion"
        case readonlytextblockquestion = "readOnlyTextBlockQuestion"
    }



















    public var _id: String?
    /** An identifier for this question that stays the same across versions of the form. */
    public var contextId: String?
    public var type: ModelType?
    /** The question text */
    public var text: String?
    public var helpText: String?
    public var naEnabled: Bool?
    public var commentsRequired: Bool?
    public var visibilityCondition: VisibilityCondition?
    /** Options from which to choose an answer for this question. Only used by Multiple Choice type questions. */
    public var answerOptions: [AnswerOption]?
    /** How many characters are allowed in the text response to this question. Used by Free Text question types. */
    public var maxResponseCharacters: Int?
    /** Does an incorrect answer to this question mark the form as having a failed kill question. Only used by Multiple Choice type questions. */
    public var isKill: Bool?
    /** Does this question contribute to the critical score. Only used by Multiple Choice type questions. */
    public var isCritical: Bool?

    public init(_id: String?, contextId: String?, type: ModelType?, text: String?, helpText: String?, naEnabled: Bool?, commentsRequired: Bool?, visibilityCondition: VisibilityCondition?, answerOptions: [AnswerOption]?, maxResponseCharacters: Int?, isKill: Bool?, isCritical: Bool?) {
        self._id = _id
        self.contextId = contextId
        self.type = type
        self.text = text
        self.helpText = helpText
        self.naEnabled = naEnabled
        self.commentsRequired = commentsRequired
        self.visibilityCondition = visibilityCondition
        self.answerOptions = answerOptions
        self.maxResponseCharacters = maxResponseCharacters
        self.isKill = isKill
        self.isCritical = isCritical
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case contextId
        case type
        case text
        case helpText
        case naEnabled
        case commentsRequired
        case visibilityCondition
        case answerOptions
        case maxResponseCharacters
        case isKill
        case isCritical
    }


}




public class AssessmentFormQuestionGroup: Codable {

























    /** The ID of the question group, */
    public var _id: String?
    /** The question group name */
    public var name: String?
    /** The question group type */
    public var type: String?
    /** An identifier for this question group that stays the same across versions of the form. */
    public var contextId: String?
    public var defaultAnswersToHighest: Bool?
    public var defaultAnswersToNA: Bool?
    public var naEnabled: Bool?
    public var weight: Float?
    public var manualWeight: Bool?
    /** The list of questions for this question group */
    public var questions: [AssessmentFormQuestion]?
    public var visibilityCondition: VisibilityCondition?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, type: String?, contextId: String?, defaultAnswersToHighest: Bool?, defaultAnswersToNA: Bool?, naEnabled: Bool?, weight: Float?, manualWeight: Bool?, questions: [AssessmentFormQuestion]?, visibilityCondition: VisibilityCondition?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.type = type
        self.contextId = contextId
        self.defaultAnswersToHighest = defaultAnswersToHighest
        self.defaultAnswersToNA = defaultAnswersToNA
        self.naEnabled = naEnabled
        self.weight = weight
        self.manualWeight = manualWeight
        self.questions = questions
        self.visibilityCondition = visibilityCondition
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case type
        case contextId
        case defaultAnswersToHighest
        case defaultAnswersToNA
        case naEnabled
        case weight
        case manualWeight
        case questions
        case visibilityCondition
        case selfUri
    }


}




public class AssessmentListing: Codable {









    public var entities: [BenefitAssessment]?
    public var nextUri: String?
    public var selfUri: String?
    public var previousUri: String?

    public init(entities: [BenefitAssessment]?, nextUri: String?, selfUri: String?, previousUri: String?) {
        self.entities = entities
        self.nextUri = nextUri
        self.selfUri = selfUri
        self.previousUri = previousUri
    }


}




public class AssessmentScoringSet: Codable {










    public enum FailureReasons: String, Codable { 
        case score = "Score"
        case criticalScore = "CriticalScore"
        case killQuestion = "KillQuestion"
    }






    /** The total score of the answers */
    public var totalScore: Float?
    /** The total score for the critical questions */
    public var totalCriticalScore: Float?
    /** The total score for the non-critical questions */
    public var totalNonCriticalScore: Float?
    /** The individual scores for each question group */
    public var questionGroupScores: [AssessmentQuestionGroupScore]?
    /** If the assessment was not passed, the reasons for failure. */
    public var failureReasons: [FailureReasons]?
    /** Comments provided for these answers. */
    public var comments: String?
    /** Comments provided by agent. */
    public var agentComments: String?
    /** True if the assessment was passed */
    public var isPassed: Bool?

    public init(totalScore: Float?, totalCriticalScore: Float?, totalNonCriticalScore: Float?, questionGroupScores: [AssessmentQuestionGroupScore]?, failureReasons: [FailureReasons]?, comments: String?, agentComments: String?, isPassed: Bool?) {
        self.totalScore = totalScore
        self.totalCriticalScore = totalCriticalScore
        self.totalNonCriticalScore = totalNonCriticalScore
        self.questionGroupScores = questionGroupScores
        self.failureReasons = failureReasons
        self.comments = comments
        self.agentComments = agentComments
        self.isPassed = isPassed
    }


}




public class AssignedSegment: Codable {





    /** The ID of the segment assigned. */
    public var _id: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, selfUri: String?) {
        self._id = _id
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
    }


}




public class AssignedWrapupCode: Codable {











    /** The user configured wrap up code id. */
    public var code: String?
    /** Text entered by the agent to describe the call or disposition. */
    public var notes: String?
    /** List of tags selected by the agent to describe the call or disposition. */
    public var tags: [String]?
    /** The duration in seconds of the wrap-up segment. */
    public var durationSeconds: Int?
    /** The timestamp when the wrap-up segment ended. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var endTime: Date?

    public init(code: String?, notes: String?, tags: [String]?, durationSeconds: Int?, endTime: Date?) {
        self.code = code
        self.notes = notes
        self.tags = tags
        self.durationSeconds = durationSeconds
        self.endTime = endTime
    }


}




public class AssistantQueueUsersQueryResponse: Codable {





    /** The queue information. */
    public var queue: AssistantQueue?
    /** List of users in the queue for which assistant is assigned. */
    public var users: [UserReference]?

    public init(queue: AssistantQueue?, users: [UserReference]?) {
        self.queue = queue
        self.users = users
    }


}




public class AssociatedValueField: Codable {

    public enum DataType: String, Codable { 
        case number = "Number"
        case integer = "Integer"
    }



    /** The data type of the value field. */
    public var dataType: DataType?
    /** The field name for extracting value from event. */
    public var name: String?

    public init(dataType: DataType?, name: String?) {
        self.dataType = dataType
        self.name = name
    }


}




public class AsyncForecastOperationResult: Codable {

    public enum Status: String, Codable { 
        case processing = "Processing"
        case complete = "Complete"
        case canceled = "Canceled"
        case error = "Error"
    }







    /** The status of the operation */
    public var status: Status?
    /** The ID for the operation */
    public var operationId: String?
    /** The result of the operation.  Null unless status == Complete */
    public var result: BuShortTermForecast?
    /** Percent progress for the operation */
    public var progress: Int?

    public init(status: Status?, operationId: String?, result: BuShortTermForecast?, progress: Int?) {
        self.status = status
        self.operationId = operationId
        self.result = result
        self.progress = progress
    }


}




public class AtzmTimeSlotWithTimeZone: Codable {







    /** The earliest time to dial a contact. Valid format is HH:mm */
    public var earliestCallableTime: String?
    /** The latest time to dial a contact. Valid format is HH:mm */
    public var latestCallableTime: String?
    /** The time zone to use for contacts that cannot be mapped. */
    public var timeZoneId: String?

    public init(earliestCallableTime: String?, latestCallableTime: String?, timeZoneId: String?) {
        self.earliestCallableTime = earliestCallableTime
        self.latestCallableTime = latestCallableTime
        self.timeZoneId = timeZoneId
    }


}




public class AuditLogMessage: Codable {













    public enum Level: String, Codable { 
        case user = "USER"
        case system = "SYSTEM"
        case genesysInternal = "GENESYS_INTERNAL"
    }











    public enum Status: String, Codable { 
        case success = "SUCCESS"
        case failure = "FAILURE"
        case warning = "WARNING"
    }













    /** Id of the audit message. */
    public var _id: String?
    /** Home Organization Id associated with this audit message. */
    public var userHomeOrgId: String?
    /** User associated with this audit message. */
    public var user: DomainEntityRef?
    /** Client associated with this audit message. */
    public var client: AddressableEntityRef?
    /** List of IP addresses of systems that originated or handled the request. */
    public var remoteIp: [String]?
    /** Name of the service that logged this audit message. */
    public var serviceName: String?
    /** Level of this audit message, USER or SYSTEM. */
    public var level: Level?
    /** Date and time of when the audit message was logged. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var eventDate: Date?
    /** Message describing the event being audited. */
    public var message: MessageInfo?
    /** Action that took place. */
    public var action: String?
    /** Entity that was impacted. */
    public var entity: DomainEntityRef?
    /** Type of the entity that was impacted. */
    public var entityType: String?
    /** Status of the event being audited */
    public var status: Status?
    /** Name of the application used to perform the audit's action */
    public var application: String?
    /** Id and action of the audit initiating the transaction */
    public var initiatingAction: InitiatingAction?
    /** Whether the current audit is the initiator of the transaction */
    public var transactionInitiator: Bool?
    /** List of properties that were changed and changes made to those properties. */
    public var propertyChanges: [PropertyChange]?
    /** Additional context for this message. */
    public var context: [String:String]?
    /** List of entities that were changed and changes made to those entities. */
    public var entityChanges: [EntityChange]?

    public init(_id: String?, userHomeOrgId: String?, user: DomainEntityRef?, client: AddressableEntityRef?, remoteIp: [String]?, serviceName: String?, level: Level?, eventDate: Date?, message: MessageInfo?, action: String?, entity: DomainEntityRef?, entityType: String?, status: Status?, application: String?, initiatingAction: InitiatingAction?, transactionInitiator: Bool?, propertyChanges: [PropertyChange]?, context: [String:String]?, entityChanges: [EntityChange]?) {
        self._id = _id
        self.userHomeOrgId = userHomeOrgId
        self.user = user
        self.client = client
        self.remoteIp = remoteIp
        self.serviceName = serviceName
        self.level = level
        self.eventDate = eventDate
        self.message = message
        self.action = action
        self.entity = entity
        self.entityType = entityType
        self.status = status
        self.application = application
        self.initiatingAction = initiatingAction
        self.transactionInitiator = transactionInitiator
        self.propertyChanges = propertyChanges
        self.context = context
        self.entityChanges = entityChanges
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case userHomeOrgId
        case user
        case client
        case remoteIp
        case serviceName
        case level
        case eventDate
        case message
        case action
        case entity
        case entityType
        case status
        case application
        case initiatingAction
        case transactionInitiator
        case propertyChanges
        case context
        case entityChanges
    }


}




public class AuditQueryExecutionLargeResultsResponse: Codable {









    /** Id of the audit query execution request. */
    public var _id: String?
    /** Number of results in a page. */
    public var pageSize: Int?
    /** Optional cursor to indicate where to resume the results. */
    public var cursor: String?
    /** The presigned url which can be used to download the results. */
    public var downloadUrl: String?

    public init(_id: String?, pageSize: Int?, cursor: String?, downloadUrl: String?) {
        self._id = _id
        self.pageSize = pageSize
        self.cursor = cursor
        self.downloadUrl = downloadUrl
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case pageSize
        case cursor
        case downloadUrl
    }


}




public class AuditQueryRequest: Codable {









    /** Date and time range of data to query. Intervals are represented as an ISO-8601 string. For example: YYYY-MM-DDThh:mm:ssZ/YYYY-MM-DDThh:mm:ssZ */
    public var interval: String?
    /** Name of the service to query audits for. */
    public var serviceName: String?
    /** Additional filters for the query. */
    public var filters: [AuditQueryFilter]?
    /** Sort parameter for the query. */
    public var sort: [AuditQuerySort]?

    public init(interval: String?, serviceName: String?, filters: [AuditQueryFilter]?, sort: [AuditQuerySort]?) {
        self.interval = interval
        self.serviceName = serviceName
        self.filters = filters
        self.sort = sort
    }


}




public class AuditRealtimeQueryResultsResponse: Codable {











    public var entities: [AuditLogMessage]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var pageCount: Int?

    public init(entities: [AuditLogMessage]?, pageSize: Int?, pageNumber: Int?, total: Int64?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.pageCount = pageCount
    }


}




public class AuditRealtimeRelatedRequest: Codable {







    /** The id of the audit of which related audits will be retrieved. */
    public var auditId: String?
    /** The id of the trustor org to which the audit belongs. Used when searching for audits performed by a trustee user within a trustor org. */
    public var trustorOrgId: String?
    /** Sort parameter for the query. */
    public var sort: [AuditQuerySort]?

    public init(auditId: String?, trustorOrgId: String?, sort: [AuditQuerySort]?) {
        self.auditId = auditId
        self.trustorOrgId = trustorOrgId
        self.sort = sort
    }


}




public class AuthorizationPolicy: Codable {









    public enum Effect: String, Codable { 
        case allow = "ALLOW"
        case deny = "DENY"
    }













    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** The targeted resource to which the policy should apply, in the form of domain:entity:action */
    public var targetResource: String?
    /** The subject to whom the policy will apply, including type and id */
    public var subject: Subject?
    /** The effect this policy should have when its conditions are met */
    public var effect: Effect?
    /** The condition tree the policy will evaluate */
    public var condition: JSON?
    public var _description: String?
    /** Date this policy was last modified. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** Map of names and values of preset attributes to use in policy evaluation */
    public var presetAttributes: [String:TypedAttribute]?
    /** Flag for active enforcement. If this value is false or null, the policy will be saved but will not be checked or enforced on users. */
    public var active: Bool?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, targetResource: String?, subject: Subject?, effect: Effect?, condition: JSON?, _description: String?, dateModified: Date?, presetAttributes: [String:TypedAttribute]?, active: Bool?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.targetResource = targetResource
        self.subject = subject
        self.effect = effect
        self.condition = condition
        self._description = _description
        self.dateModified = dateModified
        self.presetAttributes = presetAttributes
        self.active = active
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case targetResource
        case subject
        case effect
        case condition
        case _description = "description"
        case dateModified
        case presetAttributes
        case active
        case selfUri
    }


}




public class AuthorizationSettings: Codable {













    /** The globally unique identifier for the object. */
    public var _id: String?
    /** Boolean showing if organization is opted in or not to unused role/perm analysis */
    public var analysisEnabled: Bool?
    /** Integer number of days to analyze user usage */
    public var analysisDays: Int?
    /** The date and time of the most recent unused role calculation. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateLastCalculated: Date?
    /** The date of the most recent org activity used for analysis. Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd */
    public var dateLastActive: Date?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, analysisEnabled: Bool?, analysisDays: Int?, dateLastCalculated: Date?, dateLastActive: Date?, selfUri: String?) {
        self._id = _id
        self.analysisEnabled = analysisEnabled
        self.analysisDays = analysisDays
        self.dateLastCalculated = dateLastCalculated
        self.dateLastActive = dateLastActive
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case analysisEnabled
        case analysisDays
        case dateLastCalculated
        case dateLastActive
        case selfUri
    }


}




public class AuthzGrant: Codable {









    public var subjectId: String?
    public var division: AuthzDivision?
    public var role: AuthzGrantRole?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var grantMadeAt: Date?

    public init(subjectId: String?, division: AuthzDivision?, role: AuthzGrantRole?, grantMadeAt: Date?) {
        self.subjectId = subjectId
        self.division = division
        self.role = role
        self.grantMadeAt = grantMadeAt
    }


}




public class AutoAnswerSetting: Codable {



    /** The media type status. */
    public var enabled: Bool?

    public init(enabled: Bool?) {
        self.enabled = enabled
    }


}




public class AutoAnswerSettings: Codable {



    /** Map of conversation media type enabled status. */
    public var settings: [String:AutoAnswerSetting]?

    public init(settings: [String:AutoAnswerSetting]?) {
        self.settings = settings
    }


}




public class AvailableMediaTypeEntityListing: Codable {



    public var entities: [AvailableMediaType]?

    public init(entities: [AvailableMediaType]?) {
        self.entities = entities
    }


}




public class AvailableTimeOffRange: Codable {





    public enum Granularity: String, Codable { 
        case daily = "Daily"
        case fifteenMinutes = "FifteenMinutes"
    }







    /** The time off limit */
    public var timeOffLimit: TimeOffLimitReference?
    /** Start date of the requested date range. The end date is determined by the size of interval list. Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd */
    public var startDate: Date?
    /** Granularity choice for time off limit */
    public var granularity: Granularity?
    /** The list of available time off values in minutes per granularity interval */
    public var availableMinutesPerInterval: [Int]?
    /** The current number of waitlisted time off requests for every interval per granularity */
    public var waitlistedRequestsPerInterval: [Int]?
    /** Whether the time off request can be waitlisted */
    public var waitlistEnabled: Bool?

    public init(timeOffLimit: TimeOffLimitReference?, startDate: Date?, granularity: Granularity?, availableMinutesPerInterval: [Int]?, waitlistedRequestsPerInterval: [Int]?, waitlistEnabled: Bool?) {
        self.timeOffLimit = timeOffLimit
        self.startDate = startDate
        self.granularity = granularity
        self.availableMinutesPerInterval = availableMinutesPerInterval
        self.waitlistedRequestsPerInterval = waitlistedRequestsPerInterval
        self.waitlistEnabled = waitlistEnabled
    }


}




public class BaseTopicEntitiy: Codable {







    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case selfUri
    }


}




public class BatchDownloadJobStatusResult: Codable {











    public enum Status: String, Codable { 
        case inProgress = "InProgress"
        case completed = "Completed"
    }





    /** The globally unique identifier for the object. */
    public var _id: String?
    /** JobId returned when job was initially submitted. */
    public var jobId: String?
    /** Number of results expected when job is completed, this includes both success and error results. This number could change as recordings are being discovered and processed. */
    public var expectedResultCount: Int?
    /** Current number of results available, this includes both success and error results. */
    public var resultCount: Int?
    /** Current number of error results. */
    public var errorCount: Int?
    /** Current status of the job. A job is considered completed when all the submitted requests have been processed and fulfilled. */
    public var status: Status?
    /** Current set of results for the job. */
    public var results: [BatchDownloadJobResult]?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, jobId: String?, expectedResultCount: Int?, resultCount: Int?, errorCount: Int?, status: Status?, results: [BatchDownloadJobResult]?, selfUri: String?) {
        self._id = _id
        self.jobId = jobId
        self.expectedResultCount = expectedResultCount
        self.resultCount = resultCount
        self.errorCount = errorCount
        self.status = status
        self.results = results
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case jobId
        case expectedResultCount
        case resultCount
        case errorCount
        case status
        case results
        case selfUri
    }


}




public class BatchDownloadJobSubmission: Codable {



    /** List of up to 100 items requested */
    public var batchDownloadRequestList: [BatchDownloadRequest]?

    public init(batchDownloadRequestList: [BatchDownloadRequest]?) {
        self.batchDownloadRequestList = batchDownloadRequestList
    }


}



/** A maximum of 100 events are allowed per request */

public class BatchUserPresenceEventRequest: Codable {



    /** UserPresence events for this batch */
    public var userPresenceEvents: [UserPresenceEvent]?

    public init(userPresenceEvents: [UserPresenceEvent]?) {
        self.userPresenceEvents = userPresenceEvents
    }


}




public class BidGroupWorkPlanResponse: Codable {













    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The management unit to which this work plan belongs.  Nullable in some routes */
    public var managementUnit: ManagementUnitReference?
    /** The modified agent count for this work plan */
    public var overrideAgentCount: Int?
    /** The number of agents needed for this work plan to produce the optimal schedule */
    public var suggestedAgentCount: Int?
    /** The range of agent slot count per work plan. The suggested slot count must be in agent count range */
    public var agentCountRange: AgentCountRange?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, managementUnit: ManagementUnitReference?, overrideAgentCount: Int?, suggestedAgentCount: Int?, agentCountRange: AgentCountRange?, selfUri: String?) {
        self._id = _id
        self.managementUnit = managementUnit
        self.overrideAgentCount = overrideAgentCount
        self.suggestedAgentCount = suggestedAgentCount
        self.agentCountRange = agentCountRange
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case managementUnit
        case overrideAgentCount
        case suggestedAgentCount
        case agentCountRange
        case selfUri
    }


}




public class BillingUsageReport: Codable {









    public enum Status: String, Codable { 
        case inProgress = "InProgress"
        case complete = "Complete"
    }





    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** The period start date. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var startDate: Date?
    /** The period end date. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var endDate: Date?
    /** Generation status of report */
    public var status: Status?
    /** The usages for the given period. */
    public var usages: [BillingUsage]?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, startDate: Date?, endDate: Date?, status: Status?, usages: [BillingUsage]?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.startDate = startDate
        self.endDate = endDate
        self.status = status
        self.usages = usages
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case startDate
        case endDate
        case status
        case usages
        case selfUri
    }


}




public class BotAggregateQueryResponse: Codable {



    public var results: [BotAggregateDataContainer]?

    public init(results: [BotAggregateDataContainer]?) {
        self.results = results
    }


}




public class BotAggregationView: Codable {

    public enum Target: String, Codable { 
        case nbotsessionturns = "nBotSessionTurns"
        case nbotsessions = "nBotSessions"
        case obotintent = "oBotIntent"
        case obotsessioncollection = "oBotSessionCollection"
        case obotsessioncollectionselfserved = "oBotSessionCollectionSelfServed"
        case obotsessionquery = "oBotSessionQuery"
        case obotsessionqueryselfserved = "oBotSessionQuerySelfServed"
        case obotsessionturn = "oBotSessionTurn"
        case obotslot = "oBotSlot"
        case tbotdisconnect = "tBotDisconnect"
        case tbotexit = "tBotExit"
        case tbotrecognitionfailure = "tBotRecognitionFailure"
        case tbotsession = "tBotSession"
    }



    public enum Function: String, Codable { 
        case rangebound = "rangeBound"
    }



    /** Target metric name */
    public var target: Target?
    /** A unique name for this view. Must be distinct from other views and built-in metric names. */
    public var name: String?
    /** Type of view you wish to create */
    public var function: Function?
    /** Range of numbers for slicing up data */
    public var range: AggregationRange?

    public init(target: Target?, name: String?, function: Function?, range: AggregationRange?) {
        self.target = target
        self.name = name
        self.function = function
        self.range = range
    }


}




public class BotConnectorBotSummaryEntityListing: Codable {





















    public var entities: [BotSummary]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var previousUri: String?
    public var nextUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [BotSummary]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, previousUri: String?, nextUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.previousUri = previousUri
        self.nextUri = nextUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}



/** A version description for a botConnector bot. */

public class BotConnectorBotVersion: Codable {







    /** The name of the version. This can be up to 100 characters long and must be comprised of displayable characters without leading or trailing whitespace */
    public var version: String?
    /** The supported languages for this bot. EG 'en-us' or 'es', etc; These language codes are W3C language identification tags (ISO 639-1 for the language name and ISO 3166 for the country code) */
    public var supportedLanguages: [String]?
    /** A list of potential intents this bot will return, limit of 50 */
    public var intents: [BotIntent]?

    public init(version: String?, supportedLanguages: [String]?, intents: [BotIntent]?) {
        self.version = version
        self.supportedLanguages = supportedLanguages
        self.intents = intents
    }


}




public class BuActivitySettingsRequest: Codable {



    /** The ID of the activity code. This is the activity code that will be used by default for agent development activities added to the schedule */
    public var defaultActivityCodeId: String?

    public init(defaultActivityCodeId: String?) {
        self.defaultActivityCodeId = defaultActivityCodeId
    }


}




public class BuAgentScheduleHistoryChange: Codable {









    /** The metadata of the change, including who and when the change was made */
    public var metadata: BuAgentScheduleHistoryChangeMetadata?
    /** The list of changed shifts */
    public var shifts: [BuAgentScheduleShift]?
    /** The list of changed full day time off markers */
    public var fullDayTimeOffMarkers: [BuFullDayTimeOffMarker]?
    /** The deleted shifts, full day time off markers, or the entire agent schedule */
    public var deletes: BuAgentScheduleHistoryDeletedChange?

    public init(metadata: BuAgentScheduleHistoryChangeMetadata?, shifts: [BuAgentScheduleShift]?, fullDayTimeOffMarkers: [BuFullDayTimeOffMarker]?, deletes: BuAgentScheduleHistoryDeletedChange?) {
        self.metadata = metadata
        self.shifts = shifts
        self.fullDayTimeOffMarkers = fullDayTimeOffMarkers
        self.deletes = deletes
    }


}




public class BuAgentScheduleHistoryDeletedChange: Codable {







    /** The IDs of deleted shifts */
    public var shiftIds: [String]?
    /** The dates of any deleted full day time off markers */
    public var fullDayTimeOffMarkerDates: [Date]?
    /** Whether the entire agent schedule was deleted */
    public var agentSchedule: Bool?

    public init(shiftIds: [String]?, fullDayTimeOffMarkerDates: [Date]?, agentSchedule: Bool?) {
        self.shiftIds = shiftIds
        self.fullDayTimeOffMarkerDates = fullDayTimeOffMarkerDates
        self.agentSchedule = agentSchedule
    }


}




public class BuAgentScheduleHistoryResponse: Codable {









    /** The list of previously published schedules */
    public var priorPublishedSchedules: [BuScheduleReference]?
    /** The originally published agent schedules */
    public var basePublishedSchedule: BuAgentScheduleHistoryChange?
    /** The changes dropped from the schedule history. This will happen if the schedule history is too large */
    public var droppedChanges: [BuAgentScheduleHistoryDroppedChange]?
    /** The list of changes for the schedule history */
    public var changes: [BuAgentScheduleHistoryChange]?

    public init(priorPublishedSchedules: [BuScheduleReference]?, basePublishedSchedule: BuAgentScheduleHistoryChange?, droppedChanges: [BuAgentScheduleHistoryDroppedChange]?, changes: [BuAgentScheduleHistoryChange]?) {
        self.priorPublishedSchedules = priorPublishedSchedules
        self.basePublishedSchedule = basePublishedSchedule
        self.droppedChanges = droppedChanges
        self.changes = changes
    }


}




public class BuAgentScheduleQueryResponse: Codable {













    /** The user to whom this agent schedule applies */
    public var user: UserReference?
    /** The shift definitions for this agent schedule */
    public var shifts: [BuAgentScheduleShift]?
    /** Full day time off markers which apply to this agent schedule */
    public var fullDayTimeOffMarkers: [BuFullDayTimeOffMarker]?
    /** The work plan for this user */
    public var workPlan: WorkPlanReference?
    /** The work plans per week for this user from the work plan rotation. Null values in the list denotes that user is not part of any work plan for that week */
    public var workPlansPerWeek: [WorkPlanReference]?
    /** Versioned entity metadata for this agent schedule */
    public var metadata: WfmVersionedEntityMetadata?

    public init(user: UserReference?, shifts: [BuAgentScheduleShift]?, fullDayTimeOffMarkers: [BuFullDayTimeOffMarker]?, workPlan: WorkPlanReference?, workPlansPerWeek: [WorkPlanReference]?, metadata: WfmVersionedEntityMetadata?) {
        self.user = user
        self.shifts = shifts
        self.fullDayTimeOffMarkers = fullDayTimeOffMarkers
        self.workPlan = workPlan
        self.workPlansPerWeek = workPlansPerWeek
        self.metadata = metadata
    }


}




public class BuAgentScheduleUpdate: Codable {

    public enum ModelType: String, Codable { 
        case added = "Added"
        case edited = "Edited"
        case deleted = "Deleted"
    }



    /** The type of update */
    public var type: ModelType?
    /** The start date for the affected shifts */
    public var shiftStartDates: [Date]?

    public init(type: ModelType?, shiftStartDates: [Date]?) {
        self.type = type
        self.shiftStartDates = shiftStartDates
    }


}




public class BuAgentSchedulesQueryResponse: Codable {





    /** The requested agent schedules */
    public var agentSchedules: [BuAgentScheduleQueryResponse]?
    /** The time zone configured for the business unit to which these schedules apply */
    public var businessUnitTimeZone: String?

    public init(agentSchedules: [BuAgentScheduleQueryResponse]?, businessUnitTimeZone: String?) {
        self.agentSchedules = agentSchedules
        self.businessUnitTimeZone = businessUnitTimeZone
    }


}




public class BuAsyncAgentSchedulesQueryResponse: Codable {

    public enum Status: String, Codable { 
        case processing = "Processing"
        case complete = "Complete"
        case canceled = "Canceled"
        case error = "Error"
    }









    /** The status of the operation */
    public var status: Status?
    /** The ID for the operation */
    public var operationId: String?
    /** The result of the operation.  Null unless status == Complete */
    public var result: BuAgentSchedulesQueryResponse?
    /** Percent progress for the operation */
    public var progress: Int?
    /** The URL from which to download the result if it is too large to pass directly */
    public var downloadUrl: String?

    public init(status: Status?, operationId: String?, result: BuAgentSchedulesQueryResponse?, progress: Int?, downloadUrl: String?) {
        self.status = status
        self.operationId = operationId
        self.result = result
        self.progress = progress
        self.downloadUrl = downloadUrl
    }


}




public class BuAsyncScheduleRunResponse: Codable {

    public enum Status: String, Codable { 
        case processing = "Processing"
        case complete = "Complete"
        case canceled = "Canceled"
        case error = "Error"
    }





    /** The status of the operation */
    public var status: Status?
    /** The ID for the operation */
    public var operationId: String?
    /** The result of the operation.  Null unless status == Complete */
    public var result: BuScheduleRun?

    public init(status: Status?, operationId: String?, result: BuScheduleRun?) {
        self.status = status
        self.operationId = operationId
        self.result = result
    }


}




public class BuCopyScheduleRequest: Codable {





    /** The description for the new schedule */
    public var _description: String?
    /** The start weekDate for the new copy of the schedule. Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd */
    public var weekDate: Date?

    public init(_description: String?, weekDate: Date?) {
        self._description = _description
        self.weekDate = weekDate
    }

    public enum CodingKeys: String, CodingKey { 
        case _description = "description"
        case weekDate
    }


}




public class BuCreateTimeOffLimitRequest: Codable {





    /** The ID of the staffing group to which this time-off limit is associated. It can be either management unit or business unit level staffing group. One of managementUnitId or staffingGroupId must be set. This must not be set if managementUnitId has value */
    public var staffingGroupId: String?
    /** The ID of the management unit to which this time-off limit is associated. One of managementUnitId or staffingGroupId must be set. This must not be set if staffingGroupId has value */
    public var managementUnitId: String?

    public init(staffingGroupId: String?, managementUnitId: String?) {
        self.staffingGroupId = staffingGroupId
        self.managementUnitId = managementUnitId
    }


}




public class BuForecastResultResponse: Codable {





    /** The result of the operation.  Populated whenever the result is small enough to pass through the api directly */
    public var result: BuForecastResult?
    /** The download url to fetch the result.  Only populated if the result is too large to pass through the api directly */
    public var downloadUrl: String?

    public init(result: BuForecastResult?, downloadUrl: String?) {
        self.result = result
        self.downloadUrl = downloadUrl
    }


}




public class BuForecastStaffingRequirementsResult: Codable {









    /** The week number represented by this response */
    public var weekNumber: Int?
    /** The url to get the requirements results for this week */
    public var downloadUrl: String?
    /** The expiration date of the download url, as an ISO-8601 string */
    public var downloadUrlExpirationDate: Date?
    /** Results will always come via downloadUrl, however the schema is included for documentation */
    public var planningGroupStaffingRequirements: [StaffingRequirementsPlanningGroupData]?

    public init(weekNumber: Int?, downloadUrl: String?, downloadUrlExpirationDate: Date?, planningGroupStaffingRequirements: [StaffingRequirementsPlanningGroupData]?) {
        self.weekNumber = weekNumber
        self.downloadUrl = downloadUrl
        self.downloadUrlExpirationDate = downloadUrlExpirationDate
        self.planningGroupStaffingRequirements = planningGroupStaffingRequirements
    }


}




public class BuGenerateScheduleRequest: Codable {









    /** The description for the schedule */
    public var _description: String?
    /** The forecast to use when generating the schedule.  Note that the forecast must fully encompass the schedule's start week + week count */
    public var shortTermForecast: BuShortTermForecastReference?
    /** The number of weeks in the schedule. One extra day is added at the end */
    public var weekCount: Int?
    /** Additional scheduling options */
    public var options: SchedulingOptionsRequest?

    public init(_description: String?, shortTermForecast: BuShortTermForecastReference?, weekCount: Int?, options: SchedulingOptionsRequest?) {
        self._description = _description
        self.shortTermForecast = shortTermForecast
        self.weekCount = weekCount
        self.options = options
    }

    public enum CodingKeys: String, CodingKey { 
        case _description = "description"
        case shortTermForecast
        case weekCount
        case options
    }


}




public class BuHeadcountForecastBuPlanningGroupHeadcountForecastUploadSchema: Codable {





    public var entities: [BuPlanningGroupHeadcountForecastUploadSchema]?
    /** Reference start date for the interval values in each forecast entity. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var referenceStartDate: Date?

    public init(entities: [BuPlanningGroupHeadcountForecastUploadSchema]?, referenceStartDate: Date?) {
        self.entities = entities
        self.referenceStartDate = referenceStartDate
    }


}




public class BuImportAgentScheduleUploadSchema: Codable {











    /** The ID of the user to whom this agent schedule applies */
    public var userId: String?
    /** The ID of the work plan for this user.  Mutually exclusive with workPlanIdsPerWeek */
    public var workPlanId: ValueWrapperString?
    /** The IDs of the work plans per week for this user.  Mutually exclusive with workPlanId */
    public var workPlanIdsPerWeek: ListWrapperString?
    /** The shift definitions for this agent schedule */
    public var shifts: [BuAgentScheduleShiftRequest]?
    /** Any full day time off markers that apply to this agent schedule */
    public var fullDayTimeOffMarkers: [BuFullDayTimeOffMarker]?

    public init(userId: String?, workPlanId: ValueWrapperString?, workPlanIdsPerWeek: ListWrapperString?, shifts: [BuAgentScheduleShiftRequest]?, fullDayTimeOffMarkers: [BuFullDayTimeOffMarker]?) {
        self.userId = userId
        self.workPlanId = workPlanId
        self.workPlanIdsPerWeek = workPlanIdsPerWeek
        self.shifts = shifts
        self.fullDayTimeOffMarkers = fullDayTimeOffMarkers
    }


}




public class BuIntradayForecastData: Codable {





    /** The number of interactions routed into the queues in the selected planning groups for the given media type for an agent to answer */
    public var offered: Double?
    /** The average handle time in seconds an agent spent handling interactions */
    public var averageHandleTimeSeconds: Double?

    public init(offered: Double?, averageHandleTimeSeconds: Double?) {
        self.offered = offered
        self.averageHandleTimeSeconds = averageHandleTimeSeconds
    }


}




public class BuIntradayScheduleData: Codable {



    /** The total on-queue time in seconds for all agents in this group */
    public var onQueueTimeSeconds: Int64?

    public init(onQueueTimeSeconds: Int64?) {
        self.onQueueTimeSeconds = onQueueTimeSeconds
    }


}




public class BuNotificationSettingsRequest: Codable {



    /** Schedule notification settings */
    public var scheduling: BuScheduleNotificationsSettingsRequest?

    public init(scheduling: BuScheduleNotificationsSettingsRequest?) {
        self.scheduling = scheduling
    }


}




public class BuQueryAdherenceExplanationsRequest: Codable {









    /** The start date of the range to query. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var startDate: Date?
    /** The end date of the range to query. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var endDate: Date?
    /** A filter for which management units to query. Leave empty or omit entirely for all management units in the business unit */
    public var managementUnitIds: [String]?
    /** A filter for which agents within the business unit to query. Leave empty or omit entirely for all agents in the business unit (or management units if specified) */
    public var agentIds: [String]?

    public init(startDate: Date?, endDate: Date?, managementUnitIds: [String]?, agentIds: [String]?) {
        self.startDate = startDate
        self.endDate = endDate
        self.managementUnitIds = managementUnitIds
        self.agentIds = agentIds
    }


}




public class BuScheduleListItem: Codable {



















    /** The ID of the schedule */
    public var _id: String?
    /** The start week date for this schedule. Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd */
    public var weekDate: Date?
    /** The number of weeks spanned by this schedule */
    public var weekCount: Int?
    /** The description of this schedule */
    public var _description: String?
    /** Whether this schedule is published */
    public var published: Bool?
    /** The forecast used for this schedule, if applicable */
    public var shortTermForecast: BuShortTermForecastReference?
    /** Generation result summary for this schedule, if applicable */
    public var generationResults: ScheduleGenerationResultSummary?
    /** Version metadata for this schedule */
    public var metadata: WfmVersionedEntityMetadata?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, weekDate: Date?, weekCount: Int?, _description: String?, published: Bool?, shortTermForecast: BuShortTermForecastReference?, generationResults: ScheduleGenerationResultSummary?, metadata: WfmVersionedEntityMetadata?, selfUri: String?) {
        self._id = _id
        self.weekDate = weekDate
        self.weekCount = weekCount
        self._description = _description
        self.published = published
        self.shortTermForecast = shortTermForecast
        self.generationResults = generationResults
        self.metadata = metadata
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case weekDate
        case weekCount
        case _description = "description"
        case published
        case shortTermForecast
        case generationResults
        case metadata
        case selfUri
    }


}




public class BuScheduleMetadata: Codable {





















    /** The ID of the schedule */
    public var _id: String?
    /** The start week date for this schedule. Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd */
    public var weekDate: Date?
    /** The number of weeks spanned by this schedule */
    public var weekCount: Int?
    /** The description of this schedule */
    public var _description: String?
    /** Whether this schedule is published */
    public var published: Bool?
    /** The forecast used for this schedule, if applicable */
    public var shortTermForecast: BuShortTermForecastReference?
    /** Generation result summary for this schedule, if applicable */
    public var generationResults: ScheduleGenerationResultSummary?
    /** Version metadata for this schedule */
    public var metadata: WfmVersionedEntityMetadata?
    /** High level per-management unit schedule metadata */
    public var managementUnits: [BuManagementUnitScheduleSummary]?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, weekDate: Date?, weekCount: Int?, _description: String?, published: Bool?, shortTermForecast: BuShortTermForecastReference?, generationResults: ScheduleGenerationResultSummary?, metadata: WfmVersionedEntityMetadata?, managementUnits: [BuManagementUnitScheduleSummary]?, selfUri: String?) {
        self._id = _id
        self.weekDate = weekDate
        self.weekCount = weekCount
        self._description = _description
        self.published = published
        self.shortTermForecast = shortTermForecast
        self.generationResults = generationResults
        self.metadata = metadata
        self.managementUnits = managementUnits
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case weekDate
        case weekCount
        case _description = "description"
        case published
        case shortTermForecast
        case generationResults
        case metadata
        case managementUnits
        case selfUri
    }


}




public class BuScheduleNotificationsSettingsResponse: Codable {





    /** The number of minutes prior to the scheduled event to display an early reminder notification */
    public var earlyReminderMinutes: Int?
    /** List of activity category notification settings */
    public var activityCategorySettings: [BuScheduleNotificationsCategorySettings]?

    public init(earlyReminderMinutes: Int?, activityCategorySettings: [BuScheduleNotificationsCategorySettings]?) {
        self.earlyReminderMinutes = earlyReminderMinutes
        self.activityCategorySettings = activityCategorySettings
    }


}




public class BuScheduleReference: Codable {







    /** The ID of the schedule */
    public var _id: String?
    /** The start week date for this schedule. Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd */
    public var weekDate: Date?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, weekDate: Date?, selfUri: String?) {
        self._id = _id
        self.weekDate = weekDate
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case weekDate
        case selfUri
    }


}




public class BuSchedulingSettingsRequest: Codable {









    public enum ActivitySmoothingType: String, Codable { 
        case reduceConcurrentActivitiesAcrossBu = "ReduceConcurrentActivitiesAcrossBu"
        case reduceConcurrentActivitiesAcrossMu = "ReduceConcurrentActivitiesAcrossMu"
        case consistentServiceLevel = "ConsistentServiceLevel"
    }



    /** Schedule generation message severity configuration */
    public var messageSeverities: [SchedulerMessageTypeSeverity]?
    /** Synchronize set of time off properties from scheduled activities to time off requests when the schedule is published. */
    public var syncTimeOffProperties: SetWrapperSyncTimeOffProperty?
    /** Configures the max percent increase and decrease of service goals for this business unit */
    public var serviceGoalImpact: WfmServiceGoalImpactSettings?
    /** Indicates whether or not per minute granularity for scheduling will be enabled for this business unit. Defaults to false. */
    public var allowWorkPlanPerMinuteGranularity: Bool?
    /** The activity smoothing type for schedule generation in this business unit */
    public var activitySmoothingType: ActivitySmoothingType?
    /** Indicates whether to provide variability in schedule generation */
    public var induceScheduleVariability: Bool?

    public init(messageSeverities: [SchedulerMessageTypeSeverity]?, syncTimeOffProperties: SetWrapperSyncTimeOffProperty?, serviceGoalImpact: WfmServiceGoalImpactSettings?, allowWorkPlanPerMinuteGranularity: Bool?, activitySmoothingType: ActivitySmoothingType?, induceScheduleVariability: Bool?) {
        self.messageSeverities = messageSeverities
        self.syncTimeOffProperties = syncTimeOffProperties
        self.serviceGoalImpact = serviceGoalImpact
        self.allowWorkPlanPerMinuteGranularity = allowWorkPlanPerMinuteGranularity
        self.activitySmoothingType = activitySmoothingType
        self.induceScheduleVariability = induceScheduleVariability
    }


}




public class BuShortTermForecast: Codable {







    public enum CreationMethod: String, Codable { 
        case _import = "Import"
        case importedHistoricalWeightedAverage = "ImportedHistoricalWeightedAverage"
        case historicalWeightedAverage = "HistoricalWeightedAverage"
        case advanced = "Advanced"
    }

























    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The start week date of this forecast in yyyy-MM-dd.  Must fall on the start day of week for the associated business unit. Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd */
    public var weekDate: Date?
    /** The number of weeks this forecast covers */
    public var weekCount: Int?
    /** The method by which this forecast was created */
    public var creationMethod: CreationMethod?
    /** The description of this forecast */
    public var _description: String?
    /** Whether this forecast contains modifications on legacy metrics */
    public var legacy: Bool?
    /** Metadata for this forecast */
    public var metadata: WfmVersionedEntityMetadata?
    /** Whether this forecast can be used for scheduling */
    public var canUseForScheduling: Bool?
    /** The reference start date for interval-based data for this forecast. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var referenceStartDate: Date?
    /** The source day pointers for this forecast */
    public var sourceDays: [ForecastSourceDayPointer]?
    /** Any manual modifications applied to this forecast */
    public var modifications: [BuForecastModificationResponse]?
    /** Generation result metadata */
    public var generationResults: BuForecastGenerationResult?
    /** The time zone for this forecast */
    public var timeZone: String?
    /** The version of the planning groups that was used for this forecast */
    public var planningGroupsVersion: Int?
    /** A snapshot of the planning groups used for this forecast as of the version number indicated */
    public var planningGroups: ForecastPlanningGroupsResponse?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, weekDate: Date?, weekCount: Int?, creationMethod: CreationMethod?, _description: String?, legacy: Bool?, metadata: WfmVersionedEntityMetadata?, canUseForScheduling: Bool?, referenceStartDate: Date?, sourceDays: [ForecastSourceDayPointer]?, modifications: [BuForecastModificationResponse]?, generationResults: BuForecastGenerationResult?, timeZone: String?, planningGroupsVersion: Int?, planningGroups: ForecastPlanningGroupsResponse?, selfUri: String?) {
        self._id = _id
        self.weekDate = weekDate
        self.weekCount = weekCount
        self.creationMethod = creationMethod
        self._description = _description
        self.legacy = legacy
        self.metadata = metadata
        self.canUseForScheduling = canUseForScheduling
        self.referenceStartDate = referenceStartDate
        self.sourceDays = sourceDays
        self.modifications = modifications
        self.generationResults = generationResults
        self.timeZone = timeZone
        self.planningGroupsVersion = planningGroupsVersion
        self.planningGroups = planningGroups
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case weekDate
        case weekCount
        case creationMethod
        case _description = "description"
        case legacy
        case metadata
        case canUseForScheduling
        case referenceStartDate
        case sourceDays
        case modifications
        case generationResults
        case timeZone
        case planningGroupsVersion
        case planningGroups
        case selfUri
    }


}




public class BuShortTermForecastListing: Codable {



    public var entities: [BuShortTermForecastListItem]?

    public init(entities: [BuShortTermForecastListItem]?) {
        self.entities = entities
    }


}




public class BuTimeOffLimitReference: Codable {





    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, selfUri: String?) {
        self._id = _id
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
    }


}




public class BuTimeOffLimitValuesResponse: Codable {



    public var values: [BuTimeOffLimitValueRange]?

    public init(values: [BuTimeOffLimitValueRange]?) {
        self.values = values
    }


}




public class BuTimeOffPlanResponse: Codable {









    public enum AutoApprovalRule: String, Codable { 
        case never = "Never"
        case always = "Always"
        case checkLimits = "CheckLimits"
        case checkActivityCodes = "CheckActivityCodes"
        case checkLimitsAndActivityCodes = "CheckLimitsAndActivityCodes"
    }





















    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The name of this time-off plan */
    public var name: String?
    /** The IDs of activity codes associated with this time-off plan */
    public var activityCodeIds: [String]?
    /** The IDs of time-off limits associated with this time-off plan */
    public var timeOffLimits: [BuTimeOffLimitReference]?
    /** Auto approval rule for this time-off plan */
    public var autoApprovalRule: AutoApprovalRule?
    /** The number of days before the time-off request start date for when the request will be expired from the waitlist */
    public var daysBeforeStartToExpireFromWaitlist: Int?
    /** Whether newly approved time-off requests with activity codes associated with this time-off plan should be automatically published to the schedule */
    public var autoPublishApprovedTimeOffRequests: Bool?
    /** The IDs of non time-off activity codes to check for conflicts in case the auto approval rule specifies checking activity codes. If these activity codes are present in schedule and overlap with the time-off request duration, the request will not be auto approved */
    public var restrictedActivityCodes: ActivityCodesReference?
    /** Time-off type, if this time-off plan is associated with the integration */
    public var hrisTimeOffType: HrisTimeOffType?
    /** Whether this time-off plan is currently being used by agents */
    public var enabled: Bool?
    /** Whether this time-off plan counts against time-off limits */
    public var countAgainstTimeOffLimits: Bool?
    /** Business unit association, if the time-off plan belongs to a business unit. managementUnitAssociation must not be set if this is populated */
    public var businessUnitAssociation: TimeOffPlanBusinessUnitAssociation?
    /** Management Unit association, if the time-off plan belongs to a management unit. businessUnitAssociation must not be set if this is populated */
    public var managementUnitAssociation: TimeOffPlanManagementUnitAssociation?
    /** Version metadata for the time-off plan */
    public var metadata: WfmVersionedEntityMetadata?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, activityCodeIds: [String]?, timeOffLimits: [BuTimeOffLimitReference]?, autoApprovalRule: AutoApprovalRule?, daysBeforeStartToExpireFromWaitlist: Int?, autoPublishApprovedTimeOffRequests: Bool?, restrictedActivityCodes: ActivityCodesReference?, hrisTimeOffType: HrisTimeOffType?, enabled: Bool?, countAgainstTimeOffLimits: Bool?, businessUnitAssociation: TimeOffPlanBusinessUnitAssociation?, managementUnitAssociation: TimeOffPlanManagementUnitAssociation?, metadata: WfmVersionedEntityMetadata?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.activityCodeIds = activityCodeIds
        self.timeOffLimits = timeOffLimits
        self.autoApprovalRule = autoApprovalRule
        self.daysBeforeStartToExpireFromWaitlist = daysBeforeStartToExpireFromWaitlist
        self.autoPublishApprovedTimeOffRequests = autoPublishApprovedTimeOffRequests
        self.restrictedActivityCodes = restrictedActivityCodes
        self.hrisTimeOffType = hrisTimeOffType
        self.enabled = enabled
        self.countAgainstTimeOffLimits = countAgainstTimeOffLimits
        self.businessUnitAssociation = businessUnitAssociation
        self.managementUnitAssociation = managementUnitAssociation
        self.metadata = metadata
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case activityCodeIds
        case timeOffLimits
        case autoApprovalRule
        case daysBeforeStartToExpireFromWaitlist
        case autoPublishApprovedTimeOffRequests
        case restrictedActivityCodes
        case hrisTimeOffType
        case enabled
        case countAgainstTimeOffLimits
        case businessUnitAssociation
        case managementUnitAssociation
        case metadata
        case selfUri
    }


}




public class BuUpdateAgentScheduleShift: Codable {



















    /** The ID of the shift */
    public var _id: String?
    /** The start date of this shift. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var startDate: Date?
    /** The length of this shift in minutes */
    public var lengthMinutes: Int?
    /** The activities associated with this shift */
    public var activities: [BuAgentScheduleActivity]?
    /** Whether this shift was manually edited. This is only set by clients and is used for rescheduling */
    public var manuallyEdited: Bool?
    /** The schedule to which this shift belongs */
    public var schedule: BuScheduleReference?
    /** The ID of the work plan for which the work plan shift emanates from */
    public var workPlanId: ValueWrapperString?
    /** The ID of the work plan shift that was used in schedule generation */
    public var workPlanShiftId: ValueWrapperString?
    /** Set to true to delete the shift from the agent's schedule */
    public var delete: Bool?

    public init(_id: String?, startDate: Date?, lengthMinutes: Int?, activities: [BuAgentScheduleActivity]?, manuallyEdited: Bool?, schedule: BuScheduleReference?, workPlanId: ValueWrapperString?, workPlanShiftId: ValueWrapperString?, delete: Bool?) {
        self._id = _id
        self.startDate = startDate
        self.lengthMinutes = lengthMinutes
        self.activities = activities
        self.manuallyEdited = manuallyEdited
        self.schedule = schedule
        self.workPlanId = workPlanId
        self.workPlanShiftId = workPlanShiftId
        self.delete = delete
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case startDate
        case lengthMinutes
        case activities
        case manuallyEdited
        case schedule
        case workPlanId
        case workPlanShiftId
        case delete
    }


}




public class BulkCallbackPatchResponse: Codable {







    /** A list of the results from the bulk operation. */
    public var results: [BulkResult]?
    /** The number of errors from the bulk operation. */
    public var errorCount: Int?
    /** An index of where the errors are in the listing. */
    public var errorIndexes: [Int]?

    public init(results: [BulkResult]?, errorCount: Int?, errorIndexes: [Int]?) {
        self.results = results
        self.errorCount = errorCount
        self.errorIndexes = errorIndexes
    }


}




public class BulkContactsEnrichResponse: Codable {







    /** A list of results for all of the Bulk operations specified in the request. Includes both successes and failures. Ordering is NOT guaranteed - may be in a different order from the request. */
    public var results: [BulkResponseResultExternalContactContactEnrichRequestBulkEntityErrorContactEnrichRequest]?
    /** The number of failed operations in the results. */
    public var errorCount: Int?
    /** The indexes of all failed operations in the results field. */
    public var errorIndexes: [Int]?

    public init(results: [BulkResponseResultExternalContactContactEnrichRequestBulkEntityErrorContactEnrichRequest]?, errorCount: Int?, errorIndexes: [Int]?) {
        self.results = results
        self.errorCount = errorCount
        self.errorIndexes = errorIndexes
    }


}




public class BulkEntityErrorExternalOrganizationEnrichRequest: Codable {













    /** An error code for the specific error condition. */
    public var code: String?
    /** A short error message. */
    public var message: String?
    /** The HTTP Status Code for the error. */
    public var status: Int?
    /** Whether this particular error should be retried. */
    public var retryable: Bool?
    /** Additional error details for specific fields. */
    public var details: [BulkErrorDetail]?
    /** The entity body specified in the Bulk request operation that caused this error. */
    public var entity: ExternalOrganizationEnrichRequest?

    public init(code: String?, message: String?, status: Int?, retryable: Bool?, details: [BulkErrorDetail]?, entity: ExternalOrganizationEnrichRequest?) {
        self.code = code
        self.message = message
        self.status = status
        self.retryable = retryable
        self.details = details
        self.entity = entity
    }


}




public class BulkJobTerminateResult: Codable {





    /** Error details if the operation failed. */
    public var error: BulkJobError?
    /** The result of the operation if it succeeded. For Workitem Bulk Terminate this is a summary. */
    public var entity: BulkJobTerminateResultEntity?

    public init(error: BulkJobError?, entity: BulkJobTerminateResultEntity?) {
        self.error = error
        self.entity = entity
    }


}




public class BulkJobUpdate: Codable {

    public enum State: String, Codable { 
        case queued = "Queued"
        case terminated = "Terminated"
    }

    /** The destination state of the bulk job. */
    public var state: State?

    public init(state: State?) {
        self.state = state
    }


}




public class BulkOrganizationsRequest: Codable {



    public var entities: [ExternalOrganization]?

    public init(entities: [ExternalOrganization]?) {
        self.entities = entities
    }


}




public class BulkResult: Codable {





    /** Error details if the operation failed. */
    public var error: BulkError?
    /** The result of the operation if it succeeded. */
    public var entity: JSON?

    public init(error: BulkError?, entity: JSON?) {
        self.error = error
        self.entity = entity
    }


}




public class BulkResponseResultVoidEntityBulkEntityErrorEntity: Codable {











    /** The id associated with this operation. For Bulk Enrich, this id is specified in the request; for all other Bulk endpoints, this id is the id of the affected entity. */
    public var _id: String?
    /** Whether the requested operation completed successfully. */
    public var success: Bool?
    /** The entity which was affected by this Bulk operation. Only returned on success. */
    public var entity: JSON?
    /** An error describing why this Bulk operation failed. Only returned on failure. */
    public var error: BulkEntityErrorEntity?
    /** Status Code for the requested operation. */
    public var status: Int?

    public init(_id: String?, success: Bool?, entity: JSON?, error: BulkEntityErrorEntity?, status: Int?) {
        self._id = _id
        self.success = success
        self.entity = entity
        self.error = error
        self.status = status
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case success
        case entity
        case error
        case status
    }


}




public class BulkUpdateShiftTradeStateRequestItem: Codable {



    public enum State: String, Codable { 
        case unmatched = "Unmatched"
        case matched = "Matched"
        case approved = "Approved"
        case denied = "Denied"
        case expired = "Expired"
        case canceled = "Canceled"
    }



    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The new state to set on the shift trade */
    public var state: State?
    /** Version metadata for the shift trade */
    public var metadata: WfmVersionedEntityMetadata?

    public init(_id: String?, state: State?, metadata: WfmVersionedEntityMetadata?) {
        self._id = _id
        self.state = state
        self.metadata = metadata
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case state
        case metadata
    }


}




public class BulkUpdateShiftTradeStateResult: Codable {



    public var entities: [BulkUpdateShiftTradeStateResultItem]?

    public init(entities: [BulkUpdateShiftTradeStateResultItem]?) {
        self.entities = entities
    }


}




public class Bullseye: Codable {



    /** The bullseye rings configured for this queue. */
    public var rings: [Ring]?

    public init(rings: [Ring]?) {
        self.rings = rings
    }


}




public class BusinessUnitResponse: Codable {











    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** Settings for this business unit */
    public var settings: BusinessUnitSettingsResponse?
    /** The division to which this entity belongs. */
    public var division: DivisionReference?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, settings: BusinessUnitSettingsResponse?, division: DivisionReference?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.settings = settings
        self.division = division
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case settings
        case division
        case selfUri
    }


}



/** Defines an external media that has been ingested and cached by Genesys Cloud for conversation messaging */

public class CachedMediaItem: Codable {

















    /** The unique identifier for the cached media. */
    public var _id: String?
    /** The URL that represents the external media that has been cached */
    public var url: String?
    /** A URL to fetch the cached media */
    public var downloadUrl: String?
    /** The media type for the URL */
    public var mediaType: String?
    /** The content length of the media represented by the URL, in bytes. */
    public var contentLengthBytes: Int?
    /** The date the cached item was created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** The date the cached item expires and will be removed from the cache. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateExpires: Date?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, url: String?, downloadUrl: String?, mediaType: String?, contentLengthBytes: Int?, dateCreated: Date?, dateExpires: Date?, selfUri: String?) {
        self._id = _id
        self.url = url
        self.downloadUrl = downloadUrl
        self.mediaType = mediaType
        self.contentLengthBytes = contentLengthBytes
        self.dateCreated = dateCreated
        self.dateExpires = dateExpires
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case url
        case downloadUrl
        case mediaType
        case contentLengthBytes
        case dateCreated
        case dateExpires
        case selfUri
    }


}




public class CalibrationAssignment: Codable {









    public var calibrator: User?
    public var evaluators: [User]?
    public var evaluationForm: EvaluationForm?
    public var expertEvaluator: User?

    public init(calibrator: User?, evaluators: [User]?, evaluationForm: EvaluationForm?, expertEvaluator: User?) {
        self.calibrator = calibrator
        self.evaluators = evaluators
        self.evaluationForm = evaluationForm
        self.expertEvaluator = expertEvaluator
    }


}




public class CallBasic: Codable {

    public enum State: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case converting = "converting"
        case uploading = "uploading"
        case transmitting = "transmitting"
        case _none = "none"
    }

    public enum InitialState: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case converting = "converting"
        case uploading = "uploading"
        case transmitting = "transmitting"
        case _none = "none"
    }



    public enum Direction: String, Codable { 
        case inbound = "inbound"
        case outbound = "outbound"
    }



    public enum RecordingState: String, Codable { 
        case _none = "none"
        case active = "active"
        case paused = "paused"
    }

















    public enum DisconnectType: String, Codable { 
        case endpoint = "endpoint"
        case endpointDonotdisturb = "endpoint.donotdisturb"
        case client = "client"
        case system = "system"
        case timeout = "timeout"
        case transfer = "transfer"
        case transferConference = "transfer.conference"
        case transferConsult = "transfer.consult"
        case transferDonotdisturb = "transfer.donotdisturb"
        case transferForward = "transfer.forward"
        case transferNoanswer = "transfer.noanswer"
        case transferNotavailable = "transfer.notavailable"
        case transportFailure = "transport.failure"
        case error = "error"
        case peer = "peer"
        case other = "other"
        case spam = "spam"
        case uncallable = "uncallable"
    }









































    /** The connection state of this communication. */
    public var state: State?
    /** The initial connection state of this communication. */
    public var initialState: InitialState?
    /** A globally unique identifier for this communication. */
    public var _id: String?
    /** The direction of the call */
    public var direction: Direction?
    /** True if this call is being recorded. */
    public var recording: Bool?
    /** State of recording on this call. */
    public var recordingState: RecordingState?
    /** Contains the states of different recorders. */
    public var recordersState: RecordersState?
    /** True if this call is muted so that remote participants can't hear any audio from this end. */
    public var muted: Bool?
    /** True if this call is held and the person on this side hears hold music. */
    public var confined: Bool?
    /** True if this call is held and the person on this side hears silence. */
    public var held: Bool?
    /** True when the recording of this call is in secure pause status. */
    public var securePause: Bool?
    /** A globally unique identifier for the recording associated with this call. */
    public var recordingId: String?
    /** The time line of the participant's call, divided into activity segments. */
    public var segments: [Segment]?
    public var errorInfo: ErrorInfo?
    /** System defined string indicating what caused the communication to disconnect. Will be null until the communication disconnects. */
    public var disconnectType: DisconnectType?
    /** The timestamp the call was placed on hold in the cloud clock if the call is currently on hold. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var startHoldTime: Date?
    /** If call is an outbound fax of a document from content management, then this is the id in content management. */
    public var documentId: String?
    /** The timestamp the communication has when it is first put into an alerting state. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var startAlertingTime: Date?
    /** The timestamp when this communication was connected in the cloud clock. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var connectedTime: Date?
    /** The timestamp when this communication disconnected from the conversation in the provider clock. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var disconnectedTime: Date?
    /** List of reasons that this call was disconnected. This will be set once the call disconnects. */
    public var disconnectReasons: [DisconnectReason]?
    /** Extra information on fax transmission. */
    public var faxStatus: FaxStatus?
    /** The source provider for the call. */
    public var provider: String?
    /** The UUID of the script to use. */
    public var scriptId: String?
    /** The id of the peer communication corresponding to a matching leg for this communication. */
    public var peerId: String?
    /** User to User Information (UUI) data managed by SIP session application. */
    public var uuiData: String?
    /** Address and name data for a call endpoint. */
    public var _self: Address?
    /** Address and name data for a call endpoint. */
    public var other: Address?
    /** Call wrap up or disposition data. */
    public var wrapup: Wrapup?
    /** After-call work for the communication. */
    public var afterCallWork: AfterCallWork?
    /** Indicates if after-call work is required for a communication. Only used when the ACW Setting is Agent Requested. */
    public var afterCallWorkRequired: Bool?
    /** UUID of virtual agent assistant that provide suggestions to the agent participant during the conversation. */
    public var agentAssistantId: String?
    /** Indicates how call reaches the agent. */
    public var transferSource: String?
    /** Represents the queue settings for this media type. */
    public var queueMediaSettings: ConversationQueueMediaSettings?
    /** Call resolution data for Dialer bulk make calls commands. */
    public var disposition: Disposition?

    public init(state: State?, initialState: InitialState?, _id: String?, direction: Direction?, recording: Bool?, recordingState: RecordingState?, recordersState: RecordersState?, muted: Bool?, confined: Bool?, held: Bool?, securePause: Bool?, recordingId: String?, segments: [Segment]?, errorInfo: ErrorInfo?, disconnectType: DisconnectType?, startHoldTime: Date?, documentId: String?, startAlertingTime: Date?, connectedTime: Date?, disconnectedTime: Date?, disconnectReasons: [DisconnectReason]?, faxStatus: FaxStatus?, provider: String?, scriptId: String?, peerId: String?, uuiData: String?, _self: Address?, other: Address?, wrapup: Wrapup?, afterCallWork: AfterCallWork?, afterCallWorkRequired: Bool?, agentAssistantId: String?, transferSource: String?, queueMediaSettings: ConversationQueueMediaSettings?, disposition: Disposition?) {
        self.state = state
        self.initialState = initialState
        self._id = _id
        self.direction = direction
        self.recording = recording
        self.recordingState = recordingState
        self.recordersState = recordersState
        self.muted = muted
        self.confined = confined
        self.held = held
        self.securePause = securePause
        self.recordingId = recordingId
        self.segments = segments
        self.errorInfo = errorInfo
        self.disconnectType = disconnectType
        self.startHoldTime = startHoldTime
        self.documentId = documentId
        self.startAlertingTime = startAlertingTime
        self.connectedTime = connectedTime
        self.disconnectedTime = disconnectedTime
        self.disconnectReasons = disconnectReasons
        self.faxStatus = faxStatus
        self.provider = provider
        self.scriptId = scriptId
        self.peerId = peerId
        self.uuiData = uuiData
        self._self = _self
        self.other = other
        self.wrapup = wrapup
        self.afterCallWork = afterCallWork
        self.afterCallWorkRequired = afterCallWorkRequired
        self.agentAssistantId = agentAssistantId
        self.transferSource = transferSource
        self.queueMediaSettings = queueMediaSettings
        self.disposition = disposition
    }

    public enum CodingKeys: String, CodingKey { 
        case state
        case initialState
        case _id = "id"
        case direction
        case recording
        case recordingState
        case recordersState
        case muted
        case confined
        case held
        case securePause
        case recordingId
        case segments
        case errorInfo
        case disconnectType
        case startHoldTime
        case documentId
        case startAlertingTime
        case connectedTime
        case disconnectedTime
        case disconnectReasons
        case faxStatus
        case provider
        case scriptId
        case peerId
        case uuiData
        case _self = "self"
        case other
        case wrapup
        case afterCallWork
        case afterCallWorkRequired
        case agentAssistantId
        case transferSource
        case queueMediaSettings
        case disposition
    }


}




public class CallConversationEntityListing: Codable {





















    public var entities: [CallConversation]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var previousUri: String?
    public var nextUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [CallConversation]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, previousUri: String?, nextUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.previousUri = previousUri
        self.nextUri = nextUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class CallForwardingEventCall: Codable {



    public var targets: [CallForwardingEventTarget]?

    public init(targets: [CallForwardingEventTarget]?) {
        self.targets = targets
    }


}




public class CallForwardingEventTarget: Codable {





    public var type: String?
    public var value: String?

    public init(type: String?, value: String?) {
        self.type = type
        self.value = value
    }


}




public class CallForwardingEventUser: Codable {



    public var _id: String?

    public init(_id: String?) {
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
    }


}




public class CallRecord: Codable {





    /** Timestamp of the last attempt to reach this number. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var lastAttempt: Date?
    /** Result of the last attempt to reach this number */
    public var lastResult: String?

    public init(lastAttempt: Date?, lastResult: String?) {
        self.lastAttempt = lastAttempt
        self.lastResult = lastResult
    }


}




public class CallRoute: Codable {



    /** A list of CallTargets to be called when the CallRoute is executed */
    public var targets: [CallTarget]?

    public init(targets: [CallTarget]?) {
        self.targets = targets
    }


}




public class CallbackDisconnectIdentifier: Codable {





    /** The Conversation Id. */
    public var conversationId: String?
    /** The callback id. */
    public var callbackId: String?

    public init(conversationId: String?, callbackId: String?) {
        self.conversationId = conversationId
        self.callbackId = callbackId
    }


}




public class CallbackMediaParticipant: Codable {



















    public enum State: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case converting = "converting"
        case uploading = "uploading"
        case transmitting = "transmitting"
        case parked = "parked"
        case _none = "none"
    }

    public enum Direction: String, Codable { 
        case inbound = "inbound"
        case outbound = "outbound"
    }

    public enum DisconnectType: String, Codable { 
        case endpoint = "endpoint"
        case endpointDonotdisturb = "endpoint.donotdisturb"
        case client = "client"
        case system = "system"
        case transfer = "transfer"
        case transferConference = "transfer.conference"
        case transferConsult = "transfer.consult"
        case transferDonotdisturb = "transfer.donotdisturb"
        case transferForward = "transfer.forward"
        case transferNoanswer = "transfer.noanswer"
        case transferNotavailable = "transfer.notavailable"
        case transportFailure = "transport.failure"
        case error = "error"
        case peer = "peer"
        case other = "other"
        case spam = "spam"
        case inactivity = "inactivity"
        case sessionExpired = "session.expired"
    }







































    public enum FlaggedReason: String, Codable { 
        case general = "general"
    }































    /** The unique participant ID. */
    public var _id: String?
    /** The display friendly name of the participant. */
    public var name: String?
    /** The participant address. */
    public var address: String?
    /** The time when this participant first joined the conversation. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var startTime: Date?
    /** The timestamp when it is first put into an alerting state. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var startAlertingTime: Date?
    /** The time when this participant went connected for this media (eg: video connected time). Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var connectedTime: Date?
    /** The time when this participant went disconnected for this media (eg: video disconnected time). Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var endTime: Date?
    /** The time when this participant's hold started. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var startHoldTime: Date?
    /** The participant's purpose.  Values can be: 'agent', 'user', 'customer', 'external', 'acd', 'ivr */
    public var purpose: String?
    /** The participant's state.  Values can be: 'alerting', 'connected', 'disconnected', 'dialing', 'contacting */
    public var state: State?
    /** The participant's direction.  Values can be: 'inbound' or 'outbound' */
    public var direction: Direction?
    /** The reason the participant was disconnected from the conversation. */
    public var disconnectType: DisconnectType?
    /** Value is true when the participant is on hold. */
    public var held: Bool?
    /** Value is true when the participant requires wrap-up. */
    public var wrapupRequired: Bool?
    /** The wrap-up prompt indicating the type of wrap-up to be performed. */
    public var wrapupPrompt: String?
    /** List of roles this participant's media has had on the conversation, ie monitor, coach, etc */
    public var mediaRoles: [String]?
    /** The PureCloud user for this participant. */
    public var user: DomainEntityRef?
    /** The PureCloud queue for this participant. */
    public var queue: DomainEntityRef?
    /** The PureCloud team for this participant. */
    public var team: DomainEntityRef?
    /** A list of ad-hoc attributes for the participant. */
    public var attributes: [String:String]?
    /** If the conversation ends in error, contains additional error details. */
    public var errorInfo: ErrorInfo?
    /** The Engage script that should be used by this participant. */
    public var script: DomainEntityRef?
    /** The amount of time the participant has to complete wrap-up. */
    public var wrapupTimeoutMs: Int?
    /** Value is true when the participant has skipped wrap-up. */
    public var wrapupSkipped: Bool?
    /** Specifies how long the agent has to answer an interaction before being marked as not responding. */
    public var alertingTimeoutMs: Int?
    /** The source provider for the communication. */
    public var provider: String?
    /** If this participant represents an external contact, then this will be the reference for the external contact. */
    public var externalContact: DomainEntityRef?
    /** If this participant represents an external contact, then this will be the initial division for the external contact. This value will not be updated if the external contact is reassigned. */
    public var externalContactInitialDivisionId: String?
    /** If this participant represents an external org, then this will be the reference for the external org. */
    public var externalOrganization: DomainEntityRef?
    /** Wrapup for this participant, if it has been applied. */
    public var wrapup: Wrapup?
    /** The peer communication corresponding to a matching leg for this communication. */
    public var peer: String?
    /** The reason specifying why participant flagged the conversation. */
    public var flaggedReason: FlaggedReason?
    /** Journey System data/context that is applicable to this communication.  When used for historical purposes, the context should be immutable.  When null, there is no applicable Journey System context. */
    public var journeyContext: JourneyContext?
    /** Information on how a communication should be routed to an agent. */
    public var conversationRoutingData: ConversationRoutingData?
    /** The timestamp when this participant started after-call work. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var startAcwTime: Date?
    /** The timestamp when this participant ended after-call work. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var endAcwTime: Date?
    /** The time when this participant's communication was last parked.  Does not reset on resume. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var parkTime: Date?
    /** The time when this participant's communications will resume. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var resumeTime: Date?
    /** The outbound preview associated with this callback. */
    public var outboundPreview: DialerPreview?
    /** The voicemail associated with this callback. */
    public var voicemail: Voicemail?
    /** The list of phone number to use for this callback. */
    public var callbackNumbers: [String]?
    /** The name of the callback target. */
    public var callbackUserName: String?
    /** True if the call for the callback uses external dialing. */
    public var externalCampaign: Bool?
    /** If true, the callback can be skipped. */
    public var skipEnabled: Bool?
    /** Duration in seconds before the callback will be auto-dialed. */
    public var timeoutSeconds: Int?
    /** The id of the config for automatically placing the callback (and handling the disposition). If absent, the callback will not be placed automatically but routed to an agent as per normal. */
    public var automatedCallbackConfigId: String?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var callbackScheduledTime: Date?

    public init(_id: String?, name: String?, address: String?, startTime: Date?, startAlertingTime: Date?, connectedTime: Date?, endTime: Date?, startHoldTime: Date?, purpose: String?, state: State?, direction: Direction?, disconnectType: DisconnectType?, held: Bool?, wrapupRequired: Bool?, wrapupPrompt: String?, mediaRoles: [String]?, user: DomainEntityRef?, queue: DomainEntityRef?, team: DomainEntityRef?, attributes: [String:String]?, errorInfo: ErrorInfo?, script: DomainEntityRef?, wrapupTimeoutMs: Int?, wrapupSkipped: Bool?, alertingTimeoutMs: Int?, provider: String?, externalContact: DomainEntityRef?, externalContactInitialDivisionId: String?, externalOrganization: DomainEntityRef?, wrapup: Wrapup?, peer: String?, flaggedReason: FlaggedReason?, journeyContext: JourneyContext?, conversationRoutingData: ConversationRoutingData?, startAcwTime: Date?, endAcwTime: Date?, parkTime: Date?, resumeTime: Date?, outboundPreview: DialerPreview?, voicemail: Voicemail?, callbackNumbers: [String]?, callbackUserName: String?, externalCampaign: Bool?, skipEnabled: Bool?, timeoutSeconds: Int?, automatedCallbackConfigId: String?, callbackScheduledTime: Date?) {
        self._id = _id
        self.name = name
        self.address = address
        self.startTime = startTime
        self.startAlertingTime = startAlertingTime
        self.connectedTime = connectedTime
        self.endTime = endTime
        self.startHoldTime = startHoldTime
        self.purpose = purpose
        self.state = state
        self.direction = direction
        self.disconnectType = disconnectType
        self.held = held
        self.wrapupRequired = wrapupRequired
        self.wrapupPrompt = wrapupPrompt
        self.mediaRoles = mediaRoles
        self.user = user
        self.queue = queue
        self.team = team
        self.attributes = attributes
        self.errorInfo = errorInfo
        self.script = script
        self.wrapupTimeoutMs = wrapupTimeoutMs
        self.wrapupSkipped = wrapupSkipped
        self.alertingTimeoutMs = alertingTimeoutMs
        self.provider = provider
        self.externalContact = externalContact
        self.externalContactInitialDivisionId = externalContactInitialDivisionId
        self.externalOrganization = externalOrganization
        self.wrapup = wrapup
        self.peer = peer
        self.flaggedReason = flaggedReason
        self.journeyContext = journeyContext
        self.conversationRoutingData = conversationRoutingData
        self.startAcwTime = startAcwTime
        self.endAcwTime = endAcwTime
        self.parkTime = parkTime
        self.resumeTime = resumeTime
        self.outboundPreview = outboundPreview
        self.voicemail = voicemail
        self.callbackNumbers = callbackNumbers
        self.callbackUserName = callbackUserName
        self.externalCampaign = externalCampaign
        self.skipEnabled = skipEnabled
        self.timeoutSeconds = timeoutSeconds
        self.automatedCallbackConfigId = automatedCallbackConfigId
        self.callbackScheduledTime = callbackScheduledTime
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case address
        case startTime
        case startAlertingTime
        case connectedTime
        case endTime
        case startHoldTime
        case purpose
        case state
        case direction
        case disconnectType
        case held
        case wrapupRequired
        case wrapupPrompt
        case mediaRoles
        case user
        case queue
        case team
        case attributes
        case errorInfo
        case script
        case wrapupTimeoutMs
        case wrapupSkipped
        case alertingTimeoutMs
        case provider
        case externalContact
        case externalContactInitialDivisionId
        case externalOrganization
        case wrapup
        case peer
        case flaggedReason
        case journeyContext
        case conversationRoutingData
        case startAcwTime
        case endAcwTime
        case parkTime
        case resumeTime
        case outboundPreview
        case voicemail
        case callbackNumbers
        case callbackUserName
        case externalCampaign
        case skipEnabled
        case timeoutSeconds
        case automatedCallbackConfigId
        case callbackScheduledTime
    }


}




public class Callheader: Codable {









    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** parsed SIP headers */
    public var headers: [String:[String]]?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, headers: [String:[String]]?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.headers = headers
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case headers
        case selfUri
    }


}




public class CampaignEntityListing: Codable {





















    public var entities: [Campaign]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var previousUri: String?
    public var nextUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [Campaign]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, previousUri: String?, nextUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.previousUri = previousUri
        self.nextUri = nextUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class CampaignInteraction: Codable {



























    public enum Disposition: String, Codable { 
        case disconnect = "DISCONNECT"
        case liveVoice = "LIVE_VOICE"
        case busy = "BUSY"
        case machine = "MACHINE"
        case noAnswer = "NO_ANSWER"
        case sitCallable = "SIT_CALLABLE"
        case sitUncallable = "SIT_UNCALLABLE"
        case fax = "FAX"
    }















    public var _id: String?
    public var campaign: DomainEntityRef?
    public var agent: DomainEntityRef?
    public var contact: DomainEntityRef?
    public var destinationAddress: String?
    /** Boolean value if there is an active preview call on the interaction */
    public var activePreviewCall: Bool?
    /** The time when the last preview of the interaction was wrapped up. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var lastActivePreviewWrapupTime: Date?
    /** The time when dialer created the interaction. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var creationTime: Date?
    /** The time when the agent or system places the call. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var callPlacedTime: Date?
    /** The time when the agent was connected to the call. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var callRoutedTime: Date?
    /** The time when the customer and routing participant are connected. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var previewConnectedTime: Date?
    public var queue: DomainEntityRef?
    public var script: DomainEntityRef?
    /** Describes what happened with call analysis for instance: disposition.classification.callable.person, disposition.classification.callable.noanswer */
    public var disposition: Disposition?
    public var callerName: String?
    public var callerAddress: String?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var previewPopDeliveredTime: Date?
    public var conversation: ConversationBasic?
    /** conversation participant id that is the dialer system participant to monitor the call from dialer perspective */
    public var dialerSystemParticipantId: String?
    public var dialingMode: String?
    /** Any skills that are attached to the call for routing */
    public var skills: [DomainEntityRef]?

    public init(_id: String?, campaign: DomainEntityRef?, agent: DomainEntityRef?, contact: DomainEntityRef?, destinationAddress: String?, activePreviewCall: Bool?, lastActivePreviewWrapupTime: Date?, creationTime: Date?, callPlacedTime: Date?, callRoutedTime: Date?, previewConnectedTime: Date?, queue: DomainEntityRef?, script: DomainEntityRef?, disposition: Disposition?, callerName: String?, callerAddress: String?, previewPopDeliveredTime: Date?, conversation: ConversationBasic?, dialerSystemParticipantId: String?, dialingMode: String?, skills: [DomainEntityRef]?) {
        self._id = _id
        self.campaign = campaign
        self.agent = agent
        self.contact = contact
        self.destinationAddress = destinationAddress
        self.activePreviewCall = activePreviewCall
        self.lastActivePreviewWrapupTime = lastActivePreviewWrapupTime
        self.creationTime = creationTime
        self.callPlacedTime = callPlacedTime
        self.callRoutedTime = callRoutedTime
        self.previewConnectedTime = previewConnectedTime
        self.queue = queue
        self.script = script
        self.disposition = disposition
        self.callerName = callerName
        self.callerAddress = callerAddress
        self.previewPopDeliveredTime = previewPopDeliveredTime
        self.conversation = conversation
        self.dialerSystemParticipantId = dialerSystemParticipantId
        self.dialingMode = dialingMode
        self.skills = skills
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case campaign
        case agent
        case contact
        case destinationAddress
        case activePreviewCall
        case lastActivePreviewWrapupTime
        case creationTime
        case callPlacedTime
        case callRoutedTime
        case previewConnectedTime
        case queue
        case script
        case disposition
        case callerName
        case callerAddress
        case previewPopDeliveredTime
        case conversation
        case dialerSystemParticipantId
        case dialingMode
        case skills
    }


}




public class CampaignInteractions: Codable {













    public var campaign: DomainEntityRef?
    public var pendingInteractions: [CampaignInteraction]?
    public var proceedingInteractions: [CampaignInteraction]?
    public var previewingInteractions: [CampaignInteraction]?
    public var interactingInteractions: [CampaignInteraction]?
    public var scheduledInteractions: [CampaignInteraction]?

    public init(campaign: DomainEntityRef?, pendingInteractions: [CampaignInteraction]?, proceedingInteractions: [CampaignInteraction]?, previewingInteractions: [CampaignInteraction]?, interactingInteractions: [CampaignInteraction]?, scheduledInteractions: [CampaignInteraction]?) {
        self.campaign = campaign
        self.pendingInteractions = pendingInteractions
        self.proceedingInteractions = proceedingInteractions
        self.previewingInteractions = previewingInteractions
        self.interactingInteractions = interactingInteractions
        self.scheduledInteractions = scheduledInteractions
    }


}




public class CampaignLinesUtilization: Codable {





    /** Number of outbound lines assigned to the campaign */
    public var assignedOutboundLines: Int?
    /** Total number of available outbound lines in Campaign's Edge Group or Site */
    public var totalAvailableOutboundLines: Int?

    public init(assignedOutboundLines: Int?, totalAvailableOutboundLines: Int?) {
        self.assignedOutboundLines = assignedOutboundLines
        self.totalAvailableOutboundLines = totalAvailableOutboundLines
    }


}




public class CampaignRuleParameters: Codable {

    public enum Operator: String, Codable { 
        case equals = "equals"
        case greaterthan = "greaterThan"
        case greaterthanequalto = "greaterThanEqualTo"
        case lessthan = "lessThan"
        case lessthanequalto = "lessThanEqualTo"
        case before = "before"
        case after = "after"
        case between = "between"
        case _in = "in"
    }



    public enum Priority: String, Codable { 
        case _1 = "1"
        case _2 = "2"
        case _3 = "3"
        case _4 = "4"
        case _5 = "5"
    }

    public enum DialingMode: String, Codable { 
        case agentless = "agentless"
        case preview = "preview"
        case power = "power"
        case predictive = "predictive"
        case progressive = "progressive"
        case external = "external"
    }





















    /** The operator for comparison. Required for a CampaignRuleCondition. */
    public var _operator: Operator?
    /** The value for comparison. Required for a CampaignRuleCondition. */
    public var value: String?
    /** The priority to set a campaign to. Required for the 'setCampaignPriority' action. */
    public var priority: Priority?
    /** The dialing mode to set a campaign to. Required for the 'setCampaignDialingMode' action. */
    public var dialingMode: DialingMode?
    /** The abandon rate to set a campaign to. Required for the 'setCampaignAbandonRate' action. */
    public var abandonRate: Double?
    /** The  number of outbound lines to set a campaign to. Required for the 'setCampaignNumberOfLines' action. */
    public var outboundLineCount: Int?
    /** The relative weight to set a campaign to. Required for the 'setCampaignWeight' action. */
    public var relativeWeight: Int?
    /** The maximum number of calls per agent to set a campaign to. Required for the 'setCampaignMaxCallsPerAgent' action. */
    public var maxCallsPerAgent: Double?
    /** The queue a campaign to. Required for the 'changeCampaignQueue' action. */
    public var queue: DomainEntityRef?
    /** The number of messages per minute to set a messaging campaign to. */
    public var messagesPerMinute: Int?
    /** The number of messages per minute to set a SMS messaging campaign to. */
    public var smsMessagesPerMinute: Int?
    /** The number of messages per minute to set a Email messaging campaign to. */
    public var emailMessagesPerMinute: Int?
    /** The content template to set a SMS campaign to. */
    public var smsContentTemplate: DomainEntityRef?
    /** The content template to set a Email campaign to. */
    public var emailContentTemplate: DomainEntityRef?

    public init(_operator: Operator?, value: String?, priority: Priority?, dialingMode: DialingMode?, abandonRate: Double?, outboundLineCount: Int?, relativeWeight: Int?, maxCallsPerAgent: Double?, queue: DomainEntityRef?, messagesPerMinute: Int?, smsMessagesPerMinute: Int?, emailMessagesPerMinute: Int?, smsContentTemplate: DomainEntityRef?, emailContentTemplate: DomainEntityRef?) {
        self._operator = _operator
        self.value = value
        self.priority = priority
        self.dialingMode = dialingMode
        self.abandonRate = abandonRate
        self.outboundLineCount = outboundLineCount
        self.relativeWeight = relativeWeight
        self.maxCallsPerAgent = maxCallsPerAgent
        self.queue = queue
        self.messagesPerMinute = messagesPerMinute
        self.smsMessagesPerMinute = smsMessagesPerMinute
        self.emailMessagesPerMinute = emailMessagesPerMinute
        self.smsContentTemplate = smsContentTemplate
        self.emailContentTemplate = emailContentTemplate
    }

    public enum CodingKeys: String, CodingKey { 
        case _operator = "operator"
        case value
        case priority
        case dialingMode
        case abandonRate
        case outboundLineCount
        case relativeWeight
        case maxCallsPerAgent
        case queue
        case messagesPerMinute
        case smsMessagesPerMinute
        case emailMessagesPerMinute
        case smsContentTemplate
        case emailContentTemplate
    }


}




public class CampaignSequenceEntityListing: Codable {





















    public var entities: [CampaignSequence]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var previousUri: String?
    public var nextUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [CampaignSequence]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, previousUri: String?, nextUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.previousUri = previousUri
        self.nextUri = nextUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class CampaignStats: Codable {

























    /** Information regarding the campaign's connect rate */
    public var contactRate: ConnectRate?
    /** Number of available agents not currently being utilized */
    public var idleAgents: Int?
    /** Number of effective available agents not currently being utilized */
    public var effectiveIdleAgents: Double?
    /** Calls per agent adjusted by pace */
    public var adjustedCallsPerAgent: Double?
    /** Number of campaign calls currently ongoing */
    public var outstandingCalls: Int?
    /** Number of campaign calls currently scheduled */
    public var scheduledCalls: Int?
    /** Number of campaign calls currently timezone rescheduled */
    public var timeZoneRescheduledCalls: Int?
    /** Number of contacts that don't match filter. This is currently supported only for Campaigns with dynamic filter on. */
    public var filteredOutContactsCount: Int?
    /** Information on the campaign's number of Right Party Contacts */
    public var rightPartyContactsCount: Int?
    /** Information on the campaign's valid attempts */
    public var validAttempts: Int?
    /** Information on the campaign's lines utilization */
    public var linesUtilization: CampaignLinesUtilization?
    /** Information on the campaign's business category metrics */
    public var businessCategoryMetrics: CampaignBusinessCategoryMetrics?

    public init(contactRate: ConnectRate?, idleAgents: Int?, effectiveIdleAgents: Double?, adjustedCallsPerAgent: Double?, outstandingCalls: Int?, scheduledCalls: Int?, timeZoneRescheduledCalls: Int?, filteredOutContactsCount: Int?, rightPartyContactsCount: Int?, validAttempts: Int?, linesUtilization: CampaignLinesUtilization?, businessCategoryMetrics: CampaignBusinessCategoryMetrics?) {
        self.contactRate = contactRate
        self.idleAgents = idleAgents
        self.effectiveIdleAgents = effectiveIdleAgents
        self.adjustedCallsPerAgent = adjustedCallsPerAgent
        self.outstandingCalls = outstandingCalls
        self.scheduledCalls = scheduledCalls
        self.timeZoneRescheduledCalls = timeZoneRescheduledCalls
        self.filteredOutContactsCount = filteredOutContactsCount
        self.rightPartyContactsCount = rightPartyContactsCount
        self.validAttempts = validAttempts
        self.linesUtilization = linesUtilization
        self.businessCategoryMetrics = businessCategoryMetrics
    }


}




public class CampaignTimeSlot: Codable {







    /** The start time of the interval as an ISO-8601 string, i.e. HH:mm:ss */
    public var startTime: String?
    /** The end time of the interval as an ISO-8601 string, i.e. HH:mm:ss */
    public var stopTime: String?
    /** The day of the interval. Valid values: [1-7], representing Monday through Sunday */
    public var day: Int?

    public init(startTime: String?, stopTime: String?, day: Int?) {
        self.startTime = startTime
        self.stopTime = stopTime
        self.day = day
    }


}




public class CannedResponseLibraries: Codable {



    public enum Mode: String, Codable { 
        case all = "All"
        case selectedOnly = "SelectedOnly"
        case _none = "None"
    }

    /** Set of canned response library IDs associated with the queue only when mode is SelectedOnly. */
    public var libraryIds: [String]?
    /** The association mode of canned response libraries to queue */
    public var mode: Mode?

    public init(libraryIds: [String]?, mode: Mode?) {
        self.libraryIds = libraryIds
        self.mode = mode
    }


}



/** Template parameters for a single carousel card */

public class CardParameters: Codable {





    /** A list of Response Management carousel card body parameter substitutions for the response's messaging template */
    public var bodyParameters: [TemplateParameter]?
    /** A list of Response Management carousel card button URL parameter substitutions for the response's messaging template */
    public var buttonUrlParameters: [TemplateParameter]?

    public init(bodyParameters: [TemplateParameter]?, buttonUrlParameters: [TemplateParameter]?) {
        self.bodyParameters = bodyParameters
        self.buttonUrlParameters = buttonUrlParameters
    }


}




public class CategoriesEntityListing: Codable {





















    public var entities: [StaCategory]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var previousUri: String?
    public var nextUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [StaCategory]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, previousUri: String?, nextUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.previousUri = previousUri
        self.nextUri = nextUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class CategoryEntity: Codable {





    /** The Id of the category. */
    public var _id: String?
    /** The selfUri of the category. */
    public var selfUri: String?

    public init(_id: String?, selfUri: String?) {
        self._id = _id
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
    }


}




public class CategoryEntityListing: Codable {











    public var entities: [Category]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var pageCount: Int?

    public init(entities: [Category]?, pageSize: Int?, pageNumber: Int?, total: Int64?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.pageCount = pageCount
    }


}




public class CategoryResponse: Codable {





















    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The name of the category. */
    public var name: String?
    public var _description: String?
    public var externalId: String?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** The reference to category to which this category belongs to. */
    public var parentCategory: CategoryReference?
    /** Number of documents assigned to this category. */
    public var documentCount: Int?
    /** The reference to knowledge base to which the category belongs to. */
    public var knowledgeBase: KnowledgeBaseReference?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, _description: String?, externalId: String?, dateCreated: Date?, dateModified: Date?, parentCategory: CategoryReference?, documentCount: Int?, knowledgeBase: KnowledgeBaseReference?, selfUri: String?) {
        self._id = _id
        self.name = name
        self._description = _description
        self.externalId = externalId
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.parentCategory = parentCategory
        self.documentCount = documentCount
        self.knowledgeBase = knowledgeBase
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case _description = "description"
        case externalId
        case dateCreated
        case dateModified
        case parentCategory
        case documentCount
        case knowledgeBase
        case selfUri
    }


}




public class CategoryResponseListing: Codable {









    public var entities: [CategoryResponse]?
    public var nextUri: String?
    public var selfUri: String?
    public var previousUri: String?

    public init(entities: [CategoryResponse]?, nextUri: String?, selfUri: String?, previousUri: String?) {
        self.entities = entities
        self.nextUri = nextUri
        self.selfUri = selfUri
        self.previousUri = previousUri
    }


}




public class Channel: Codable {







    public var connectUri: String?
    public var _id: String?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var expires: Date?

    public init(connectUri: String?, _id: String?, expires: Date?) {
        self.connectUri = connectUri
        self._id = _id
        self.expires = expires
    }

    public enum CodingKeys: String, CodingKey { 
        case connectUri
        case _id = "id"
        case expires
    }


}




public class ClientPublicApiUsage: Codable {





    public enum HttpMethod: String, Codable { 
        case _get = "GET"
        case post = "POST"
        case put = "PUT"
        case patch = "PATCH"
        case delete = "DELETE"
        case head = "HEAD"
    }

















    /** The date of the usage. Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd */
    public var date: Date?
    /** The platform the request(s) is/were made on. */
    public var platform: String?
    /** The http method of the request(s) */
    public var httpMethod: HttpMethod?
    /** The templateUri of the request(s). */
    public var templateUri: String?
    /** The total number of requests. */
    public var requestCount: Int64?
    /** The number of requests resulting in a 2xx HTTP status code. */
    public var status200: Int64?
    /** The number of requests resulting in a 3xx HTTP status code. */
    public var status300: Int64?
    /** The number of requests resulting in a 4xx HTTP status code. */
    public var status400: Int64?
    /** The number of requests resulting in a 429 HTTP status code. */
    public var status429: Int64?
    /** The number of requests resulting in a 5xx HTTP status code. */
    public var status500: Int64?
    /** The organizationId that made the request. */
    public var organizationId: String?

    public init(date: Date?, platform: String?, httpMethod: HttpMethod?, templateUri: String?, requestCount: Int64?, status200: Int64?, status300: Int64?, status400: Int64?, status429: Int64?, status500: Int64?, organizationId: String?) {
        self.date = date
        self.platform = platform
        self.httpMethod = httpMethod
        self.templateUri = templateUri
        self.requestCount = requestCount
        self.status200 = status200
        self.status300 = status300
        self.status400 = status400
        self.status429 = status429
        self.status500 = status500
        self.organizationId = organizationId
    }


}



/** Represents a cloned user in a trustor organization. */

public class ClonedUser: Codable {









    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** The ID of the trustor organization this clone exists in. */
    public var trustor: DomainEntityRef?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, trustor: DomainEntityRef?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.trustor = trustor
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case trustor
        case selfUri
    }


}




public class CoachingAnnotation: Codable {















    public enum AccessType: String, Codable { 
        case _public = "Public"
        case _private = "Private"
    }



    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The user who created the annotation. */
    public var createdBy: UserReference?
    /** The date/time the annotation was created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** The last user to modify the annotation. */
    public var modifiedBy: UserReference?
    /** The date/time the annotation was last modified. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** The text of the annotation. */
    public var text: String?
    /** Flag indicating whether the annotation is deleted. */
    public var isDeleted: Bool?
    /** Determines the permissions required to view this item. */
    public var accessType: AccessType?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, createdBy: UserReference?, dateCreated: Date?, modifiedBy: UserReference?, dateModified: Date?, text: String?, isDeleted: Bool?, accessType: AccessType?, selfUri: String?) {
        self._id = _id
        self.createdBy = createdBy
        self.dateCreated = dateCreated
        self.modifiedBy = modifiedBy
        self.dateModified = dateModified
        self.text = text
        self.isDeleted = isDeleted
        self.accessType = accessType
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case createdBy
        case dateCreated
        case modifiedBy
        case dateModified
        case text
        case isDeleted
        case accessType
        case selfUri
    }


}




public class CoachingAppointmentResponseList: Codable {





















    public var entities: [CoachingAppointmentResponse]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var previousUri: String?
    public var nextUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [CoachingAppointmentResponse]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, previousUri: String?, nextUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.previousUri = previousUri
        self.nextUri = nextUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class CoachingAppointmentStatusRequest: Codable {

    public enum Status: String, Codable { 
        case scheduled = "Scheduled"
        case inProgress = "InProgress"
        case completed = "Completed"
    }

    /** The status of the coaching appointment */
    public var status: Status?

    public init(status: Status?) {
        self.status = status
    }


}




public class CoachingScheduleSlotsJobResponse: Codable {















    public enum SlotsType: String, Codable { 
        case bestTime = "BestTime"
    }



    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The attendee IDs to fetch the slots for. */
    public var attendeeIds: [String]?
    /** The facilitator IDs to fetch the slots for. */
    public var facilitatorIds: [String]?
    /** The length in minutes of the slots. */
    public var lengthInMinutes: Int?
    /** The Business Unit Id of the users. */
    public var businessUnitId: String?
    /** The Activity Code Id of the slots. */
    public var activityCodeId: String?
    /** The results of the job. */
    public var results: [CoachingScheduleSlotsJobResult]?
    /** The type of slots fetched in the job. */
    public var slotsType: SlotsType?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, attendeeIds: [String]?, facilitatorIds: [String]?, lengthInMinutes: Int?, businessUnitId: String?, activityCodeId: String?, results: [CoachingScheduleSlotsJobResult]?, slotsType: SlotsType?, selfUri: String?) {
        self._id = _id
        self.attendeeIds = attendeeIds
        self.facilitatorIds = facilitatorIds
        self.lengthInMinutes = lengthInMinutes
        self.businessUnitId = businessUnitId
        self.activityCodeId = activityCodeId
        self.results = results
        self.slotsType = slotsType
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case attendeeIds
        case facilitatorIds
        case lengthInMinutes
        case businessUnitId
        case activityCodeId
        case results
        case slotsType
        case selfUri
    }


}




public class CobrowseMediaParticipant: Codable {



















    public enum State: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case converting = "converting"
        case uploading = "uploading"
        case transmitting = "transmitting"
        case parked = "parked"
        case _none = "none"
    }

    public enum Direction: String, Codable { 
        case inbound = "inbound"
        case outbound = "outbound"
    }

    public enum DisconnectType: String, Codable { 
        case endpoint = "endpoint"
        case endpointDonotdisturb = "endpoint.donotdisturb"
        case client = "client"
        case system = "system"
        case transfer = "transfer"
        case transferConference = "transfer.conference"
        case transferConsult = "transfer.consult"
        case transferDonotdisturb = "transfer.donotdisturb"
        case transferForward = "transfer.forward"
        case transferNoanswer = "transfer.noanswer"
        case transferNotavailable = "transfer.notavailable"
        case transportFailure = "transport.failure"
        case error = "error"
        case peer = "peer"
        case other = "other"
        case spam = "spam"
        case inactivity = "inactivity"
        case sessionExpired = "session.expired"
    }







































    public enum FlaggedReason: String, Codable { 
        case general = "general"
    }























    /** The unique participant ID. */
    public var _id: String?
    /** The display friendly name of the participant. */
    public var name: String?
    /** The participant address. */
    public var address: String?
    /** The time when this participant first joined the conversation. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var startTime: Date?
    /** The timestamp when it is first put into an alerting state. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var startAlertingTime: Date?
    /** The time when this participant went connected for this media (eg: video connected time). Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var connectedTime: Date?
    /** The time when this participant went disconnected for this media (eg: video disconnected time). Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var endTime: Date?
    /** The time when this participant's hold started. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var startHoldTime: Date?
    /** The participant's purpose.  Values can be: 'agent', 'user', 'customer', 'external', 'acd', 'ivr */
    public var purpose: String?
    /** The participant's state.  Values can be: 'alerting', 'connected', 'disconnected', 'dialing', 'contacting */
    public var state: State?
    /** The participant's direction.  Values can be: 'inbound' or 'outbound' */
    public var direction: Direction?
    /** The reason the participant was disconnected from the conversation. */
    public var disconnectType: DisconnectType?
    /** Value is true when the participant is on hold. */
    public var held: Bool?
    /** Value is true when the participant requires wrap-up. */
    public var wrapupRequired: Bool?
    /** The wrap-up prompt indicating the type of wrap-up to be performed. */
    public var wrapupPrompt: String?
    /** List of roles this participant's media has had on the conversation, ie monitor, coach, etc */
    public var mediaRoles: [String]?
    /** The PureCloud user for this participant. */
    public var user: DomainEntityRef?
    /** The PureCloud queue for this participant. */
    public var queue: DomainEntityRef?
    /** The PureCloud team for this participant. */
    public var team: DomainEntityRef?
    /** A list of ad-hoc attributes for the participant. */
    public var attributes: [String:String]?
    /** If the conversation ends in error, contains additional error details. */
    public var errorInfo: ErrorInfo?
    /** The Engage script that should be used by this participant. */
    public var script: DomainEntityRef?
    /** The amount of time the participant has to complete wrap-up. */
    public var wrapupTimeoutMs: Int?
    /** Value is true when the participant has skipped wrap-up. */
    public var wrapupSkipped: Bool?
    /** Specifies how long the agent has to answer an interaction before being marked as not responding. */
    public var alertingTimeoutMs: Int?
    /** The source provider for the communication. */
    public var provider: String?
    /** If this participant represents an external contact, then this will be the reference for the external contact. */
    public var externalContact: DomainEntityRef?
    /** If this participant represents an external contact, then this will be the initial division for the external contact. This value will not be updated if the external contact is reassigned. */
    public var externalContactInitialDivisionId: String?
    /** If this participant represents an external org, then this will be the reference for the external org. */
    public var externalOrganization: DomainEntityRef?
    /** Wrapup for this participant, if it has been applied. */
    public var wrapup: Wrapup?
    /** The peer communication corresponding to a matching leg for this communication. */
    public var peer: String?
    /** The reason specifying why participant flagged the conversation. */
    public var flaggedReason: FlaggedReason?
    /** Journey System data/context that is applicable to this communication.  When used for historical purposes, the context should be immutable.  When null, there is no applicable Journey System context. */
    public var journeyContext: JourneyContext?
    /** Information on how a communication should be routed to an agent. */
    public var conversationRoutingData: ConversationRoutingData?
    /** The timestamp when this participant started after-call work. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var startAcwTime: Date?
    /** The timestamp when this participant ended after-call work. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var endAcwTime: Date?
    /** The time when this participant's communication was last parked.  Does not reset on resume. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var parkTime: Date?
    /** The time when this participant's communications will resume. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var resumeTime: Date?
    /** The co-browse session ID. */
    public var cobrowseSessionId: String?
    /** This value identifies the role of the co-browse client within the co-browse session (a client is a sharer or a viewer). */
    public var cobrowseRole: String?
    /** ID of co-browse participants for which this client has been granted control (list is empty if this client cannot control any shared pages). */
    public var controlling: [String]?
    /** The URL that can be used to open co-browse session in web browser. */
    public var viewerUrl: String?
    /** The time when the provider event which triggered this conversation update happened in the corrected provider clock. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var providerEventTime: Date?

    public init(_id: String?, name: String?, address: String?, startTime: Date?, startAlertingTime: Date?, connectedTime: Date?, endTime: Date?, startHoldTime: Date?, purpose: String?, state: State?, direction: Direction?, disconnectType: DisconnectType?, held: Bool?, wrapupRequired: Bool?, wrapupPrompt: String?, mediaRoles: [String]?, user: DomainEntityRef?, queue: DomainEntityRef?, team: DomainEntityRef?, attributes: [String:String]?, errorInfo: ErrorInfo?, script: DomainEntityRef?, wrapupTimeoutMs: Int?, wrapupSkipped: Bool?, alertingTimeoutMs: Int?, provider: String?, externalContact: DomainEntityRef?, externalContactInitialDivisionId: String?, externalOrganization: DomainEntityRef?, wrapup: Wrapup?, peer: String?, flaggedReason: FlaggedReason?, journeyContext: JourneyContext?, conversationRoutingData: ConversationRoutingData?, startAcwTime: Date?, endAcwTime: Date?, parkTime: Date?, resumeTime: Date?, cobrowseSessionId: String?, cobrowseRole: String?, controlling: [String]?, viewerUrl: String?, providerEventTime: Date?) {
        self._id = _id
        self.name = name
        self.address = address
        self.startTime = startTime
        self.startAlertingTime = startAlertingTime
        self.connectedTime = connectedTime
        self.endTime = endTime
        self.startHoldTime = startHoldTime
        self.purpose = purpose
        self.state = state
        self.direction = direction
        self.disconnectType = disconnectType
        self.held = held
        self.wrapupRequired = wrapupRequired
        self.wrapupPrompt = wrapupPrompt
        self.mediaRoles = mediaRoles
        self.user = user
        self.queue = queue
        self.team = team
        self.attributes = attributes
        self.errorInfo = errorInfo
        self.script = script
        self.wrapupTimeoutMs = wrapupTimeoutMs
        self.wrapupSkipped = wrapupSkipped
        self.alertingTimeoutMs = alertingTimeoutMs
        self.provider = provider
        self.externalContact = externalContact
        self.externalContactInitialDivisionId = externalContactInitialDivisionId
        self.externalOrganization = externalOrganization
        self.wrapup = wrapup
        self.peer = peer
        self.flaggedReason = flaggedReason
        self.journeyContext = journeyContext
        self.conversationRoutingData = conversationRoutingData
        self.startAcwTime = startAcwTime
        self.endAcwTime = endAcwTime
        self.parkTime = parkTime
        self.resumeTime = resumeTime
        self.cobrowseSessionId = cobrowseSessionId
        self.cobrowseRole = cobrowseRole
        self.controlling = controlling
        self.viewerUrl = viewerUrl
        self.providerEventTime = providerEventTime
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case address
        case startTime
        case startAlertingTime
        case connectedTime
        case endTime
        case startHoldTime
        case purpose
        case state
        case direction
        case disconnectType
        case held
        case wrapupRequired
        case wrapupPrompt
        case mediaRoles
        case user
        case queue
        case team
        case attributes
        case errorInfo
        case script
        case wrapupTimeoutMs
        case wrapupSkipped
        case alertingTimeoutMs
        case provider
        case externalContact
        case externalContactInitialDivisionId
        case externalOrganization
        case wrapup
        case peer
        case flaggedReason
        case journeyContext
        case conversationRoutingData
        case startAcwTime
        case endAcwTime
        case parkTime
        case resumeTime
        case cobrowseSessionId
        case cobrowseRole
        case controlling
        case viewerUrl
        case providerEventTime
    }


}




public class CollaborateChatGroupMessageEventTopicCollaborateChatMessage: Codable {





    public enum ActionType: String, Codable { 
        case create = "Create"
        case edit = "Edit"
        case delete = "Delete"
    }













    public var messageId: String?
    public var created: String?
    public var actionType: ActionType?
    public var body: String?
    public var from: CollaborateChatGroupMessageEventTopicCollaborateChatEntity?
    public var to: CollaborateChatGroupMessageEventTopicCollaborateChatEntity?
    public var mentions: [CollaborateChatGroupMessageEventTopicCollaborateChatEntity]?
    public var notifyAll: Bool?
    public var reactions: [String:[String]]?

    public init(messageId: String?, created: String?, actionType: ActionType?, body: String?, from: CollaborateChatGroupMessageEventTopicCollaborateChatEntity?, to: CollaborateChatGroupMessageEventTopicCollaborateChatEntity?, mentions: [CollaborateChatGroupMessageEventTopicCollaborateChatEntity]?, notifyAll: Bool?, reactions: [String:[String]]?) {
        self.messageId = messageId
        self.created = created
        self.actionType = actionType
        self.body = body
        self.from = from
        self.to = to
        self.mentions = mentions
        self.notifyAll = notifyAll
        self.reactions = reactions
    }


}




public class Column: Codable {









    /** Column name. Mandatory for Fixed position/length file format. */
    public var columnName: String?
    /** 0 based column number in delimited file format */
    public var columnNumber: Int?
    /** Zero-based position of the first column's character. Mandatory for Fixed position/length file format. */
    public var startPosition: Int?
    /** Column width. Mandatory for Fixed position/length file format. */
    public var length: Int?

    public init(columnName: String?, columnNumber: Int?, startPosition: Int?, length: Int?) {
        self.columnName = columnName
        self.columnNumber = columnNumber
        self.startPosition = startPosition
        self.length = length
    }


}




public class CommandStatus: Codable {









    public enum StatusCode: String, Codable { 
        case inprogress = "INPROGRESS"
        case complete = "COMPLETE"
        case error = "ERROR"
        case canceling = "CANCELING"
        case canceled = "CANCELED"
    }

    public enum CommandType: String, Codable { 
        case upload = "UPLOAD"
        case copydocument = "COPYDOCUMENT"
        case movedocument = "MOVEDOCUMENT"
        case deleteworkspace = "DELETEWORKSPACE"
        case deletedocument = "DELETEDOCUMENT"
        case deletetag = "DELETETAG"
        case updatetag = "UPDATETAG"
        case reindex = "REINDEX"
        case cleanup = "CLEANUP"
        case replacedocument = "REPLACEDOCUMENT"
    }





    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var expiration: Date?
    public var userId: String?
    public var statusCode: StatusCode?
    public var commandType: CommandType?
    public var document: Document?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, expiration: Date?, userId: String?, statusCode: StatusCode?, commandType: CommandType?, document: Document?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.expiration = expiration
        self.userId = userId
        self.statusCode = statusCode
        self.commandType = commandType
        self.document = document
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case expiration
        case userId
        case statusCode
        case commandType
        case document
        case selfUri
    }


}




public class CommonCampaign: Codable {







    public enum MediaType: String, Codable { 
        case email = "email"
        case sms = "sms"
        case voice = "voice"
        case whatsapp = "whatsapp"
    }



    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The name of the Campaign. */
    public var name: String?
    /** The division to which this entity belongs. */
    public var division: Division?
    /** The media type used for this campaign. */
    public var mediaType: MediaType?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, division: Division?, mediaType: MediaType?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.division = division
        self.mediaType = mediaType
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case division
        case mediaType
        case selfUri
    }


}




public class CommonCampaignDivisionViewEntityListing: Codable {





















    public var entities: [CommonCampaignDivisionView]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var previousUri: String?
    public var nextUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [CommonCampaignDivisionView]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, previousUri: String?, nextUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.previousUri = previousUri
        self.nextUri = nextUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class ComparisonPeriod: Codable {















    /** The globally unique identifier for the object. */
    public var _id: String?
    /** Key Performance Indicator optimised during the comparison period. */
    public var kpi: String?
    /** Start date of the comparison period. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateStarted: Date?
    /** End date of the comparison period. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateEnded: Date?
    /** The percentage benefit on this queue for the duration of the comparison period */
    public var percentageBenefit: Double?
    /** KPI results for each metric */
    public var kpiResults: [KpiResult]?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, kpi: String?, dateStarted: Date?, dateEnded: Date?, percentageBenefit: Double?, kpiResults: [KpiResult]?, selfUri: String?) {
        self._id = _id
        self.kpi = kpi
        self.dateStarted = dateStarted
        self.dateEnded = dateEnded
        self.percentageBenefit = percentageBenefit
        self.kpiResults = kpiResults
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case kpi
        case dateStarted
        case dateEnded
        case percentageBenefit
        case kpiResults
        case selfUri
    }


}




public class ComparisonPeriodListing: Codable {







    public var total: Int64?
    public var entities: [ComparisonPeriod]?
    public var selfUri: String?

    public init(total: Int64?, entities: [ComparisonPeriod]?, selfUri: String?) {
        self.total = total
        self.entities = entities
        self.selfUri = selfUri
    }


}




public class ConditionalGroupActivation: Codable {





    /** The pilot rule for this queue, which executes periodically to determine queue health */
    public var pilotRule: ConditionalGroupActivationPilotRule?
    /** The set of rules to be periodically executed on the queue (if the pilot rule evaluates as true or there is no pilot rule) */
    public var rules: [ConditionalGroupActivationRule]?

    public init(pilotRule: ConditionalGroupActivationPilotRule?, rules: [ConditionalGroupActivationRule]?) {
        self.pilotRule = pilotRule
        self.rules = rules
    }


}




public class ConditionalGroupActivationCondition: Codable {



    public enum Operator: String, Codable { 
        case greaterThan = "GreaterThan"
        case greaterThanOrEqualTo = "GreaterThanOrEqualTo"
        case lessThan = "LessThan"
        case lessThanOrEqualTo = "LessThanOrEqualTo"
        case equalTo = "EqualTo"
        case notEqualTo = "NotEqualTo"
    }



    /** Instructs this condition to evaluate a simple queue-level metric */
    public var simpleMetric: ConditionalGroupActivationSimpleMetric?
    /** The operator used to compare the actual value against the threshold value */
    public var _operator: Operator?
    /** The threshold value, beyond which a rule evaluates as true */
    public var value: Double?

    public init(simpleMetric: ConditionalGroupActivationSimpleMetric?, _operator: Operator?, value: Double?) {
        self.simpleMetric = simpleMetric
        self._operator = _operator
        self.value = value
    }

    public enum CodingKeys: String, CodingKey { 
        case simpleMetric
        case _operator = "operator"
        case value
    }


}




public class ConditionalGroupActivationSimpleMetric: Codable {

    public enum Metric: String, Codable { 
        case estimatedWaitTime = "EstimatedWaitTime"
        case idleAgentCount = "IdleAgentCount"
        case serviceLevel = "ServiceLevel"
    }



    /** The queue metric being evaluated */
    public var metric: Metric?
    /** The queue being evaluated for this rule.  If null, the current queue will be used. */
    public var queue: DomainEntityRef?

    public init(metric: Metric?, queue: DomainEntityRef?) {
        self.metric = metric
        self.queue = queue
    }


}




public class ConditionalGroupRoutingRule: Codable {



    public enum Metric: String, Codable { 
        case estimatedWaitTime = "EstimatedWaitTime"
        case serviceLevel = "ServiceLevel"
    }

    public enum Operator: String, Codable { 
        case greaterThan = "GreaterThan"
        case greaterThanOrEqualTo = "GreaterThanOrEqualTo"
        case lessThan = "LessThan"
        case lessThanOrEqualTo = "LessThanOrEqualTo"
    }







    /** The queue being evaluated for this rule.  If null, the current queue will be used. */
    public var queue: DomainEntityRef?
    /** The queue metric being evaluated */
    public var metric: Metric?
    /** The operator that compares the actual value against the condition value */
    public var _operator: Operator?
    /** The limit value, beyond which a rule evaluates as true */
    public var conditionValue: Double?
    /** The group(s) to activate if the rule evaluates as true */
    public var groups: [MemberGroup]?
    /** The number of seconds to wait in this rule, if it evaluates as true, before evaluating the next rule.  For the final rule, this is ignored, so need not be specified. */
    public var waitSeconds: Int?

    public init(queue: DomainEntityRef?, metric: Metric?, _operator: Operator?, conditionValue: Double?, groups: [MemberGroup]?, waitSeconds: Int?) {
        self.queue = queue
        self.metric = metric
        self._operator = _operator
        self.conditionValue = conditionValue
        self.groups = groups
        self.waitSeconds = waitSeconds
    }

    public enum CodingKeys: String, CodingKey { 
        case queue
        case metric
        case _operator = "operator"
        case conditionValue
        case groups
        case waitSeconds
    }


}




public class ConfusionUtterance: Codable {







    /** The globally unique identifier for the object. */
    public var _id: String?
    /** Utterance Text. */
    public var text: String?
    /** Utterance's similarity score, 0 being dissimilar and 1 being very similar. */
    public var similarity: Float?

    public init(_id: String?, text: String?, similarity: Float?) {
        self._id = _id
        self.text = text
        self.similarity = similarity
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case text
        case similarity
    }


}




public class ConnectedQueue: Codable {





    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, selfUri: String?) {
        self._id = _id
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
    }


}




public class ConsultTransferToExternalContact: Codable {

    public enum SpeakTo: String, Codable { 
        case destination = "DESTINATION"
        case object = "OBJECT"
        case both = "BOTH"
        case conference = "CONFERENCE"
    }





    public enum PhoneType: String, Codable { 
        case workPhone = "WorkPhone"
        case cellPhone = "CellPhone"
        case homePhone = "HomePhone"
        case otherPhone = "OtherPhone"
    }

    /** Determines to whom the initiating participant is requesting to speak. Defaults to DESTINATION */
    public var speakTo: SpeakTo?
    /** The user ID of the person who wants to talk before completing the transfer. Could be the same of the context user ID */
    public var consultingUserId: String?
    /** The external contact id. */
    public var contactId: String?
    /** The external contact phone type. */
    public var phoneType: PhoneType?

    public init(speakTo: SpeakTo?, consultingUserId: String?, contactId: String?, phoneType: PhoneType?) {
        self.speakTo = speakTo
        self.consultingUserId = consultingUserId
        self.contactId = contactId
        self.phoneType = phoneType
    }


}




public class ConsultTransferUpdate: Codable {

    public enum SpeakTo: String, Codable { 
        case destination = "DESTINATION"
        case object = "OBJECT"
        case both = "BOTH"
        case conference = "CONFERENCE"
    }



    /** Determines to whom the initiating participant is speaking. */
    public var speakTo: SpeakTo?
    /** The user ID of the person who wants to talk before completing the transfer. Could be the same of the context user ID */
    public var consultingUserId: String?

    public init(speakTo: SpeakTo?, consultingUserId: String?) {
        self.speakTo = speakTo
        self.consultingUserId = consultingUserId
    }


}




public class ConsumedResourcesEntityListing: Codable {





















    public var entities: [Dependency]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var previousUri: String?
    public var nextUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [Dependency]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, previousUri: String?, nextUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.previousUri = previousUri
        self.nextUri = nextUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class ContactAddressableEntityRef: Codable {





    public var _id: String?
    public var selfUri: String?

    public init(_id: String?, selfUri: String?) {
        self._id = _id
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
    }


}




public class ContactCallbackRequest: Codable {











    /** Campaign identifier */
    public var campaignId: String?
    /** Contact list identifier */
    public var contactListId: String?
    /** Contact identifier */
    public var contactId: String?
    /** Name of the phone column containing the number to be called */
    public var phoneColumn: String?
    /** The scheduled time for the callback as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss.SSSZ\", example = \"2016-01-02T16:59:59\" */
    public var schedule: String?

    public init(campaignId: String?, contactListId: String?, contactId: String?, phoneColumn: String?, schedule: String?) {
        self.campaignId = campaignId
        self.contactListId = contactListId
        self.contactId = contactId
        self.phoneColumn = phoneColumn
        self.schedule = schedule
    }


}




public class ContactColumnConditionSettings: Codable {



    public enum Operator: String, Codable { 
        case equals = "Equals"
        case lessThan = "LessThan"
        case lessThanEquals = "LessThanEquals"
        case greaterThan = "GreaterThan"
        case greaterThanEquals = "GreaterThanEquals"
        case contains = "Contains"
        case beginsWith = "BeginsWith"
        case endsWith = "EndsWith"
        case before = "Before"
        case after = "After"
    }



    public enum ValueType: String, Codable { 
        case dateTime = "DateTime"
        case numeric = "Numeric"
        case period = "Period"
        case string = "String"
    }

    /** The name of the contact list column to evaluate. */
    public var columnName: String?
    /** The operator to use when comparing values. */
    public var _operator: Operator?
    /** The value to compare against the contact's data. */
    public var value: String?
    /** The data type the value should be treated as. */
    public var valueType: ValueType?

    public init(columnName: String?, _operator: Operator?, value: String?, valueType: ValueType?) {
        self.columnName = columnName
        self._operator = _operator
        self.value = value
        self.valueType = valueType
    }

    public enum CodingKeys: String, CodingKey { 
        case columnName
        case _operator = "operator"
        case value
        case valueType
    }


}




public class ContactColumnToDataActionFieldMapping: Codable {





    /** The name of a contact column whose data will be passed to the data action */
    public var contactColumnName: String?
    /** The name of an input field from the data action that the contact column data will be passed to */
    public var dataActionField: String?

    public init(contactColumnName: String?, dataActionField: String?) {
        self.contactColumnName = contactColumnName
        self.dataActionField = dataActionField
    }


}




public class ContactDetailEventTopicContactUpdateEvent: Codable {









    public enum MediaType: String, Codable { 
        case unknown = "UNKNOWN"
        case voice = "VOICE"
        case chat = "CHAT"
        case email = "EMAIL"
        case callback = "CALLBACK"
        case cobrowse = "COBROWSE"
        case video = "VIDEO"
        case screenshare = "SCREENSHARE"
        case message = "MESSAGE"
        case internalmessage = "INTERNALMESSAGE"
        case screenmonitoring = "SCREENMONITORING"
    }







    public enum Direction: String, Codable { 
        case unknown = "UNKNOWN"
        case inbound = "INBOUND"
        case outbound = "OUTBOUND"
    }

















    public enum MessageType: String, Codable { 
        case unknown = "UNKNOWN"
        case sms = "SMS"
        case twitter = "TWITTER"
        case facebook = "FACEBOOK"
        case line = "LINE"
        case whatsapp = "WHATSAPP"
        case webmessaging = "WEBMESSAGING"
        case _open = "OPEN"
        case instagram = "INSTAGRAM"
        case apple = "APPLE"
    }







    public var eventTime: Int64?
    public var conversationId: String?
    public var participantId: String?
    public var sessionId: String?
    public var mediaType: MediaType?
    public var externalOrganizationId: String?
    public var externalContactId: String?
    public var provider: String?
    public var direction: Direction?
    public var ani: String?
    public var dnis: String?
    public var addressTo: String?
    public var addressFrom: String?
    public var callbackUserName: String?
    public var callbackNumbers: [String]?
    public var callbackScheduledTime: Int64?
    public var subject: String?
    public var messageType: MessageType?
    public var conversationExternalContactIds: [String]?
    public var conversationExternalOrganizationIds: [String]?
    public var divisionId: String?

    public init(eventTime: Int64?, conversationId: String?, participantId: String?, sessionId: String?, mediaType: MediaType?, externalOrganizationId: String?, externalContactId: String?, provider: String?, direction: Direction?, ani: String?, dnis: String?, addressTo: String?, addressFrom: String?, callbackUserName: String?, callbackNumbers: [String]?, callbackScheduledTime: Int64?, subject: String?, messageType: MessageType?, conversationExternalContactIds: [String]?, conversationExternalOrganizationIds: [String]?, divisionId: String?) {
        self.eventTime = eventTime
        self.conversationId = conversationId
        self.participantId = participantId
        self.sessionId = sessionId
        self.mediaType = mediaType
        self.externalOrganizationId = externalOrganizationId
        self.externalContactId = externalContactId
        self.provider = provider
        self.direction = direction
        self.ani = ani
        self.dnis = dnis
        self.addressTo = addressTo
        self.addressFrom = addressFrom
        self.callbackUserName = callbackUserName
        self.callbackNumbers = callbackNumbers
        self.callbackScheduledTime = callbackScheduledTime
        self.subject = subject
        self.messageType = messageType
        self.conversationExternalContactIds = conversationExternalContactIds
        self.conversationExternalOrganizationIds = conversationExternalOrganizationIds
        self.divisionId = divisionId
    }


}




public class ContactEnrichRequest: Codable {







    public enum Action: String, Codable { 
        case merge = "Merge"
        case upsert = "Upsert"
        case update = "Update"
        case insert = "Insert"
    }







    /** A user-specified tracker string, only useful in the Bulk-Enrich API. If one Bulk-Enrich operation in a request fails, the requested operation will be repeated in the Bulk API response, including this id field, allowing associating of request and response operations. */
    public var _id: String?
    /** The division to which this entity belongs. */
    public var division: WritableStarrableDivision?
    /** An ordered list of one or more Identifiers which might each be claimed by a Contact. `action` describes what to do with any possibly matching Contacts. Identifier lookups will occur in the order specified here. */
    public var matchingIdentifiers: [ContactIdentifier]?
    /** The action that should be taken based on any Contacts found by `matchingIdentifiers`. */
    public var action: Action?
    /** Data to be added, either as an update to an existing Contact or the body of a new Contact. Omitting a field in this contract means that it will be treated as null in the `fieldRules` logic. */
    public var contact: ExternalContact?
    /** Logic describing how to combine data from the submitted request with data found in the database. */
    public var fieldRules: EnrichFieldRules?
    /** Additional options modifying the behavior of the API operation. */
    public var options: ContactEnrichOptions?

    public init(_id: String?, division: WritableStarrableDivision?, matchingIdentifiers: [ContactIdentifier]?, action: Action?, contact: ExternalContact?, fieldRules: EnrichFieldRules?, options: ContactEnrichOptions?) {
        self._id = _id
        self.division = division
        self.matchingIdentifiers = matchingIdentifiers
        self.action = action
        self.contact = contact
        self.fieldRules = fieldRules
        self.options = options
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case division
        case matchingIdentifiers
        case action
        case contact
        case fieldRules
        case options
    }


}




public class ContactImportSettingsEntityListing: Codable {











    public var entities: [ContactImportSettings]?
    public var nextUri: String?
    public var selfUri: String?
    public var previousUri: String?
    /** The cursor that points to the next set of entities being returned. */
    public var cursors: Cursors?

    public init(entities: [ContactImportSettings]?, nextUri: String?, selfUri: String?, previousUri: String?, cursors: Cursors?) {
        self.entities = entities
        self.nextUri = nextUri
        self.selfUri = selfUri
        self.previousUri = previousUri
        self.cursors = cursors
    }


}




public class ContactListFilter: Codable {















    public enum SourceType: String, Codable { 
        case contactList = "ContactList"
        case contactListTemplate = "ContactListTemplate"
    }



    public enum FilterType: String, Codable { 
        case and = "AND"
        case or = "OR"
    }



    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The name of the list. */
    public var name: String?
    /** Creation time of the entity. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** Last modified time of the entity. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** Required for updates, must match the version number of the most recent update */
    public var version: Int?
    /** The contact list the filter is based on. Required if sourceType is ContactList */
    public var contactList: DomainEntityRef?
    /** The contact list template the filter is based on. Required if sourceType is ContactListTemplate */
    public var contactListTemplate: DomainEntityRef?
    /** The source type the filter is based on. */
    public var sourceType: SourceType?
    /** Groups of conditions to filter the contacts by. */
    public var clauses: [ContactListFilterClause]?
    /** How to join clauses together. */
    public var filterType: FilterType?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, dateCreated: Date?, dateModified: Date?, version: Int?, contactList: DomainEntityRef?, contactListTemplate: DomainEntityRef?, sourceType: SourceType?, clauses: [ContactListFilterClause]?, filterType: FilterType?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.version = version
        self.contactList = contactList
        self.contactListTemplate = contactListTemplate
        self.sourceType = sourceType
        self.clauses = clauses
        self.filterType = filterType
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case dateCreated
        case dateModified
        case version
        case contactList
        case contactListTemplate
        case sourceType
        case clauses
        case filterType
        case selfUri
    }


}




public class ContactListFilterClause: Codable {

    public enum FilterType: String, Codable { 
        case and = "AND"
        case or = "OR"
    }



    /** How to join predicates together. */
    public var filterType: FilterType?
    /** Conditions to filter the contacts by. */
    public var predicates: [ContactListFilterPredicate]?

    public init(filterType: FilterType?, predicates: [ContactListFilterPredicate]?) {
        self.filterType = filterType
        self.predicates = predicates
    }


}




public class ContactsBulkOperationJob: Codable {



    public enum State: String, Codable { 
        case inProgress = "InProgress"
        case complete = "Complete"
        case failed = "Failed"
    }

    public enum ModelType: String, Codable { 
        case bulkDelete = "BulkDelete"
        case bulkEdit = "BulkEdit"
    }













    /** The globally unique job identifier. */
    public var _id: String?
    /** The job state. */
    public var state: State?
    /** The job type. */
    public var type: ModelType?
    /** Total records that will be impacted by the bulk operation. */
    public var totalRecords: Int64?
    /** Amount of records that have been impacted by the bulk operation. */
    public var completedRecords: Int64?
    /** Percentage of records that have been impacted by the bulk operation. */
    public var percentComplete: Int?
    /** Information on failure reason. */
    public var failureReason: ErrorInfo?
    /** URI to download the original backup contacts. */
    public var downloadURI: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, state: State?, type: ModelType?, totalRecords: Int64?, completedRecords: Int64?, percentComplete: Int?, failureReason: ErrorInfo?, downloadURI: String?, selfUri: String?) {
        self._id = _id
        self.state = state
        self.type = type
        self.totalRecords = totalRecords
        self.completedRecords = completedRecords
        self.percentComplete = percentComplete
        self.failureReason = failureReason
        self.downloadURI = downloadURI
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case state
        case type
        case totalRecords
        case completedRecords
        case percentComplete
        case failureReason
        case downloadURI
        case selfUri
    }


}




public class ContactsBulkOperationJobListing: Codable {







    public var total: Int64?
    public var entities: [ContactsBulkOperationJob]?
    public var selfUri: String?

    public init(total: Int64?, entities: [ContactsBulkOperationJob]?, selfUri: String?) {
        self.total = total
        self.entities = entities
        self.selfUri = selfUri
    }


}




public class ContactsExportFilter: Codable {











    /** Filtered field should have the same value */
    public var eq: ContactsExportFieldFilter?
    /** Filtered field should match one of the listed values */
    public var _in: ContactsExportFieldListFilter?
    /** Boolean AND combination of filters */
    public var and: [ContactsExportFilter]?
    /** Boolean OR combination of filters */
    public var or: [ContactsExportFilter]?
    /** Boolean negation of filters */
    public var not: ContactsExportFilter?

    public init(eq: ContactsExportFieldFilter?, _in: ContactsExportFieldListFilter?, and: [ContactsExportFilter]?, or: [ContactsExportFilter]?, not: ContactsExportFilter?) {
        self.eq = eq
        self._in = _in
        self.and = and
        self.or = or
        self.not = not
    }

    public enum CodingKeys: String, CodingKey { 
        case eq
        case _in = "in"
        case and
        case or
        case not
    }


}




public class ContactsExportQueryConditions: Codable {





    /** Filters to apply on export */
    public var filters: ContactsExportFilter?
    /** Maximum result count in export, default is 180 000 000 */
    public var limit: Int?

    public init(filters: ContactsExportFilter?, limit: Int?) {
        self.filters = filters
        self.limit = limit
    }


}



/** User actions available on the content. All actions are optional and all actions are executed simultaneously. */

public class ContentActions: Codable {







    /** A URL of a web page to direct the user to. */
    public var url: String?
    /** The target window in which to open the URL. If empty will open a blank page or tab. */
    public var urlTarget: String?
    /** Text to be returned as the payload from a ButtonResponse when a button is clicked. The textback and title are a combination which will have to be unique across each card and carousel in order to determine which button was clicked in that card or carousel. */
    public var textback: String?

    public init(url: String?, urlTarget: String?, textback: String?) {
        self.url = url
        self.urlTarget = urlTarget
        self.textback = textback
    }


}




public class ContentFileResponse: Codable {



    public enum ModelType: String, Codable { 
        case pdf = "Pdf"
        case docx = "Docx"
        case doc = "Doc"
    }







    /** The name of the file */
    public var name: String?
    /** The file format */
    public var type: ModelType?
    /** The checksum of the file */
    public var checksum: String?
    /** The size of the file in bytes */
    public var size: Int64?
    /** Public download url for content. Needs to be expanded */
    public var contentUrl: String?

    public init(name: String?, type: ModelType?, checksum: String?, size: Int64?, contentUrl: String?) {
        self.name = name
        self.type = type
        self.checksum = checksum
        self.size = size
        self.contentUrl = contentUrl
    }


}




public class ContentManagementSingleDocumentTopicUserData: Codable {





    public var _id: String?
    public var name: String?

    public init(_id: String?, name: String?) {
        self._id = _id
        self.name = name
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
    }


}




public class ContentManagementWorkspaceDocumentsTopicDocumentDataV2: Codable {





























    public var _id: String?
    public var name: String?
    public var dateCreated: Date?
    public var dateModified: Date?
    public var workspace: ContentManagementWorkspaceDocumentsTopicWorkspaceData?
    public var createdBy: ContentManagementWorkspaceDocumentsTopicUserData?
    public var contentType: String?
    public var contentLength: Int64?
    public var filename: String?
    public var changeNumber: Int64?
    public var dateUploaded: Date?
    public var uploadedBy: ContentManagementWorkspaceDocumentsTopicUserData?
    public var lockInfo: ContentManagementWorkspaceDocumentsTopicLockData?
    public var selfUri: String?

    public init(_id: String?, name: String?, dateCreated: Date?, dateModified: Date?, workspace: ContentManagementWorkspaceDocumentsTopicWorkspaceData?, createdBy: ContentManagementWorkspaceDocumentsTopicUserData?, contentType: String?, contentLength: Int64?, filename: String?, changeNumber: Int64?, dateUploaded: Date?, uploadedBy: ContentManagementWorkspaceDocumentsTopicUserData?, lockInfo: ContentManagementWorkspaceDocumentsTopicLockData?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.workspace = workspace
        self.createdBy = createdBy
        self.contentType = contentType
        self.contentLength = contentLength
        self.filename = filename
        self.changeNumber = changeNumber
        self.dateUploaded = dateUploaded
        self.uploadedBy = uploadedBy
        self.lockInfo = lockInfo
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case dateCreated
        case dateModified
        case workspace
        case createdBy
        case contentType
        case contentLength
        case filename
        case changeNumber
        case dateUploaded
        case uploadedBy
        case lockInfo
        case selfUri
    }


}




public class ContentOfferStyleProperties: Codable {







    /** Padding of the offer. (eg. 10px) */
    public var padding: String?
    /** Text color of the offer. (eg. #FF0000) */
    public var color: String?
    /** Background color of the offer. (eg. #000000) */
    public var backgroundColor: String?

    public init(padding: String?, color: String?, backgroundColor: String?) {
        self.padding = padding
        self.color = color
        self.backgroundColor = backgroundColor
    }


}



/** User reaction to public message. */

public class ContentReaction: Codable {

    public enum ReactionType: String, Codable { 
        case like = "Like"
        case love = "Love"
        case wow = "Wow"
        case haha = "Haha"
        case sad = "Sad"
        case angry = "Angry"
        case thankful = "Thankful"
        case pride = "Pride"
        case care = "Care"
        case share = "Share"
        case comment = "Comment"
        case view = "View"
        case rating = "Rating"
    }



    /** Type of reaction. */
    public var reactionType: ReactionType?
    /** Number of users that reacted this way to the message. */
    public var count: Int?

    public init(reactionType: ReactionType?, count: Int?) {
        self.reactionType = reactionType
        self.count = count
    }


}




public class ContestCompleteDataScore: Codable {



    /** The Contest score */
    public var score: Double?

    public init(score: Double?) {
        self.score = score
    }


}




public class ContestDisqualifiedAgents: Codable {







    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The disqualification explanation */
    public var note: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, note: String?, selfUri: String?) {
        self._id = _id
        self.note = note
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case note
        case selfUri
    }


}




public class ContestProfile: Codable {







    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case selfUri
    }


}




public class ContestScoresAgentsPagedList: Codable {













    public var entities: [ContestScoresAgents]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    /** Workday of the contest scores leaderboard. Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd */
    public var dateWorkday: Date?
    public var pageCount: Int?

    public init(entities: [ContestScoresAgents]?, pageSize: Int?, pageNumber: Int?, total: Int64?, dateWorkday: Date?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.dateWorkday = dateWorkday
        self.pageCount = pageCount
    }


}




public class ContestUserRank: Codable {









    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The user's rank in contest, a lower rank is better (1 is the best) */
    public var rank: Int?
    /** The user's contest score */
    public var score: Double?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, rank: Int?, score: Double?, selfUri: String?) {
        self._id = _id
        self.rank = rank
        self.score = score
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case rank
        case score
        case selfUri
    }


}




public class ContestsCreateRequest: Codable {













    public enum WinningCriteria: String, Codable { 
        case highestOverallScore = "HighestOverallScore"
        case highestOverallPercentOfGoal = "HighestOverallPercentOfGoal"
    }





    public enum Anonymization: String, Codable { 
        case noAnonymization = "NoAnonymization"
        case all = "All"
        case allExceptTop = "AllExceptTop"
    }











    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The division for this performance profile associate to. Only set for DEFAULT profile. */
    public var division: WritableDivision?
    /** The Contest title */
    public var title: String?
    /** The Contest description */
    public var _description: String?
    /** Start date of the contest. Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd */
    public var dateStart: Date?
    /** End date of the contest. Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd */
    public var dateEnd: Date?
    /** The Contest winning criteria */
    public var winningCriteria: WinningCriteria?
    /** The Contest's Announcement Datetime. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateAnnounced: Date?
    /** The Contest's Announcement Timezone. Valid values are strings of the zone name as found in the IANA time zone database. For example: UTC, Etc/UTC, or Europe/London */
    public var announcementTimezone: String?
    /** The Contest anonymization */
    public var anonymization: Anonymization?
    /** The Contest's Metrics */
    public var metrics: [ContestMetrics]?
    /** The Contest Prizes */
    public var prizes: [ContestPrizes]?
    /** The Contest profile */
    public var profileId: String?
    /** The Contest's participants */
    public var participantIds: [String]?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, division: WritableDivision?, title: String?, _description: String?, dateStart: Date?, dateEnd: Date?, winningCriteria: WinningCriteria?, dateAnnounced: Date?, announcementTimezone: String?, anonymization: Anonymization?, metrics: [ContestMetrics]?, prizes: [ContestPrizes]?, profileId: String?, participantIds: [String]?, selfUri: String?) {
        self._id = _id
        self.division = division
        self.title = title
        self._description = _description
        self.dateStart = dateStart
        self.dateEnd = dateEnd
        self.winningCriteria = winningCriteria
        self.dateAnnounced = dateAnnounced
        self.announcementTimezone = announcementTimezone
        self.anonymization = anonymization
        self.metrics = metrics
        self.prizes = prizes
        self.profileId = profileId
        self.participantIds = participantIds
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case division
        case title
        case _description = "description"
        case dateStart
        case dateEnd
        case winningCriteria
        case dateAnnounced
        case announcementTimezone
        case anonymization
        case metrics
        case prizes
        case profileId
        case participantIds
        case selfUri
    }


}




public class ContestsEssentials: Codable {





    public enum Status: String, Codable { 
        case upcoming = "Upcoming"
        case ongoing = "Ongoing"
        case pending = "Pending"
        case recentlyCompleted = "RecentlyCompleted"
        case completed = "Completed"
        case cancelled = "Cancelled"
    }

























    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The Contest title */
    public var title: String?
    /** The Contest status */
    public var status: Status?
    /** Start date of the contest. Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd */
    public var dateStart: Date?
    /** End date of the contest. Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd */
    public var dateEnd: Date?
    /** The performance profile */
    public var profile: ContestProfile?
    /** The Number of participants in the contest */
    public var participantCount: Int?
    /** The Contest's Announcement datetime. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateAnnounced: Date?
    /** The Contest's finalize datetime, returned when a contest is complete. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateFinalized: Date?
    /** The Contest's cancelled datetime, returned when a contest is complete. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCancelled: Date?
    /** The Contest's last modified datetime. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** The datetime the contest scores were last updated. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateScoresModified: Date?
    /** The Contest's Metrics */
    public var metrics: [ContestMetrics]?
    /** The Most Recent Contest Info for the requesting participant */
    public var requestingParticipantContestInfo: ContestRequesingParticipantDailyInfo?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, title: String?, status: Status?, dateStart: Date?, dateEnd: Date?, profile: ContestProfile?, participantCount: Int?, dateAnnounced: Date?, dateFinalized: Date?, dateCancelled: Date?, dateModified: Date?, dateScoresModified: Date?, metrics: [ContestMetrics]?, requestingParticipantContestInfo: ContestRequesingParticipantDailyInfo?, selfUri: String?) {
        self._id = _id
        self.title = title
        self.status = status
        self.dateStart = dateStart
        self.dateEnd = dateEnd
        self.profile = profile
        self.participantCount = participantCount
        self.dateAnnounced = dateAnnounced
        self.dateFinalized = dateFinalized
        self.dateCancelled = dateCancelled
        self.dateModified = dateModified
        self.dateScoresModified = dateScoresModified
        self.metrics = metrics
        self.requestingParticipantContestInfo = requestingParticipantContestInfo
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case title
        case status
        case dateStart
        case dateEnd
        case profile
        case participantCount
        case dateAnnounced
        case dateFinalized
        case dateCancelled
        case dateModified
        case dateScoresModified
        case metrics
        case requestingParticipantContestInfo
        case selfUri
    }


}




public class ContextIntent: Codable {



    /** The name of the intent. */
    public var name: String?

    public init(name: String?) {
        self.name = name
    }


}




public class ContractPropertyDefinition: Codable {















    public var title: String?
    public var _description: String?
    public var type: [String]?
    public var pattern: String?
    public var format: String?
    public var items: ContractItems?
    public var properties: [String:ContractPropertyDefinition]?

    public init(title: String?, _description: String?, type: [String]?, pattern: String?, format: String?, items: ContractItems?, properties: [String:ContractPropertyDefinition]?) {
        self.title = title
        self._description = _description
        self.type = type
        self.pattern = pattern
        self.format = format
        self.items = items
        self.properties = properties
    }

    public enum CodingKeys: String, CodingKey { 
        case title
        case _description = "description"
        case type
        case pattern
        case format
        case items
        case properties
    }


}




public class Contractual: Codable {





    /** The contract schema property key that describes the input value of this column. */
    public var schemaPropertyKey: String?
    /** The nested contractual definition that is defined by a contract schema, if any. */
    public var contractual: Contractual?

    public init(schemaPropertyKey: String?, contractual: Contractual?) {
        self.schemaPropertyKey = schemaPropertyKey
        self.contractual = contractual
    }


}




public class ConversationActivityQueryPredicate: Codable {

    public enum ModelType: String, Codable { 
        case dimension = "dimension"
        case property = "property"
        case metric = "metric"
    }

    public enum Dimension: String, Codable { 
        case activerouting = "activeRouting"
        case addressfrom = "addressFrom"
        case addressto = "addressTo"
        case agentscore = "agentScore"
        case ani = "ani"
        case conversationid = "conversationId"
        case convertedfrom = "convertedFrom"
        case convertedto = "convertedTo"
        case direction = "direction"
        case dnis = "dnis"
        case mediatype = "mediaType"
        case participantname = "participantName"
        case queueid = "queueId"
        case requestedlanguageid = "requestedLanguageId"
        case requestedrouting = "requestedRouting"
        case requestedroutingskillid = "requestedRoutingSkillId"
        case routingpriority = "routingPriority"
        case scoredagentid = "scoredAgentId"
        case sessionid = "sessionId"
        case teamid = "teamId"
        case usedrouting = "usedRouting"
        case userid = "userId"
    }

    public enum Operator: String, Codable { 
        case matches = "matches"
        case exists = "exists"
        case notexists = "notExists"
    }



    /** Optional type, can usually be inferred */
    public var type: ModelType?
    /** Left hand side for dimension predicates */
    public var dimension: Dimension?
    /** Optional operator, default is matches */
    public var _operator: Operator?
    /** Right hand side for dimension predicates */
    public var value: String?

    public init(type: ModelType?, dimension: Dimension?, _operator: Operator?, value: String?) {
        self.type = type
        self.dimension = dimension
        self._operator = _operator
        self.value = value
    }

    public enum CodingKeys: String, CodingKey { 
        case type
        case dimension
        case _operator = "operator"
        case value
    }


}




public class ConversationActivityResponse: Codable {



    public enum EntityIdDimension: String, Codable { 
        case activerouting = "activeRouting"
        case addressfrom = "addressFrom"
        case addressto = "addressTo"
        case agentscore = "agentScore"
        case ani = "ani"
        case conversationid = "conversationId"
        case convertedfrom = "convertedFrom"
        case convertedto = "convertedTo"
        case direction = "direction"
        case dnis = "dnis"
        case mediatype = "mediaType"
        case participantname = "participantName"
        case queueid = "queueId"
        case requestedlanguageid = "requestedLanguageId"
        case requestedrouting = "requestedRouting"
        case requestedroutingskillid = "requestedRoutingSkillId"
        case routingpriority = "routingPriority"
        case scoredagentid = "scoredAgentId"
        case sessionid = "sessionId"
        case teamid = "teamId"
        case usedrouting = "usedRouting"
        case userid = "userId"
    }

    /** Query results */
    public var results: [ConversationActivityData]?
    /** Dimension that is used as an entityId */
    public var entityIdDimension: EntityIdDimension?

    public init(results: [ConversationActivityData]?, entityIdDimension: EntityIdDimension?) {
        self.results = results
        self.entityIdDimension = entityIdDimension
    }


}




public class ConversationAggregateDataContainer: Codable {





    /** A mapping from dimension to value */
    public var group: [String:String]?
    public var data: [StatisticalResponse]?

    public init(group: [String:String]?, data: [StatisticalResponse]?) {
        self.group = group
        self.data = data
    }


}




public class ConversationAggregateQueryClause: Codable {

    public enum ModelType: String, Codable { 
        case and = "and"
        case or = "or"
    }



    /** Boolean operation to apply to the provided predicates */
    public var type: ModelType?
    /** Like a three-word sentence: (attribute-name) (operator) (target-value). */
    public var predicates: [ConversationAggregateQueryPredicate]?

    public init(type: ModelType?, predicates: [ConversationAggregateQueryPredicate]?) {
        self.type = type
        self.predicates = predicates
    }


}




public class ConversationAggregationQuery: Codable {







    public enum GroupBy: String, Codable { 
        case activerouting = "activeRouting"
        case activeskillid = "activeSkillId"
        case addressfrom = "addressFrom"
        case addressto = "addressTo"
        case agentassistantid = "agentAssistantId"
        case agentbullseyering = "agentBullseyeRing"
        case agentowned = "agentOwned"
        case agentrank = "agentRank"
        case agentscore = "agentScore"
        case ani = "ani"
        case assignerid = "assignerId"
        case authenticated = "authenticated"
        case conversationid = "conversationId"
        case conversationinitiator = "conversationInitiator"
        case convertedfrom = "convertedFrom"
        case convertedto = "convertedTo"
        case customerparticipation = "customerParticipation"
        case deliverystatus = "deliveryStatus"
        case destinationaddress = "destinationAddress"
        case direction = "direction"
        case disconnecttype = "disconnectType"
        case divisionid = "divisionId"
        case dnis = "dnis"
        case edgeid = "edgeId"
        case eligibleagentcount = "eligibleAgentCount"
        case errorcode = "errorCode"
        case extendeddeliverystatus = "extendedDeliveryStatus"
        case externalcontactid = "externalContactId"
        case externalmediacount = "externalMediaCount"
        case externalorganizationid = "externalOrganizationId"
        case externaltag = "externalTag"
        case firstqueue = "firstQueue"
        case flaggedreason = "flaggedReason"
        case flowintype = "flowInType"
        case flowouttype = "flowOutType"
        case groupid = "groupId"
        case interactiontype = "interactionType"
        case journeyactionid = "journeyActionId"
        case journeyactionmapid = "journeyActionMapId"
        case journeyactionmapversion = "journeyActionMapVersion"
        case journeycustomerid = "journeyCustomerId"
        case journeycustomeridtype = "journeyCustomerIdType"
        case journeycustomersessionid = "journeyCustomerSessionId"
        case journeycustomersessionidtype = "journeyCustomerSessionIdType"
        case knowledgebaseid = "knowledgeBaseId"
        case mediacount = "mediaCount"
        case mediatype = "mediaType"
        case messagetype = "messageType"
        case originatingdirection = "originatingDirection"
        case originatingsocialmediapublic = "originatingSocialMediaPublic"
        case outboundcampaignid = "outboundCampaignId"
        case outboundcontactid = "outboundContactId"
        case outboundcontactlistid = "outboundContactListId"
        case participantname = "participantName"
        case peerid = "peerId"
        case proposedagentid = "proposedAgentId"
        case provider = "provider"
        case purpose = "purpose"
        case queueid = "queueId"
        case remote = "remote"
        case removedskillid = "removedSkillId"
        case requestedlanguageid = "requestedLanguageId"
        case requestedrouting = "requestedRouting"
        case requestedroutingskillid = "requestedRoutingSkillId"
        case roomid = "roomId"
        case routingpriority = "routingPriority"
        case routingring = "routingRing"
        case routingrule = "routingRule"
        case routingruletype = "routingRuleType"
        case scoredagentid = "scoredAgentId"
        case selectedagentid = "selectedAgentId"
        case selectedagentrank = "selectedAgentRank"
        case selfserved = "selfServed"
        case sessiondnis = "sessionDnis"
        case sessionid = "sessionId"
        case stationid = "stationId"
        case teamid = "teamId"
        case usedrouting = "usedRouting"
        case userid = "userId"
        case videopresent = "videoPresent"
        case waitinginteractioncount = "waitingInteractionCount"
        case wrapupcode = "wrapUpCode"
    }



    public enum Metrics: String, Codable { 
        case nblindtransferred = "nBlindTransferred"
        case nbotinteractions = "nBotInteractions"
        case ncobrowsesessions = "nCobrowseSessions"
        case nconnected = "nConnected"
        case nconsult = "nConsult"
        case nconsulttransferred = "nConsultTransferred"
        case nconversations = "nConversations"
        case nerror = "nError"
        case noffered = "nOffered"
        case noutbound = "nOutbound"
        case noutboundabandoned = "nOutboundAbandoned"
        case noutboundattempted = "nOutboundAttempted"
        case noutboundconnected = "nOutboundConnected"
        case noversla = "nOverSla"
        case nstatetransitionerror = "nStateTransitionError"
        case ntransferred = "nTransferred"
        case oaudiomessagecount = "oAudioMessageCount"
        case oexternalaudiomessagecount = "oExternalAudioMessageCount"
        case oexternalmediacount = "oExternalMediaCount"
        case omediacount = "oMediaCount"
        case omessagecount = "oMessageCount"
        case omessagesegmentcount = "oMessageSegmentCount"
        case omessageturn = "oMessageTurn"
        case oservicelevel = "oServiceLevel"
        case oservicetarget = "oServiceTarget"
        case tabandon = "tAbandon"
        case tacd = "tAcd"
        case tactivecallback = "tActiveCallback"
        case tactivecallbackcomplete = "tActiveCallbackComplete"
        case tacw = "tAcw"
        case tagentresponsetime = "tAgentResponseTime"
        case tagentvideoconnected = "tAgentVideoConnected"
        case talert = "tAlert"
        case tanswered = "tAnswered"
        case taverageagentresponsetime = "tAverageAgentResponseTime"
        case taveragecustomerresponsetime = "tAverageCustomerResponseTime"
        case tbarging = "tBarging"
        case tcoaching = "tCoaching"
        case tcoachingcomplete = "tCoachingComplete"
        case tconnected = "tConnected"
        case tcontacting = "tContacting"
        case tdialing = "tDialing"
        case tfirstconnect = "tFirstConnect"
        case tfirstdial = "tFirstDial"
        case tfirstengagement = "tFirstEngagement"
        case tfirstresponse = "tFirstResponse"
        case tflowout = "tFlowOut"
        case thandle = "tHandle"
        case theld = "tHeld"
        case theldcomplete = "tHeldComplete"
        case tivr = "tIvr"
        case tmonitoring = "tMonitoring"
        case tmonitoringcomplete = "tMonitoringComplete"
        case tnotresponding = "tNotResponding"
        case tpark = "tPark"
        case tparkcomplete = "tParkComplete"
        case tscreenmonitoring = "tScreenMonitoring"
        case tshortabandon = "tShortAbandon"
        case ttalk = "tTalk"
        case ttalkcomplete = "tTalkComplete"
        case tuserresponsetime = "tUserResponseTime"
        case tvoicemail = "tVoicemail"
        case twait = "tWait"
    }





    public enum AlternateTimeDimension: String, Codable { 
        case eventtime = "eventTime"
    }

    /** Behaves like one clause in a SQL WHERE. Specifies the date and time range of data being queried. Intervals are represented as an ISO-8601 string. For example: YYYY-MM-DDThh:mm:ss/YYYY-MM-DDThh:mm:ss */
    public var interval: String?
    /** Granularity aggregates metrics into subpartitions within the time interval specified. The default granularity is the same duration as the interval. Periods are represented as an ISO-8601 string. For example: P1D or P1DT12H */
    public var granularity: String?
    /** Time zone context used to calculate response intervals (this allows resolving DST changes). The interval offset is used even when timeZone is specified. Default is UTC. Time zones are represented as a string of the zone name as found in the IANA time zone database. For example: UTC, Etc/UTC, or Europe/London */
    public var timeZone: String?
    /** Behaves like a SQL GROUPBY. Allows for multiple levels of grouping as a list of dimensions. Partitions resulting aggregate computations into distinct named subgroups rather than across the entire result set as if it were one group. */
    public var groupBy: [GroupBy]?
    /** Behaves like a SQL WHERE clause. This is ANDed with the interval parameter. Expresses boolean logical predicates as well as dimensional filters */
    public var filter: ConversationAggregateQueryFilter?
    /** Behaves like a SQL SELECT clause. Only named metrics will be retrieved. */
    public var metrics: [Metrics]?
    /** Flattens any multivalued dimensions used in response groups (e.g. ['a','b','c']->'a,b,c') */
    public var flattenMultivaluedDimensions: Bool?
    /** Custom derived metric views */
    public var views: [ConversationAggregationView]?
    /** Dimension to use as the alternative timestamp for data in the aggregate.  Choosing \"eventTime\" uses the actual time of the data event. */
    public var alternateTimeDimension: AlternateTimeDimension?

    public init(interval: String?, granularity: String?, timeZone: String?, groupBy: [GroupBy]?, filter: ConversationAggregateQueryFilter?, metrics: [Metrics]?, flattenMultivaluedDimensions: Bool?, views: [ConversationAggregationView]?, alternateTimeDimension: AlternateTimeDimension?) {
        self.interval = interval
        self.granularity = granularity
        self.timeZone = timeZone
        self.groupBy = groupBy
        self.filter = filter
        self.metrics = metrics
        self.flattenMultivaluedDimensions = flattenMultivaluedDimensions
        self.views = views
        self.alternateTimeDimension = alternateTimeDimension
    }


}




public class ConversationAggregationSort: Codable {

    public enum Name: String, Codable { 
        case nblindtransferred = "nBlindTransferred"
        case nbotinteractions = "nBotInteractions"
        case ncobrowsesessions = "nCobrowseSessions"
        case nconnected = "nConnected"
        case nconsult = "nConsult"
        case nconsulttransferred = "nConsultTransferred"
        case nconversations = "nConversations"
        case nerror = "nError"
        case noffered = "nOffered"
        case noutbound = "nOutbound"
        case noutboundabandoned = "nOutboundAbandoned"
        case noutboundattempted = "nOutboundAttempted"
        case noutboundconnected = "nOutboundConnected"
        case noversla = "nOverSla"
        case nstatetransitionerror = "nStateTransitionError"
        case ntransferred = "nTransferred"
        case oaudiomessagecount = "oAudioMessageCount"
        case oexternalaudiomessagecount = "oExternalAudioMessageCount"
        case oexternalmediacount = "oExternalMediaCount"
        case omediacount = "oMediaCount"
        case omessagecount = "oMessageCount"
        case omessagesegmentcount = "oMessageSegmentCount"
        case omessageturn = "oMessageTurn"
        case oservicetarget = "oServiceTarget"
        case tabandon = "tAbandon"
        case tacd = "tAcd"
        case tactivecallback = "tActiveCallback"
        case tactivecallbackcomplete = "tActiveCallbackComplete"
        case tacw = "tAcw"
        case tagentresponsetime = "tAgentResponseTime"
        case tagentvideoconnected = "tAgentVideoConnected"
        case talert = "tAlert"
        case tanswered = "tAnswered"
        case taverageagentresponsetime = "tAverageAgentResponseTime"
        case taveragecustomerresponsetime = "tAverageCustomerResponseTime"
        case tbarging = "tBarging"
        case tcoaching = "tCoaching"
        case tcoachingcomplete = "tCoachingComplete"
        case tconnected = "tConnected"
        case tcontacting = "tContacting"
        case tdialing = "tDialing"
        case tfirstconnect = "tFirstConnect"
        case tfirstdial = "tFirstDial"
        case tfirstengagement = "tFirstEngagement"
        case tfirstresponse = "tFirstResponse"
        case tflowout = "tFlowOut"
        case thandle = "tHandle"
        case theld = "tHeld"
        case theldcomplete = "tHeldComplete"
        case tivr = "tIvr"
        case tmonitoring = "tMonitoring"
        case tmonitoringcomplete = "tMonitoringComplete"
        case tnotresponding = "tNotResponding"
        case tpark = "tPark"
        case tparkcomplete = "tParkComplete"
        case tscreenmonitoring = "tScreenMonitoring"
        case ttalk = "tTalk"
        case ttalkcomplete = "tTalkComplete"
        case tuserresponsetime = "tUserResponseTime"
        case tvoicemail = "tVoicemail"
    }

    public enum Function: String, Codable { 
        case average = "average"
        case count = "count"
        case max = "max"
        case min = "min"
        case sum = "sum"
    }

    /** Name of the metric used for sorting values. */
    public var name: Name?
    /** Aggregation function used for the sort metric. */
    public var function: Function?

    public init(name: Name?, function: Function?) {
        self.name = name
        self.function = function
    }


}




public class ConversationAttributeFilter: Codable {



    /** Schemas and attributes to filter for. */
    public var schemas: [ConversationSchemaData]?

    public init(schemas: [ConversationSchemaData]?) {
        self.schemas = schemas
    }


}




public class ConversationBasic: Codable {























    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** The external tag associated with the conversation. */
    public var externalTag: String?
    /** The time when the conversation started. This will be the time when the first participant joined the conversation. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var startTime: Date?
    /** The time when the conversation ended. This will be the time when the last participant left the conversation, or null when the conversation is still active. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var endTime: Date?
    /** Identifiers of divisions associated with this conversation */
    public var divisions: [ConversationDivisionMembership]?
    /** True when the recording of this conversation is in secure pause status. */
    public var securePause: Bool?
    /** An optional label that categorizes the conversation.  Max-utilization settings can be configured at a per-label level */
    public var utilizationLabelId: String?
    /** The time in the future, after which this conversation would be considered inactive. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var inactivityTimeout: Date?
    /** The URI for this object */
    public var selfUri: String?
    public var participants: [ParticipantBasic]?

    public init(_id: String?, name: String?, externalTag: String?, startTime: Date?, endTime: Date?, divisions: [ConversationDivisionMembership]?, securePause: Bool?, utilizationLabelId: String?, inactivityTimeout: Date?, selfUri: String?, participants: [ParticipantBasic]?) {
        self._id = _id
        self.name = name
        self.externalTag = externalTag
        self.startTime = startTime
        self.endTime = endTime
        self.divisions = divisions
        self.securePause = securePause
        self.utilizationLabelId = utilizationLabelId
        self.inactivityTimeout = inactivityTimeout
        self.selfUri = selfUri
        self.participants = participants
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case externalTag
        case startTime
        case endTime
        case divisions
        case securePause
        case utilizationLabelId
        case inactivityTimeout
        case selfUri
        case participants
    }


}




public class ConversationCallEventTopicConversationRoutingData: Codable {











    /** A UriReference for a resource */
    public var queue: ConversationCallEventTopicUriReference?
    /** A UriReference for a resource */
    public var language: ConversationCallEventTopicUriReference?
    /** The priority of the conversation to use for routing decisions */
    public var priority: Int64?
    /** The skills to use for routing decisions */
    public var skills: [ConversationCallEventTopicUriReference]?
    /** A collection of agents and their assigned scores for this conversation (0 - 100, higher being better), for use in routing to preferred agents */
    public var scoredAgents: [ConversationCallEventTopicScoredAgent]?

    public init(queue: ConversationCallEventTopicUriReference?, language: ConversationCallEventTopicUriReference?, priority: Int64?, skills: [ConversationCallEventTopicUriReference]?, scoredAgents: [ConversationCallEventTopicScoredAgent]?) {
        self.queue = queue
        self.language = language
        self.priority = priority
        self.skills = skills
        self.scoredAgents = scoredAgents
    }


}



/** A reference to another domain entity. */

public class ConversationCallEventTopicDomainEntityRef: Codable {





    public var _id: String?
    public var selfUri: String?

    public init(_id: String?, selfUri: String?) {
        self._id = _id
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
    }


}




public class ConversationCallbackEventTopicCallbackConversation: Codable {

















    public var _id: String?
    public var name: String?
    public var participants: [ConversationCallbackEventTopicCallbackMediaParticipant]?
    public var otherMediaUris: [String]?
    public var address: String?
    public var utilizationLabelId: String?
    public var inactivityTimeout: Date?
    public var divisions: [ConversationCallbackEventTopicConversationDivisionMembership]?

    public init(_id: String?, name: String?, participants: [ConversationCallbackEventTopicCallbackMediaParticipant]?, otherMediaUris: [String]?, address: String?, utilizationLabelId: String?, inactivityTimeout: Date?, divisions: [ConversationCallbackEventTopicConversationDivisionMembership]?) {
        self._id = _id
        self.name = name
        self.participants = participants
        self.otherMediaUris = otherMediaUris
        self.address = address
        self.utilizationLabelId = utilizationLabelId
        self.inactivityTimeout = inactivityTimeout
        self.divisions = divisions
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case participants
        case otherMediaUris
        case address
        case utilizationLabelId
        case inactivityTimeout
        case divisions
    }


}




public class ConversationCallbackEventTopicDialerPreview: Codable {











    public var _id: String?
    /** The contact associated with this preview data pop */
    public var contactId: String?
    /** The contactList associated with this preview data pop. */
    public var contactListId: String?
    /** The campaignId associated with this preview data pop. */
    public var campaignId: String?
    /** The phone number columns associated with this campaign */
    public var phoneNumberColumns: [ConversationCallbackEventTopicPhoneNumberColumn]?

    public init(_id: String?, contactId: String?, contactListId: String?, campaignId: String?, phoneNumberColumns: [ConversationCallbackEventTopicPhoneNumberColumn]?) {
        self._id = _id
        self.contactId = contactId
        self.contactListId = contactListId
        self.campaignId = campaignId
        self.phoneNumberColumns = phoneNumberColumns
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case contactId
        case contactListId
        case campaignId
        case phoneNumberColumns
    }


}




public class ConversationCallbackEventTopicLimit: Codable {



    public enum Namespace: String, Codable { 
        case agentAssistant = "agent.assistant"
        case analyticsAlerting = "analytics.alerting"
        case analytics = "analytics"
        case analyticsRealtime = "analytics.realtime"
        case analyticsReportingSettings = "analytics.reporting.settings"
        case architect = "architect"
        case audiohook = "audiohook"
        case audit = "audit"
        case authApi = "auth.api"
        case authorization = "authorization"
        case automationTesting = "automation.testing"
        case bots = "bots"
        case botsVoice = "bots.voice"
        case callback = "callback"
        case cobrowse = "cobrowse"
        case contentManagement = "content.management"
        case conversation = "conversation"
        case dataactions = "dataactions"
        case datatables = "datatables"
        case directory = "directory"
        case email = "email"
        case eventOrchestration = "event.orchestration"
        case externalContacts = "external.contacts"
        case gcv = "gcv"
        case gdpr = "gdpr"
        case groups = "groups"
        case historicalAdherence = "historical.adherence"
        case infrastructureascode = "infrastructureascode"
        case integrations = "integrations"
        case intentMiner = "intent.miner"
        case journey = "journey"
        case knowledge = "knowledge"
        case languageUnderstanding = "language.understanding"
        case learning = "learning"
        case limitRegistry = "limit.registry"
        case marketplace = "marketplace"
        case mediaCommunications = "media.communications"
        case messaging = "messaging"
        case notifications = "notifications"
        case onboarding = "onboarding"
        case outbound = "outbound"
        case platformApi = "platform.api"
        case predictiveRouting = "predictive.routing"
        case presence = "presence"
        case quality = "quality"
        case recording = "recording"
        case responseManagement = "response.management"
        case routing = "routing"
        case scim = "scim"
        case search = "search"
        case secondaryAutomationTesting = "secondary.automation.testing"
        case skills = "skills"
        case speechAndTextAnalytics = "speech.and.text.analytics"
        case speechIntegration = "speech.integration"
        case supportability = "supportability"
        case taskManagement = "task.management"
        case telephonyConfiguration = "telephony.configuration"
        case usage = "usage"
        case users = "users"
        case webDeployments = "web.deployments"
        case webMessaging = "web.messaging"
        case webchat = "webchat"
        case webhooks = "webhooks"
        case workforceManagement = "workforce.management"
    }





    public var key: String?
    public var namespace: Namespace?
    public var value: Int64?
    public var documented: Bool?

    public init(key: String?, namespace: Namespace?, value: Int64?, documented: Bool?) {
        self.key = key
        self.namespace = namespace
        self.value = value
        self.documented = documented
    }


}




public class ConversationCallbackEventTopicQueueMediaSettings: Codable {









    /** Specifies how long the agent has to answer an interaction before being marked as not responding. */
    public var alertingTimeoutSeconds: Int64?
    /** Specifies the duration of the alerting sound to be played for auto answered interactions. */
    public var autoAnswerAlertToneSeconds: Double?
    /** Specifies the duration of the alerting sound to be played for manually answered interactions */
    public var manualAnswerAlertToneSeconds: Double?
    /** Flag to indicate if auto answer is enabled for the given media type or media subtype. */
    public var enableAutoAnswer: Bool?

    public init(alertingTimeoutSeconds: Int64?, autoAnswerAlertToneSeconds: Double?, manualAnswerAlertToneSeconds: Double?, enableAutoAnswer: Bool?) {
        self.alertingTimeoutSeconds = alertingTimeoutSeconds
        self.autoAnswerAlertToneSeconds = autoAnswerAlertToneSeconds
        self.manualAnswerAlertToneSeconds = manualAnswerAlertToneSeconds
        self.enableAutoAnswer = enableAutoAnswer
    }


}




public class ConversationCallbackEventTopicVoicemail: Codable {



    public enum UploadStatus: String, Codable { 
        case pending = "pending"
        case complete = "complete"
        case failed = "failed"
        case timeout = "timeout"
        case _none = "none"
    }

    /** The voicemail id */
    public var _id: String?
    /** current state of the voicemail upload */
    public var uploadStatus: UploadStatus?

    public init(_id: String?, uploadStatus: UploadStatus?) {
        self._id = _id
        self.uploadStatus = uploadStatus
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case uploadStatus
    }


}




public class ConversationCategoriesEntityListing: Codable {





















    public var entities: [ConversationCategory]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var previousUri: String?
    public var nextUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [ConversationCategory]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, previousUri: String?, nextUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.previousUri = previousUri
        self.nextUri = nextUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class ConversationChannel: Codable {

    public enum ModelType: String, Codable { 
        case unknown = "Unknown"
        case call = "Call"
        case callback = "Callback"
        case email = "Email"
        case genericObject = "GenericObject"
        case messaging = "Messaging"
        case social = "Social"
        case webchat = "Webchat"
        case voice = "Voice"
        case chat = "Chat"
        case cobrowse = "Cobrowse"
        case video = "Video"
        case screenshare = "Screenshare"
        case message = "Message"
        case internalMessage = "InternalMessage"
    }

    public enum MessageType: String, Codable { 
        case unknown = "Unknown"
        case sms = "Sms"
        case twitter = "Twitter"
        case facebook = "Facebook"
        case line = "Line"
        case whatsApp = "WhatsApp"
        case webMessaging = "WebMessaging"
        case _open = "Open"
        case instagram = "Instagram"
        case apple = "Apple"
    }



    /** The type or category of this channel. */
    public var type: ModelType?
    /** Message type for messaging conversations. */
    public var messageType: MessageType?
    /** The source provider for the conversation (e.g. Edge, PureCloud Messaging, PureCloud Email). */
    public var platform: String?

    public init(type: ModelType?, messageType: MessageType?, platform: String?) {
        self.type = type
        self.messageType = messageType
        self.platform = platform
    }


}




public class ConversationChatEventTopicConversationDivisionMembership: Codable {





    public var division: ConversationChatEventTopicDomainEntityRef?
    public var entities: [ConversationChatEventTopicDivisionEntityRef]?

    public init(division: ConversationChatEventTopicDomainEntityRef?, entities: [ConversationChatEventTopicDivisionEntityRef]?) {
        self.division = division
        self.entities = entities
    }


}



/** A subset of the Journey System's customer data at a point-in-time (for external linkage and internal usage/context) */

public class ConversationChatEventTopicJourneyCustomer: Codable {





    /** An ID of a customer within the Journey System at a point-in-time.  Note that a customer entity can have multiple customerIds based on the stitching process.  Depending on the context within the PureCloud conversation, this may or may not be mutable. */
    public var _id: String?
    /** The type of the customerId within the Journey System (e.g. cookie). */
    public var idType: String?

    public init(_id: String?, idType: String?) {
        self._id = _id
        self.idType = idType
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case idType
    }


}



/** A subset of the Journey System's tracked customer session data at a point-in-time (for external linkage and internal usage/context) */

public class ConversationChatEventTopicJourneyCustomerSession: Codable {





    /** An ID of a Customer/User's session within the Journey System at a point-in-time */
    public var _id: String?
    /** The type of the Customer/User's session within the Journey System (e.g. web, app) */
    public var type: String?

    public init(_id: String?, type: String?) {
        self._id = _id
        self.type = type
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case type
    }


}




public class ConversationChatEventTopicScoredAgent: Codable {





    /** A UriReference for a resource */
    public var agent: ConversationChatEventTopicUriReference?
    /** Agent's score for the current conversation, from 0 - 100, higher being better */
    public var score: Int64?

    public init(agent: ConversationChatEventTopicUriReference?, score: Int64?) {
        self.agent = agent
        self.score = score
    }


}




public class ConversationChecklistTopicAgentChecklistItemState: Codable {







    public enum StateFromModel: String, Codable { 
        case unknown = "Unknown"
        case ticked = "Ticked"
        case unticked = "Unticked"
    }

    public enum StateFromAgent: String, Codable { 
        case unknown = "Unknown"
        case ticked = "Ticked"
        case unticked = "Unticked"
    }











    public var _id: UUID?
    public var name: String?
    public var _description: String?
    public var stateFromModel: StateFromModel?
    public var stateFromAgent: StateFromAgent?
    public var dateLastModifiedByModel: Date?
    public var dateLastModifiedByAgent: Date?
    public var automatedCheckEnabled: Bool?
    public var important: Bool?
    public var lastModifiedInAcw: Bool?

    public init(_id: UUID?, name: String?, _description: String?, stateFromModel: StateFromModel?, stateFromAgent: StateFromAgent?, dateLastModifiedByModel: Date?, dateLastModifiedByAgent: Date?, automatedCheckEnabled: Bool?, important: Bool?, lastModifiedInAcw: Bool?) {
        self._id = _id
        self.name = name
        self._description = _description
        self.stateFromModel = stateFromModel
        self.stateFromAgent = stateFromAgent
        self.dateLastModifiedByModel = dateLastModifiedByModel
        self.dateLastModifiedByAgent = dateLastModifiedByAgent
        self.automatedCheckEnabled = automatedCheckEnabled
        self.important = important
        self.lastModifiedInAcw = lastModifiedInAcw
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case _description = "description"
        case stateFromModel
        case stateFromAgent
        case dateLastModifiedByModel
        case dateLastModifiedByAgent
        case automatedCheckEnabled
        case important
        case lastModifiedInAcw
    }


}




public class ConversationChecklistTopicAgentChecklistRuntimeEventBody: Codable {



























    public enum MediaType: String, Codable { 
        case unknown = "Unknown"
        case voice = "Voice"
        case message = "Message"
        case email = "Email"
    }

    public enum Direction: String, Codable { 
        case unknown = "Unknown"
        case inbound = "Inbound"
        case outbound = "Outbound"
    }

    public enum Status: String, Codable { 
        case unknown = "Unknown"
        case evaluationStarted = "EvaluationStarted"
        case evaluationInProgress = "EvaluationInProgress"
        case evaluationFinalized = "EvaluationFinalized"
        case evaluationFinalizedWithAcw = "EvaluationFinalizedWithAcw"
    }









    public var evaluationStartDate: Date?
    public var evaluationLastModifiedDate: Date?
    public var evaluationFinalizedDate: Date?
    public var evaluationFinalizedWithAcwDate: Date?
    public var conversationId: UUID?
    public var communicationId: UUID?
    public var agentChecklistId: UUID?
    public var name: String?
    public var language: String?
    public var agentId: String?
    public var participantId: String?
    public var queueId: UUID?
    public var assistantId: UUID?
    public var mediaType: MediaType?
    public var direction: Direction?
    public var status: Status?
    public var exitReason: String?
    public var activationTriggers: [ConversationChecklistTopicAgentChecklistActivationTrigger]?
    public var conversationContext: [ConversationChecklistTopicConversationContextTurnInfo]?
    public var agentChecklistItems: [ConversationChecklistTopicAgentChecklistItemState]?

    public init(evaluationStartDate: Date?, evaluationLastModifiedDate: Date?, evaluationFinalizedDate: Date?, evaluationFinalizedWithAcwDate: Date?, conversationId: UUID?, communicationId: UUID?, agentChecklistId: UUID?, name: String?, language: String?, agentId: String?, participantId: String?, queueId: UUID?, assistantId: UUID?, mediaType: MediaType?, direction: Direction?, status: Status?, exitReason: String?, activationTriggers: [ConversationChecklistTopicAgentChecklistActivationTrigger]?, conversationContext: [ConversationChecklistTopicConversationContextTurnInfo]?, agentChecklistItems: [ConversationChecklistTopicAgentChecklistItemState]?) {
        self.evaluationStartDate = evaluationStartDate
        self.evaluationLastModifiedDate = evaluationLastModifiedDate
        self.evaluationFinalizedDate = evaluationFinalizedDate
        self.evaluationFinalizedWithAcwDate = evaluationFinalizedWithAcwDate
        self.conversationId = conversationId
        self.communicationId = communicationId
        self.agentChecklistId = agentChecklistId
        self.name = name
        self.language = language
        self.agentId = agentId
        self.participantId = participantId
        self.queueId = queueId
        self.assistantId = assistantId
        self.mediaType = mediaType
        self.direction = direction
        self.status = status
        self.exitReason = exitReason
        self.activationTriggers = activationTriggers
        self.conversationContext = conversationContext
        self.agentChecklistItems = agentChecklistItems
    }


}




public class ConversationCobrowseEventTopicCobrowseConversation: Codable {

















    public var _id: String?
    public var name: String?
    public var participants: [ConversationCobrowseEventTopicCobrowseMediaParticipant]?
    public var otherMediaUris: [String]?
    public var address: String?
    public var utilizationLabelId: String?
    public var inactivityTimeout: Date?
    public var divisions: [ConversationCobrowseEventTopicConversationDivisionMembership]?

    public init(_id: String?, name: String?, participants: [ConversationCobrowseEventTopicCobrowseMediaParticipant]?, otherMediaUris: [String]?, address: String?, utilizationLabelId: String?, inactivityTimeout: Date?, divisions: [ConversationCobrowseEventTopicConversationDivisionMembership]?) {
        self._id = _id
        self.name = name
        self.participants = participants
        self.otherMediaUris = otherMediaUris
        self.address = address
        self.utilizationLabelId = utilizationLabelId
        self.inactivityTimeout = inactivityTimeout
        self.divisions = divisions
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case participants
        case otherMediaUris
        case address
        case utilizationLabelId
        case inactivityTimeout
        case divisions
    }


}




public class ConversationCobrowseEventTopicLimit: Codable {



    public enum Namespace: String, Codable { 
        case agentAssistant = "agent.assistant"
        case analyticsAlerting = "analytics.alerting"
        case analytics = "analytics"
        case analyticsRealtime = "analytics.realtime"
        case analyticsReportingSettings = "analytics.reporting.settings"
        case architect = "architect"
        case audiohook = "audiohook"
        case audit = "audit"
        case authApi = "auth.api"
        case authorization = "authorization"
        case automationTesting = "automation.testing"
        case bots = "bots"
        case botsVoice = "bots.voice"
        case callback = "callback"
        case cobrowse = "cobrowse"
        case contentManagement = "content.management"
        case conversation = "conversation"
        case dataactions = "dataactions"
        case datatables = "datatables"
        case directory = "directory"
        case email = "email"
        case eventOrchestration = "event.orchestration"
        case externalContacts = "external.contacts"
        case gcv = "gcv"
        case gdpr = "gdpr"
        case groups = "groups"
        case historicalAdherence = "historical.adherence"
        case infrastructureascode = "infrastructureascode"
        case integrations = "integrations"
        case intentMiner = "intent.miner"
        case journey = "journey"
        case knowledge = "knowledge"
        case languageUnderstanding = "language.understanding"
        case learning = "learning"
        case limitRegistry = "limit.registry"
        case marketplace = "marketplace"
        case mediaCommunications = "media.communications"
        case messaging = "messaging"
        case notifications = "notifications"
        case onboarding = "onboarding"
        case outbound = "outbound"
        case platformApi = "platform.api"
        case predictiveRouting = "predictive.routing"
        case presence = "presence"
        case quality = "quality"
        case recording = "recording"
        case responseManagement = "response.management"
        case routing = "routing"
        case scim = "scim"
        case search = "search"
        case secondaryAutomationTesting = "secondary.automation.testing"
        case skills = "skills"
        case speechAndTextAnalytics = "speech.and.text.analytics"
        case speechIntegration = "speech.integration"
        case supportability = "supportability"
        case taskManagement = "task.management"
        case telephonyConfiguration = "telephony.configuration"
        case usage = "usage"
        case users = "users"
        case webDeployments = "web.deployments"
        case webMessaging = "web.messaging"
        case webchat = "webchat"
        case webhooks = "webhooks"
        case workforceManagement = "workforce.management"
    }





    public var key: String?
    public var namespace: Namespace?
    public var value: Int64?
    public var documented: Bool?

    public init(key: String?, namespace: Namespace?, value: Int64?, documented: Bool?) {
        self.key = key
        self.namespace = namespace
        self.value = value
        self.documented = documented
    }


}




public class ConversationCobrowseEventTopicQueueMediaSettings: Codable {









    /** Specifies how long the agent has to answer an interaction before being marked as not responding. */
    public var alertingTimeoutSeconds: Int64?
    /** Specifies the duration of the alerting sound to be played for auto answered interactions. */
    public var autoAnswerAlertToneSeconds: Double?
    /** Specifies the duration of the alerting sound to be played for manually answered interactions */
    public var manualAnswerAlertToneSeconds: Double?
    /** Flag to indicate if auto answer is enabled for the given media type or media subtype. */
    public var enableAutoAnswer: Bool?

    public init(alertingTimeoutSeconds: Int64?, autoAnswerAlertToneSeconds: Double?, manualAnswerAlertToneSeconds: Double?, enableAutoAnswer: Bool?) {
        self.alertingTimeoutSeconds = alertingTimeoutSeconds
        self.autoAnswerAlertToneSeconds = autoAnswerAlertToneSeconds
        self.manualAnswerAlertToneSeconds = manualAnswerAlertToneSeconds
        self.enableAutoAnswer = enableAutoAnswer
    }


}



/** Item included in an order. */

public class ConversationContentLineItem: Codable {









    /** The display name for the item. */
    public var name: String?
    /** The price of the item. */
    public var price: Double?
    /** Additional details about the item (e.g. the length of time to deliver for shipping options). */
    public var _description: String?
    /** A client defined value used to identify the item. */
    public var identifier: String?

    public init(name: String?, price: Double?, _description: String?, identifier: String?) {
        self.name = name
        self.price = price
        self._description = _description
        self.identifier = identifier
    }

    public enum CodingKeys: String, CodingKey { 
        case name
        case price
        case _description = "description"
        case identifier
    }


}



/** Payment response object representing the status of a payment transaction. */

public class ConversationContentPaymentResponse: Codable {



    public enum PaymentStatus: String, Codable { 
        case completed = "Completed"
        case failed = "Failed"
    }



    /** Reference to the ID of the original payment request message this response is for. */
    public var originatingMessageId: String?
    /** The status of the payment transaction. */
    public var paymentStatus: PaymentStatus?
    /** The reason the payment request failed. */
    public var failureReason: String?

    public init(originatingMessageId: String?, paymentStatus: PaymentStatus?, failureReason: String?) {
        self.originatingMessageId = originatingMessageId
        self.paymentStatus = paymentStatus
        self.failureReason = failureReason
    }


}



/** A Push object */

public class ConversationContentPush: Codable {

    public enum DeviceType: String, Codable { 
        case android = "Android"
        case ios = "IOS"
    }













    /** The device type used to send the push notification */
    public var deviceType: DeviceType?
    /** Unique Id of the device token */
    public var deviceTokenId: String?
    /** device token from the notification provider */
    public var deviceToken: String?
    /** MessageIds failed to be sent which trigger the push event */
    public var failedMessages: [ConversationPushFailedMessageReferences]?
    /** Title and body localized according to deployment */
    public var notificationMessage: ConversationPushNotificationMessageLabel?
    /** Push provider integrations details configured on the deployment */
    public var pushProviderIntegration: ConversationPushProviderIntegration?
    /** The time to live of the pushed message */
    public var expiration: Int64?

    public init(deviceType: DeviceType?, deviceTokenId: String?, deviceToken: String?, failedMessages: [ConversationPushFailedMessageReferences]?, notificationMessage: ConversationPushNotificationMessageLabel?, pushProviderIntegration: ConversationPushProviderIntegration?, expiration: Int64?) {
        self.deviceType = deviceType
        self.deviceTokenId = deviceTokenId
        self.deviceToken = deviceToken
        self.failedMessages = failedMessages
        self.notificationMessage = notificationMessage
        self.pushProviderIntegration = pushProviderIntegration
        self.expiration = expiration
    }


}



/** User reaction to public message. */

public class ConversationContentReaction: Codable {

    public enum ReactionType: String, Codable { 
        case _none = "None"
        case like = "Like"
        case love = "Love"
        case wow = "Wow"
        case haha = "Haha"
        case sad = "Sad"
        case angry = "Angry"
        case thankful = "Thankful"
        case pride = "Pride"
        case care = "Care"
        case share = "Share"
        case comment = "Comment"
        case view = "View"
        case rating = "Rating"
    }



    /** Type of reaction. */
    public var reactionType: ReactionType?
    /** Number of users that reacted this way to the message. */
    public var count: Int?

    public init(reactionType: ReactionType?, count: Int?) {
        self.reactionType = reactionType
        self.count = count
    }


}



/** Message content element containing text only. */

public class ConversationContentText: Codable {

    public enum ModelType: String, Codable { 
        case text = "Text"
    }



    /** Type of text content (Deprecated). */
    public var type: ModelType?
    /** Text to be shown for this content element. */
    public var body: String?

    public init(type: ModelType?, body: String?) {
        self.type = type
        self.body = body
    }


}



/** Represents a selectable item in a Wheel Picker */

public class ConversationContentWheelPickerItem: Codable {







    /** Unique identifier for the wheel picker item */
    public var _id: String?
    /** The main text displayed for the item. */
    public var title: String?
    /** The value of the item. */
    public var value: String?

    public init(_id: String?, title: String?, value: String?) {
        self._id = _id
        self.title = title
        self.value = value
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case title
        case value
    }


}




public class ConversationDeletionProtectionQuery: Codable {



    /** This is a list of ConversationIds. The list cannot exceed 100 conversationids. */
    public var conversationIds: [String]?

    public init(conversationIds: [String]?) {
        self.conversationIds = conversationIds
    }


}




public class ConversationDetailQueryPredicate: Codable {

    public enum ModelType: String, Codable { 
        case dimension = "dimension"
        case property = "property"
        case metric = "metric"
    }

    public enum Dimension: String, Codable { 
        case conversationend = "conversationEnd"
        case conversationid = "conversationId"
        case conversationinitiator = "conversationInitiator"
        case conversationstart = "conversationStart"
        case customerparticipation = "customerParticipation"
        case divisionid = "divisionId"
        case externaltag = "externalTag"
        case mediastatsminconversationmos = "mediaStatsMinConversationMos"
        case originatingdirection = "originatingDirection"
        case originatingsocialmediapublic = "originatingSocialMediaPublic"
    }

    public enum Metric: String, Codable { 
        case nblindtransferred = "nBlindTransferred"
        case nbotinteractions = "nBotInteractions"
        case ncobrowsesessions = "nCobrowseSessions"
        case nconnected = "nConnected"
        case nconsult = "nConsult"
        case nconsulttransferred = "nConsultTransferred"
        case nconversations = "nConversations"
        case nerror = "nError"
        case nflow = "nFlow"
        case nflowmilestone = "nFlowMilestone"
        case nflowoutcome = "nFlowOutcome"
        case nflowoutcomefailed = "nFlowOutcomeFailed"
        case noffered = "nOffered"
        case noutbound = "nOutbound"
        case noutboundabandoned = "nOutboundAbandoned"
        case noutboundattempted = "nOutboundAttempted"
        case noutboundconnected = "nOutboundConnected"
        case noversla = "nOverSla"
        case nstatetransitionerror = "nStateTransitionError"
        case ntransferred = "nTransferred"
        case oaudiomessagecount = "oAudioMessageCount"
        case oexternalaudiomessagecount = "oExternalAudioMessageCount"
        case oexternalmediacount = "oExternalMediaCount"
        case oflowmilestone = "oFlowMilestone"
        case omediacount = "oMediaCount"
        case omessagecount = "oMessageCount"
        case omessagesegmentcount = "oMessageSegmentCount"
        case omessageturn = "oMessageTurn"
        case tabandon = "tAbandon"
        case tacd = "tAcd"
        case tactivecallback = "tActiveCallback"
        case tactivecallbackcomplete = "tActiveCallbackComplete"
        case tacw = "tAcw"
        case tagentresponsetime = "tAgentResponseTime"
        case tagentvideoconnected = "tAgentVideoConnected"
        case talert = "tAlert"
        case tanswered = "tAnswered"
        case taverageagentresponsetime = "tAverageAgentResponseTime"
        case taveragecustomerresponsetime = "tAverageCustomerResponseTime"
        case tbarging = "tBarging"
        case tcoaching = "tCoaching"
        case tcoachingcomplete = "tCoachingComplete"
        case tconnected = "tConnected"
        case tcontacting = "tContacting"
        case tconversationduration = "tConversationDuration"
        case tdialing = "tDialing"
        case tfirstconnect = "tFirstConnect"
        case tfirstdial = "tFirstDial"
        case tfirstengagement = "tFirstEngagement"
        case tfirstresponse = "tFirstResponse"
        case tflow = "tFlow"
        case tflowdisconnect = "tFlowDisconnect"
        case tflowexit = "tFlowExit"
        case tflowout = "tFlowOut"
        case tflowoutcome = "tFlowOutcome"
        case thandle = "tHandle"
        case theld = "tHeld"
        case theldcomplete = "tHeldComplete"
        case tivr = "tIvr"
        case tmonitoring = "tMonitoring"
        case tmonitoringcomplete = "tMonitoringComplete"
        case tnotresponding = "tNotResponding"
        case tpark = "tPark"
        case tparkcomplete = "tParkComplete"
        case tscreenmonitoring = "tScreenMonitoring"
        case tshortabandon = "tShortAbandon"
        case ttalk = "tTalk"
        case ttalkcomplete = "tTalkComplete"
        case tuserresponsetime = "tUserResponseTime"
        case tvoicemail = "tVoicemail"
    }

    public enum Operator: String, Codable { 
        case matches = "matches"
        case exists = "exists"
        case notexists = "notExists"
    }





    /** Optional type, can usually be inferred */
    public var type: ModelType?
    /** Left hand side for dimension predicates */
    public var dimension: Dimension?
    /** Left hand side for metric predicates */
    public var metric: Metric?
    /** Optional operator, default is matches */
    public var _operator: Operator?
    /** Right hand side for dimension or metric predicates */
    public var value: String?
    /** Right hand side for dimension or metric predicates */
    public var range: NumericRange?

    public init(type: ModelType?, dimension: Dimension?, metric: Metric?, _operator: Operator?, value: String?, range: NumericRange?) {
        self.type = type
        self.dimension = dimension
        self.metric = metric
        self._operator = _operator
        self.value = value
        self.range = range
    }

    public enum CodingKeys: String, CodingKey { 
        case type
        case dimension
        case metric
        case _operator = "operator"
        case value
        case range
    }


}




public class ConversationEmailEventTopicDivisionEntityRef: Codable {







    public var _id: String?
    public var selfUri: String?
    /** The time the entity division was last updated. */
    public var dateDivisionUpdated: Date?

    public init(_id: String?, selfUri: String?, dateDivisionUpdated: Date?) {
        self._id = _id
        self.selfUri = selfUri
        self.dateDivisionUpdated = dateDivisionUpdated
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
        case dateDivisionUpdated
    }


}




public class ConversationEmailEventTopicEmailMediaParticipant: Codable {

















    public enum State: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case converting = "converting"
        case uploading = "uploading"
        case transmitting = "transmitting"
        case scheduled = "scheduled"
        case parked = "parked"
        case _none = "none"
    }

    public enum InitialState: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case converting = "converting"
        case uploading = "uploading"
        case transmitting = "transmitting"
        case scheduled = "scheduled"
        case parked = "parked"
        case _none = "none"
    }

    public enum Direction: String, Codable { 
        case inbound = "inbound"
        case outbound = "outbound"
    }

    public enum DisconnectType: String, Codable { 
        case endpoint = "endpoint"
        case endpointDnd = "endpoint.dnd"
        case client = "client"
        case system = "system"
        case transfer = "transfer"
        case timeout = "timeout"
        case transferConference = "transfer.conference"
        case transferConsult = "transfer.consult"
        case transferForward = "transfer.forward"
        case transferNoanswer = "transfer.noanswer"
        case transferNotavailable = "transfer.notavailable"
        case transferDnd = "transfer.dnd"
        case transportFailure = "transport.failure"
        case error = "error"
        case peer = "peer"
        case other = "other"
        case spam = "spam"
        case uncallable = "uncallable"
        case inactivity = "inactivity"
        case sessionExpired = "session.expired"
    }









































    public enum FlaggedReason: String, Codable { 
        case general = "general"
    }



























    public var _id: String?
    public var name: String?
    public var address: String?
    public var startTime: Date?
    public var connectedTime: Date?
    public var endTime: Date?
    public var startHoldTime: Date?
    public var purpose: String?
    public var state: State?
    public var initialState: InitialState?
    public var direction: Direction?
    public var disconnectType: DisconnectType?
    public var held: Bool?
    public var wrapupRequired: Bool?
    public var wrapupPrompt: String?
    public var user: ConversationEmailEventTopicUriReference?
    public var queue: ConversationEmailEventTopicUriReference?
    public var team: ConversationEmailEventTopicUriReference?
    public var attributes: [String:String]?
    public var errorInfo: ConversationEmailEventTopicErrorBody?
    public var script: ConversationEmailEventTopicUriReference?
    public var wrapupTimeoutMs: Int64?
    public var wrapupSkipped: Bool?
    public var alertingTimeoutMs: Int64?
    public var provider: String?
    public var externalContact: ConversationEmailEventTopicUriReference?
    public var externalContactInitialDivisionId: String?
    public var externalOrganization: ConversationEmailEventTopicUriReference?
    public var wrapup: ConversationEmailEventTopicWrapup?
    public var conversationRoutingData: ConversationEmailEventTopicConversationRoutingData?
    public var peer: String?
    public var screenRecordingState: String?
    public var flaggedReason: FlaggedReason?
    public var journeyContext: ConversationEmailEventTopicJourneyContext?
    public var startAcwTime: Date?
    public var endAcwTime: Date?
    public var resumeTime: Date?
    public var parkTime: Date?
    public var mediaRoles: [String]?
    public var queueMediaSettings: ConversationEmailEventTopicQueueMediaSettings?
    public var subject: String?
    public var messagesSent: Int64?
    public var autoGenerated: Bool?
    public var messageId: String?
    public var draftAttachments: [ConversationEmailEventTopicAttachment]?
    public var spam: Bool?

    public init(_id: String?, name: String?, address: String?, startTime: Date?, connectedTime: Date?, endTime: Date?, startHoldTime: Date?, purpose: String?, state: State?, initialState: InitialState?, direction: Direction?, disconnectType: DisconnectType?, held: Bool?, wrapupRequired: Bool?, wrapupPrompt: String?, user: ConversationEmailEventTopicUriReference?, queue: ConversationEmailEventTopicUriReference?, team: ConversationEmailEventTopicUriReference?, attributes: [String:String]?, errorInfo: ConversationEmailEventTopicErrorBody?, script: ConversationEmailEventTopicUriReference?, wrapupTimeoutMs: Int64?, wrapupSkipped: Bool?, alertingTimeoutMs: Int64?, provider: String?, externalContact: ConversationEmailEventTopicUriReference?, externalContactInitialDivisionId: String?, externalOrganization: ConversationEmailEventTopicUriReference?, wrapup: ConversationEmailEventTopicWrapup?, conversationRoutingData: ConversationEmailEventTopicConversationRoutingData?, peer: String?, screenRecordingState: String?, flaggedReason: FlaggedReason?, journeyContext: ConversationEmailEventTopicJourneyContext?, startAcwTime: Date?, endAcwTime: Date?, resumeTime: Date?, parkTime: Date?, mediaRoles: [String]?, queueMediaSettings: ConversationEmailEventTopicQueueMediaSettings?, subject: String?, messagesSent: Int64?, autoGenerated: Bool?, messageId: String?, draftAttachments: [ConversationEmailEventTopicAttachment]?, spam: Bool?) {
        self._id = _id
        self.name = name
        self.address = address
        self.startTime = startTime
        self.connectedTime = connectedTime
        self.endTime = endTime
        self.startHoldTime = startHoldTime
        self.purpose = purpose
        self.state = state
        self.initialState = initialState
        self.direction = direction
        self.disconnectType = disconnectType
        self.held = held
        self.wrapupRequired = wrapupRequired
        self.wrapupPrompt = wrapupPrompt
        self.user = user
        self.queue = queue
        self.team = team
        self.attributes = attributes
        self.errorInfo = errorInfo
        self.script = script
        self.wrapupTimeoutMs = wrapupTimeoutMs
        self.wrapupSkipped = wrapupSkipped
        self.alertingTimeoutMs = alertingTimeoutMs
        self.provider = provider
        self.externalContact = externalContact
        self.externalContactInitialDivisionId = externalContactInitialDivisionId
        self.externalOrganization = externalOrganization
        self.wrapup = wrapup
        self.conversationRoutingData = conversationRoutingData
        self.peer = peer
        self.screenRecordingState = screenRecordingState
        self.flaggedReason = flaggedReason
        self.journeyContext = journeyContext
        self.startAcwTime = startAcwTime
        self.endAcwTime = endAcwTime
        self.resumeTime = resumeTime
        self.parkTime = parkTime
        self.mediaRoles = mediaRoles
        self.queueMediaSettings = queueMediaSettings
        self.subject = subject
        self.messagesSent = messagesSent
        self.autoGenerated = autoGenerated
        self.messageId = messageId
        self.draftAttachments = draftAttachments
        self.spam = spam
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case address
        case startTime
        case connectedTime
        case endTime
        case startHoldTime
        case purpose
        case state
        case initialState
        case direction
        case disconnectType
        case held
        case wrapupRequired
        case wrapupPrompt
        case user
        case queue
        case team
        case attributes
        case errorInfo
        case script
        case wrapupTimeoutMs
        case wrapupSkipped
        case alertingTimeoutMs
        case provider
        case externalContact
        case externalContactInitialDivisionId
        case externalOrganization
        case wrapup
        case conversationRoutingData
        case peer
        case screenRecordingState
        case flaggedReason
        case journeyContext
        case startAcwTime
        case endAcwTime
        case resumeTime
        case parkTime
        case mediaRoles
        case queueMediaSettings
        case subject
        case messagesSent
        case autoGenerated
        case messageId
        case draftAttachments
        case spam
    }


}



/** A subset of the Journey System's action data relevant to a part of a conversation (for external linkage and internal usage/context) */

public class ConversationEmailEventTopicJourneyAction: Codable {





    /** The ID of an action from the Journey System (an action is spawned from an actionMap) */
    public var _id: String?
    public var actionMap: ConversationEmailEventTopicJourneyActionMap?

    public init(_id: String?, actionMap: ConversationEmailEventTopicJourneyActionMap?) {
        self._id = _id
        self.actionMap = actionMap
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case actionMap
    }


}




public class ConversationEmailEventTopicJourneyContext: Codable {







    public var customer: ConversationEmailEventTopicJourneyCustomer?
    public var customerSession: ConversationEmailEventTopicJourneyCustomerSession?
    public var triggeringAction: ConversationEmailEventTopicJourneyAction?

    public init(customer: ConversationEmailEventTopicJourneyCustomer?, customerSession: ConversationEmailEventTopicJourneyCustomerSession?, triggeringAction: ConversationEmailEventTopicJourneyAction?) {
        self.customer = customer
        self.customerSession = customerSession
        self.triggeringAction = triggeringAction
    }


}




public class ConversationEmailEventTopicWrapup: Codable {











    /** The user configured wrap up code name. */
    public var code: String?
    /** Text entered by the agent to describe the call or disposition. */
    public var notes: String?
    /** List of tags selected by the agent to describe the call or disposition. */
    public var tags: [String]?
    /** The length of time in seconds that the agent spent doing after call work., Note, the format of utc-millisec should be ignored, our code generator needs it to generate a Long for us internally */
    public var durationSeconds: Int64?
    /** The timestamp when the wrapup was finished. */
    public var endTime: Date?

    public init(code: String?, notes: String?, tags: [String]?, durationSeconds: Int64?, endTime: Date?) {
        self.code = code
        self.notes = notes
        self.tags = tags
        self.durationSeconds = durationSeconds
        self.endTime = endTime
    }


}



/** Metadata enrichments provided by the platform. */

public class ConversationEnrichment: Codable {





    /** Detected language of this message. */
    public var language: ConversationEnrichmentLanguage?
    /** Detected sentiment of this message. */
    public var sentimentV2: ConversationEnrichmentSentimentV2?

    public init(language: ConversationEnrichmentLanguage?, sentimentV2: ConversationEnrichmentSentimentV2?) {
        self.language = language
        self.sentimentV2 = sentimentV2
    }


}




public class ConversationEntityListing: Codable {





















    public var entities: [Conversation]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var previousUri: String?
    public var nextUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [Conversation]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, previousUri: String?, nextUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.previousUri = previousUri
        self.nextUri = nextUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}



/** A communication's after-call work data. */

public class ConversationEventTopicAfterCallWork: Codable {

    public enum State: String, Codable { 
        case unknown = "unknown"
        case skipped = "skipped"
        case pending = "pending"
        case complete = "complete"
        case notapplicable = "notApplicable"
    }





    /** The communication's after-call work state. */
    public var state: State?
    /** The timestamp when this communication started after-call work in the cloud clock. */
    public var startTime: Date?
    /** The timestamp when this communication ended after-call work in the cloud clock. */
    public var endTime: Date?

    public init(state: State?, startTime: Date?, endTime: Date?) {
        self.state = state
        self.startTime = startTime
        self.endTime = endTime
    }


}



/** Information on how a communication should be routed to an agent. */

public class ConversationEventTopicConversationRoutingData: Codable {











    public var queue: ConversationEventTopicUriReference?
    /** A UriReference for a resource */
    public var language: ConversationEventTopicUriReference?
    /** The priority of the conversation to use for routing decisions */
    public var priority: Int64?
    /** The skills to use for routing decisions */
    public var skills: [ConversationEventTopicUriReference]?
    /** A collection of agents and their assigned scores for this conversation (0 - 100, higher being better), for use in routing to preferred agents */
    public var scoredAgents: [ConversationEventTopicScoredAgent]?

    public init(queue: ConversationEventTopicUriReference?, language: ConversationEventTopicUriReference?, priority: Int64?, skills: [ConversationEventTopicUriReference]?, scoredAgents: [ConversationEventTopicScoredAgent]?) {
        self.queue = queue
        self.language = language
        self.priority = priority
        self.skills = skills
        self.scoredAgents = scoredAgents
    }


}




public class ConversationEventTopicDomainEntityRef: Codable {





    public var _id: String?
    public var selfUri: String?

    public init(_id: String?, selfUri: String?) {
        self._id = _id
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
    }


}



/** Detailed information about an error response. */

public class ConversationEventTopicErrorDetails: Codable {















    /** The HTTP status code for this message (400, 401, 403, 404, 500, etc. */
    public var status: Int64?
    /** A code unique to this error. */
    public var code: String?
    /** Friendly description of this error. */
    public var message: String?
    /** This is the same as message except it uses template fields for variable replacement. For instance: 'User {username} was not found' */
    public var messageWithParams: String?
    /** Used in conjunction with messageWithParams. These are the template parameters. For instance: UserParam.key = 'username', UserParam.value = 'john.doe' */
    public var messageParams: [String:String]?
    /** The correlation Id or context Id for this message. If left blank the Public API will look at the HTTP response header 'ININ-Correlation-Id' instead. */
    public var contextId: String?
    public var uri: String?

    public init(status: Int64?, code: String?, message: String?, messageWithParams: String?, messageParams: [String:String]?, contextId: String?, uri: String?) {
        self.status = status
        self.code = code
        self.message = message
        self.messageWithParams = messageWithParams
        self.messageParams = messageParams
        self.contextId = contextId
        self.uri = uri
    }


}




public class ConversationEventTopicScreenShare: Codable {

    public enum State: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case _none = "none"
    }

    public enum InitialState: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case _none = "none"
    }

















    public enum DisconnectType: String, Codable { 
        case endpoint = "endpoint"
        case endpointDnd = "endpoint.dnd"
        case client = "client"
        case system = "system"
        case timeout = "timeout"
        case transfer = "transfer"
        case transferConference = "transfer.conference"
        case transferConsult = "transfer.consult"
        case transferForward = "transfer.forward"
        case transferNoanswer = "transfer.noanswer"
        case transferNotavailable = "transfer.notavailable"
        case transferDnd = "transfer.dnd"
        case transportFailure = "transport.failure"
        case error = "error"
        case peer = "peer"
        case other = "other"
        case spam = "spam"
        case uncallable = "uncallable"
    }













    public var state: State?
    public var initialState: InitialState?
    /** Address and name data for a call endpoint. */
    public var _self: ConversationEventTopicAddress?
    /** A globally unique identifier for this communication. */
    public var _id: String?
    /** The room id context (xmpp jid) for the conference session. */
    public var context: String?
    /** Indicates whether this participant is sharing their screen to the session. */
    public var sharing: Bool?
    /** The source provider of the screen share. */
    public var provider: String?
    /** The UUID of the script to use. */
    public var scriptId: String?
    /** The id of the peer communication corresponding to a matching leg for this communication. */
    public var peerId: String?
    /** The number of peer participants from the perspective of the participant in the conference. */
    public var peerCount: Int64?
    /** System defined string indicating what caused the communication to disconnect. Will be null until the communication disconnects. */
    public var disconnectType: DisconnectType?
    /** The timestamp when this communication was connected in the cloud clock. */
    public var connectedTime: Date?
    /** The timestamp when this communication disconnected from the conversation in the provider clock. */
    public var disconnectedTime: Date?
    /** Call wrap up or disposition data. */
    public var wrapup: ConversationEventTopicWrapup?
    /** A communication's after-call work data. */
    public var afterCallWork: ConversationEventTopicAfterCallWork?
    /** Indicates if after-call is required for a communication. Only used when the ACW Setting is Agent Requested. */
    public var afterCallWorkRequired: Bool?
    /** Represents the queue setting for this media. */
    public var queueMediaSettings: ConversationEventTopicQueueMediaSettings?

    public init(state: State?, initialState: InitialState?, _self: ConversationEventTopicAddress?, _id: String?, context: String?, sharing: Bool?, provider: String?, scriptId: String?, peerId: String?, peerCount: Int64?, disconnectType: DisconnectType?, connectedTime: Date?, disconnectedTime: Date?, wrapup: ConversationEventTopicWrapup?, afterCallWork: ConversationEventTopicAfterCallWork?, afterCallWorkRequired: Bool?, queueMediaSettings: ConversationEventTopicQueueMediaSettings?) {
        self.state = state
        self.initialState = initialState
        self._self = _self
        self._id = _id
        self.context = context
        self.sharing = sharing
        self.provider = provider
        self.scriptId = scriptId
        self.peerId = peerId
        self.peerCount = peerCount
        self.disconnectType = disconnectType
        self.connectedTime = connectedTime
        self.disconnectedTime = disconnectedTime
        self.wrapup = wrapup
        self.afterCallWork = afterCallWork
        self.afterCallWorkRequired = afterCallWorkRequired
        self.queueMediaSettings = queueMediaSettings
    }

    public enum CodingKeys: String, CodingKey { 
        case state
        case initialState
        case _self = "self"
        case _id = "id"
        case context
        case sharing
        case provider
        case scriptId
        case peerId
        case peerCount
        case disconnectType
        case connectedTime
        case disconnectedTime
        case wrapup
        case afterCallWork
        case afterCallWorkRequired
        case queueMediaSettings
    }


}



/** A Video event. */

public class ConversationEventVideo: Codable {

    public enum ModelType: String, Codable { 
        case offering = "Offering"
        case offeringExpired = "OfferingExpired"
        case offeringAccepted = "OfferingAccepted"
        case offeringRejected = "OfferingRejected"
    }





    /** Describes the type of Video event. */
    public var type: ModelType?
    /** The Video offering ID. */
    public var offeringId: String?
    /** The Video offering JWT token. */
    public var jwt: String?

    public init(type: ModelType?, offeringId: String?, jwt: String?) {
        self.type = type
        self.offeringId = offeringId
        self.jwt = jwt
    }


}



/** Form component element. Examples include: List Picker, Date Picker, Wheel Picker and Input text. */

public class ConversationFormPageComponent: Codable {

    public enum FormComponentType: String, Codable { 
        case listPicker = "ListPicker"
        case datePicker = "DatePicker"
        case wheelPicker = "WheelPicker"
        case input = "Input"
    }









    /** Type of this form component element */
    public var formComponentType: FormComponentType?
    /** Date Picker content. */
    public var datePicker: ConversationContentDatePicker?
    /** Wheel Picker content. */
    public var wheelPicker: ConversationContentWheelPicker?
    /** List Picker content. */
    public var listPicker: ConversationContentListPicker?
    /** Input content. */
    public var input: ConversationContentInput?

    public init(formComponentType: FormComponentType?, datePicker: ConversationContentDatePicker?, wheelPicker: ConversationContentWheelPicker?, listPicker: ConversationContentListPicker?, input: ConversationContentInput?) {
        self.formComponentType = formComponentType
        self.datePicker = datePicker
        self.wheelPicker = wheelPicker
        self.listPicker = listPicker
        self.input = input
    }


}



/** Message content element for form responses */

public class ConversationFormResponseContent: Codable {

    public enum ContentType: String, Codable { 
        case buttonResponse = "ButtonResponse"
    }



    /** Type of this content element. */
    public var contentType: ContentType?
    /** Button response content. */
    public var buttonResponse: ConversationContentButtonResponse?

    public init(contentType: ContentType?, buttonResponse: ConversationContentButtonResponse?) {
        self.contentType = contentType
        self.buttonResponse = buttonResponse
    }


}




public class ConversationKnowledgeSearchSuggestionsTopicSuggestedSearchResult: Codable {





















    public var title: String?
    public var uri: String?
    public var snippets: [String]?
    public var confidence: Double?
    public var metadata: [String:String]?
    public var searchId: UUID?
    public var documentId: UUID?
    public var versionId: UUID?
    public var variationIds: [UUID]?
    public var knowledgeAnswer: ConversationKnowledgeSearchSuggestionsTopicKnowledgeAnswer?

    public init(title: String?, uri: String?, snippets: [String]?, confidence: Double?, metadata: [String:String]?, searchId: UUID?, documentId: UUID?, versionId: UUID?, variationIds: [UUID]?, knowledgeAnswer: ConversationKnowledgeSearchSuggestionsTopicKnowledgeAnswer?) {
        self.title = title
        self.uri = uri
        self.snippets = snippets
        self.confidence = confidence
        self.metadata = metadata
        self.searchId = searchId
        self.documentId = documentId
        self.versionId = versionId
        self.variationIds = variationIds
        self.knowledgeAnswer = knowledgeAnswer
    }


}




public class ConversationMessageEventTopicConversationDivisionMembership: Codable {





    public var division: ConversationMessageEventTopicDomainEntityRef?
    public var entities: [ConversationMessageEventTopicDivisionEntityRef]?

    public init(division: ConversationMessageEventTopicDomainEntityRef?, entities: [ConversationMessageEventTopicDivisionEntityRef]?) {
        self.division = division
        self.entities = entities
    }


}



/** A subset of the Journey System's customer data at a point-in-time (for external linkage and internal usage/context) */

public class ConversationMessageEventTopicJourneyCustomer: Codable {





    /** An ID of a customer within the Journey System at a point-in-time.  Note that a customer entity can have multiple customerIds based on the stitching process.  Depending on the context within the PureCloud conversation, this may or may not be mutable. */
    public var _id: String?
    /** The type of the customerId within the Journey System (e.g. cookie). */
    public var idType: String?

    public init(_id: String?, idType: String?) {
        self._id = _id
        self.idType = idType
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case idType
    }


}



/** A subset of the Journey System's tracked customer session data at a point-in-time (for external linkage and internal usage/context) */

public class ConversationMessageEventTopicJourneyCustomerSession: Codable {





    /** An ID of a Customer/User's session within the Journey System at a point-in-time */
    public var _id: String?
    /** The type of the Customer/User's session within the Journey System (e.g. web, app) */
    public var type: String?

    public init(_id: String?, type: String?) {
        self._id = _id
        self.type = type
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case type
    }


}




public class ConversationMessageEventTopicScoredAgent: Codable {





    /** A UriReference for a resource */
    public var agent: ConversationMessageEventTopicUriReference?
    /** Agent's score for the current conversation, from 0 - 100, higher being better */
    public var score: Int64?

    public init(agent: ConversationMessageEventTopicUriReference?, score: Int64?) {
        self.agent = agent
        self.score = score
    }


}



/** Information about the recipient the message is sent to. */

public class ConversationMessagingToRecipient: Codable {





    public enum IdType: String, Codable { 
        case email = "Email"
        case phone = "Phone"
        case opaque = "Opaque"
        case topic = "Topic"
    }













    /** Nickname or display name of the recipient. */
    public var nickname: String?
    /** The recipient ID specific to the provider. */
    public var _id: String?
    /** The recipient ID type. This is used to indicate the format used for the ID. */
    public var idType: IdType?
    /** URL of an image that represents the recipient. */
    public var image: String?
    /** First name of the recipient. */
    public var firstName: String?
    /** Last name of the recipient. */
    public var lastName: String?
    /** E-mail address of the recipient. */
    public var email: String?
    /** The identifier of the external contact. */
    public var externalContactId: String?
    /** List of recipient additional identifiers */
    public var additionalIds: [ConversationRecipientAdditionalIdentifier]?

    public init(nickname: String?, _id: String?, idType: IdType?, image: String?, firstName: String?, lastName: String?, email: String?, externalContactId: String?, additionalIds: [ConversationRecipientAdditionalIdentifier]?) {
        self.nickname = nickname
        self._id = _id
        self.idType = idType
        self.image = image
        self.firstName = firstName
        self.lastName = lastName
        self.email = email
        self.externalContactId = externalContactId
        self.additionalIds = additionalIds
    }

    public enum CodingKeys: String, CodingKey { 
        case nickname
        case _id = "id"
        case idType
        case image
        case firstName
        case lastName
        case email
        case externalContactId
        case additionalIds
    }


}




public class ConversationMetrics: Codable {







    public enum SentimentTrendClass: String, Codable { 
        case notCalculated = "NotCalculated"
        case declining = "Declining"
        case slightlyDeclining = "SlightlyDeclining"
        case noChange = "NoChange"
        case slightlyImproving = "SlightlyImproving"
        case improving = "Improving"
    }





    /** The Conversation Reference */
    public var conversation: AddressableEntityRef?
    /** The Sentiment Score */
    public var sentimentScore: Double?
    /** The Sentiment Trend */
    public var sentimentTrend: Double?
    /** The Sentiment Trend Class */
    public var sentimentTrendClass: SentimentTrendClass?
    /** The Empathy Scores */
    public var empathyScores: [EmpathyScore]?
    /** The Participant Metrics */
    public var participantMetrics: ParticipantMetrics?

    public init(conversation: AddressableEntityRef?, sentimentScore: Double?, sentimentTrend: Double?, sentimentTrendClass: SentimentTrendClass?, empathyScores: [EmpathyScore]?, participantMetrics: ParticipantMetrics?) {
        self.conversation = conversation
        self.sentimentScore = sentimentScore
        self.sentimentTrend = sentimentTrend
        self.sentimentTrendClass = sentimentTrendClass
        self.empathyScores = empathyScores
        self.participantMetrics = participantMetrics
    }


}




public class ConversationMetricsTopicConversationMetricRecord: Codable {

    public enum Metric: String, Codable { 
        case nblindtransferred = "nBlindTransferred"
        case nbotinteractions = "nBotInteractions"
        case ncobrowsesessions = "nCobrowseSessions"
        case nconnected = "nConnected"
        case nconsult = "nConsult"
        case nconsulttransferred = "nConsultTransferred"
        case nconversations = "nConversations"
        case nerror = "nError"
        case noffered = "nOffered"
        case noutbound = "nOutbound"
        case noutboundabandoned = "nOutboundAbandoned"
        case noutboundattempted = "nOutboundAttempted"
        case noutboundconnected = "nOutboundConnected"
        case noversla = "nOverSla"
        case ntransferred = "nTransferred"
        case oaudiomessagecount = "oAudioMessageCount"
        case oexternalaudiomessagecount = "oExternalAudioMessageCount"
        case oexternalmediacount = "oExternalMediaCount"
        case omediacount = "oMediaCount"
        case omessagecount = "oMessageCount"
        case omessagesegmentcount = "oMessageSegmentCount"
        case omessageturn = "oMessageTurn"
        case tabandon = "tAbandon"
        case tacd = "tAcd"
        case tactivecallback = "tActiveCallback"
        case tactivecallbackcomplete = "tActiveCallbackComplete"
        case tacw = "tAcw"
        case tagentresponsetime = "tAgentResponseTime"
        case tagentvideoconnected = "tAgentVideoConnected"
        case talert = "tAlert"
        case tanswered = "tAnswered"
        case taverageagentresponsetime = "tAverageAgentResponseTime"
        case taveragecustomerresponsetime = "tAverageCustomerResponseTime"
        case tbarging = "tBarging"
        case tcoaching = "tCoaching"
        case tcoachingcomplete = "tCoachingComplete"
        case tconnected = "tConnected"
        case tcontacting = "tContacting"
        case tdialing = "tDialing"
        case tfirstconnect = "tFirstConnect"
        case tfirstdial = "tFirstDial"
        case tfirstengagement = "tFirstEngagement"
        case tfirstresponse = "tFirstResponse"
        case tflowout = "tFlowOut"
        case thandle = "tHandle"
        case theld = "tHeld"
        case theldcomplete = "tHeldComplete"
        case tivr = "tIvr"
        case tmonitoring = "tMonitoring"
        case tmonitoringcomplete = "tMonitoringComplete"
        case tnotresponding = "tNotResponding"
        case tpark = "tPark"
        case tparkcomplete = "tParkComplete"
        case tscreenmonitoring = "tScreenMonitoring"
        case ttalk = "tTalk"
        case ttalkcomplete = "tTalkComplete"
        case tuserresponsetime = "tUserResponseTime"
        case tvoicemail = "tVoicemail"
    }







    public enum ActiveRouting: String, Codable { 
        case bullseye = "Bullseye"
        case conditional = "Conditional"
        case direct = "Direct"
        case last = "Last"
        case manual = "Manual"
        case predictive = "Predictive"
        case preferred = "Preferred"
        case standard = "Standard"
        case vip = "Vip"
    }





















    public enum ConversationInitiator: String, Codable { 
        case acd = "acd"
        case agent = "agent"
        case api = "api"
        case botflow = "botflow"
        case campaign = "campaign"
        case customer = "customer"
        case dialer = "dialer"
        case external = "external"
        case fax = "fax"
        case group = "group"
        case inbound = "inbound"
        case ivr = "ivr"
        case manual = "manual"
        case outbound = "outbound"
        case station = "station"
        case user = "user"
        case voicemail = "voicemail"
        case voicesurveyflow = "voicesurveyflow"
        case workflow = "workflow"
    }







    public enum DeliveryStatus: String, Codable { 
        case deliveryFailed = "DeliveryFailed"
        case deliveryPushed = "DeliveryPushed"
        case deliverySuccess = "DeliverySuccess"
        case failed = "Failed"
        case published = "Published"
        case queued = "Queued"
        case read = "Read"
        case received = "Received"
        case sent = "Sent"
    }



    public enum Direction: String, Codable { 
        case inbound = "inbound"
        case outbound = "outbound"
    }

    public enum DisconnectType: String, Codable { 
        case client = "client"
        case conferencetransfer = "conferenceTransfer"
        case consulttransfer = "consultTransfer"
        case endpoint = "endpoint"
        case endpointdnd = "endpointDnd"
        case error = "error"
        case forwardtransfer = "forwardTransfer"
        case inactivity = "inactivity"
        case noanswertransfer = "noAnswerTransfer"
        case notavailabletransfer = "notAvailableTransfer"
        case other = "other"
        case peer = "peer"
        case sessionexpired = "sessionExpired"
        case spam = "spam"
        case system = "system"
        case timeout = "timeout"
        case transfer = "transfer"
        case transferdnd = "transferDnd"
        case transportfailure = "transportFailure"
        case uncallable = "uncallable"
    }























    public enum FlaggedReason: String, Codable { 
        case general = "general"
    }



























    public enum MediaType: String, Codable { 
        case callback = "callback"
        case chat = "chat"
        case cobrowse = "cobrowse"
        case email = "email"
        case internalmessage = "internalmessage"
        case message = "message"
        case screenmonitoring = "screenmonitoring"
        case screenshare = "screenshare"
        case unknown = "unknown"
        case video = "video"
        case voice = "voice"
    }



    public enum OriginatingDirection: String, Codable { 
        case inbound = "inbound"
        case outbound = "outbound"
    }















    public enum Purpose: String, Codable { 
        case acd = "acd"
        case agent = "agent"
        case api = "api"
        case botflow = "botflow"
        case campaign = "campaign"
        case customer = "customer"
        case dialer = "dialer"
        case external = "external"
        case fax = "fax"
        case group = "group"
        case inbound = "inbound"
        case ivr = "ivr"
        case manual = "manual"
        case outbound = "outbound"
        case station = "station"
        case user = "user"
        case voicemail = "voicemail"
        case voicesurveyflow = "voicesurveyflow"
        case workflow = "workflow"
    }











    public enum RequestedRoutings: String, Codable { 
        case bullseye = "Bullseye"
        case conditional = "Conditional"
        case direct = "Direct"
        case last = "Last"
        case manual = "Manual"
        case predictive = "Predictive"
        case preferred = "Preferred"
        case standard = "Standard"
        case vip = "Vip"
    }









    public enum RoutingRuleType: String, Codable { 
        case bullseye = "Bullseye"
        case conditional = "Conditional"
        case predictive = "Predictive"
        case preferred = "Preferred"
    }















    public enum UsedRouting: String, Codable { 
        case bullseye = "Bullseye"
        case conditional = "Conditional"
        case direct = "Direct"
        case last = "Last"
        case manual = "Manual"
        case predictive = "Predictive"
        case preferred = "Preferred"
        case standard = "Standard"
        case vip = "Vip"
    }













    /** Metric name */
    public var metric: Metric?
    /** The date and time of metric creation */
    public var metricDate: Date?
    /** Metric value */
    public var value: Int64?
    /** Record identifier */
    public var recordId: String?
    /** Active routing method */
    public var activeRouting: ActiveRouting?
    /** ID(s) of Skill(s) that are active on the conversation */
    public var activeSkillIds: [String]?
    /** The address that initiated an action */
    public var addressFrom: String?
    /** The address receiving an action */
    public var addressTo: String?
    /** Unique identifier of the active virtual agent assistant */
    public var agentAssistantId: String?
    /** Bullseye ring of the targeted agent */
    public var agentBullseyeRing: Int64?
    /** Flag indicating an agent-owned callback */
    public var agentOwned: Bool?
    /** Automatic Number Identification (caller's number) */
    public var ani: String?
    /** ID of the user that manually assigned a conversation */
    public var assignerId: String?
    /** Flag that indicates that the identity of the customer has been asserted as verified by the provider. */
    public var authenticated: Bool?
    /** Unique identifier for the conversation */
    public var conversationId: String?
    /** Indicates the participant purpose of the participant initiating a message conversation */
    public var conversationInitiator: ConversationInitiator?
    /** Session media type that was converted from in case of a media type conversion */
    public var convertedFrom: String?
    /** Session media type that was converted to in case of a media type conversion */
    public var convertedTo: String?
    /** Indicates a messaging conversation in which the customer participated by sending at least one message */
    public var customerParticipation: Bool?
    /** The email or SMS delivery status */
    public var deliveryStatus: DeliveryStatus?
    /** Destination address(es) of transfers or consults */
    public var destinationAddresses: [String]?
    /** The direction of the communication */
    public var direction: Direction?
    /** The session disconnect type */
    public var disconnectType: DisconnectType?
    /** Identifier(s) of division(s) associated with a conversation */
    public var divisionIds: [String]?
    /** Dialed number identification service (number dialed by the calling party) */
    public var dnis: String?
    /** Unique identifier of the edge device */
    public var edgeId: String?
    /** Number of eligible agents for each predictive routing attempt */
    public var eligibleAgentCounts: [Int64]?
    /** A code corresponding to the error that occurred */
    public var errorCode: String?
    /** Extended delivery status */
    public var extendedDeliveryStatus: String?
    /** External contact identifier */
    public var externalContactId: String?
    /** Count of any media (images, files, etc) included on the external session */
    public var externalMediaCount: Int64?
    /** External organization identifier */
    public var externalOrganizationId: String?
    /** External tag for the conversation */
    public var externalTag: String?
    /** Marker that is set if the current queue is the first queue in a conversation */
    public var firstQueue: Bool?
    /** Reason for which participant flagged conversation */
    public var flaggedReason: FlaggedReason?
    /** Type of flow in that occurred when entering ACD. */
    public var flowInType: String?
    /** Type of flow out that occurred when emitting tFlowOut. */
    public var flowOutType: String?
    /** Unique identifier for a Genesys Cloud group */
    public var groupId: String?
    /** The interaction type (enterprise or contactCenter) */
    public var interactionType: String?
    /** Identifier of the journey action. */
    public var journeyActionId: String?
    /** Identifier of the journey action map that triggered the action. */
    public var journeyActionMapId: String?
    /** Version of the journey action map that triggered the action. */
    public var journeyActionMapVersion: Int64?
    /** Primary identifier of the journey customer in the source where the activities originate from. */
    public var journeyCustomerId: String?
    /** Type of primary identifier of the journey customer (e.g. cookie). */
    public var journeyCustomerIdType: String?
    /** Unique identifier of the journey session. */
    public var journeyCustomerSessionId: String?
    /** Type or category of journey sessions (e.g. web, ticket, delivery, atm). */
    public var journeyCustomerSessionIdType: String?
    /** The unique identifier(s) of the knowledge base(s) used */
    public var knowledgeBaseIds: [String]?
    /** Count of any media (images, files, etc) included in this session */
    public var mediaCount: Int64?
    /** The session media type */
    public var mediaType: MediaType?
    /** Message type for messaging services. E.g.: sms, facebook, twitter, line */
    public var messageType: String?
    /** The original direction of the conversation */
    public var originatingDirection: OriginatingDirection?
    /** Indicates that the conversation originated from a public message on social media */
    public var originatingSocialMediaPublic: Bool?
    /** (Dialer) Unique identifier of the outbound campaign */
    public var outboundCampaignId: String?
    /** (Dialer) Unique identifier of the contact */
    public var outboundContactId: String?
    /** (Dialer) Unique identifier of the contact list that this contact belongs to */
    public var outboundContactListId: String?
    /** A human readable name identifying the participant */
    public var participantName: String?
    /** This identifies pairs of related sessions on a conversation. E.g. an external sessions peerId will be the session that the call originally connected to, e.g. if an IVR was dialed, the IVR session, which will also have the external sessions ID as its peer. After that point, any transfers of that session to other internal components (acd, agent, etc.) will all spawn new sessions whose peerIds point back to that original external session. */
    public var peerId: String?
    /** The source provider for the communication. */
    public var provider: String?
    /** The participant's purpose */
    public var purpose: Purpose?
    /** Queue identifier */
    public var queueId: String?
    /** Name, phone number, or email address of the remote party. */
    public var remote: String?
    /** ID(s) of Skill(s) that have been removed by bullseye routing */
    public var removedSkillIds: [String]?
    /** Unique identifier for the language requested for an interaction */
    public var requestedLanguageId: String?
    /** Unique identifier(s) for skill(s) requested for an interaction */
    public var requestedRoutingSkillIds: [String]?
    /** Routing type(s) for requested/attempted routing methods. */
    public var requestedRoutings: [RequestedRoutings]?
    /** Unique identifier for the room */
    public var roomId: String?
    /** Routing priority for the current interaction */
    public var routingPriority: Int64?
    /** Routing ring for bullseye or preferred agent routing */
    public var routingRing: Int64?
    /** Routing rule for preferred, conditional and predictive routing type */
    public var routingRule: String?
    /** Routing rule type */
    public var routingRuleType: RoutingRuleType?
    /** Selected agent ID */
    public var selectedAgentId: String?
    /** Selected agent GPR rank */
    public var selectedAgentRank: Int64?
    /** Indicates whether all flow sessions were self serviced */
    public var selfServed: Bool?
    /** Dialed number for the current session; this can be different from dnis, e.g. if the call was transferred */
    public var sessionDnis: String?
    /** The unique identifier of this session */
    public var sessionId: String?
    /** Unique identifier for a phone */
    public var stationId: String?
    /** The team ID the user is a member of */
    public var teamId: String?
    /** Complete routing method */
    public var usedRouting: UsedRouting?
    /** Unique identifier for the user */
    public var userId: String?
    /** Flag indicating if video is present */
    public var videoPresent: Bool?
    /** Number of waiting interactions for each predictive routing attempt */
    public var waitingInteractionCounts: [Int64]?
    /** Wrap up code */
    public var wrapUpCode: String?
    /** Proposed agents */
    public var proposedAgents: [ConversationMetricsTopicConversationProposedAgent]?
    /** Scored agents */
    public var scoredAgents: [ConversationMetricsTopicConversationScoredAgent]?

    public init(metric: Metric?, metricDate: Date?, value: Int64?, recordId: String?, activeRouting: ActiveRouting?, activeSkillIds: [String]?, addressFrom: String?, addressTo: String?, agentAssistantId: String?, agentBullseyeRing: Int64?, agentOwned: Bool?, ani: String?, assignerId: String?, authenticated: Bool?, conversationId: String?, conversationInitiator: ConversationInitiator?, convertedFrom: String?, convertedTo: String?, customerParticipation: Bool?, deliveryStatus: DeliveryStatus?, destinationAddresses: [String]?, direction: Direction?, disconnectType: DisconnectType?, divisionIds: [String]?, dnis: String?, edgeId: String?, eligibleAgentCounts: [Int64]?, errorCode: String?, extendedDeliveryStatus: String?, externalContactId: String?, externalMediaCount: Int64?, externalOrganizationId: String?, externalTag: String?, firstQueue: Bool?, flaggedReason: FlaggedReason?, flowInType: String?, flowOutType: String?, groupId: String?, interactionType: String?, journeyActionId: String?, journeyActionMapId: String?, journeyActionMapVersion: Int64?, journeyCustomerId: String?, journeyCustomerIdType: String?, journeyCustomerSessionId: String?, journeyCustomerSessionIdType: String?, knowledgeBaseIds: [String]?, mediaCount: Int64?, mediaType: MediaType?, messageType: String?, originatingDirection: OriginatingDirection?, originatingSocialMediaPublic: Bool?, outboundCampaignId: String?, outboundContactId: String?, outboundContactListId: String?, participantName: String?, peerId: String?, provider: String?, purpose: Purpose?, queueId: String?, remote: String?, removedSkillIds: [String]?, requestedLanguageId: String?, requestedRoutingSkillIds: [String]?, requestedRoutings: [RequestedRoutings]?, roomId: String?, routingPriority: Int64?, routingRing: Int64?, routingRule: String?, routingRuleType: RoutingRuleType?, selectedAgentId: String?, selectedAgentRank: Int64?, selfServed: Bool?, sessionDnis: String?, sessionId: String?, stationId: String?, teamId: String?, usedRouting: UsedRouting?, userId: String?, videoPresent: Bool?, waitingInteractionCounts: [Int64]?, wrapUpCode: String?, proposedAgents: [ConversationMetricsTopicConversationProposedAgent]?, scoredAgents: [ConversationMetricsTopicConversationScoredAgent]?) {
        self.metric = metric
        self.metricDate = metricDate
        self.value = value
        self.recordId = recordId
        self.activeRouting = activeRouting
        self.activeSkillIds = activeSkillIds
        self.addressFrom = addressFrom
        self.addressTo = addressTo
        self.agentAssistantId = agentAssistantId
        self.agentBullseyeRing = agentBullseyeRing
        self.agentOwned = agentOwned
        self.ani = ani
        self.assignerId = assignerId
        self.authenticated = authenticated
        self.conversationId = conversationId
        self.conversationInitiator = conversationInitiator
        self.convertedFrom = convertedFrom
        self.convertedTo = convertedTo
        self.customerParticipation = customerParticipation
        self.deliveryStatus = deliveryStatus
        self.destinationAddresses = destinationAddresses
        self.direction = direction
        self.disconnectType = disconnectType
        self.divisionIds = divisionIds
        self.dnis = dnis
        self.edgeId = edgeId
        self.eligibleAgentCounts = eligibleAgentCounts
        self.errorCode = errorCode
        self.extendedDeliveryStatus = extendedDeliveryStatus
        self.externalContactId = externalContactId
        self.externalMediaCount = externalMediaCount
        self.externalOrganizationId = externalOrganizationId
        self.externalTag = externalTag
        self.firstQueue = firstQueue
        self.flaggedReason = flaggedReason
        self.flowInType = flowInType
        self.flowOutType = flowOutType
        self.groupId = groupId
        self.interactionType = interactionType
        self.journeyActionId = journeyActionId
        self.journeyActionMapId = journeyActionMapId
        self.journeyActionMapVersion = journeyActionMapVersion
        self.journeyCustomerId = journeyCustomerId
        self.journeyCustomerIdType = journeyCustomerIdType
        self.journeyCustomerSessionId = journeyCustomerSessionId
        self.journeyCustomerSessionIdType = journeyCustomerSessionIdType
        self.knowledgeBaseIds = knowledgeBaseIds
        self.mediaCount = mediaCount
        self.mediaType = mediaType
        self.messageType = messageType
        self.originatingDirection = originatingDirection
        self.originatingSocialMediaPublic = originatingSocialMediaPublic
        self.outboundCampaignId = outboundCampaignId
        self.outboundContactId = outboundContactId
        self.outboundContactListId = outboundContactListId
        self.participantName = participantName
        self.peerId = peerId
        self.provider = provider
        self.purpose = purpose
        self.queueId = queueId
        self.remote = remote
        self.removedSkillIds = removedSkillIds
        self.requestedLanguageId = requestedLanguageId
        self.requestedRoutingSkillIds = requestedRoutingSkillIds
        self.requestedRoutings = requestedRoutings
        self.roomId = roomId
        self.routingPriority = routingPriority
        self.routingRing = routingRing
        self.routingRule = routingRule
        self.routingRuleType = routingRuleType
        self.selectedAgentId = selectedAgentId
        self.selectedAgentRank = selectedAgentRank
        self.selfServed = selfServed
        self.sessionDnis = sessionDnis
        self.sessionId = sessionId
        self.stationId = stationId
        self.teamId = teamId
        self.usedRouting = usedRouting
        self.userId = userId
        self.videoPresent = videoPresent
        self.waitingInteractionCounts = waitingInteractionCounts
        self.wrapUpCode = wrapUpCode
        self.proposedAgents = proposedAgents
        self.scoredAgents = scoredAgents
    }


}




public class ConversationMetricsTopicConversationProposedAgent: Codable {





    /** Proposed agent rank for this conversation from predictive routing (lower is better) */
    public var agentRank: Int64?
    /** Unique identifier for the agent that was proposed by predictive routing */
    public var proposedAgentId: String?

    public init(agentRank: Int64?, proposedAgentId: String?) {
        self.agentRank = agentRank
        self.proposedAgentId = proposedAgentId
    }


}



/** Template parameters for placeholders in template. */

public class ConversationNotificationTemplateParameter: Codable {





    /** Parameter name. */
    public var name: String?
    /** Parameter text value. */
    public var text: String?

    public init(name: String?, text: String?) {
        self.name = name
        self.text = text
    }


}



/** References of failed messages requiring a push. */

public class ConversationPushFailedMessageReferences: Codable {



    /** Unique ID of the message. */
    public var _id: String?

    public init(_id: String?) {
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
    }


}




public class ConversationResponseSuggestionsTopicCannedResponseSuggestionEvent: Codable {







    public enum State: String, Codable { 
        case unknown = "Unknown"
        case suggested = "Suggested"
        case accepted = "Accepted"
        case dismissed = "Dismissed"
        case failed = "Failed"
        case rated = "Rated"
        case triggered = "Triggered"
    }

    public enum TriggerType: String, Codable { 
        case unknown = "Unknown"
        case fallback = "Fallback"
        case conversationStart = "ConversationStart"
        case conversationTransfer = "ConversationTransfer"
        case conversationEnd = "ConversationEnd"
        case intent = "Intent"
    }

    public enum EngagementType: String, Codable { 
        case unknown = "Unknown"
        case dismissed = "Dismissed"
        case copied = "Copied"
        case opened = "Opened"
        case feedback = "Feedback"
    }









    public var eventTime: Date?
    public var conversationId: UUID?
    public var suggestionId: UUID?
    public var state: State?
    public var triggerType: TriggerType?
    public var engagementType: EngagementType?
    public var context: ConversationResponseSuggestionsTopicSuggestionContext?
    public var feedback: ConversationResponseSuggestionsTopicSuggestionFeedback?
    public var cannedResponse: ConversationResponseSuggestionsTopicSuggestedCannedResponse?
    public var activeIntent: ConversationResponseSuggestionsTopicSuggestedIntent?

    public init(eventTime: Date?, conversationId: UUID?, suggestionId: UUID?, state: State?, triggerType: TriggerType?, engagementType: EngagementType?, context: ConversationResponseSuggestionsTopicSuggestionContext?, feedback: ConversationResponseSuggestionsTopicSuggestionFeedback?, cannedResponse: ConversationResponseSuggestionsTopicSuggestedCannedResponse?, activeIntent: ConversationResponseSuggestionsTopicSuggestedIntent?) {
        self.eventTime = eventTime
        self.conversationId = conversationId
        self.suggestionId = suggestionId
        self.state = state
        self.triggerType = triggerType
        self.engagementType = engagementType
        self.context = context
        self.feedback = feedback
        self.cannedResponse = cannedResponse
        self.activeIntent = activeIntent
    }


}




public class ConversationResponseSuggestionsTopicSuggestedIntent: Codable {









    public var intent: String?
    public var intentId: String?
    public var confidence: Double?
    public var detectedSlots: [ConversationResponseSuggestionsTopicSuggestedIntentSlot]?

    public init(intent: String?, intentId: String?, confidence: Double?, detectedSlots: [ConversationResponseSuggestionsTopicSuggestedIntentSlot]?) {
        self.intent = intent
        self.intentId = intentId
        self.confidence = confidence
        self.detectedSlots = detectedSlots
    }


}




public class ConversationResponseSuggestionsTopicSuggestionContext: Codable {



    public enum MediaType: String, Codable { 
        case unknown = "UNKNOWN"
        case voice = "VOICE"
        case message = "MESSAGE"
        case email = "EMAIL"
    }















    public var queueId: UUID?
    public var mediaType: MediaType?
    public var userId: UUID?
    public var externalContactId: UUID?
    public var assistantId: UUID?
    public var utteranceId: UUID?
    public var messageId: String?
    public var queryStatement: String?
    public var language: String?

    public init(queueId: UUID?, mediaType: MediaType?, userId: UUID?, externalContactId: UUID?, assistantId: UUID?, utteranceId: UUID?, messageId: String?, queryStatement: String?, language: String?) {
        self.queueId = queueId
        self.mediaType = mediaType
        self.userId = userId
        self.externalContactId = externalContactId
        self.assistantId = assistantId
        self.utteranceId = utteranceId
        self.messageId = messageId
        self.queryStatement = queryStatement
        self.language = language
    }


}




public class ConversationRoutingData: Codable {













    /** The queue to use for routing decisions */
    public var queue: AddressableEntityRef?
    /** The language to use for routing decisions */
    public var language: AddressableEntityRef?
    /** The priority of the conversation to use for routing decisions */
    public var priority: Int?
    /** The skills to use for routing decisions */
    public var skills: [AddressableEntityRef]?
    /** A collection of agents and their assigned scores for this conversation (0 - 100, higher being better), for use in routing to preferred agents */
    public var scoredAgents: [ScoredAgent]?
    /** An optional label that categorizes the conversation.  Max-utilization settings can be configured at a per-label level */
    public var label: String?

    public init(queue: AddressableEntityRef?, language: AddressableEntityRef?, priority: Int?, skills: [AddressableEntityRef]?, scoredAgents: [ScoredAgent]?, label: String?) {
        self.queue = queue
        self.language = language
        self.priority = priority
        self.skills = skills
        self.scoredAgents = scoredAgents
        self.label = label
    }


}




public class ConversationScreenShareEventTopicDetail: Codable {









    public var errorCode: String?
    public var fieldName: String?
    public var entityId: String?
    public var entityName: String?

    public init(errorCode: String?, fieldName: String?, entityId: String?, entityName: String?) {
        self.errorCode = errorCode
        self.fieldName = fieldName
        self.entityId = entityId
        self.entityName = entityName
    }


}




public class ConversationScreenShareEventTopicErrorBody: Codable {























    public var message: String?
    public var code: String?
    public var status: Int64?
    public var entityId: String?
    public var entityName: String?
    public var messageWithParams: String?
    public var messageParams: [String:String]?
    public var contextId: String?
    public var details: [ConversationScreenShareEventTopicDetail]?
    public var errors: [ConversationScreenShareEventTopicErrorBody]?
    public var limit: ConversationScreenShareEventTopicLimit?

    public init(message: String?, code: String?, status: Int64?, entityId: String?, entityName: String?, messageWithParams: String?, messageParams: [String:String]?, contextId: String?, details: [ConversationScreenShareEventTopicDetail]?, errors: [ConversationScreenShareEventTopicErrorBody]?, limit: ConversationScreenShareEventTopicLimit?) {
        self.message = message
        self.code = code
        self.status = status
        self.entityId = entityId
        self.entityName = entityName
        self.messageWithParams = messageWithParams
        self.messageParams = messageParams
        self.contextId = contextId
        self.details = details
        self.errors = errors
        self.limit = limit
    }


}



/** Details about the action map from the Journey System which triggered this action */

public class ConversationScreenShareEventTopicJourneyActionMap: Codable {





    /** The ID of the actionMap in the Journey System which triggered this action */
    public var _id: String?
    /** The version number of the actionMap in the Journey System at the time this action was triggered */
    public var version: Int64?

    public init(_id: String?, version: Int64?) {
        self._id = _id
        self.version = version
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case version
    }


}




public class ConversationScreenShareEventTopicUriReference: Codable {





    /** The ID of the resource */
    public var _id: String?
    /** The name of the resource */
    public var name: String?

    public init(_id: String?, name: String?) {
        self._id = _id
        self.name = name
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
    }


}




public class ConversationScriptSuggestionsTopicSuggestedIntentSlot: Codable {









    public var slotName: String?
    public var entityType: String?
    public var slotValue: String?
    public var probability: Double?

    public init(slotName: String?, entityType: String?, slotValue: String?, probability: Double?) {
        self.slotName = slotName
        self.entityType = entityType
        self.slotValue = slotValue
        self.probability = probability
    }


}




public class ConversationScriptSuggestionsTopicSuggestedScript: Codable {







    public var scriptId: UUID?
    public var pageId: UUID?
    public var data: [String:String]?

    public init(scriptId: UUID?, pageId: UUID?, data: [String:String]?) {
        self.scriptId = scriptId
        self.pageId = pageId
        self.data = data
    }


}




public class ConversationSocialExpressionEventTopicConversationRoutingData: Codable {











    /** A UriReference for a resource */
    public var queue: ConversationSocialExpressionEventTopicUriReference?
    /** A UriReference for a resource */
    public var language: ConversationSocialExpressionEventTopicUriReference?
    /** The priority of the conversation to use for routing decisions */
    public var priority: Int64?
    /** The skills to use for routing decisions */
    public var skills: [ConversationSocialExpressionEventTopicUriReference]?
    /** A collection of agents and their assigned scores for this conversation (0 - 100, higher being better), for use in routing to preferred agents */
    public var scoredAgents: [ConversationSocialExpressionEventTopicScoredAgent]?

    public init(queue: ConversationSocialExpressionEventTopicUriReference?, language: ConversationSocialExpressionEventTopicUriReference?, priority: Int64?, skills: [ConversationSocialExpressionEventTopicUriReference]?, scoredAgents: [ConversationSocialExpressionEventTopicScoredAgent]?) {
        self.queue = queue
        self.language = language
        self.priority = priority
        self.skills = skills
        self.scoredAgents = scoredAgents
    }


}



/** A reference to another domain entity. */

public class ConversationSocialExpressionEventTopicDomainEntityRef: Codable {





    public var _id: String?
    public var selfUri: String?

    public init(_id: String?, selfUri: String?) {
        self._id = _id
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
    }


}




public class ConversationSummaryTopicConversationReason: Codable {







    public var text: String?
    public var _description: String?
    public var score: Double?

    public init(text: String?, _description: String?, score: Double?) {
        self.text = text
        self._description = _description
        self.score = score
    }

    public enum CodingKeys: String, CodingKey { 
        case text
        case _description = "description"
        case score
    }


}




public class ConversationSummaryTopicConversationResolution: Codable {









    public var text: String?
    public var _description: String?
    public var resolutionValue: String?
    public var score: Double?

    public init(text: String?, _description: String?, resolutionValue: String?, score: Double?) {
        self.text = text
        self._description = _description
        self.resolutionValue = resolutionValue
        self.score = score
    }

    public enum CodingKeys: String, CodingKey { 
        case text
        case _description = "description"
        case resolutionValue
        case score
    }


}




public class ConversationSummaryTopicConversationSummaryParticipant: Codable {



    public enum Purpose: String, Codable { 
        case unknown = "UNKNOWN"
        case acd = "ACD"
        case agent = "AGENT"
        case customer = "CUSTOMER"
        case workflow = "WORKFLOW"
    }

    public var userId: String?
    public var purpose: Purpose?

    public init(userId: String?, purpose: Purpose?) {
        self.userId = userId
        self.purpose = purpose
    }


}




public class ConversationSummaryTopicConversationWrapUpCode: Codable {









    public var wrapUpCodeId: String?
    public var name: String?
    public var _description: String?
    public var score: Double?

    public init(wrapUpCodeId: String?, name: String?, _description: String?, score: Double?) {
        self.wrapUpCodeId = wrapUpCodeId
        self.name = name
        self._description = _description
        self.score = score
    }

    public enum CodingKeys: String, CodingKey { 
        case wrapUpCodeId
        case name
        case _description = "description"
        case score
    }


}




public class ConversationVideoEventTopicDivisionEntityRef: Codable {







    public var _id: String?
    public var selfUri: String?
    /** The time the entity division was last updated. */
    public var dateDivisionUpdated: Date?

    public init(_id: String?, selfUri: String?, dateDivisionUpdated: Date?) {
        self._id = _id
        self.selfUri = selfUri
        self.dateDivisionUpdated = dateDivisionUpdated
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
        case dateDivisionUpdated
    }


}



/** A subset of the Journey System's action data relevant to a part of a conversation (for external linkage and internal usage/context) */

public class ConversationVideoEventTopicJourneyAction: Codable {





    /** The ID of an action from the Journey System (an action is spawned from an actionMap) */
    public var _id: String?
    public var actionMap: ConversationVideoEventTopicJourneyActionMap?

    public init(_id: String?, actionMap: ConversationVideoEventTopicJourneyActionMap?) {
        self._id = _id
        self.actionMap = actionMap
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case actionMap
    }


}




public class ConversationVideoEventTopicJourneyContext: Codable {







    public var customer: ConversationVideoEventTopicJourneyCustomer?
    public var customerSession: ConversationVideoEventTopicJourneyCustomerSession?
    public var triggeringAction: ConversationVideoEventTopicJourneyAction?

    public init(customer: ConversationVideoEventTopicJourneyCustomer?, customerSession: ConversationVideoEventTopicJourneyCustomerSession?, triggeringAction: ConversationVideoEventTopicJourneyAction?) {
        self.customer = customer
        self.customerSession = customerSession
        self.triggeringAction = triggeringAction
    }


}




public class ConversationVideoEventTopicVideoMediaParticipant: Codable {

















    public enum State: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case converting = "converting"
        case uploading = "uploading"
        case transmitting = "transmitting"
        case scheduled = "scheduled"
        case parked = "parked"
        case _none = "none"
    }

    public enum InitialState: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case converting = "converting"
        case uploading = "uploading"
        case transmitting = "transmitting"
        case scheduled = "scheduled"
        case parked = "parked"
        case _none = "none"
    }

    public enum Direction: String, Codable { 
        case inbound = "inbound"
        case outbound = "outbound"
    }

    public enum DisconnectType: String, Codable { 
        case endpoint = "endpoint"
        case endpointDnd = "endpoint.dnd"
        case client = "client"
        case system = "system"
        case transfer = "transfer"
        case timeout = "timeout"
        case transferConference = "transfer.conference"
        case transferConsult = "transfer.consult"
        case transferForward = "transfer.forward"
        case transferNoanswer = "transfer.noanswer"
        case transferNotavailable = "transfer.notavailable"
        case transferDnd = "transfer.dnd"
        case transportFailure = "transport.failure"
        case error = "error"
        case peer = "peer"
        case other = "other"
        case spam = "spam"
        case uncallable = "uncallable"
        case inactivity = "inactivity"
        case sessionExpired = "session.expired"
    }









































    public enum FlaggedReason: String, Codable { 
        case general = "general"
    }



























    public var _id: String?
    public var name: String?
    public var address: String?
    public var startTime: Date?
    public var connectedTime: Date?
    public var endTime: Date?
    public var startHoldTime: Date?
    public var purpose: String?
    public var state: State?
    public var initialState: InitialState?
    public var direction: Direction?
    public var disconnectType: DisconnectType?
    public var held: Bool?
    public var wrapupRequired: Bool?
    public var wrapupPrompt: String?
    public var user: ConversationVideoEventTopicUriReference?
    public var queue: ConversationVideoEventTopicUriReference?
    public var team: ConversationVideoEventTopicUriReference?
    public var attributes: [String:String]?
    public var errorInfo: ConversationVideoEventTopicErrorBody?
    public var script: ConversationVideoEventTopicUriReference?
    public var wrapupTimeoutMs: Int64?
    public var wrapupSkipped: Bool?
    public var alertingTimeoutMs: Int64?
    public var provider: String?
    public var externalContact: ConversationVideoEventTopicUriReference?
    public var externalContactInitialDivisionId: String?
    public var externalOrganization: ConversationVideoEventTopicUriReference?
    public var wrapup: ConversationVideoEventTopicWrapup?
    public var conversationRoutingData: ConversationVideoEventTopicConversationRoutingData?
    public var peer: String?
    public var screenRecordingState: String?
    public var flaggedReason: FlaggedReason?
    public var journeyContext: ConversationVideoEventTopicJourneyContext?
    public var startAcwTime: Date?
    public var endAcwTime: Date?
    public var resumeTime: Date?
    public var parkTime: Date?
    public var mediaRoles: [String]?
    public var queueMediaSettings: ConversationVideoEventTopicQueueMediaSettings?
    public var audioMuted: Bool?
    public var videoMuted: Bool?
    public var sharingScreen: Bool?
    public var peerCount: Int64?
    public var context: String?
    public var msids: [String]?

    public init(_id: String?, name: String?, address: String?, startTime: Date?, connectedTime: Date?, endTime: Date?, startHoldTime: Date?, purpose: String?, state: State?, initialState: InitialState?, direction: Direction?, disconnectType: DisconnectType?, held: Bool?, wrapupRequired: Bool?, wrapupPrompt: String?, user: ConversationVideoEventTopicUriReference?, queue: ConversationVideoEventTopicUriReference?, team: ConversationVideoEventTopicUriReference?, attributes: [String:String]?, errorInfo: ConversationVideoEventTopicErrorBody?, script: ConversationVideoEventTopicUriReference?, wrapupTimeoutMs: Int64?, wrapupSkipped: Bool?, alertingTimeoutMs: Int64?, provider: String?, externalContact: ConversationVideoEventTopicUriReference?, externalContactInitialDivisionId: String?, externalOrganization: ConversationVideoEventTopicUriReference?, wrapup: ConversationVideoEventTopicWrapup?, conversationRoutingData: ConversationVideoEventTopicConversationRoutingData?, peer: String?, screenRecordingState: String?, flaggedReason: FlaggedReason?, journeyContext: ConversationVideoEventTopicJourneyContext?, startAcwTime: Date?, endAcwTime: Date?, resumeTime: Date?, parkTime: Date?, mediaRoles: [String]?, queueMediaSettings: ConversationVideoEventTopicQueueMediaSettings?, audioMuted: Bool?, videoMuted: Bool?, sharingScreen: Bool?, peerCount: Int64?, context: String?, msids: [String]?) {
        self._id = _id
        self.name = name
        self.address = address
        self.startTime = startTime
        self.connectedTime = connectedTime
        self.endTime = endTime
        self.startHoldTime = startHoldTime
        self.purpose = purpose
        self.state = state
        self.initialState = initialState
        self.direction = direction
        self.disconnectType = disconnectType
        self.held = held
        self.wrapupRequired = wrapupRequired
        self.wrapupPrompt = wrapupPrompt
        self.user = user
        self.queue = queue
        self.team = team
        self.attributes = attributes
        self.errorInfo = errorInfo
        self.script = script
        self.wrapupTimeoutMs = wrapupTimeoutMs
        self.wrapupSkipped = wrapupSkipped
        self.alertingTimeoutMs = alertingTimeoutMs
        self.provider = provider
        self.externalContact = externalContact
        self.externalContactInitialDivisionId = externalContactInitialDivisionId
        self.externalOrganization = externalOrganization
        self.wrapup = wrapup
        self.conversationRoutingData = conversationRoutingData
        self.peer = peer
        self.screenRecordingState = screenRecordingState
        self.flaggedReason = flaggedReason
        self.journeyContext = journeyContext
        self.startAcwTime = startAcwTime
        self.endAcwTime = endAcwTime
        self.resumeTime = resumeTime
        self.parkTime = parkTime
        self.mediaRoles = mediaRoles
        self.queueMediaSettings = queueMediaSettings
        self.audioMuted = audioMuted
        self.videoMuted = videoMuted
        self.sharingScreen = sharingScreen
        self.peerCount = peerCount
        self.context = context
        self.msids = msids
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case address
        case startTime
        case connectedTime
        case endTime
        case startHoldTime
        case purpose
        case state
        case initialState
        case direction
        case disconnectType
        case held
        case wrapupRequired
        case wrapupPrompt
        case user
        case queue
        case team
        case attributes
        case errorInfo
        case script
        case wrapupTimeoutMs
        case wrapupSkipped
        case alertingTimeoutMs
        case provider
        case externalContact
        case externalContactInitialDivisionId
        case externalOrganization
        case wrapup
        case conversationRoutingData
        case peer
        case screenRecordingState
        case flaggedReason
        case journeyContext
        case startAcwTime
        case endAcwTime
        case resumeTime
        case parkTime
        case mediaRoles
        case queueMediaSettings
        case audioMuted
        case videoMuted
        case sharingScreen
        case peerCount
        case context
        case msids
    }


}




public class ConversationVideoEventTopicWrapup: Codable {











    /** The user configured wrap up code name. */
    public var code: String?
    /** Text entered by the agent to describe the call or disposition. */
    public var notes: String?
    /** List of tags selected by the agent to describe the call or disposition. */
    public var tags: [String]?
    /** The length of time in seconds that the agent spent doing after call work., Note, the format of utc-millisec should be ignored, our code generator needs it to generate a Long for us internally */
    public var durationSeconds: Int64?
    /** The timestamp when the wrapup was finished. */
    public var endTime: Date?

    public init(code: String?, notes: String?, tags: [String]?, durationSeconds: Int64?, endTime: Date?) {
        self.code = code
        self.notes = notes
        self.tags = tags
        self.durationSeconds = durationSeconds
        self.endTime = endTime
    }


}




public class CopyBuForecastRequest: Codable {





    /** The description for the forecast */
    public var _description: String?
    /** The start date of the new forecast to create from the existing forecast. Must correspond to the start day of week for the business unit. Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd */
    public var weekDate: Date?

    public init(_description: String?, weekDate: Date?) {
        self._description = _description
        self.weekDate = weekDate
    }

    public enum CodingKeys: String, CodingKey { 
        case _description = "description"
        case weekDate
    }


}




public class CreateAdminTimeOffRequest: Codable {

    public enum Status: String, Codable { 
        case pending = "PENDING"
        case approved = "APPROVED"
    }



















    /** The status of this time off request */
    public var status: Status?
    /** A set of IDs for users to associate with this time off request */
    public var users: [UserReference]?
    /** The ID of the activity code associated with this time off request. Activity code must be of the TimeOff category */
    public var activityCodeId: String?
    /** Notes about the time off request */
    public var notes: String?
    /** A set of dates in yyyy-MM-dd format.  Should be interpreted in the management unit's configured time zone. */
    public var fullDayManagementUnitDates: [String]?
    /** A set of start date-times in ISO-8601 format for partial day requests. */
    public var partialDayStartDateTimes: [Date]?
    /** The daily duration of this time off request in minutes */
    public var dailyDurationMinutes: Int?
    /** Daily durations for each day of this time off request in minutes */
    public var durationMinutes: [Int]?
    /** Payable minutes for each day of this time off request */
    public var payableMinutes: [Int]?
    /** Whether this is a paid time off request */
    public var paid: Bool?

    public init(status: Status?, users: [UserReference]?, activityCodeId: String?, notes: String?, fullDayManagementUnitDates: [String]?, partialDayStartDateTimes: [Date]?, dailyDurationMinutes: Int?, durationMinutes: [Int]?, payableMinutes: [Int]?, paid: Bool?) {
        self.status = status
        self.users = users
        self.activityCodeId = activityCodeId
        self.notes = notes
        self.fullDayManagementUnitDates = fullDayManagementUnitDates
        self.partialDayStartDateTimes = partialDayStartDateTimes
        self.dailyDurationMinutes = dailyDurationMinutes
        self.durationMinutes = durationMinutes
        self.payableMinutes = payableMinutes
        self.paid = paid
    }


}




public class CreateBenefitAssessmentJobRequest: Codable {



    /** The list of division ids for routing queues that are to be assessed for Predictive Routing benefit. */
    public var divisionIds: [String]?

    public init(divisionIds: [String]?) {
        self.divisionIds = divisionIds
    }


}




public class CreateCapacityPlanStaffingGroupMetricChangeRequest: Codable {







    public enum Metric: String, Codable { 
        case startingWeeklyFullTimeEquivalentCount = "StartingWeeklyFullTimeEquivalentCount"
        case newHiresFullTimeEquivalentCount = "NewHiresFullTimeEquivalentCount"
        case attritionPercentage = "AttritionPercentage"
        case shrinkagePercentage = "ShrinkagePercentage"
        case transfersFullTimeEquivalentCount = "TransfersFullTimeEquivalentCount"
        case extraTimeUnderTimeFullTimeEquivalentCount = "ExtraTimeUnderTimeFullTimeEquivalentCount"
    }







    /** The number of weeks to which the metric change applies */
    public var numberOfWeeks: Int?
    /** The start number of the week (starting from 1) to which the metric change applies, related to numberOfWeeks */
    public var weekStartNumber: Int?
    /** The value of the metric */
    public var value: Double?
    /** The metric which is going to be modified for the selected staffing groups */
    public var metric: Metric?
    /** Notes about the staffing groups metric changes */
    public var notes: String?
    /** The IDs of the staffing groups affected by the metric change */
    public var staffingGroupIds: [String]?
    /** The version of the capacity plan */
    public var version: Int?

    public init(numberOfWeeks: Int?, weekStartNumber: Int?, value: Double?, metric: Metric?, notes: String?, staffingGroupIds: [String]?, version: Int?) {
        self.numberOfWeeks = numberOfWeeks
        self.weekStartNumber = weekStartNumber
        self.value = value
        self.metric = metric
        self.notes = notes
        self.staffingGroupIds = staffingGroupIds
        self.version = version
    }


}



/** Details for an Integration */

public class CreateIntegrationRequest: Codable {









    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The name of the integration, used to distinguish this integration from others of the same type. */
    public var name: String?
    /** Type of the integration to create. */
    public var integrationType: IntegrationType?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, integrationType: IntegrationType?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.integrationType = integrationType
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case integrationType
        case selfUri
    }


}




public class CreateManagementUnitSettingsRequest: Codable {











    /** Adherence settings for this management unit */
    public var adherence: AdherenceSettings?
    /** Short term forecasting settings for this management unit.  Moving to Business Unit */
    public var shortTermForecasting: ShortTermForecastingSettings?
    /** Time off request settings for this management unit */
    public var timeOff: TimeOffSettingsRequest?
    /** Scheduling settings for this management unit */
    public var scheduling: SchedulingSettingsRequest?
    /** Shift trade settings for this management unit */
    public var shiftTrading: ShiftTradeSettings?

    public init(adherence: AdherenceSettings?, shortTermForecasting: ShortTermForecastingSettings?, timeOff: TimeOffSettingsRequest?, scheduling: SchedulingSettingsRequest?, shiftTrading: ShiftTradeSettings?) {
        self.adherence = adherence
        self.shortTermForecasting = shortTermForecasting
        self.timeOff = timeOff
        self.scheduling = scheduling
        self.shiftTrading = shiftTrading
    }


}




public class CreateOutboundMessagingConversationResponse: Codable {





    /** The created outbound messaging conversation ID. */
    public var _id: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, selfUri: String?) {
        self._id = _id
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
    }


}




public class CreateResponseAssetResponse: Codable {







    /** The globally unique identifier for the object. */
    public var _id: String?
    /** Pre-signed URL to PUT the file to */
    public var url: String?
    /** Required headers when uploading a file through PUT request to the URL */
    public var headers: [String:String]?

    public init(_id: String?, url: String?, headers: [String:String]?) {
        self._id = _id
        self.url = url
        self.headers = headers
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case url
        case headers
    }


}




public class CreateServiceGoalTemplate: Codable {











    /** The name of the service goal template. */
    public var name: String?
    /** Service level targets for this service goal template */
    public var serviceLevel: BuServiceLevel?
    /** Average speed of answer targets for this service goal template */
    public var averageSpeedOfAnswer: BuAverageSpeedOfAnswer?
    /** Abandon rate targets for this service goal template */
    public var abandonRate: BuAbandonRate?
    /** Settings controlling max percent increase and decrease of service goals for this service goal template */
    public var impactOverride: ServiceGoalTemplateImpactOverride?

    public init(name: String?, serviceLevel: BuServiceLevel?, averageSpeedOfAnswer: BuAverageSpeedOfAnswer?, abandonRate: BuAbandonRate?, impactOverride: ServiceGoalTemplateImpactOverride?) {
        self.name = name
        self.serviceLevel = serviceLevel
        self.averageSpeedOfAnswer = averageSpeedOfAnswer
        self.abandonRate = abandonRate
        self.impactOverride = impactOverride
    }


}




public class CreateShareResponse: Codable {





    public enum SharedEntityType: String, Codable { 
        case document = "DOCUMENT"
    }



    public enum MemberType: String, Codable { 
        case user = "USER"
        case group = "GROUP"
        case _public = "PUBLIC"
    }













    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    public var sharedEntityType: SharedEntityType?
    public var sharedEntity: DomainEntityRef?
    public var memberType: MemberType?
    public var member: DomainEntityRef?
    public var sharedBy: DomainEntityRef?
    public var workspace: DomainEntityRef?
    public var succeeded: [Share]?
    public var failed: [Share]?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, sharedEntityType: SharedEntityType?, sharedEntity: DomainEntityRef?, memberType: MemberType?, member: DomainEntityRef?, sharedBy: DomainEntityRef?, workspace: DomainEntityRef?, succeeded: [Share]?, failed: [Share]?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.sharedEntityType = sharedEntityType
        self.sharedEntity = sharedEntity
        self.memberType = memberType
        self.member = member
        self.sharedBy = sharedBy
        self.workspace = workspace
        self.succeeded = succeeded
        self.failed = failed
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case sharedEntityType
        case sharedEntity
        case memberType
        case member
        case sharedBy
        case workspace
        case succeeded
        case failed
        case selfUri
    }


}




public class CreateTimeOffPlanBusinessUnitAssociation: Codable {





    /** The IDs of management units to which this time-off plan applies. This must not be set if staffingGroupIds is populated */
    public var managementUnitIds: [String]?
    /** The IDs of staffing groups to which this time-off plan applies. This must not be set if managementUnitIds is populated */
    public var staffingGroupIds: [String]?

    public init(managementUnitIds: [String]?, staffingGroupIds: [String]?) {
        self.managementUnitIds = managementUnitIds
        self.staffingGroupIds = staffingGroupIds
    }


}




public class CredentialType: Codable {











    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** Properties describing credentials of this type. */
    public var properties: JSON?
    /** Order in which properties should be displayed in the UI. */
    public var displayOrder: [String]?
    /** Properties that are required fields. */
    public var _required: [String]?

    public init(_id: String?, name: String?, properties: JSON?, displayOrder: [String]?, _required: [String]?) {
        self._id = _id
        self.name = name
        self.properties = properties
        self.displayOrder = displayOrder
        self._required = _required
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case properties
        case displayOrder
        case _required = "required"
    }


}




public class CredentialTypeListing: Codable {





















    public var entities: [CredentialType]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var previousUri: String?
    public var nextUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [CredentialType]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, previousUri: String?, nextUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.previousUri = previousUri
        self.nextUri = nextUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class CrossPlatformChatMediaPolicy: Codable {





    /** Actions applied when specified conditions are met */
    public var actions: CrossPlatformPolicyActions?
    /** Conditions for when actions should be applied */
    public var conditions: ChatMediaPolicyConditions?

    public init(actions: CrossPlatformPolicyActions?, conditions: ChatMediaPolicyConditions?) {
        self.actions = actions
        self.conditions = conditions
    }


}




public class CrossPlatformMessageMediaPolicy: Codable {





    /** Actions applied when specified conditions are met */
    public var actions: CrossPlatformPolicyActions?
    /** Conditions for when actions should be applied */
    public var conditions: MessageMediaPolicyConditions?

    public init(actions: CrossPlatformPolicyActions?, conditions: MessageMediaPolicyConditions?) {
        self.actions = actions
        self.conditions = conditions
    }


}




public class CursorOrganizationListing: Codable {











    public var entities: [ExternalOrganization]?
    public var nextUri: String?
    public var selfUri: String?
    public var previousUri: String?
    /** The cursor that points to the next set of entities being returned. */
    public var cursors: Cursors?

    public init(entities: [ExternalOrganization]?, nextUri: String?, selfUri: String?, previousUri: String?, cursors: Cursors?) {
        self.entities = entities
        self.nextUri = nextUri
        self.selfUri = selfUri
        self.previousUri = previousUri
        self.cursors = cursors
    }


}




public class CustomEventAttribute: Codable {





    /** The data type of the custom attribute. */
    public var dataType: String?
    /** The value of the custom attribute. */
    public var value: String?

    public init(dataType: String?, value: String?) {
        self.dataType = dataType
        self.value = value
    }


}




public class CustomerEndDetailEventTopicCustomerEndEvent: Codable {









    public enum DisconnectType: String, Codable { 
        case unknown = "UNKNOWN"
        case endpoint = "ENDPOINT"
        case client = "CLIENT"
        case system = "SYSTEM"
        case transfer = "TRANSFER"
        case error = "ERROR"
        case peer = "PEER"
        case other = "OTHER"
        case spam = "SPAM"
        case timeout = "TIMEOUT"
        case transportFailure = "TRANSPORT_FAILURE"
        case conferenceTransfer = "CONFERENCE_TRANSFER"
        case consultTransfer = "CONSULT_TRANSFER"
        case forwardTransfer = "FORWARD_TRANSFER"
        case noAnswerTransfer = "NO_ANSWER_TRANSFER"
        case notAvailableTransfer = "NOT_AVAILABLE_TRANSFER"
        case uncallable = "UNCALLABLE"
        case dndEndpoint = "DND_ENDPOINT"
        case dndTransfer = "DND_TRANSFER"
        case inactivity = "INACTIVITY"
        case sessionExpired = "SESSION_EXPIRED"
    }

    public enum MediaType: String, Codable { 
        case unknown = "UNKNOWN"
        case voice = "VOICE"
        case chat = "CHAT"
        case email = "EMAIL"
        case callback = "CALLBACK"
        case cobrowse = "COBROWSE"
        case video = "VIDEO"
        case screenshare = "SCREENSHARE"
        case message = "MESSAGE"
        case internalmessage = "INTERNALMESSAGE"
        case screenmonitoring = "SCREENMONITORING"
    }







    public enum Direction: String, Codable { 
        case unknown = "UNKNOWN"
        case inbound = "INBOUND"
        case outbound = "OUTBOUND"
    }

















    public enum MessageType: String, Codable { 
        case unknown = "UNKNOWN"
        case sms = "SMS"
        case twitter = "TWITTER"
        case facebook = "FACEBOOK"
        case line = "LINE"
        case whatsapp = "WHATSAPP"
        case webmessaging = "WEBMESSAGING"
        case _open = "OPEN"
        case instagram = "INSTAGRAM"
        case apple = "APPLE"
    }









    public var eventTime: Int64?
    public var conversationId: String?
    public var participantId: String?
    public var sessionId: String?
    public var disconnectType: DisconnectType?
    public var mediaType: MediaType?
    public var externalOrganizationId: String?
    public var externalContactId: String?
    public var provider: String?
    public var direction: Direction?
    public var ani: String?
    public var dnis: String?
    public var addressTo: String?
    public var addressFrom: String?
    public var callbackUserName: String?
    public var callbackNumbers: [String]?
    public var callbackScheduledTime: Int64?
    public var subject: String?
    public var messageType: MessageType?
    public var interactingDurationMs: Int64?
    public var conversationExternalContactIds: [String]?
    public var conversationExternalOrganizationIds: [String]?
    public var divisionId: String?

    public init(eventTime: Int64?, conversationId: String?, participantId: String?, sessionId: String?, disconnectType: DisconnectType?, mediaType: MediaType?, externalOrganizationId: String?, externalContactId: String?, provider: String?, direction: Direction?, ani: String?, dnis: String?, addressTo: String?, addressFrom: String?, callbackUserName: String?, callbackNumbers: [String]?, callbackScheduledTime: Int64?, subject: String?, messageType: MessageType?, interactingDurationMs: Int64?, conversationExternalContactIds: [String]?, conversationExternalOrganizationIds: [String]?, divisionId: String?) {
        self.eventTime = eventTime
        self.conversationId = conversationId
        self.participantId = participantId
        self.sessionId = sessionId
        self.disconnectType = disconnectType
        self.mediaType = mediaType
        self.externalOrganizationId = externalOrganizationId
        self.externalContactId = externalContactId
        self.provider = provider
        self.direction = direction
        self.ani = ani
        self.dnis = dnis
        self.addressTo = addressTo
        self.addressFrom = addressFrom
        self.callbackUserName = callbackUserName
        self.callbackNumbers = callbackNumbers
        self.callbackScheduledTime = callbackScheduledTime
        self.subject = subject
        self.messageType = messageType
        self.interactingDurationMs = interactingDurationMs
        self.conversationExternalContactIds = conversationExternalContactIds
        self.conversationExternalOrganizationIds = conversationExternalOrganizationIds
        self.divisionId = divisionId
    }


}




public class DailyPossibleShift: Codable {

    public enum DayOfWeek: String, Codable { 
        case sunday = "Sunday"
        case monday = "Monday"
        case tuesday = "Tuesday"
        case wednesday = "Wednesday"
        case thursday = "Thursday"
        case friday = "Friday"
        case saturday = "Saturday"
    }











    /** Day of the shift */
    public var dayOfWeek: DayOfWeek?
    /** Minutes of the earliest shift start from midnight. Note that midnight is 12:00 am in the time zone specified in the timeZone field (in the top level of the response) */
    public var earliestShiftStartMinutesFromMidnight: Int?
    /** Whether this is a required shift */
    public var _required: Bool?
    /** Minimum paid time in minutes of this daily shift */
    public var minimumPaidTimeMinutes: Int?
    /** Maximum paid time in minutes of this daily shift */
    public var maximumPaidTimeMinutes: Int?
    /** The percentage of being scheduled in each interval between the earliest shift start and latest shift end. Range of the values: [0, 100]. */
    public var intervalScheduleProbabilities: [Int]?

    public init(dayOfWeek: DayOfWeek?, earliestShiftStartMinutesFromMidnight: Int?, _required: Bool?, minimumPaidTimeMinutes: Int?, maximumPaidTimeMinutes: Int?, intervalScheduleProbabilities: [Int]?) {
        self.dayOfWeek = dayOfWeek
        self.earliestShiftStartMinutesFromMidnight = earliestShiftStartMinutesFromMidnight
        self._required = _required
        self.minimumPaidTimeMinutes = minimumPaidTimeMinutes
        self.maximumPaidTimeMinutes = maximumPaidTimeMinutes
        self.intervalScheduleProbabilities = intervalScheduleProbabilities
    }

    public enum CodingKeys: String, CodingKey { 
        case dayOfWeek
        case earliestShiftStartMinutesFromMidnight
        case _required = "required"
        case minimumPaidTimeMinutes
        case maximumPaidTimeMinutes
        case intervalScheduleProbabilities
    }


}




public class DashboardConfiguration: Codable {

















    public enum LayoutType: String, Codable { 
        case grid = "Grid"
        case flow = "Flow"
    }















    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The name of dashboard configuration. */
    public var name: String?
    /** The count of rows for the specific dashboard configuration. */
    public var rows: Int?
    /** The count of columns for the specific dashboard. */
    public var columns: Int?
    /** List of widgets for dashboard configuration. */
    public var widgets: [Widget]?
    /** The flag indicates if the dashboard is favorited by the user */
    public var favorite: Bool?
    /** The flag to indicate if the dashboard is published by an user */
    public var publicDashboard: Bool?
    /** The flag to indicate if the dashboard has any restricted data for that user */
    public var restricted: Bool?
    /** The layout type of the dashboard */
    public var layoutType: LayoutType?
    /** The created date of the dashboard. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** The last modified date of the dashboard. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** The deleted date of the dashboard. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateDeleted: Date?
    /** The id of user who created the dashboard */
    public var createdBy: AddressableEntityRef?
    /** The flag to indicate if the dashboard is shared */
    public var shared: Bool?
    /** The list of users and teams the dashboard is shared with */
    public var dashboardsSharedWith: DashboardsSharedWith?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, rows: Int?, columns: Int?, widgets: [Widget]?, favorite: Bool?, publicDashboard: Bool?, restricted: Bool?, layoutType: LayoutType?, dateCreated: Date?, dateModified: Date?, dateDeleted: Date?, createdBy: AddressableEntityRef?, shared: Bool?, dashboardsSharedWith: DashboardsSharedWith?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.rows = rows
        self.columns = columns
        self.widgets = widgets
        self.favorite = favorite
        self.publicDashboard = publicDashboard
        self.restricted = restricted
        self.layoutType = layoutType
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.dateDeleted = dateDeleted
        self.createdBy = createdBy
        self.shared = shared
        self.dashboardsSharedWith = dashboardsSharedWith
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case rows
        case columns
        case widgets
        case favorite
        case publicDashboard
        case restricted
        case layoutType
        case dateCreated
        case dateModified
        case dateDeleted
        case createdBy
        case shared
        case dashboardsSharedWith
        case selfUri
    }


}




public class DashboardConfigurationListing: Codable {





















    public var entities: [DashboardConfiguration]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var previousUri: String?
    public var nextUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [DashboardConfiguration]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, previousUri: String?, nextUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.previousUri = previousUri
        self.nextUri = nextUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class DataActionConditionPredicate: Codable {



    public enum OutputOperator: String, Codable { 
        case equals = "EQUALS"
        case lessThan = "LESS_THAN"
        case lessThanEquals = "LESS_THAN_EQUALS"
        case greaterThan = "GREATER_THAN"
        case greaterThanEquals = "GREATER_THAN_EQUALS"
        case contains = "CONTAINS"
        case beginsWith = "BEGINS_WITH"
        case endsWith = "ENDS_WITH"
        case before = "BEFORE"
        case after = "AFTER"
    }







    /** The name of an output field from the data action's output to use for this condition */
    public var outputField: String?
    /** The operation with which to evaluate this condition */
    public var outputOperator: OutputOperator?
    /** The value to compare against for this condition */
    public var comparisonValue: String?
    /** If true, inverts the result of evaluating this Predicate. Default is false. */
    public var inverted: Bool?
    /** The result of this predicate if the requested output field is missing from the data action's result */
    public var outputFieldMissingResolution: Bool?

    public init(outputField: String?, outputOperator: OutputOperator?, comparisonValue: String?, inverted: Bool?, outputFieldMissingResolution: Bool?) {
        self.outputField = outputField
        self.outputOperator = outputOperator
        self.comparisonValue = comparisonValue
        self.inverted = inverted
        self.outputFieldMissingResolution = outputFieldMissingResolution
    }


}




public class DataActionContactColumnFieldMapping: Codable {





    /** The name of a contact column whose data will be passed to the data action */
    public var contactColumnName: String?
    /** The name of an input field from the data action that the contact column data will be passed to */
    public var dataActionField: String?

    public init(contactColumnName: String?, dataActionField: String?) {
        self.contactColumnName = contactColumnName
        self.dataActionField = dataActionField
    }


}




public class DataIngestionRuleResponse: Codable {







    public enum Status: String, Codable { 
        case active = "Active"
        case deleted = "Deleted"
        case error = "Error"
        case paused = "Paused"
        case pending = "Pending"
        case systemPaused = "SystemPaused"
    }













    /** ID of the data ingestion rule. */
    public var _id: String?
    /** The name of the data ingestion rule. */
    public var name: String?
    /** A description of the data ingestion rule. */
    public var _description: String?
    /** The status of the data ingestion rule. */
    public var status: Status?
    /** The version number of the data ingestion rule. */
    public var version: Int?
    /** Timestamp indicating when the data ingestion rule was created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** Timestamp indicating when the data ingestion rule was last updated. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** The platform of the data ingestion rule. */
    public var platform: String?
    /** The countries is available only on twitter data ingestion rule. ISO 3166-1 alpha-2 country codes where Data Ingestion Rules should apply. Defaults to worldwide. */
    public var countries: [String]?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, _description: String?, status: Status?, version: Int?, dateCreated: Date?, dateModified: Date?, platform: String?, countries: [String]?, selfUri: String?) {
        self._id = _id
        self.name = name
        self._description = _description
        self.status = status
        self.version = version
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.platform = platform
        self.countries = countries
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case _description = "description"
        case status
        case version
        case dateCreated
        case dateModified
        case platform
        case countries
        case selfUri
    }


}




public class DecisionTable: Codable {

























    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** The division to which this entity belongs. */
    public var division: Division?
    /** The decision table description. */
    public var _description: String?
    /** UTC date time indicating when this decision table was created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** UTC date time indicating when this decision table was last updated. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** UTC date time indicating when this decision table was published. Null if never published. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var datePublished: Date?
    /** The entity reference to the most recently published decision table version. Null if never published. */
    public var published: DecisionTableVersionEntity?
    /** The entity reference to the most recently created decision table version. */
    public var latest: DecisionTableVersionEntity?
    /** The column definitions of this decision table. */
    public var columns: DecisionTableColumns?
    /** The published contract information for this decision table. */
    public var publishedContract: DecisionTableContract?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, division: Division?, _description: String?, dateCreated: Date?, dateModified: Date?, datePublished: Date?, published: DecisionTableVersionEntity?, latest: DecisionTableVersionEntity?, columns: DecisionTableColumns?, publishedContract: DecisionTableContract?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.division = division
        self._description = _description
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.datePublished = datePublished
        self.published = published
        self.latest = latest
        self.columns = columns
        self.publishedContract = publishedContract
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case division
        case _description = "description"
        case dateCreated
        case dateModified
        case datePublished
        case published
        case latest
        case columns
        case publishedContract
        case selfUri
    }


}




public class DecisionTableContract: Codable {









    /** DSS schema entity defining source properties for the decision table contract schemas */
    public var parentSchema: DomainEntityRef?
    /** JSON schema describing required value types for each column in every row in a decision table */
    public var rowAuthoringSchema: ContractJsonSchema?
    /** JSON schema for execution input data for a decision table */
    public var executionInputSchema: ContractJsonSchema?
    /** JSON schema for execution output data for a decision table */
    public var executionOutputSchema: ContractJsonSchema?

    public init(parentSchema: DomainEntityRef?, rowAuthoringSchema: ContractJsonSchema?, executionInputSchema: ContractJsonSchema?, executionOutputSchema: ContractJsonSchema?) {
        self.parentSchema = parentSchema
        self.rowAuthoringSchema = rowAuthoringSchema
        self.executionInputSchema = executionInputSchema
        self.executionOutputSchema = executionOutputSchema
    }


}




public class DecisionTableExecutionResponse: Codable {









    /** The decision table version entity that was executed. */
    public var table: DecisionTableVersionEntity?
    /** Total number of rows that matched execution input and would return results */
    public var totalMatchRowCount: Int?
    /** Top 5 rows matching execution input, excluding the one produced the result. */
    public var topMatchRows: [DecisionTableRowEntityRef]?
    /** The output data for each executed row for which output is collected. */
    public var rowExecutionOutputs: [DecisionTableRowExecutionOutput]?

    public init(table: DecisionTableVersionEntity?, totalMatchRowCount: Int?, topMatchRows: [DecisionTableRowEntityRef]?, rowExecutionOutputs: [DecisionTableRowExecutionOutput]?) {
        self.table = table
        self.totalMatchRowCount = totalMatchRowCount
        self.topMatchRows = topMatchRows
        self.rowExecutionOutputs = rowExecutionOutputs
    }


}




public class DecisionTableInputColumn: Codable {







    /** The id of the column. */
    public var _id: String?
    /** The default row value for this column that will complete the condition expression where no value is provided by a row. */
    public var defaultsTo: DecisionTableColumnDefaultRowValue?
    /** The input column condition expression, comprising the left side and comparator of a logical condition in the form of left|comparator|right, where each row of the decision table will provide the right side to form a complete condition */
    public var expression: DecisionTableInputColumnExpression?

    public init(_id: String?, defaultsTo: DecisionTableColumnDefaultRowValue?, expression: DecisionTableInputColumnExpression?) {
        self._id = _id
        self.defaultsTo = defaultsTo
        self.expression = expression
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case defaultsTo
        case expression
    }


}




public class DecisionTableInputColumnRequest: Codable {





    /** The default row value for this column that will complete the condition expression where no value is provided by a row. */
    public var defaultsTo: DecisionTableColumnDefaultRowValue?
    /** The input column condition expression, comprising the left side and comparator of a logical condition in the form of left|comparator|right, where each row of the decision table will provide the right side to form a complete condition */
    public var expression: DecisionTableInputColumnExpression?

    public init(defaultsTo: DecisionTableColumnDefaultRowValue?, expression: DecisionTableInputColumnExpression?) {
        self.defaultsTo = defaultsTo
        self.expression = expression
    }


}




public class DecisionTableListing: Codable {









    public var entities: [DecisionTable]?
    public var nextUri: String?
    public var selfUri: String?
    public var previousUri: String?

    public init(entities: [DecisionTable]?, nextUri: String?, selfUri: String?, previousUri: String?) {
        self.entities = entities
        self.nextUri = nextUri
        self.selfUri = selfUri
        self.previousUri = previousUri
    }


}




public class DecisionTableRowParameterValue: Codable {



    /** A literal parameter value */
    public var literal: Literal?

    public init(literal: Literal?) {
        self.literal = literal
    }


}




public class DefaultGreetingList: Codable {







    public enum OwnerType: String, Codable { 
        case user = "USER"
        case organization = "ORGANIZATION"
        case group = "GROUP"
    }













    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    public var owner: GreetingOwner?
    public var ownerType: OwnerType?
    public var greetings: [String:Greeting]?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var createdDate: Date?
    public var createdBy: String?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var modifiedDate: Date?
    public var modifiedBy: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, owner: GreetingOwner?, ownerType: OwnerType?, greetings: [String:Greeting]?, createdDate: Date?, createdBy: String?, modifiedDate: Date?, modifiedBy: String?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.owner = owner
        self.ownerType = ownerType
        self.greetings = greetings
        self.createdDate = createdDate
        self.createdBy = createdBy
        self.modifiedDate = modifiedDate
        self.modifiedBy = modifiedBy
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case owner
        case ownerType
        case greetings
        case createdDate
        case createdBy
        case modifiedDate
        case modifiedBy
        case selfUri
    }


}




public class DefaultObjective: Codable {









    public enum MediaTypes: String, Codable { 
        case callback = "callback"
        case chat = "chat"
        case cobrowse = "cobrowse"
        case email = "email"
        case internalmessage = "internalmessage"
        case message = "message"
        case screenmonitoring = "screenmonitoring"
        case screenshare = "screenshare"
        case unknown = "unknown"
        case video = "video"
        case voice = "voice"
    }





    public enum TopicIdsFilterType: String, Codable { 
        case and = "and"
        case or = "or"
    }



    public enum InitialDirection: String, Codable { 
        case inbound = "inbound"
        case outbound = "outbound"
    }

    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The id of this objective's base template */
    public var templateId: String?
    /** Objective zone specifies min,max points and values for the associated metric */
    public var zones: [ObjectiveZone]?
    /** A flag for whether this objective is enabled for the related metric */
    public var enabled: Bool?
    /** A list of media types for the metric */
    public var mediaTypes: [MediaTypes]?
    /** A list of queues for the metric */
    public var queues: [AddressableEntityRef]?
    /** A list of topic ids for detected topic metrics */
    public var topics: [AddressableEntityRef]?
    /** A filter type for topic Ids. It's only used for objectives with topicIds. Default filter behavior is \"or\". */
    public var topicIdsFilterType: TopicIdsFilterType?
    /** The ids of associated evaluation form context, for Quality Evaluation Score metrics */
    public var evaluationFormContextIds: [String]?
    /** The initial direction to filter on */
    public var initialDirection: InitialDirection?

    public init(_id: String?, templateId: String?, zones: [ObjectiveZone]?, enabled: Bool?, mediaTypes: [MediaTypes]?, queues: [AddressableEntityRef]?, topics: [AddressableEntityRef]?, topicIdsFilterType: TopicIdsFilterType?, evaluationFormContextIds: [String]?, initialDirection: InitialDirection?) {
        self._id = _id
        self.templateId = templateId
        self.zones = zones
        self.enabled = enabled
        self.mediaTypes = mediaTypes
        self.queues = queues
        self.topics = topics
        self.topicIdsFilterType = topicIdsFilterType
        self.evaluationFormContextIds = evaluationFormContextIds
        self.initialDirection = initialDirection
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case templateId
        case zones
        case enabled
        case mediaTypes
        case queues
        case topics
        case topicIdsFilterType
        case evaluationFormContextIds
        case initialDirection
    }


}




public class DeleteRetention: Codable {



    public var days: Int?

    public init(days: Int?) {
        self.days = days
    }


}




public class DependencyObject: Codable {







    public enum ModelType: String, Codable { 
        case acdlanguage = "ACDLANGUAGE"
        case acdskill = "ACDSKILL"
        case acdwrapupcode = "ACDWRAPUPCODE"
        case agenticvirtualagent = "AGENTICVIRTUALAGENT"
        case agenticvirtualagentversion = "AGENTICVIRTUALAGENTVERSION"
        case audioconnectorbot = "AUDIOCONNECTORBOT"
        case botconnectorbot = "BOTCONNECTORBOT"
        case botconnectorintegration = "BOTCONNECTORINTEGRATION"
        case botflow = "BOTFLOW"
        case bridgeaction = "BRIDGEACTION"
        case commonmoduleflow = "COMMONMODULEFLOW"
        case composerscript = "COMPOSERSCRIPT"
        case contactlist = "CONTACTLIST"
        case conversationcustomattributeschema = "CONVERSATIONCUSTOMATTRIBUTESCHEMA"
        case dataaction = "DATAACTION"
        case datatable = "DATATABLE"
        case decisiontable = "DECISIONTABLE"
        case dialogenginebot = "DIALOGENGINEBOT"
        case dialogenginebotversion = "DIALOGENGINEBOTVERSION"
        case dialogflowagent = "DIALOGFLOWAGENT"
        case dialogflowcxagent = "DIALOGFLOWCXAGENT"
        case digitalbotconnector = "DIGITALBOTCONNECTOR"
        case digitalbotconnectorintegration = "DIGITALBOTCONNECTORINTEGRATION"
        case digitalbotflow = "DIGITALBOTFLOW"
        case division = "DIVISION"
        case emailroute = "EMAILROUTE"
        case emergencygroup = "EMERGENCYGROUP"
        case flowaction = "FLOWACTION"
        case flowdatatype = "FLOWDATATYPE"
        case flowmilestone = "FLOWMILESTONE"
        case flowoutcome = "FLOWOUTCOME"
        case grammar = "GRAMMAR"
        case group = "GROUP"
        case guide = "GUIDE"
        case guideversion = "GUIDEVERSION"
        case image = "IMAGE"
        case inboundcallflow = "INBOUNDCALLFLOW"
        case inboundchatflow = "INBOUNDCHATFLOW"
        case inboundemailflow = "INBOUNDEMAILFLOW"
        case inboundshortmessageflow = "INBOUNDSHORTMESSAGEFLOW"
        case inqueuecallflow = "INQUEUECALLFLOW"
        case inqueueemailflow = "INQUEUEEMAILFLOW"
        case inqueueshortmessageflow = "INQUEUESHORTMESSAGEFLOW"
        case ivrconfiguration = "IVRCONFIGURATION"
        case knowledgebase = "KNOWLEDGEBASE"
        case knowledgebasedocument = "KNOWLEDGEBASEDOCUMENT"
        case knowledgesetting = "KNOWLEDGESETTING"
        case language = "LANGUAGE"
        case lexbot = "LEXBOT"
        case lexbotalias = "LEXBOTALIAS"
        case lexv2bot = "LEXV2BOT"
        case lexv2botalias = "LEXV2BOTALIAS"
        case nludomain = "NLUDOMAIN"
        case nuancemixbot = "NUANCEMIXBOT"
        case nuancemixintegration = "NUANCEMIXINTEGRATION"
        case oauthclient = "OAUTHCLIENT"
        case outboundcallflow = "OUTBOUNDCALLFLOW"
        case queue = "QUEUE"
        case recordingpolicy = "RECORDINGPOLICY"
        case response = "RESPONSE"
        case schedule = "SCHEDULE"
        case schedulegroup = "SCHEDULEGROUP"
        case secureaction = "SECUREACTION"
        case securecallflow = "SECURECALLFLOW"
        case smsphonenumber = "SMSPHONENUMBER"
        case sttengine = "STTENGINE"
        case surveyform = "SURVEYFORM"
        case surveyinviteflow = "SURVEYINVITEFLOW"
        case systemprompt = "SYSTEMPROMPT"
        case ttsengine = "TTSENGINE"
        case ttsvoice = "TTSVOICE"
        case user = "USER"
        case userprompt = "USERPROMPT"
        case utilizationlabel = "UTILIZATIONLABEL"
        case voiceflow = "VOICEFLOW"
        case voicemailflow = "VOICEMAILFLOW"
        case voicesurveyflow = "VOICESURVEYFLOW"
        case widget = "WIDGET"
        case workflow = "WORKFLOW"
        case workitemflow = "WORKITEMFLOW"
        case worktype = "WORKTYPE"
    }













    /** The dependency identifier */
    public var _id: String?
    public var name: String?
    public var version: String?
    public var type: ModelType?
    public var deleted: Bool?
    public var updated: Bool?
    public var stateUnknown: Bool?
    public var consumedResources: [Dependency]?
    public var consumingResources: [Dependency]?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, version: String?, type: ModelType?, deleted: Bool?, updated: Bool?, stateUnknown: Bool?, consumedResources: [Dependency]?, consumingResources: [Dependency]?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.version = version
        self.type = type
        self.deleted = deleted
        self.updated = updated
        self.stateUnknown = stateUnknown
        self.consumedResources = consumedResources
        self.consumingResources = consumingResources
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case version
        case type
        case deleted
        case updated
        case stateUnknown
        case consumedResources
        case consumingResources
        case selfUri
    }


}




public class DependencyStatus: Codable {















    public enum Status: String, Codable { 
        case buildincomplete = "BUILDINCOMPLETE"
        case buildinitializing = "BUILDINITIALIZING"
        case buildinprogress = "BUILDINPROGRESS"
        case buildqueued = "BUILDQUEUED"
        case notbuilt = "NOTBUILT"
        case operational = "OPERATIONAL"
        case operationalneedsrebuild = "OPERATIONALNEEDSREBUILD"
    }





    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** User that initiated the build. */
    public var user: User?
    /** OAuth client that initiated the build. */
    public var client: DomainEntityRef?
    public var buildId: String?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateStarted: Date?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCompleted: Date?
    public var status: Status?
    public var failedObjects: [FailedObject]?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, user: User?, client: DomainEntityRef?, buildId: String?, dateStarted: Date?, dateCompleted: Date?, status: Status?, failedObjects: [FailedObject]?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.user = user
        self.client = client
        self.buildId = buildId
        self.dateStarted = dateStarted
        self.dateCompleted = dateCompleted
        self.status = status
        self.failedObjects = failedObjects
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case user
        case client
        case buildId
        case dateStarted
        case dateCompleted
        case status
        case failedObjects
        case selfUri
    }


}




public class DevelopmentActivityAggregateQueryRequestClause: Codable {

    public enum ModelType: String, Codable { 
        case and = "And"
        case or = "Or"
    }



    /** The logic used to combine the predicates */
    public var type: ModelType?
    /** The list of predicates used to filter the data */
    public var predicates: [DevelopmentActivityAggregateQueryRequestPredicate]?

    public init(type: ModelType?, predicates: [DevelopmentActivityAggregateQueryRequestPredicate]?) {
        self.type = type
        self.predicates = predicates
    }


}




public class DevelopmentActivityAggregateQueryResponseData: Codable {





    /** Specifies the range of due dates to be used for filtering. A maximum of 1 year can be specified in the range. Intervals are represented as an ISO-8601 string. For example: YYYY-MM-DDThh:mm:ss/YYYY-MM-DDThh:mm:ss */
    public var interval: String?
    /** The list of aggregated metrics */
    public var metrics: [DevelopmentActivityAggregateQueryResponseMetric]?

    public init(interval: String?, metrics: [DevelopmentActivityAggregateQueryResponseMetric]?) {
        self.interval = interval
        self.metrics = metrics
    }


}




public class Device: Codable {

    public enum Category: String, Codable { 
        case desktop = "desktop"
        case mobile = "mobile"
        case tablet = "tablet"
        case other = "other"
    }



















    /** Device category. */
    public var category: Category?
    /** Device type (e.g. iPad, iPhone, Other). */
    public var type: String?
    /** Flag that is true for mobile devices. */
    public var isMobile: Bool?
    /** Device's screen height. */
    public var screenHeight: Int?
    /** Device's screen width. */
    public var screenWidth: Int?
    /** Device's screen density, measured as a scale factor where a value of 1 represents a baseline 1:1 ratio of pixels to logical (device-independent) pixels. */
    public var screenDensity: Int?
    /** Fingerprint generated by looking at the individual device features. */
    public var fingerprint: String?
    /** Operating system family. */
    public var osFamily: String?
    /** Operating system version. */
    public var osVersion: String?
    /** Manufacturer of the device. */
    public var manufacturer: String?

    public init(category: Category?, type: String?, isMobile: Bool?, screenHeight: Int?, screenWidth: Int?, screenDensity: Int?, fingerprint: String?, osFamily: String?, osVersion: String?, manufacturer: String?) {
        self.category = category
        self.type = type
        self.isMobile = isMobile
        self.screenHeight = screenHeight
        self.screenWidth = screenWidth
        self.screenDensity = screenDensity
        self.fingerprint = fingerprint
        self.osFamily = osFamily
        self.osVersion = osVersion
        self.manufacturer = manufacturer
    }


}




public class DialerCallabletimesetConfigChangeTimeSlot: Codable {











    /** The start time of this time slot */
    public var startTime: String?
    /** The stop time of this time slot */
    public var stopTime: String?
    /** The day this time slot applies */
    public var day: Int64?
    public var additionalProperties: [String:JSON]?
    public var getAdditionalProperties: [String:JSON]?

    public init(startTime: String?, stopTime: String?, day: Int64?, additionalProperties: [String:JSON]?, getAdditionalProperties: [String:JSON]?) {
        self.startTime = startTime
        self.stopTime = stopTime
        self.day = day
        self.additionalProperties = additionalProperties
        self.getAdditionalProperties = getAdditionalProperties
    }


}



/** the campaign/sequence entities that this action acts on */

public class DialerCampaignRuleConfigChangeCampaignRuleActionEntities: Codable {











    /** Whether this action should act on the entity that triggered it */
    public var useTriggeringEntity: Bool?
    public var additionalProperties: [String:JSON]?
    /** A list of campaignIds to act on */
    public var campaigns: [DialerCampaignRuleConfigChangeUriReference]?
    /** A list of sequenceIds to act on */
    public var sequences: [DialerCampaignRuleConfigChangeUriReference]?
    public var getAdditionalProperties: [String:JSON]?

    public init(useTriggeringEntity: Bool?, additionalProperties: [String:JSON]?, campaigns: [DialerCampaignRuleConfigChangeUriReference]?, sequences: [DialerCampaignRuleConfigChangeUriReference]?, getAdditionalProperties: [String:JSON]?) {
        self.useTriggeringEntity = useTriggeringEntity
        self.additionalProperties = additionalProperties
        self.campaigns = campaigns
        self.sequences = sequences
        self.getAdditionalProperties = getAdditionalProperties
    }


}



/** the schedule range */

public class DialerCampaignScheduleConfigChangeRecurrenceRange: Codable {

    public enum ModelType: String, Codable { 
        case noEnd = "NoEnd"
        case numbered = "Numbered"
        case endDate = "EndDate"
    }









    public var type: ModelType?
    /** the range end date */
    public var end: String?
    /** the number of occurrences to happen before ending */
    public var numberOfOccurrences: Int64?
    public var additionalProperties: [String:JSON]?
    public var getAdditionalProperties: [String:JSON]?

    public init(type: ModelType?, end: String?, numberOfOccurrences: Int64?, additionalProperties: [String:JSON]?, getAdditionalProperties: [String:JSON]?) {
        self.type = type
        self.end = end
        self.numberOfOccurrences = numberOfOccurrences
        self.additionalProperties = additionalProperties
        self.getAdditionalProperties = getAdditionalProperties
    }


}




public class DialerCampaignScheduleConfigChangeScheduleRecurrence: Codable {



















    /** the recurrence id */
    public var _id: String?
    /** scheduled start time represented as an ISO-8601 string; for example, yyyy-MM-ddTHH:mm:ss.SSSZ */
    public var start: String?
    /** scheduled end time represented as an ISO-8601 string; for example, yyyy-MM-ddTHH:mm:ss.SSSZ */
    public var end: String?
    /** the timezone the recurrence will use */
    public var timeZone: String?
    public var range: DialerCampaignScheduleConfigChangeRecurrenceRange?
    public var pattern: DialerCampaignScheduleConfigChangeRecurrencePattern?
    /** modifications to the original recurrence schedule */
    public var alterations: [DialerCampaignScheduleConfigChangeAlteration]?
    public var additionalProperties: [String:JSON]?
    public var getAdditionalProperties: [String:JSON]?

    public init(_id: String?, start: String?, end: String?, timeZone: String?, range: DialerCampaignScheduleConfigChangeRecurrenceRange?, pattern: DialerCampaignScheduleConfigChangeRecurrencePattern?, alterations: [DialerCampaignScheduleConfigChangeAlteration]?, additionalProperties: [String:JSON]?, getAdditionalProperties: [String:JSON]?) {
        self._id = _id
        self.start = start
        self.end = end
        self.timeZone = timeZone
        self.range = range
        self.pattern = pattern
        self.alterations = alterations
        self.additionalProperties = additionalProperties
        self.getAdditionalProperties = getAdditionalProperties
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case start
        case end
        case timeZone
        case range
        case pattern
        case alterations
        case additionalProperties
        case getAdditionalProperties
    }


}




public class DialerContactId: Codable {





    public var _id: String?
    public var contactListId: String?

    public init(_id: String?, contactListId: String?) {
        self._id = _id
        self.contactListId = contactListId
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case contactListId
    }


}




public class DialerContactlistConfigChangeImportStatus: Codable {

    public enum ImportState: String, Codable { 
        case inProgress = "IN_PROGRESS"
        case failed = "FAILED"
    }

















    /** current status of the import */
    public var importState: ImportState?
    /** total number of records to be imported */
    public var totalRecords: Int64?
    /** number of records finished importing */
    public var completedRecords: Int64?
    /** percentage of records finished importing */
    public var percentageComplete: Int64?
    /** if the import has failed, the reason for the failure */
    public var failureReason: String?
    /** The ids for target contact lists */
    public var targetContactListIds: [String]?
    /** The prefix used for target contact list names */
    public var listNamePrefix: String?
    public var additionalProperties: [String:JSON]?
    public var getAdditionalProperties: [String:JSON]?

    public init(importState: ImportState?, totalRecords: Int64?, completedRecords: Int64?, percentageComplete: Int64?, failureReason: String?, targetContactListIds: [String]?, listNamePrefix: String?, additionalProperties: [String:JSON]?, getAdditionalProperties: [String:JSON]?) {
        self.importState = importState
        self.totalRecords = totalRecords
        self.completedRecords = completedRecords
        self.percentageComplete = percentageComplete
        self.failureReason = failureReason
        self.targetContactListIds = targetContactListIds
        self.listNamePrefix = listNamePrefix
        self.additionalProperties = additionalProperties
        self.getAdditionalProperties = getAdditionalProperties
    }


}



/** The time interval to place outbound calls */

public class DialerOutboundSettingsConfigChangeAtzmTimeSlotWithTimeZone: Codable {







    /** The time zone to use for contacts that cannot be mapped */
    public var timeZoneId: String?
    /** The earliest time to dial a contact */
    public var earliestCallableTime: String?
    /** The latest time to dial a contact */
    public var latestCallableTime: String?

    public init(timeZoneId: String?, earliestCallableTime: String?, latestCallableTime: String?) {
        self.timeZoneId = timeZoneId
        self.earliestCallableTime = earliestCallableTime
        self.latestCallableTime = latestCallableTime
    }


}




public class DialerOutboundSettingsConfigChangeOutboundSettings: Codable {







    public enum ComplianceAbandonRateDenominator: String, Codable { 
        case allCalls = "ALL_CALLS"
        case callsThatReachedQueue = "CALLS_THAT_REACHED_QUEUE"
    }













    /** The maximum number of calls that can be placed per agent on any campaign */
    public var maxCallsPerAgent: Int64?
    /** The maximum percentage of lines that should be used for Outbound, expressed as a decimal in the range [0.0, 1.0] */
    public var maxLineUtilization: Double?
    /** The number of seconds used to determine if a call is abandoned */
    public var abandonSeconds: Double?
    /** The denominator to be used in determining the compliance abandon rate */
    public var complianceAbandonRateDenominator: ComplianceAbandonRateDenominator?
    public var automaticTimeZoneMapping: DialerOutboundSettingsConfigChangeAutomaticTimeZoneMappingSettings?
    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The UI-visible name of the object */
    public var name: String?
    /** Creation time of the entity */
    public var dateCreated: Date?
    /** Last modified time of the entity */
    public var dateModified: Date?
    /** Required for updates, must match the version number of the most recent update */
    public var version: Int64?

    public init(maxCallsPerAgent: Int64?, maxLineUtilization: Double?, abandonSeconds: Double?, complianceAbandonRateDenominator: ComplianceAbandonRateDenominator?, automaticTimeZoneMapping: DialerOutboundSettingsConfigChangeAutomaticTimeZoneMappingSettings?, _id: String?, name: String?, dateCreated: Date?, dateModified: Date?, version: Int64?) {
        self.maxCallsPerAgent = maxCallsPerAgent
        self.maxLineUtilization = maxLineUtilization
        self.abandonSeconds = abandonSeconds
        self.complianceAbandonRateDenominator = complianceAbandonRateDenominator
        self.automaticTimeZoneMapping = automaticTimeZoneMapping
        self._id = _id
        self.name = name
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.version = version
    }

    public enum CodingKeys: String, CodingKey { 
        case maxCallsPerAgent
        case maxLineUtilization
        case abandonSeconds
        case complianceAbandonRateDenominator
        case automaticTimeZoneMapping
        case _id = "id"
        case name
        case dateCreated
        case dateModified
        case version
    }


}



/** the schedule range */

public class DialerSequenceScheduleConfigChangeRecurrenceRange: Codable {

    public enum ModelType: String, Codable { 
        case noEnd = "NoEnd"
        case numbered = "Numbered"
        case endDate = "EndDate"
    }









    public var type: ModelType?
    /** the range end date */
    public var end: String?
    /** the number of occurrences to happen before ending */
    public var numberOfOccurrences: Int64?
    public var additionalProperties: [String:JSON]?
    public var getAdditionalProperties: [String:JSON]?

    public init(type: ModelType?, end: String?, numberOfOccurrences: Int64?, additionalProperties: [String:JSON]?, getAdditionalProperties: [String:JSON]?) {
        self.type = type
        self.end = end
        self.numberOfOccurrences = numberOfOccurrences
        self.additionalProperties = additionalProperties
        self.getAdditionalProperties = getAdditionalProperties
    }


}




public class DialerSequenceScheduleConfigChangeScheduleRecurrence: Codable {



















    /** the recurrence id */
    public var _id: String?
    /** scheduled start time represented as an ISO-8601 string; for example, yyyy-MM-ddTHH:mm:ss.SSSZ */
    public var start: String?
    /** scheduled end time represented as an ISO-8601 string; for example, yyyy-MM-ddTHH:mm:ss.SSSZ */
    public var end: String?
    /** the timezone the recurrence will use */
    public var timeZone: String?
    public var range: DialerSequenceScheduleConfigChangeRecurrenceRange?
    public var pattern: DialerSequenceScheduleConfigChangeRecurrencePattern?
    /** modifications to the original recurrence schedule */
    public var alterations: [DialerSequenceScheduleConfigChangeAlteration]?
    public var additionalProperties: [String:JSON]?
    public var getAdditionalProperties: [String:JSON]?

    public init(_id: String?, start: String?, end: String?, timeZone: String?, range: DialerSequenceScheduleConfigChangeRecurrenceRange?, pattern: DialerSequenceScheduleConfigChangeRecurrencePattern?, alterations: [DialerSequenceScheduleConfigChangeAlteration]?, additionalProperties: [String:JSON]?, getAdditionalProperties: [String:JSON]?) {
        self._id = _id
        self.start = start
        self.end = end
        self.timeZone = timeZone
        self.range = range
        self.pattern = pattern
        self.alterations = alterations
        self.additionalProperties = additionalProperties
        self.getAdditionalProperties = getAdditionalProperties
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case start
        case end
        case timeZone
        case range
        case pattern
        case alterations
        case additionalProperties
        case getAdditionalProperties
    }


}




public class DialogflowAgent: Codable {

















    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** The project this Dialogflow agent belongs to */
    public var project: DialogflowProject?
    /** The supported languages of the Dialogflow agent */
    public var languages: [String]?
    /** An array of Intents associated with this agent */
    public var intents: [DialogflowIntent]?
    /** Available environments for this agent */
    public var environments: [String]?
    /** The Integration this Dialogflow agent was referenced from. */
    public var integration: DomainEntityRef?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, project: DialogflowProject?, languages: [String]?, intents: [DialogflowIntent]?, environments: [String]?, integration: DomainEntityRef?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.project = project
        self.languages = languages
        self.intents = intents
        self.environments = environments
        self.integration = integration
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case project
        case languages
        case intents
        case environments
        case integration
        case selfUri
    }


}




public class DialogflowAgentSummary: Codable {













    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** The project this Dialogflow agent belongs to. */
    public var project: DialogflowProject?
    /** A description of the Dialogflow agent. */
    public var _description: String?
    /** The Integration this Dialogflow agent was referenced from. */
    public var integration: DomainEntityRef?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, project: DialogflowProject?, _description: String?, integration: DomainEntityRef?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.project = project
        self._description = _description
        self.integration = integration
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case project
        case _description = "description"
        case integration
        case selfUri
    }


}




public class DialogflowCXAgent: Codable {















    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** The project this Dialogflow CX agent belongs to. */
    public var project: DialogflowCXProject?
    /** The supported languages of the Dialogflow CX agent.  Each value will be a language code in the country-locale format. e.g. en-us, es-us, fr-ca, etc. */
    public var languages: [String]?
    /** Available environments for this CX agent. */
    public var environments: [DialogflowCXEnvironment]?
    /** The Integration this Dialogflow CX agent was referenced from. */
    public var integration: DomainEntityRef?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, project: DialogflowCXProject?, languages: [String]?, environments: [DialogflowCXEnvironment]?, integration: DomainEntityRef?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.project = project
        self.languages = languages
        self.environments = environments
        self.integration = integration
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case project
        case languages
        case environments
        case integration
        case selfUri
    }


}




public class DialogflowCXAgentSummary: Codable {













    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** The project this Dialogflow CX agent belongs to. */
    public var project: DialogflowCXProject?
    /** A description of the Dialogflow CX agent. */
    public var _description: String?
    /** The Integration this Dialogflow CX agent was referenced from. */
    public var integration: DomainEntityRef?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, project: DialogflowCXProject?, _description: String?, integration: DomainEntityRef?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.project = project
        self._description = _description
        self.integration = integration
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case project
        case _description = "description"
        case integration
        case selfUri
    }


}




public class DigitLength: Codable {





    public var start: String?
    public var end: String?

    public init(start: String?, end: String?) {
        self.start = start
        self.end = end
    }


}




public class DigitalCondition: Codable {



















    /** If true, inverts the result of evaluating this condition. Default is false. */
    public var inverted: Bool?
    /** The settings for a 'contact list column' condition. */
    public var contactColumnConditionSettings: ContactColumnConditionSettings?
    /** The settings for a 'contact address' condition. */
    public var contactAddressConditionSettings: ContactAddressConditionSettings?
    /** The settings for a 'contact address type' condition. */
    public var contactAddressTypeConditionSettings: ContactAddressTypeConditionSettings?
    /** The settings for a 'last attempt by column' condition. */
    public var lastAttemptByColumnConditionSettings: LastAttemptByColumnConditionSettings?
    /** The settings for a 'last attempt overall' condition. */
    public var lastAttemptOverallConditionSettings: LastAttemptOverallConditionSettings?
    /** The settings for a 'last result by column' condition. */
    public var lastResultByColumnConditionSettings: LastResultByColumnConditionSettings?
    /** The settings for a 'last result overall' condition. */
    public var lastResultOverallConditionSettings: LastResultOverallConditionSettings?
    /** The settings for a 'data action' condition. */
    public var dataActionConditionSettings: DataActionConditionSettings?

    public init(inverted: Bool?, contactColumnConditionSettings: ContactColumnConditionSettings?, contactAddressConditionSettings: ContactAddressConditionSettings?, contactAddressTypeConditionSettings: ContactAddressTypeConditionSettings?, lastAttemptByColumnConditionSettings: LastAttemptByColumnConditionSettings?, lastAttemptOverallConditionSettings: LastAttemptOverallConditionSettings?, lastResultByColumnConditionSettings: LastResultByColumnConditionSettings?, lastResultOverallConditionSettings: LastResultOverallConditionSettings?, dataActionConditionSettings: DataActionConditionSettings?) {
        self.inverted = inverted
        self.contactColumnConditionSettings = contactColumnConditionSettings
        self.contactAddressConditionSettings = contactAddressConditionSettings
        self.contactAddressTypeConditionSettings = contactAddressTypeConditionSettings
        self.lastAttemptByColumnConditionSettings = lastAttemptByColumnConditionSettings
        self.lastAttemptOverallConditionSettings = lastAttemptOverallConditionSettings
        self.lastResultByColumnConditionSettings = lastResultByColumnConditionSettings
        self.lastResultOverallConditionSettings = lastResultOverallConditionSettings
        self.dataActionConditionSettings = dataActionConditionSettings
    }


}




public class DigitalRuleSetEntityListing: Codable {





















    public var entities: [DigitalRuleSet]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var previousUri: String?
    public var nextUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [DigitalRuleSet]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, previousUri: String?, nextUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.previousUri = previousUri
        self.nextUri = nextUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class Digits: Codable {



    /** A string representing the digits pressed on phone. */
    public var digits: String?

    public init(digits: String?) {
        self.digits = digits
    }


}




public class DirectRouting: Codable {













    /** Direct Routing Settings specific to Call media. */
    public var callMediaSettings: DirectRoutingMediaSettings?
    /** Direct Routing Settings specific to Email media. */
    public var emailMediaSettings: DirectRoutingMediaSettings?
    /** Direct Routing Settings specific to Message media. */
    public var messageMediaSettings: DirectRoutingMediaSettings?
    /** ID of another queue to be used as the default backup if an agent does not have their Backup Settings configured. If not set, the current queue will be used as backup, but with Direct Routing criteria removed from the conversation. */
    public var backupQueueId: String?
    /** Flag indicating if Direct Routing interactions should wait for Direct Routing agent or go immediately to selected backup. */
    public var waitForAgent: Bool?
    /** Time (in seconds) that a Direct Routing interaction will wait for Direct Routing agent before going to selected backup. Valid range [60, 864000]. */
    public var agentWaitSeconds: Int?

    public init(callMediaSettings: DirectRoutingMediaSettings?, emailMediaSettings: DirectRoutingMediaSettings?, messageMediaSettings: DirectRoutingMediaSettings?, backupQueueId: String?, waitForAgent: Bool?, agentWaitSeconds: Int?) {
        self.callMediaSettings = callMediaSettings
        self.emailMediaSettings = emailMediaSettings
        self.messageMediaSettings = messageMediaSettings
        self.backupQueueId = backupQueueId
        self.waitForAgent = waitForAgent
        self.agentWaitSeconds = agentWaitSeconds
    }


}




public class DisableSiteConnectionsRequest: Codable {



    public var enabled: Bool?

    public init(enabled: Bool?) {
        self.enabled = enabled
    }


}




public class DispositionParameters: Codable {



    /** ALSD evaluation inputs and output (isPersonalLikely) of the ALSD detector the last time it ran on the call (could be multiple times) */
    public var adjustableLiveSpeakerDetection: AdjustableLiveSpeakerDetection?

    public init(adjustableLiveSpeakerDetection: AdjustableLiveSpeakerDetection?) {
        self.adjustableLiveSpeakerDetection = adjustableLiveSpeakerDetection
    }


}




public class Division: Codable {







    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case selfUri
    }


}




public class DncListDivisionView: Codable {











    public enum DncSourceType: String, Codable { 
        case rds = "rds"
        case rdsCustom = "rds_custom"
        case dncCom = "dnc.com"
        case gryphon = "gryphon"
    }

    public enum ContactMethod: String, Codable { 
        case email = "Email"
        case phone = "Phone"
        case any = "Any"
        case whatsApp = "WhatsApp"
    }



    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** The division to which this entity belongs. */
    public var division: Division?
    /** The status of the import process. */
    public var importStatus: ImportStatus?
    /** The number of contacts in the DncList. */
    public var size: Int64?
    /** The type of the DncList. */
    public var dncSourceType: DncSourceType?
    /** The contact method. Required if dncSourceType is rds. */
    public var contactMethod: ContactMethod?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, division: Division?, importStatus: ImportStatus?, size: Int64?, dncSourceType: DncSourceType?, contactMethod: ContactMethod?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.division = division
        self.importStatus = importStatus
        self.size = size
        self.dncSourceType = dncSourceType
        self.contactMethod = contactMethod
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case division
        case importStatus
        case size
        case dncSourceType
        case contactMethod
        case selfUri
    }


}




public class DncListDivisionViewListing: Codable {





















    public var entities: [DncListDivisionView]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var previousUri: String?
    public var nextUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [DncListDivisionView]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, previousUri: String?, nextUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.previousUri = previousUri
        self.nextUri = nextUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class DnclistDownloadReadyExportUri: Codable {









    public var uri: String?
    public var exportTimestamp: String?
    public var additionalProperties: [String:JSON]?
    public var getAdditionalProperties: [String:JSON]?

    public init(uri: String?, exportTimestamp: String?, additionalProperties: [String:JSON]?, getAdditionalProperties: [String:JSON]?) {
        self.uri = uri
        self.exportTimestamp = exportTimestamp
        self.additionalProperties = additionalProperties
        self.getAdditionalProperties = getAdditionalProperties
    }


}




public class DocumentBodyBlockWithHighlight: Codable {

    public enum ModelType: String, Codable { 
        case paragraph = "Paragraph"
        case image = "Image"
        case video = "Video"
        case orderedList = "OrderedList"
        case unorderedList = "UnorderedList"
        case table = "Table"
    }











    /** The type of the block for the body. This determines which body block object (paragraph, list, video, image or table) would have a value. */
    public var type: ModelType?
    /** Image. It must contain a value if the type of the block is Image. */
    public var image: DocumentBodyImage?
    /** Video. It must contain a value if the type of the block is Video. */
    public var video: DocumentBodyVideo?
    /** Paragraph. It must contain a value if the type of the block is Paragraph. */
    public var paragraph: DocumentBodyParagraphWithHighlight?
    /** List. It must contain a value if the type of the block is UnorderedList or OrderedList. */
    public var list: DocumentBodyListWithHighlight?
    /** Table. It must contain a value if type of the block is Table. */
    public var table: DocumentBodyTableWithHighlight?

    public init(type: ModelType?, image: DocumentBodyImage?, video: DocumentBodyVideo?, paragraph: DocumentBodyParagraphWithHighlight?, list: DocumentBodyListWithHighlight?, table: DocumentBodyTableWithHighlight?) {
        self.type = type
        self.image = image
        self.video = video
        self.paragraph = paragraph
        self.list = list
        self.table = table
    }


}




public class DocumentBodyImage: Codable {







    /** The URL for the image. */
    public var url: String?
    /** The URL of the page OR an email OR the reference to the knowledge article that the hyperlink goes to. Possible URL value types are https://<url link> | mailto:<email> | grn:knowledge:::documentVariation/<knowledgeBaseId>/<documentId>/<variationId> | grn:knowledge:::document/<knowledgeBaseId>/<documentId> | grn:knowledge:::category/<knowledgeBaseId>/<categoryId> | grn:knowledge:::label/<knowledgeBaseId>/<labelId> */
    public var hyperlink: String?
    /** The properties for the image. */
    public var properties: DocumentBodyImageProperties?

    public init(url: String?, hyperlink: String?, properties: DocumentBodyImageProperties?) {
        self.url = url
        self.hyperlink = hyperlink
        self.properties = properties
    }


}




public class DocumentBodyListBlock: Codable {

    public enum ModelType: String, Codable { 
        case listItem = "ListItem"
    }





    /** The type of the list block. */
    public var type: ModelType?
    /** The properties for the list block. */
    public var properties: DocumentBodyListItemProperties?
    /** The list of items for an OrderedList or an UnorderedList. */
    public var blocks: [DocumentListContentBlock]?

    public init(type: ModelType?, properties: DocumentBodyListItemProperties?, blocks: [DocumentListContentBlock]?) {
        self.type = type
        self.properties = properties
        self.blocks = blocks
    }


}




public class DocumentBodyParagraph: Codable {





    /** The list of blocks for the paragraph. */
    public var blocks: [DocumentContentBlock]?
    /** The properties for the paragraph. */
    public var properties: DocumentBodyParagraphProperties?

    public init(blocks: [DocumentContentBlock]?, properties: DocumentBodyParagraphProperties?) {
        self.blocks = blocks
        self.properties = properties
    }


}




public class DocumentBodyTable: Codable {





    /** The properties for the table. */
    public var properties: DocumentBodyTableProperties?
    /** The list of rows for the table. */
    public var rows: [DocumentBodyTableRowBlock]?

    public init(properties: DocumentBodyTableProperties?, rows: [DocumentBodyTableRowBlock]?) {
        self.properties = properties
        self.rows = rows
    }


}




public class DocumentBodyTableCellBlock: Codable {





    /** The properties for the table cell. */
    public var properties: DocumentBodyTableCellBlockProperties?
    /** The list of content blocks for the table. */
    public var blocks: [DocumentTableContentBlock]?

    public init(properties: DocumentBodyTableCellBlockProperties?, blocks: [DocumentTableContentBlock]?) {
        self.properties = properties
        self.blocks = blocks
    }


}




public class DocumentBodyTableRowBlockWithHighlight: Codable {





    /** The properties for the table rows. */
    public var properties: DocumentBodyTableRowBlockProperties?
    /** The list of cells for the table. */
    public var cells: [DocumentBodyTableCellBlockWithHighlight]?

    public init(properties: DocumentBodyTableRowBlockProperties?, cells: [DocumentBodyTableCellBlockWithHighlight]?) {
        self.properties = properties
        self.cells = cells
    }


}




public class DocumentBodyVideo: Codable {





    /** The URL for the video. */
    public var url: String?
    /** The properties for the video. */
    public var properties: DocumentBodyVideoProperties?

    public init(url: String?, properties: DocumentBodyVideoProperties?) {
        self.url = url
        self.properties = properties
    }


}




public class DocumentChunkBlock: Codable {









    /** The globally unique identifier for the chunk. */
    public var _id: String?
    /** The chunk text associated with the variation. */
    public var text: String?
    /** The confidence associated with a chunk with respect to a search query. */
    public var confidence: Float?
    /** Reference to document associated with a chunk */
    public var document: DocumentChunkReference?

    public init(_id: String?, text: String?, confidence: Float?, document: DocumentChunkReference?) {
        self._id = _id
        self.text = text
        self.confidence = confidence
        self.document = document
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case text
        case confidence
        case document
    }


}




public class DocumentChunkReference: Codable {







    /** The globally unique identifier for the document. */
    public var _id: String?
    /** The title of the document. */
    public var title: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, title: String?, selfUri: String?) {
        self._id = _id
        self.title = title
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case title
        case selfUri
    }


}




public class DocumentListContentBlockWithHighlight: Codable {

    public enum ModelType: String, Codable { 
        case text = "Text"
        case image = "Image"
        case orderedList = "OrderedList"
        case unorderedList = "UnorderedList"
        case video = "Video"
    }











    /** The type of the list block. */
    public var type: ModelType?
    /** Text. It must contain a value if the type of the block is Text. */
    public var text: DocumentText?
    /** Image. It must contain a value if the type of the block is Image. */
    public var image: DocumentBodyImage?
    /** Video. It must contain a value if the type of the block is Video. */
    public var video: DocumentBodyVideo?
    /** List. It must contain a value if the type of the block is UnorderedList or OrderedList. */
    public var list: DocumentBodyListWithHighlight?
    /** The block highlight data. */
    public var answerHighlight: DocumentContentHighlightIndex?

    public init(type: ModelType?, text: DocumentText?, image: DocumentBodyImage?, video: DocumentBodyVideo?, list: DocumentBodyListWithHighlight?, answerHighlight: DocumentContentHighlightIndex?) {
        self.type = type
        self.text = text
        self.image = image
        self.video = video
        self.list = list
        self.answerHighlight = answerHighlight
    }


}




public class DocumentQueryInterval: Codable {

    public enum Field: String, Codable { 
        case datecreated = "dateCreated"
        case datemodified = "dateModified"
        case datepublished = "datePublished"
    }



    /** Specifies the date field to be used for date and time range. */
    public var field: Field?
    /** Specifies the date and time range for filtering the documents. Intervals are represented as an ISO-8601 string. For example: YYYY-MM-DDThh:mm:ss/YYYY-MM-DDThh:mm:ss */
    public var value: String?

    public init(field: Field?, value: String?) {
        self.field = field
        self.value = value
    }


}




public class DocumentReference: Codable {





    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, selfUri: String?) {
        self._id = _id
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
    }


}




public class DocumentText: Codable {




    public enum Marks: String, Codable { 
        case bold = "Bold"
        case italic = "Italic"
        case underline = "Underline"
        case strikethrough = "Strikethrough"
        case _subscript = "Subscript"
        case superscript = "Superscript"
    }




    /** Text. */
    public var text: String?
    /** The unique list of marks (whether it is bold and/or underlined etc.) for the text. */
    public var marks: [Marks]?
    /** The URL of the page OR an email OR the reference to the knowledge article that the hyperlink goes to. Possible URL value types are https://<url link> | mailto:<email> | grn:knowledge:::documentVariation/<knowledgeBaseId>/<documentId>/<variationId> | grn:knowledge:::document/<knowledgeBaseId>/<documentId> | grn:knowledge:::category/<knowledgeBaseId>/<categoryId> | grn:knowledge:::label/<knowledgeBaseId>/<labelId> */
    public var hyperlink: String?
    /** The properties for the text. */
    public var properties: DocumentTextProperties?

    public init(text: String?, marks: [Marks]?, hyperlink: String?, properties: DocumentTextProperties?) {
        self.text = text
        self.marks = marks
        self.hyperlink = hyperlink
        self.properties = properties
    }


}




public class DocumentUpdate: Codable {



















    public var changeNumber: Int?
    /** The name of the document */
    public var name: String?
    public var read: Bool?
    public var addTags: [String]?
    public var removeTags: [String]?
    public var addTagIds: [String]?
    public var removeTagIds: [String]?
    public var updateAttributes: [DocumentAttribute]?
    public var removeAttributes: [String]?

    public init(changeNumber: Int?, name: String?, read: Bool?, addTags: [String]?, removeTags: [String]?, addTagIds: [String]?, removeTagIds: [String]?, updateAttributes: [DocumentAttribute]?, removeAttributes: [String]?) {
        self.changeNumber = changeNumber
        self.name = name
        self.read = read
        self.addTags = addTags
        self.removeTags = removeTags
        self.addTagIds = addTagIds
        self.removeTagIds = removeTagIds
        self.updateAttributes = updateAttributes
        self.removeAttributes = removeAttributes
    }


}




public class DocumentVariationQueryChunkBlock: Codable {





    /** The globally unique identifier for the chunk. */
    public var _id: String?
    /** The chunk text associated with the variation. */
    public var text: String?

    public init(_id: String?, text: String?) {
        self._id = _id
        self.text = text
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case text
    }


}




public class DocumentVariationRequest: Codable {





















    /** The globally unique identifier for the variation. */
    public var _id: String?
    /** The creation date-time for the document variation. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** The last modification date-time for the document variation. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** The version of the document. */
    public var documentVersion: AddressableEntityRef?
    /** The context values associated with the variation. */
    public var contexts: [DocumentVariationContext]?
    /** The reference to document to which the variation is associated. */
    public var document: KnowledgeDocumentReference?
    /** The priority of the variation. */
    public var priority: Int?
    /** The name of the variation. */
    public var name: String?
    /** The content for the variation. */
    public var body: DocumentBodyRequest?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, dateCreated: Date?, dateModified: Date?, documentVersion: AddressableEntityRef?, contexts: [DocumentVariationContext]?, document: KnowledgeDocumentReference?, priority: Int?, name: String?, body: DocumentBodyRequest?, selfUri: String?) {
        self._id = _id
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.documentVersion = documentVersion
        self.contexts = contexts
        self.document = document
        self.priority = priority
        self.name = name
        self.body = body
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case dateCreated
        case dateModified
        case documentVersion
        case contexts
        case document
        case priority
        case name
        case body
        case selfUri
    }


}




public class DocumentationSearchCriteria: Codable {









    public enum Operator: String, Codable { 
        case and = "AND"
        case or = "OR"
        case not = "NOT"
    }





    public enum ModelType: String, Codable { 
        case exact = "EXACT"
        case startsWith = "STARTS_WITH"
        case contains = "CONTAINS"
        case term = "TERM"
        case terms = "TERMS"
        case matchAll = "MATCH_ALL"
        case simple = "SIMPLE"
        case queryString = "QUERY_STRING"
        case multiMatch = "MULTI_MATCH"
    }



    /** The end value of the range. This field is used for range search types. */
    public var endValue: String?
    /** A list of values for the search to match against */
    public var values: [String]?
    /** The start value of the range. This field is used for range search types. */
    public var startValue: String?
    /** A value for the search to match against */
    public var value: String?
    /** How to apply this search criteria against other criteria */
    public var _operator: Operator?
    /** Groups multiple conditions */
    public var group: [DocumentationSearchCriteria]?
    /** Set date format for criteria values when using date range search type.  Supports Java date format syntax, example yyyy-MM-dd'T'HH:mm:ss.SSSX. */
    public var dateFormat: String?
    /** Search Type */
    public var type: ModelType?
    /** Field names to search against */
    public var fields: [String]?

    public init(endValue: String?, values: [String]?, startValue: String?, value: String?, _operator: Operator?, group: [DocumentationSearchCriteria]?, dateFormat: String?, type: ModelType?, fields: [String]?) {
        self.endValue = endValue
        self.values = values
        self.startValue = startValue
        self.value = value
        self._operator = _operator
        self.group = group
        self.dateFormat = dateFormat
        self.type = type
        self.fields = fields
    }

    public enum CodingKeys: String, CodingKey { 
        case endValue
        case values
        case startValue
        case value
        case _operator = "operator"
        case group
        case dateFormat
        case type
        case fields
    }


}



/** A certificate authority represents an organization that has issued a digital certificate for making secure connections with an edge device. */

public class DomainCertificateAuthority: Codable {



















    public enum State: String, Codable { 
        case active = "active"
        case inactive = "inactive"
        case deleted = "deleted"
    }







    public enum ModelType: String, Codable { 
        case managed = "MANAGED"
        case remote = "REMOTE"
    }

    public enum Services: String, Codable { 
        case sip = "SIP"
        case provision = "PROVISION"
        case provisionPhone = "PROVISION_PHONE"
    }





    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The name of the entity. */
    public var name: String?
    /** The division to which this entity belongs. */
    public var division: Division?
    /** The resource's description. */
    public var _description: String?
    /** The current version of the resource. */
    public var version: Int?
    /** The date the resource was created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** The date of the last modification to the resource. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** The ID of the user that last modified the resource. */
    public var modifiedBy: String?
    /** The ID of the user that created the resource. */
    public var createdBy: String?
    /** Indicates if the resource is active, inactive, or deleted. */
    public var state: State?
    /** The application that last modified the resource. */
    public var modifiedByApp: String?
    /** The application that created the resource. */
    public var createdByApp: String?
    /** The authorities signed X509 PEM encoded certificate. */
    public var certificate: String?
    /** The certificate authorities type.  Managed certificate authorities are generated and maintained by Interactive Intelligence.  These are read-only and not modifiable by clients.  Remote authorities are customer managed. */
    public var type: ModelType?
    /** The service(s) that the authority can be used to authenticate. */
    public var services: [Services]?
    /** The details of the parsed certificate(s). */
    public var certificateDetails: [CertificateDetails]?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, division: Division?, _description: String?, version: Int?, dateCreated: Date?, dateModified: Date?, modifiedBy: String?, createdBy: String?, state: State?, modifiedByApp: String?, createdByApp: String?, certificate: String?, type: ModelType?, services: [Services]?, certificateDetails: [CertificateDetails]?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.division = division
        self._description = _description
        self.version = version
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.modifiedBy = modifiedBy
        self.createdBy = createdBy
        self.state = state
        self.modifiedByApp = modifiedByApp
        self.createdByApp = createdByApp
        self.certificate = certificate
        self.type = type
        self.services = services
        self.certificateDetails = certificateDetails
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case division
        case _description = "description"
        case version
        case dateCreated
        case dateModified
        case modifiedBy
        case createdBy
        case state
        case modifiedByApp
        case createdByApp
        case certificate
        case type
        case services
        case certificateDetails
        case selfUri
    }


}




public class DomainEdgeSoftwareUpdateDto: Codable {













    public enum Status: String, Codable { 
        case _none = "NONE"
        case _init = "INIT"
        case inProgress = "IN_PROGRESS"
        case expired = "EXPIRED"
        case exception = "EXCEPTION"
        case aborted = "ABORTED"
        case failed = "FAILED"
        case succeeded = "SUCCEEDED"
        case delete = "DELETE"
    }







    /** Version */
    public var version: DomainEdgeSoftwareVersionDto?
    public var maxDownloadRate: Int?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var downloadStartTime: Date?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var executeStartTime: Date?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var executeStopTime: Date?
    public var executeOnIdle: Bool?
    public var status: Status?
    public var edgeUri: String?
    public var callDrainingWaitTimeSeconds: Int64?
    public var current: Bool?

    public init(version: DomainEdgeSoftwareVersionDto?, maxDownloadRate: Int?, downloadStartTime: Date?, executeStartTime: Date?, executeStopTime: Date?, executeOnIdle: Bool?, status: Status?, edgeUri: String?, callDrainingWaitTimeSeconds: Int64?, current: Bool?) {
        self.version = version
        self.maxDownloadRate = maxDownloadRate
        self.downloadStartTime = downloadStartTime
        self.executeStartTime = executeStartTime
        self.executeStopTime = executeStopTime
        self.executeOnIdle = executeOnIdle
        self.status = status
        self.edgeUri = edgeUri
        self.callDrainingWaitTimeSeconds = callDrainingWaitTimeSeconds
        self.current = current
    }


}




public class DomainEntity: Codable {







    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case selfUri
    }


}




public class DomainEntityListing: Codable {





















    public var entities: [DomainEntity]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var previousUri: String?
    public var nextUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [DomainEntity]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, previousUri: String?, nextUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.previousUri = previousUri
        self.nextUri = nextUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class DomainEntityRef: Codable {







    public var _id: String?
    public var name: String?
    public var selfUri: String?

    public init(_id: String?, name: String?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case selfUri
    }


}




public class DomainLogicalInterface: Codable {



















    public enum State: String, Codable { 
        case active = "active"
        case inactive = "inactive"
        case deleted = "deleted"
    }



















    public enum InterfaceType: String, Codable { 
        case diagnostic = "DIAGNOSTIC"
        case system = "SYSTEM"
    }













    public enum CurrentState: String, Codable { 
        case _init = "INIT"
        case creating = "CREATING"
        case updating = "UPDATING"
        case ok = "OK"
        case exception = "EXCEPTION"
        case deleting = "DELETING"
    }































    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The name of the entity. */
    public var name: String?
    /** The division to which this entity belongs. */
    public var division: Division?
    /** The resource's description. */
    public var _description: String?
    /** The current version of the resource. */
    public var version: Int?
    /** The date the resource was created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** The date of the last modification to the resource. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** The ID of the user that last modified the resource. */
    public var modifiedBy: String?
    /** The ID of the user that created the resource. */
    public var createdBy: String?
    /** Indicates if the resource is active, inactive, or deleted. */
    public var state: State?
    /** The application that last modified the resource. */
    public var modifiedByApp: String?
    /** The application that created the resource. */
    public var createdByApp: String?
    public var edgeUri: String?
    public var edgeAssignedId: String?
    /** Friendly Name */
    public var friendlyName: String?
    public var vlanTagId: Int?
    /** Hardware Address */
    public var hardwareAddress: String?
    /** Physical Adapter Id */
    public var physicalAdapterId: String?
    public var ifStatus: String?
    /** The type of this network interface. */
    public var interfaceType: InterfaceType?
    /** IPv4 NENT IP Address */
    public var publicNatAddressIpV4: String?
    /** IPv6 NENT IP Address */
    public var publicNatAddressIpV6: String?
    /** The list of routes assigned to this interface. */
    public var routes: [DomainNetworkRoute]?
    /** The list of IP addresses on this interface.  Priority of dns addresses are based on order in the list. */
    public var addresses: [DomainNetworkAddress]?
    /** IPv4 interface settings. */
    public var ipv4Capabilities: DomainCapabilities?
    /** IPv6 interface settings. */
    public var ipv6Capabilities: DomainCapabilities?
    public var currentState: CurrentState?
    public var lastModifiedUserId: String?
    public var lastModifiedCorrelationId: String?
    public var commandResponses: [DomainNetworkCommandResponse]?
    /** The IPv4 phone trunk base assignment will be inherited from the Edge Group. */
    public var inheritPhoneTrunkBasesIPv4: Bool?
    /** The IPv6 phone trunk base assignment will be inherited from the Edge Group. */
    public var inheritPhoneTrunkBasesIPv6: Bool?
    /** This interface will be used for all internal edge-to-edge communication using settings from the edgeTrunkBaseAssignment on the Edge Group. */
    public var useForInternalEdgeCommunication: Bool?
    /** Site Interconnects using the \"Indirect\" method will communicate using the Public IP Address specified on the interface. Use this option when a NAT enabled firewall is between the Edge and the far end. */
    public var useForIndirectEdgeCommunication: Bool?
    /** Site Interconnects using the \"Cloud Proxy\" method will broker the connection between them with a Cloud Proxy. This method is required for connections between one or more Sites using Cloud Media, but can optionally be used between two premises Sites if Direct or Indirect are not an option. */
    public var useForCloudProxyEdgeCommunication: Bool?
    /** This interface will be used for all communication with the internet. */
    public var useForWanInterface: Bool?
    /** External trunk base settings to use for external communication from this interface. */
    public var externalTrunkBaseAssignments: [TrunkBaseAssignment]?
    /** Phone trunk base settings to use for phone communication from this interface.  These settings will be ignored when \"inheritPhoneTrunkBases\" is true. */
    public var phoneTrunkBaseAssignments: [TrunkBaseAssignment]?
    public var traceEnabled: Bool?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var startDate: Date?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var endDate: Date?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, division: Division?, _description: String?, version: Int?, dateCreated: Date?, dateModified: Date?, modifiedBy: String?, createdBy: String?, state: State?, modifiedByApp: String?, createdByApp: String?, edgeUri: String?, edgeAssignedId: String?, friendlyName: String?, vlanTagId: Int?, hardwareAddress: String?, physicalAdapterId: String?, ifStatus: String?, interfaceType: InterfaceType?, publicNatAddressIpV4: String?, publicNatAddressIpV6: String?, routes: [DomainNetworkRoute]?, addresses: [DomainNetworkAddress]?, ipv4Capabilities: DomainCapabilities?, ipv6Capabilities: DomainCapabilities?, currentState: CurrentState?, lastModifiedUserId: String?, lastModifiedCorrelationId: String?, commandResponses: [DomainNetworkCommandResponse]?, inheritPhoneTrunkBasesIPv4: Bool?, inheritPhoneTrunkBasesIPv6: Bool?, useForInternalEdgeCommunication: Bool?, useForIndirectEdgeCommunication: Bool?, useForCloudProxyEdgeCommunication: Bool?, useForWanInterface: Bool?, externalTrunkBaseAssignments: [TrunkBaseAssignment]?, phoneTrunkBaseAssignments: [TrunkBaseAssignment]?, traceEnabled: Bool?, startDate: Date?, endDate: Date?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.division = division
        self._description = _description
        self.version = version
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.modifiedBy = modifiedBy
        self.createdBy = createdBy
        self.state = state
        self.modifiedByApp = modifiedByApp
        self.createdByApp = createdByApp
        self.edgeUri = edgeUri
        self.edgeAssignedId = edgeAssignedId
        self.friendlyName = friendlyName
        self.vlanTagId = vlanTagId
        self.hardwareAddress = hardwareAddress
        self.physicalAdapterId = physicalAdapterId
        self.ifStatus = ifStatus
        self.interfaceType = interfaceType
        self.publicNatAddressIpV4 = publicNatAddressIpV4
        self.publicNatAddressIpV6 = publicNatAddressIpV6
        self.routes = routes
        self.addresses = addresses
        self.ipv4Capabilities = ipv4Capabilities
        self.ipv6Capabilities = ipv6Capabilities
        self.currentState = currentState
        self.lastModifiedUserId = lastModifiedUserId
        self.lastModifiedCorrelationId = lastModifiedCorrelationId
        self.commandResponses = commandResponses
        self.inheritPhoneTrunkBasesIPv4 = inheritPhoneTrunkBasesIPv4
        self.inheritPhoneTrunkBasesIPv6 = inheritPhoneTrunkBasesIPv6
        self.useForInternalEdgeCommunication = useForInternalEdgeCommunication
        self.useForIndirectEdgeCommunication = useForIndirectEdgeCommunication
        self.useForCloudProxyEdgeCommunication = useForCloudProxyEdgeCommunication
        self.useForWanInterface = useForWanInterface
        self.externalTrunkBaseAssignments = externalTrunkBaseAssignments
        self.phoneTrunkBaseAssignments = phoneTrunkBaseAssignments
        self.traceEnabled = traceEnabled
        self.startDate = startDate
        self.endDate = endDate
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case division
        case _description = "description"
        case version
        case dateCreated
        case dateModified
        case modifiedBy
        case createdBy
        case state
        case modifiedByApp
        case createdByApp
        case edgeUri
        case edgeAssignedId
        case friendlyName
        case vlanTagId
        case hardwareAddress
        case physicalAdapterId
        case ifStatus
        case interfaceType
        case publicNatAddressIpV4
        case publicNatAddressIpV6
        case routes
        case addresses
        case ipv4Capabilities
        case ipv6Capabilities
        case currentState
        case lastModifiedUserId
        case lastModifiedCorrelationId
        case commandResponses
        case inheritPhoneTrunkBasesIPv4
        case inheritPhoneTrunkBasesIPv6
        case useForInternalEdgeCommunication
        case useForIndirectEdgeCommunication
        case useForCloudProxyEdgeCommunication
        case useForWanInterface
        case externalTrunkBaseAssignments
        case phoneTrunkBaseAssignments
        case traceEnabled
        case startDate
        case endDate
        case selfUri
    }


}




public class DomainOrganizationRoleCreate: Codable {































    /** role id */
    public var _id: String?
    /** The role name */
    public var name: String?
    public var _description: String?
    public var defaultRoleId: String?
    public var permissions: [String]?
    /** A collection of the permissions the role is not using */
    public var unusedPermissions: [String]?
    public var permissionPolicies: [DomainPermissionPolicy]?
    public var userCount: Int?
    /** Optional unless patch operation. */
    public var roleNeedsUpdate: Bool?
    public var baseLicense: String?
    public var addonLicenses: [String]?
    /** The time that this role licenses were most recently updated. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateLicenseLastUpdated: Date?
    public var base: Bool?
    public var _default: Bool?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, _description: String?, defaultRoleId: String?, permissions: [String]?, unusedPermissions: [String]?, permissionPolicies: [DomainPermissionPolicy]?, userCount: Int?, roleNeedsUpdate: Bool?, baseLicense: String?, addonLicenses: [String]?, dateLicenseLastUpdated: Date?, base: Bool?, _default: Bool?, selfUri: String?) {
        self._id = _id
        self.name = name
        self._description = _description
        self.defaultRoleId = defaultRoleId
        self.permissions = permissions
        self.unusedPermissions = unusedPermissions
        self.permissionPolicies = permissionPolicies
        self.userCount = userCount
        self.roleNeedsUpdate = roleNeedsUpdate
        self.baseLicense = baseLicense
        self.addonLicenses = addonLicenses
        self.dateLicenseLastUpdated = dateLicenseLastUpdated
        self.base = base
        self._default = _default
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case _description = "description"
        case defaultRoleId
        case permissions
        case unusedPermissions
        case permissionPolicies
        case userCount
        case roleNeedsUpdate
        case baseLicense
        case addonLicenses
        case dateLicenseLastUpdated
        case base
        case _default = "default"
        case selfUri
    }


}




public class DomainOrganizationRoleUpdate: Codable {































    /** role id */
    public var _id: String?
    /** The name of the role */
    public var name: String?
    public var _description: String?
    public var defaultRoleId: String?
    public var permissions: [String]?
    /** A collection of the permissions the role is not using */
    public var unusedPermissions: [String]?
    public var permissionPolicies: [DomainPermissionPolicy]?
    public var userCount: Int?
    /** Optional unless patch operation. */
    public var roleNeedsUpdate: Bool?
    public var baseLicense: String?
    public var addonLicenses: [String]?
    /** The time that this role licenses were most recently updated. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateLicenseLastUpdated: Date?
    public var base: Bool?
    public var _default: Bool?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, _description: String?, defaultRoleId: String?, permissions: [String]?, unusedPermissions: [String]?, permissionPolicies: [DomainPermissionPolicy]?, userCount: Int?, roleNeedsUpdate: Bool?, baseLicense: String?, addonLicenses: [String]?, dateLicenseLastUpdated: Date?, base: Bool?, _default: Bool?, selfUri: String?) {
        self._id = _id
        self.name = name
        self._description = _description
        self.defaultRoleId = defaultRoleId
        self.permissions = permissions
        self.unusedPermissions = unusedPermissions
        self.permissionPolicies = permissionPolicies
        self.userCount = userCount
        self.roleNeedsUpdate = roleNeedsUpdate
        self.baseLicense = baseLicense
        self.addonLicenses = addonLicenses
        self.dateLicenseLastUpdated = dateLicenseLastUpdated
        self.base = base
        self._default = _default
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case _description = "description"
        case defaultRoleId
        case permissions
        case unusedPermissions
        case permissionPolicies
        case userCount
        case roleNeedsUpdate
        case baseLicense
        case addonLicenses
        case dateLicenseLastUpdated
        case base
        case _default = "default"
        case selfUri
    }


}




public class DomainPhysicalInterface: Codable {



















    public enum State: String, Codable { 
        case active = "active"
        case inactive = "inactive"
        case deleted = "deleted"
    }

















    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The name of the entity. */
    public var name: String?
    /** The division to which this entity belongs. */
    public var division: Division?
    /** The resource's description. */
    public var _description: String?
    /** The current version of the resource. */
    public var version: Int?
    /** The date the resource was created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** The date of the last modification to the resource. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** The ID of the user that last modified the resource. */
    public var modifiedBy: String?
    /** The ID of the user that created the resource. */
    public var createdBy: String?
    /** Indicates if the resource is active, inactive, or deleted. */
    public var state: State?
    /** The application that last modified the resource. */
    public var modifiedByApp: String?
    /** The application that created the resource. */
    public var createdByApp: String?
    public var edgeUri: String?
    public var friendlyName: String?
    public var hardwareAddress: String?
    public var portLabel: String?
    public var physicalCapabilities: DomainPhysicalCapabilities?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, division: Division?, _description: String?, version: Int?, dateCreated: Date?, dateModified: Date?, modifiedBy: String?, createdBy: String?, state: State?, modifiedByApp: String?, createdByApp: String?, edgeUri: String?, friendlyName: String?, hardwareAddress: String?, portLabel: String?, physicalCapabilities: DomainPhysicalCapabilities?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.division = division
        self._description = _description
        self.version = version
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.modifiedBy = modifiedBy
        self.createdBy = createdBy
        self.state = state
        self.modifiedByApp = modifiedByApp
        self.createdByApp = createdByApp
        self.edgeUri = edgeUri
        self.friendlyName = friendlyName
        self.hardwareAddress = hardwareAddress
        self.portLabel = portLabel
        self.physicalCapabilities = physicalCapabilities
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case division
        case _description = "description"
        case version
        case dateCreated
        case dateModified
        case modifiedBy
        case createdBy
        case state
        case modifiedByApp
        case createdByApp
        case edgeUri
        case friendlyName
        case hardwareAddress
        case portLabel
        case physicalCapabilities
        case selfUri
    }


}




public class DomainRole: Codable {





    /** The ID of the role */
    public var _id: String?
    /** The name of the role */
    public var name: String?

    public init(_id: String?, name: String?) {
        self._id = _id
        self.name = name
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
    }


}




public class Draft: Codable {

















    /** The globally unique identifier for the object. */
    public var _id: String?
    /** Draft name */
    public var name: String?
    /** Miner to which the draft belongs. */
    public var miner: Miner?
    /** Draft intent object. */
    public var intents: [DraftIntents]?
    /** Draft topic object. */
    public var topics: [DraftTopics]?
    /** Date when the draft was created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** Date when the draft was updated. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, miner: Miner?, intents: [DraftIntents]?, topics: [DraftTopics]?, dateCreated: Date?, dateModified: Date?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.miner = miner
        self.intents = intents
        self.topics = topics
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case miner
        case intents
        case topics
        case dateCreated
        case dateModified
        case selfUri
    }


}




public class DraftListing: Codable {









    public var entities: [Draft]?
    public var nextUri: String?
    public var selfUri: String?
    public var previousUri: String?

    public init(entities: [Draft]?, nextUri: String?, selfUri: String?, previousUri: String?) {
        self.entities = entities
        self.nextUri = nextUri
        self.selfUri = selfUri
        self.previousUri = previousUri
    }


}




public class DraftManipulationRequest: Codable {



    public enum DraftType: String, Codable { 
        case reply = "Reply"
        case replyAll = "ReplyAll"
        case forward = "Forward"
    }

    /** A set of definitions to translate email attributes and correctly display date and time, for a given language */
    public var translate: HistoryHeadersTranslation?
    /** The kind of draft that as to be treated. Used to prefix response subject or auto-include information */
    public var draftType: DraftType?

    public init(translate: HistoryHeadersTranslation?, draftType: DraftType?) {
        self.translate = translate
        self.draftType = draftType
    }


}




public class DraftRequest: Codable {





    /** Draft intent object. */
    public var intents: [DraftIntents]?
    /** Draft topic object. */
    public var topics: [DraftTopicRequest]?

    public init(intents: [DraftIntents]?, topics: [DraftTopicRequest]?) {
        self.intents = intents
        self.topics = topics
    }


}




public class EdgeLogicalInterfacesChangeTopicDomainLogicalInterfaceChange: Codable {





    public var _id: String?
    public var errorInfo: EdgeLogicalInterfacesChangeTopicErrorInfo?

    public init(_id: String?, errorInfo: EdgeLogicalInterfacesChangeTopicErrorInfo?) {
        self._id = _id
        self.errorInfo = errorInfo
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case errorInfo
    }


}




public class EdgeMetricsTopicEdgeMetricNetworks: Codable {











    public var ifname: String?
    public var sentBytesPerSec: Int64?
    public var receivedBytesPerSec: Int64?
    public var bandwidthBitsPerSec: Int64?
    public var utilizationPct: Double?

    public init(ifname: String?, sentBytesPerSec: Int64?, receivedBytesPerSec: Int64?, bandwidthBitsPerSec: Int64?, utilizationPct: Double?) {
        self.ifname = ifname
        self.sentBytesPerSec = sentBytesPerSec
        self.receivedBytesPerSec = receivedBytesPerSec
        self.bandwidthBitsPerSec = bandwidthBitsPerSec
        self.utilizationPct = utilizationPct
    }


}




public class EdgeServiceStateRequest: Codable {





    /** A boolean that sets the Edge in-service or out-of-service. */
    public var inService: Bool?
    /** The number of seconds to wait for call draining to complete before initiating the reboot. A value of 0 will prevent call draining and all calls will disconnect immediately. */
    public var callDrainingWaitTimeSeconds: Int?

    public init(inService: Bool?, callDrainingWaitTimeSeconds: Int?) {
        self.inService = inService
        self.callDrainingWaitTimeSeconds = callDrainingWaitTimeSeconds
    }


}




public class EmailCommunicationSentMessageEvent: Codable {









    /** A unique (V4 UUID) eventId for this event */
    public var eventId: String?
    /** A Date Time representing the time this event occurred. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var eventDateTime: Date?
    /** A unique Id (V4 UUID) identifying this conversation */
    public var conversationId: String?
    /** A unique Id (V4 UUID) identifying this communication. */
    public var communicationId: String?

    public init(eventId: String?, eventDateTime: Date?, conversationId: String?, communicationId: String?) {
        self.eventId = eventId
        self.eventDateTime = eventDateTime
        self.conversationId = conversationId
        self.communicationId = communicationId
    }


}




public class EmailMediaPolicy: Codable {





    /** Actions applied when specified conditions are met */
    public var actions: PolicyActions?
    /** Conditions for when actions should be applied */
    public var conditions: EmailMediaPolicyConditions?

    public init(actions: PolicyActions?, conditions: EmailMediaPolicyConditions?) {
        self.actions = actions
        self.conditions = conditions
    }


}




public class EmailMediaPolicyConditions: Codable {















    public enum CustomerParticipation: String, Codable { 
        case yes = "YES"
        case no = "NO"
    }

    /** List of users to apply this policy to. Each user object can include the 'id' field containing the user's unique identifier. Example: [{\"id\":\"<userId>\"}]. */
    public var forUsers: [PolicyUser]?
    public var dateRanges: [String]?
    public var forQueues: [Queue]?
    public var wrapupCodes: [WrapupCode]?
    public var languages: [Language]?
    public var timeAllowed: TimeAllowed?
    /** Teams to match conversations against */
    public var teams: [Team]?
    public var customerParticipation: CustomerParticipation?

    public init(forUsers: [PolicyUser]?, dateRanges: [String]?, forQueues: [Queue]?, wrapupCodes: [WrapupCode]?, languages: [Language]?, timeAllowed: TimeAllowed?, teams: [Team]?, customerParticipation: CustomerParticipation?) {
        self.forUsers = forUsers
        self.dateRanges = dateRanges
        self.forQueues = forQueues
        self.wrapupCodes = wrapupCodes
        self.languages = languages
        self.timeAllowed = timeAllowed
        self.teams = teams
        self.customerParticipation = customerParticipation
    }


}




public class EmailMediaSettings: Codable {











    /** Indicates if auto-answer is enabled for the given media type or subtype (default is false).  Subtype settings take precedence over media type settings. */
    public var enableAutoAnswer: Bool?
    /** The alerting timeout for the media type, in seconds */
    public var alertingTimeoutSeconds: Int?
    /** The targeted service level for the media type */
    public var serviceLevel: ServiceLevel?
    /** How long to play the alerting tone for an auto-answer interaction */
    public var autoAnswerAlertToneSeconds: Double?
    /** How long to play the alerting tone for a manual-answer interaction */
    public var manualAnswerAlertToneSeconds: Double?

    public init(enableAutoAnswer: Bool?, alertingTimeoutSeconds: Int?, serviceLevel: ServiceLevel?, autoAnswerAlertToneSeconds: Double?, manualAnswerAlertToneSeconds: Double?) {
        self.enableAutoAnswer = enableAutoAnswer
        self.alertingTimeoutSeconds = alertingTimeoutSeconds
        self.serviceLevel = serviceLevel
        self.autoAnswerAlertToneSeconds = autoAnswerAlertToneSeconds
        self.manualAnswerAlertToneSeconds = manualAnswerAlertToneSeconds
    }


}




public class EmailMessage: Codable {



























    public enum State: String, Codable { 
        case created = "Created"
        case ready = "Ready"
        case edited = "Edited"
    }

    public enum DraftType: String, Codable { 
        case reply = "Reply"
        case replyAll = "ReplyAll"
        case forward = "Forward"
    }







    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** The recipients of the email message. */
    public var to: [EmailAddress]?
    /** The recipients that were copied on the email message. */
    public var cc: [EmailAddress]?
    /** The recipients that were blind copied on the email message. */
    public var bcc: [EmailAddress]?
    /** The sender of the email message. */
    public var from: EmailAddress?
    /** The receiver of the reply email message. */
    public var replyTo: EmailAddress?
    /** The subject of the email message. */
    public var subject: String?
    /** The attachments of the email message. */
    public var attachments: [Attachment]?
    /** The text body of the email message. */
    public var textBody: String?
    /** The html body of the email message. */
    public var htmlBody: String?
    /** The time when the message was received or sent. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var time: Date?
    /** Indicates whether the history of previous emails of the conversation is included within the email bodies of this message. */
    public var historyIncluded: Bool?
    /** The state of the current draft. */
    public var state: State?
    /** The type of draft that need to be treated. */
    public var draftType: DraftType?
    /** Indicates an estimation of the size of the current email as a whole, in its final, ready to be sent form. */
    public var emailSizeBytes: Int?
    /** Indicates the maximum allowed size for an email to be send via SMTP server, based on the email domain configuration */
    public var maxEmailSizeBytes: Int?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, to: [EmailAddress]?, cc: [EmailAddress]?, bcc: [EmailAddress]?, from: EmailAddress?, replyTo: EmailAddress?, subject: String?, attachments: [Attachment]?, textBody: String?, htmlBody: String?, time: Date?, historyIncluded: Bool?, state: State?, draftType: DraftType?, emailSizeBytes: Int?, maxEmailSizeBytes: Int?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.to = to
        self.cc = cc
        self.bcc = bcc
        self.from = from
        self.replyTo = replyTo
        self.subject = subject
        self.attachments = attachments
        self.textBody = textBody
        self.htmlBody = htmlBody
        self.time = time
        self.historyIncluded = historyIncluded
        self.state = state
        self.draftType = draftType
        self.emailSizeBytes = emailSizeBytes
        self.maxEmailSizeBytes = maxEmailSizeBytes
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case to
        case cc
        case bcc
        case from
        case replyTo
        case subject
        case attachments
        case textBody
        case htmlBody
        case time
        case historyIncluded
        case state
        case draftType
        case emailSizeBytes
        case maxEmailSizeBytes
        case selfUri
    }


}




public class EmailProgressTransferEvent: Codable {













    /** A unique (V4 UUID) eventId for this event */
    public var eventId: String?
    /** A Date Time representing the time this event occurred. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var eventDateTime: Date?
    /** A unique Id (V4 UUID) identifying this conversation */
    public var conversationId: String?
    /** The id (V4 UUID) used to identify the transfer already started by the external platform. */
    public var commandId: String?
    /** The id (V4 UUID) of the communication that is being transferred. */
    public var objectCommunicationId: String?
    /** The id (V4 UUID) of the communication that is being transferred to. */
    public var destinationCommunicationId: String?

    public init(eventId: String?, eventDateTime: Date?, conversationId: String?, commandId: String?, objectCommunicationId: String?, destinationCommunicationId: String?) {
        self.eventId = eventId
        self.eventDateTime = eventDateTime
        self.conversationId = conversationId
        self.commandId = commandId
        self.objectCommunicationId = objectCommunicationId
        self.destinationCommunicationId = destinationCommunicationId
    }


}



/** Email routing settings. */

public class EmailSetting: Codable {









    /** The globally unique identifier for the settings. */
    public var _id: String?
    /** The name of the email setting. */
    public var name: String?
    /** The domain list settings. */
    public var domains: Domains?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, domains: Domains?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.domains = domains
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case domains
        case selfUri
    }


}




public class EmailSettings: Codable {



    /** This setting allows a single inbound email that contains multiple routes configured in Genesys Cloud to create a conversation per route. When this setting is disabled only a single conversation will be created */
    public var multipleRouteDestinationsOnInboundEmailEnabled: Bool?

    public init(multipleRouteDestinationsOnInboundEmailEnabled: Bool?) {
        self.multipleRouteDestinationsOnInboundEmailEnabled = multipleRouteDestinationsOnInboundEmailEnabled
    }


}




public class EmailSetup: Codable {



    /** The root PureCloud domain that all sub-domains are created from. */
    public var rootDomain: String?

    public init(rootDomain: String?) {
        self.rootDomain = rootDomain
    }


}




public class EmailsSettings: Codable {



    public var sendingSizeLimit: Int?

    public init(sendingSizeLimit: Int?) {
        self.sendingSizeLimit = sendingSizeLimit
    }


}



/** A group of emergency call flows to use in an emergency. */

public class EmergencyGroup: Codable {



















    public enum State: String, Codable { 
        case active = "active"
        case inactive = "inactive"
        case deleted = "deleted"
    }











    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The name of the entity. */
    public var name: String?
    /** The division to which this entity belongs. */
    public var division: WritableDivision?
    /** The resource's description. */
    public var _description: String?
    /** The current version of the resource. */
    public var version: Int?
    /** The date the resource was created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** The date of the last modification to the resource. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** The ID of the user that last modified the resource. */
    public var modifiedBy: String?
    /** The ID of the user that created the resource. */
    public var createdBy: String?
    /** Indicates if the resource is active, inactive, or deleted. */
    public var state: State?
    /** The application that last modified the resource. */
    public var modifiedByApp: String?
    /** The application that created the resource. */
    public var createdByApp: String?
    /** True if an emergency is occurring and the associated emergency call flow(s) should be used.  False otherwise. */
    public var enabled: Bool?
    /** The emergency call flow(s) to use during an emergency. */
    public var emergencyCallFlows: [EmergencyCallFlow]?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, division: WritableDivision?, _description: String?, version: Int?, dateCreated: Date?, dateModified: Date?, modifiedBy: String?, createdBy: String?, state: State?, modifiedByApp: String?, createdByApp: String?, enabled: Bool?, emergencyCallFlows: [EmergencyCallFlow]?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.division = division
        self._description = _description
        self.version = version
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.modifiedBy = modifiedBy
        self.createdBy = createdBy
        self.state = state
        self.modifiedByApp = modifiedByApp
        self.createdByApp = createdByApp
        self.enabled = enabled
        self.emergencyCallFlows = emergencyCallFlows
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case division
        case _description = "description"
        case version
        case dateCreated
        case dateModified
        case modifiedBy
        case createdBy
        case state
        case modifiedByApp
        case createdByApp
        case enabled
        case emergencyCallFlows
        case selfUri
    }


}




public class EmergencyGroupDivisionViewEntityListing: Codable {























    public var entities: [EmergencyGroupDivisionView]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    /** The total organization-wide number of entities. */
    public var totalNumberOfEntities: Int64?
    public var firstUri: String?
    public var previousUri: String?
    public var nextUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [EmergencyGroupDivisionView]?, pageSize: Int?, pageNumber: Int?, total: Int64?, totalNumberOfEntities: Int64?, firstUri: String?, previousUri: String?, nextUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.totalNumberOfEntities = totalNumberOfEntities
        self.firstUri = firstUri
        self.previousUri = previousUri
        self.nextUri = nextUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class EmergencyGroupListing: Codable {





















    public var entities: [EmergencyGroup]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var previousUri: String?
    public var nextUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [EmergencyGroup]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, previousUri: String?, nextUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.previousUri = previousUri
        self.nextUri = nextUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class EmergencyLocation: Codable {









    public enum Source: String, Codable { 
        case admin = "Admin"
        case user = "User"
    }



    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** Emergency address */
    public var address: LocationAddress?
    /** Phone number in E164 format */
    public var did: String?
    /** source */
    public var source: Source?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, address: LocationAddress?, did: String?, source: Source?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.address = address
        self.did = did
        self.source = source
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case address
        case did
        case source
        case selfUri
    }


}




public class Entity: Codable {



    /** The globally unique identifier for the object. */
    public var _id: String?

    public init(_id: String?) {
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
    }


}




public class EntityListing: Codable {



    public var entities: [JSON]?

    public init(entities: [JSON]?) {
        self.entities = entities
    }


}




public class ErrorDetails: Codable {

















    public var status: Int?
    public var message: String?
    public var messageWithParams: String?
    public var messageParams: [String:String]?
    public var code: String?
    public var contextId: String?
    public var nested: ErrorDetails?
    public var details: String?

    public init(status: Int?, message: String?, messageWithParams: String?, messageParams: [String:String]?, code: String?, contextId: String?, nested: ErrorDetails?, details: String?) {
        self.status = status
        self.message = message
        self.messageWithParams = messageWithParams
        self.messageParams = messageParams
        self.code = code
        self.contextId = contextId
        self.nested = nested
        self.details = details
    }


}




public class EscalationRuleResponse: Codable {

















    public enum Status: String, Codable { 
        case active = "Active"
        case paused = "Paused"
    }











    /** ID of the escalation rule. */
    public var _id: String?
    /** The name of the escalation rule. */
    public var name: String?
    /** The criteria that defines when a social media message should be escalated. */
    public var matchCriteria: String?
    /** The priority of the escalation rule. */
    public var priority: Int?
    /** The ID of the division the social escalation rule belongs to. */
    public var divisionId: String?
    /** A description of the social escalation rule. */
    public var _description: String?
    /** Timestamp indicating when the escalation rule was created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** Timestamp indicating when the escalation rule was last updated. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** The status of the escalation rule. */
    public var status: Status?
    /** The target integration configuration used for an open message escalation. */
    public var openEscalation: EscalationTarget?
    /** The target integration configuration used for a Facebook message escalation. */
    public var facebookEscalation: EscalationTarget?
    /** The target integration configuration used for an Instagram message escalation. */
    public var instagramEscalation: EscalationTarget?
    /** The target integration configuration used for a X (formerly Twitter) message escalation. */
    public var twitterEscalation: EscalationTarget?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, matchCriteria: String?, priority: Int?, divisionId: String?, _description: String?, dateCreated: Date?, dateModified: Date?, status: Status?, openEscalation: EscalationTarget?, facebookEscalation: EscalationTarget?, instagramEscalation: EscalationTarget?, twitterEscalation: EscalationTarget?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.matchCriteria = matchCriteria
        self.priority = priority
        self.divisionId = divisionId
        self._description = _description
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.status = status
        self.openEscalation = openEscalation
        self.facebookEscalation = facebookEscalation
        self.instagramEscalation = instagramEscalation
        self.twitterEscalation = twitterEscalation
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case matchCriteria
        case priority
        case divisionId
        case _description = "description"
        case dateCreated
        case dateModified
        case status
        case openEscalation
        case facebookEscalation
        case instagramEscalation
        case twitterEscalation
        case selfUri
    }


}




public class EscalationTarget: Codable {

    public enum TargetType: String, Codable { 
        case conversation = "Conversation"
    }

    public enum Destination: String, Codable { 
        case sourceIntegration = "SourceIntegration"
        case overrideIntegration = "OverrideIntegration"
    }



    /** Defines the target that the message will be escalated to. */
    public var targetType: TargetType?
    /** Defines the destination of the escalation.SourceIntegration means use the SocialMedia Source Integration as the destination.OverrideIntegration means the set integration will be used regardless of the source. */
    public var destination: Destination?
    /** Set the integration ID.Only valid when type is OverrideIntegration. */
    public var _override: OverrideEscalationTarget?

    public init(targetType: TargetType?, destination: Destination?, _override: OverrideEscalationTarget?) {
        self.targetType = targetType
        self.destination = destination
        self._override = _override
    }

    public enum CodingKeys: String, CodingKey { 
        case targetType
        case destination
        case _override = "override"
    }


}




public class EstimateAvailablePartialDayTimeOffResponse: Codable {









    /** Start date-time in ISO-8601 format for partial day request */
    public var date: Date?
    /** An estimation of time off request length in minutes */
    public var durationMinutes: Int?
    /** An estimation of payable part of time off request in minutes */
    public var payableMinutes: Int?
    /** Whether there is flexibility for a user to choose different hours than the system estimated */
    public var flexible: Bool?

    public init(date: Date?, durationMinutes: Int?, payableMinutes: Int?, flexible: Bool?) {
        self.date = date
        self.durationMinutes = durationMinutes
        self.payableMinutes = payableMinutes
        self.flexible = flexible
    }


}




public class EstimateAvailableTimeOffRequest: Codable {









    /** Full day dates. partialDayDates must be empty if this field is populated */
    public var fullDayDates: [EstimateAvailableFullDayTimeOffRequest]?
    /** Partial day dates. fullDayDates must be empty if this field is populated */
    public var partialDayDates: [EstimateAvailablePartialDayTimeOffRequest]?
    /** The ID of the activity code associated with the time off request. Activity code must be of the TimeOff category */
    public var activityCodeId: String?
    /** Whether this estimate is for a paid time off request */
    public var paid: Bool?

    public init(fullDayDates: [EstimateAvailableFullDayTimeOffRequest]?, partialDayDates: [EstimateAvailablePartialDayTimeOffRequest]?, activityCodeId: String?, paid: Bool?) {
        self.fullDayDates = fullDayDates
        self.partialDayDates = partialDayDates
        self.activityCodeId = activityCodeId
        self.paid = paid
    }


}




public class EvaluationAggregateQueryResponse: Codable {



    public var results: [EvaluationAggregateDataContainer]?

    public init(results: [EvaluationAggregateDataContainer]?) {
        self.results = results
    }


}




public class EvaluationAggregationView: Codable {

    public enum Target: String, Codable { 
        case nevaluations = "nEvaluations"
        case nevaluationsdeleted = "nEvaluationsDeleted"
        case nevaluationsrescored = "nEvaluationsRescored"
        case ototalcriticalscore = "oTotalCriticalScore"
        case ototalscore = "oTotalScore"
    }



    public enum Function: String, Codable { 
        case rangebound = "rangeBound"
    }



    /** Target metric name */
    public var target: Target?
    /** A unique name for this view. Must be distinct from other views and built-in metric names. */
    public var name: String?
    /** Type of view you wish to create */
    public var function: Function?
    /** Range of numbers for slicing up data */
    public var range: AggregationRange?

    public init(target: Target?, name: String?, function: Function?, range: AggregationRange?) {
        self.target = target
        self.name = name
        self.function = function
        self.range = range
    }


}




public class EvaluationAssignment: Codable {





    public var evaluationForm: EvaluationForm?
    public var user: User?

    public init(evaluationForm: EvaluationForm?, user: User?) {
        self.evaluationForm = evaluationForm
        self.user = user
    }


}




public class EvaluationCreateBody: Codable {



















    public enum ResourceType: String, Codable { 
        case email = "EMAIL"
    }









    public enum Status: String, Codable { 
        case pending = "PENDING"
        case inprogress = "INPROGRESS"
        case finished = "FINISHED"
        case inreview = "INREVIEW"
        case retracted = "RETRACTED"
    }









    /** The globally unique identifier for the object. */
    public var _id: String?
    /** Evaluation form used for evaluation (must be included for a successful request) */
    public var evaluationForm: EvaluationCreateEvalForm?
    /** User ID of the evaluator (must be included for a successful request) */
    public var evaluator: EvaluationCreateUser?
    /** User ID of the agent (must be included for a successful request) */
    public var agent: EvaluationCreateUser?
    public var agentHasRead: Bool?
    public var answers: EvaluationScoringSet?
    public var calibration: EvaluationCreateCalibration?
    public var evaluationContextId: String?
    public var conversation: EvaluationCreateConversation?
    public var resourceType: ResourceType?
    public var evaluationSource: EvaluationSource?
    public var rescore: Bool?
    public var queue: EvaluationCreateQueue?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var releaseDate: Date?
    public var status: Status?
    public var neverRelease: Bool?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateAssigneeChanged: Date?
    public var assignee: EvaluationCreateUser?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, evaluationForm: EvaluationCreateEvalForm?, evaluator: EvaluationCreateUser?, agent: EvaluationCreateUser?, agentHasRead: Bool?, answers: EvaluationScoringSet?, calibration: EvaluationCreateCalibration?, evaluationContextId: String?, conversation: EvaluationCreateConversation?, resourceType: ResourceType?, evaluationSource: EvaluationSource?, rescore: Bool?, queue: EvaluationCreateQueue?, releaseDate: Date?, status: Status?, neverRelease: Bool?, dateAssigneeChanged: Date?, assignee: EvaluationCreateUser?, selfUri: String?) {
        self._id = _id
        self.evaluationForm = evaluationForm
        self.evaluator = evaluator
        self.agent = agent
        self.agentHasRead = agentHasRead
        self.answers = answers
        self.calibration = calibration
        self.evaluationContextId = evaluationContextId
        self.conversation = conversation
        self.resourceType = resourceType
        self.evaluationSource = evaluationSource
        self.rescore = rescore
        self.queue = queue
        self.releaseDate = releaseDate
        self.status = status
        self.neverRelease = neverRelease
        self.dateAssigneeChanged = dateAssigneeChanged
        self.assignee = assignee
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case evaluationForm
        case evaluator
        case agent
        case agentHasRead
        case answers
        case calibration
        case evaluationContextId
        case conversation
        case resourceType
        case evaluationSource
        case rescore
        case queue
        case releaseDate
        case status
        case neverRelease
        case dateAssigneeChanged
        case assignee
        case selfUri
    }


}




public class EvaluationCreateCalibration: Codable {





    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, selfUri: String?) {
        self._id = _id
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
    }


}




public class EvaluationDetailQueryClause: Codable {

    public enum ModelType: String, Codable { 
        case and = "and"
        case or = "or"
    }



    /** Boolean operation to apply to the provided predicates */
    public var type: ModelType?
    /** Like a three-word sentence: (attribute-name) (operator) (target-value). */
    public var predicates: [EvaluationDetailQueryPredicate]?

    public init(type: ModelType?, predicates: [EvaluationDetailQueryPredicate]?) {
        self.type = type
        self.predicates = predicates
    }


}




public class EvaluationForm: Codable {





















    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The evaluation form name */
    public var name: String?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var modifiedDate: Date?
    public var published: Bool?
    public var contextId: String?
    /** A list of question groups */
    public var questionGroups: [EvaluationQuestionGroup]?
    /** A list of the published versions of this form. Not populated by default, its availability depends on the endpoint. Use the 'expand=publishHistory' query parameter to retrieve this data where applicable (refer to the endpoint description to see if it is applicable). */
    public var publishedVersions: DomainEntityListingEvaluationForm?
    /** Settings for evaluations associated with this form */
    public var evaluationSettings: EvaluationSettings?
    /** AI scoring settings for the evaluation form. */
    public var aiScoring: AiScoringSettings?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, modifiedDate: Date?, published: Bool?, contextId: String?, questionGroups: [EvaluationQuestionGroup]?, publishedVersions: DomainEntityListingEvaluationForm?, evaluationSettings: EvaluationSettings?, aiScoring: AiScoringSettings?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.modifiedDate = modifiedDate
        self.published = published
        self.contextId = contextId
        self.questionGroups = questionGroups
        self.publishedVersions = publishedVersions
        self.evaluationSettings = evaluationSettings
        self.aiScoring = aiScoring
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case modifiedDate
        case published
        case contextId
        case questionGroups
        case publishedVersions
        case evaluationSettings
        case aiScoring
        case selfUri
    }


}




public class EvaluationFormAndScoringSet: Codable {





    public var evaluationForm: EvaluationForm?
    public var answers: EvaluationScoringSet?

    public init(evaluationForm: EvaluationForm?, answers: EvaluationScoringSet?) {
        self.evaluationForm = evaluationForm
        self.answers = answers
    }


}




public class EvaluationQuestionGroupScore: Codable {

































    public var questionGroupId: String?
    /** Score of all questions in the group */
    public var totalScore: Float?
    /** Maximum possible score of all questions in the group */
    public var maxTotalScore: Float?
    /** True when the evaluation is submitted with a question group that does not have any answers. Only allowed when naEnabled is true or if set by the system */
    public var markedNA: Bool?
    /** If markedNA is true, systemMarkedNA indicates whether it was marked by a user or by the system due to visibility conditions. Always false if markedNA is false. */
    public var systemMarkedNA: Bool?
    /** Score of only the critical questions in the group */
    public var totalCriticalScore: Float?
    /** Maximum possible score of only the critical questions in the group */
    public var maxTotalCriticalScore: Float?
    /** Score of only the non critical questions in the group */
    public var totalNonCriticalScore: Float?
    /** Maximum possible score of only the non critical questions in the group */
    public var maxTotalNonCriticalScore: Float?
    /** Unweighted score of all questions in the group */
    public var totalScoreUnweighted: Float?
    /** Maximum possible unweighted score of all questions in the group */
    public var maxTotalScoreUnweighted: Float?
    /** Unweighted score of only the critical questions in the group */
    public var totalCriticalScoreUnweighted: Float?
    /** Maximum possible unweighted score of only the critical questions in the group */
    public var maxTotalCriticalScoreUnweighted: Float?
    /** Unweighted score of only the non critical questions in the group */
    public var totalNonCriticalScoreUnweighted: Float?
    /** Maximum possible unweighted score of only the non critical questions in the group */
    public var maxTotalNonCriticalScoreUnweighted: Float?
    public var questionScores: [EvaluationQuestionScore]?

    public init(questionGroupId: String?, totalScore: Float?, maxTotalScore: Float?, markedNA: Bool?, systemMarkedNA: Bool?, totalCriticalScore: Float?, maxTotalCriticalScore: Float?, totalNonCriticalScore: Float?, maxTotalNonCriticalScore: Float?, totalScoreUnweighted: Float?, maxTotalScoreUnweighted: Float?, totalCriticalScoreUnweighted: Float?, maxTotalCriticalScoreUnweighted: Float?, totalNonCriticalScoreUnweighted: Float?, maxTotalNonCriticalScoreUnweighted: Float?, questionScores: [EvaluationQuestionScore]?) {
        self.questionGroupId = questionGroupId
        self.totalScore = totalScore
        self.maxTotalScore = maxTotalScore
        self.markedNA = markedNA
        self.systemMarkedNA = systemMarkedNA
        self.totalCriticalScore = totalCriticalScore
        self.maxTotalCriticalScore = maxTotalCriticalScore
        self.totalNonCriticalScore = totalNonCriticalScore
        self.maxTotalNonCriticalScore = maxTotalNonCriticalScore
        self.totalScoreUnweighted = totalScoreUnweighted
        self.maxTotalScoreUnweighted = maxTotalScoreUnweighted
        self.totalCriticalScoreUnweighted = totalCriticalScoreUnweighted
        self.maxTotalCriticalScoreUnweighted = maxTotalCriticalScoreUnweighted
        self.totalNonCriticalScoreUnweighted = totalNonCriticalScoreUnweighted
        self.maxTotalNonCriticalScoreUnweighted = maxTotalNonCriticalScoreUnweighted
        self.questionScores = questionScores
    }


}




public class EvaluationQuestionScore: Codable {





















    public var questionId: String?
    public var answerId: String?
    /** Unweighted score of the question */
    public var score: Int?
    /** True when the evaluation is submitted with a question that does not have an answer. Only allowed when naEnabled is true or if set by the system */
    public var markedNA: Bool?
    /** If markedNA is true, systemMarkedNA indicates whether it was marked by a user or by the system due to visibility conditions. Always false if markedNA is false. */
    public var systemMarkedNA: Bool?
    /** AnswerId found with evaluation assistance conditions */
    public var assistedAnswerId: String?
    /** Applicable only on fatal questions. Indicates that the answer selected was not the highest score available for the question */
    public var failedKillQuestion: Bool?
    /** Comments from the evaluator specific to this question */
    public var comments: String?
    /** Suggested AI answer */
    public var aiAnswer: AiAnswer?
    /** Only applicable to Multiple Select questions. Scores corresponding to the options of Multiple Select questions. */
    public var multipleSelectQuestionOptionScores: [EvaluationQuestionScore]?

    public init(questionId: String?, answerId: String?, score: Int?, markedNA: Bool?, systemMarkedNA: Bool?, assistedAnswerId: String?, failedKillQuestion: Bool?, comments: String?, aiAnswer: AiAnswer?, multipleSelectQuestionOptionScores: [EvaluationQuestionScore]?) {
        self.questionId = questionId
        self.answerId = answerId
        self.score = score
        self.markedNA = markedNA
        self.systemMarkedNA = systemMarkedNA
        self.assistedAnswerId = assistedAnswerId
        self.failedKillQuestion = failedKillQuestion
        self.comments = comments
        self.aiAnswer = aiAnswer
        self.multipleSelectQuestionOptionScores = multipleSelectQuestionOptionScores
    }


}




public class EvaluationSettings: Codable {









    /** Whether revisions are allowed for evaluations. When enabled, rescoring creates a new version of the evaluation and retracts the existing evaluation version. Does not apply for calibration evaluations. */
    public var revisionsEnabled: Bool?
    /** Whether disputes are allowed for evaluations. Does not apply for calibration evaluations. */
    public var disputesEnabled: Bool?
    /** The maximum number of disputes allowed for an evaluation. */
    public var disputesAllowedPerEvaluation: Int?
    /** A list of assignees responsible for handling each dispute. This list size needs to be equal to disputesAllowedPerEvaluation. */
    public var disputesAssignees: [EvaluationSettingsAssignee]?

    public init(revisionsEnabled: Bool?, disputesEnabled: Bool?, disputesAllowedPerEvaluation: Int?, disputesAssignees: [EvaluationSettingsAssignee]?) {
        self.revisionsEnabled = revisionsEnabled
        self.disputesEnabled = disputesEnabled
        self.disputesAllowedPerEvaluation = disputesAllowedPerEvaluation
        self.disputesAssignees = disputesAssignees
    }


}




public class EvaluationSettingsAssignee: Codable {



    public enum ModelType: String, Codable { 
        case original = "Original"
        case individual = "Individual"
        case _none = "None"
    }

    /** The user the dispute should be assigned to */
    public var user: UserReferenceWithName?
    /** The assignee type. Valid values: Original, Individual, None */
    public var type: ModelType?

    public init(user: UserReferenceWithName?, type: ModelType?) {
        self.user = user
        self.type = type
    }


}




public class EvaluatorActivity: Codable {























    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    public var evaluator: User?
    public var numEvaluationsAssigned: Int?
    public var numEvaluationsStarted: Int?
    public var numEvaluationsCompleted: Int?
    public var numCalibrationsAssigned: Int?
    public var numCalibrationsStarted: Int?
    public var numCalibrationsCompleted: Int?
    public var numEvaluationsWithoutViewPermission: Int?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, evaluator: User?, numEvaluationsAssigned: Int?, numEvaluationsStarted: Int?, numEvaluationsCompleted: Int?, numCalibrationsAssigned: Int?, numCalibrationsStarted: Int?, numCalibrationsCompleted: Int?, numEvaluationsWithoutViewPermission: Int?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.evaluator = evaluator
        self.numEvaluationsAssigned = numEvaluationsAssigned
        self.numEvaluationsStarted = numEvaluationsStarted
        self.numEvaluationsCompleted = numEvaluationsCompleted
        self.numCalibrationsAssigned = numCalibrationsAssigned
        self.numCalibrationsStarted = numCalibrationsStarted
        self.numCalibrationsCompleted = numCalibrationsCompleted
        self.numEvaluationsWithoutViewPermission = numEvaluationsWithoutViewPermission
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case evaluator
        case numEvaluationsAssigned
        case numEvaluationsStarted
        case numEvaluationsCompleted
        case numCalibrationsAssigned
        case numCalibrationsStarted
        case numCalibrationsCompleted
        case numEvaluationsWithoutViewPermission
        case selfUri
    }


}




public class EventDefinition: Codable {







    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The name of the object. */
    public var name: String?
    /** description */
    public var _description: String?

    public init(_id: String?, name: String?, _description: String?) {
        self._id = _id
        self.name = name
        self._description = _description
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case _description = "description"
    }


}




public class EventDefinitionListing: Codable {



    public var entities: [EventDefinition]?

    public init(entities: [EventDefinition]?) {
        self.entities = entities
    }


}




public class ExpandableWebDeploymentEntityListing: Codable {











    public var entities: [ExpandableWebDeployment]?
    public var nextUri: String?
    public var selfUri: String?
    public var previousUri: String?
    public var total: Int64?

    public init(entities: [ExpandableWebDeployment]?, nextUri: String?, selfUri: String?, previousUri: String?, total: Int64?) {
        self.entities = entities
        self.nextUri = nextUri
        self.selfUri = selfUri
        self.previousUri = previousUri
        self.total = total
    }


}




public class ExpansionCriterium: Codable {

    public enum ModelType: String, Codable { 
        case timeoutSeconds = "TIMEOUT_SECONDS"
    }



    public var type: ModelType?
    public var threshold: Double?

    public init(type: ModelType?, threshold: Double?) {
        self.type = type
        self.threshold = threshold
    }


}




public class ExportDetails: Codable {





    public enum ExportType: String, Codable { 
        case architect = "Architect"
        case yaml = "Yaml"
    }

    /** The flow to export. If you do not provide the flow ID, you must provide both the name and type. */
    public var flow: ArchitectFlowReference?
    /** Name to assign to the file after download. The extension will be automatically appended based on desired export type. Must contain only alphanumeric characters, underscores, or hyphens. */
    public var fileName: String?
    /** The export type for the flow. Default: 'Yaml'. */
    public var exportType: ExportType?

    public init(flow: ArchitectFlowReference?, fileName: String?, exportType: ExportType?) {
        self.flow = flow
        self.fileName = fileName
        self.exportType = exportType
    }


}




public class ExportListing: Codable {









    public var entities: [ContactsExport]?
    public var nextUri: String?
    public var selfUri: String?
    public var previousUri: String?

    public init(entities: [ContactsExport]?, nextUri: String?, selfUri: String?, previousUri: String?) {
        self.entities = entities
        self.nextUri = nextUri
        self.selfUri = selfUri
        self.previousUri = previousUri
    }


}




public class Extension: Codable {



















    public enum State: String, Codable { 
        case active = "active"
        case inactive = "inactive"
        case deleted = "deleted"
    }











    public enum OwnerType: String, Codable { 
        case user = "USER"
        case phone = "PHONE"
        case ivrConfig = "IVR_CONFIG"
        case group = "GROUP"
    }



    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The name of the entity. */
    public var name: String?
    /** The division to which this entity belongs. */
    public var division: Division?
    /** The resource's description. */
    public var _description: String?
    /** The current version of the resource. */
    public var version: Int?
    /** The date the resource was created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** The date of the last modification to the resource. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** The ID of the user that last modified the resource. */
    public var modifiedBy: String?
    /** The ID of the user that created the resource. */
    public var createdBy: String?
    /** Indicates if the resource is active, inactive, or deleted. */
    public var state: State?
    /** The application that last modified the resource. */
    public var modifiedByApp: String?
    /** The application that created the resource. */
    public var createdByApp: String?
    public var number: String?
    /** A Uri reference to the owner of this extension, which is either a User or an IVR */
    public var owner: DomainEntityRef?
    public var extensionPool: DomainEntityRef?
    public var ownerType: OwnerType?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, division: Division?, _description: String?, version: Int?, dateCreated: Date?, dateModified: Date?, modifiedBy: String?, createdBy: String?, state: State?, modifiedByApp: String?, createdByApp: String?, number: String?, owner: DomainEntityRef?, extensionPool: DomainEntityRef?, ownerType: OwnerType?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.division = division
        self._description = _description
        self.version = version
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.modifiedBy = modifiedBy
        self.createdBy = createdBy
        self.state = state
        self.modifiedByApp = modifiedByApp
        self.createdByApp = createdByApp
        self.number = number
        self.owner = owner
        self.extensionPool = extensionPool
        self.ownerType = ownerType
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case division
        case _description = "description"
        case version
        case dateCreated
        case dateModified
        case modifiedBy
        case createdBy
        case state
        case modifiedByApp
        case createdByApp
        case number
        case owner
        case extensionPool
        case ownerType
        case selfUri
    }


}




public class ExtensionPool: Codable {



















    public enum State: String, Codable { 
        case active = "active"
        case inactive = "inactive"
        case deleted = "deleted"
    }











    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The name of the entity. */
    public var name: String?
    /** The division to which this entity belongs. */
    public var division: Division?
    /** The resource's description. */
    public var _description: String?
    /** The current version of the resource. */
    public var version: Int?
    /** The date the resource was created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** The date of the last modification to the resource. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** The ID of the user that last modified the resource. */
    public var modifiedBy: String?
    /** The ID of the user that created the resource. */
    public var createdBy: String?
    /** Indicates if the resource is active, inactive, or deleted. */
    public var state: State?
    /** The application that last modified the resource. */
    public var modifiedByApp: String?
    /** The application that created the resource. */
    public var createdByApp: String?
    /** The starting phone number for the range of this Extension pool. The number must be between 3 and 9 digits in length and the same length as the endNumber. */
    public var startNumber: String?
    /** The ending phone number for the range of this Extension pool. The number must be between 3 and 9 digits in length and the same length as the startNumber. */
    public var endNumber: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, division: Division?, _description: String?, version: Int?, dateCreated: Date?, dateModified: Date?, modifiedBy: String?, createdBy: String?, state: State?, modifiedByApp: String?, createdByApp: String?, startNumber: String?, endNumber: String?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.division = division
        self._description = _description
        self.version = version
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.modifiedBy = modifiedBy
        self.createdBy = createdBy
        self.state = state
        self.modifiedByApp = modifiedByApp
        self.createdByApp = createdByApp
        self.startNumber = startNumber
        self.endNumber = endNumber
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case division
        case _description = "description"
        case version
        case dateCreated
        case dateModified
        case modifiedBy
        case createdBy
        case state
        case modifiedByApp
        case createdByApp
        case startNumber
        case endNumber
        case selfUri
    }


}




public class ExtensionPoolDivisionViewEntityListing: Codable {























    public var entities: [ExtensionPoolDivisionView]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    /** The total organization-wide number of entities. */
    public var totalNumberOfEntities: Int64?
    public var firstUri: String?
    public var previousUri: String?
    public var nextUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [ExtensionPoolDivisionView]?, pageSize: Int?, pageNumber: Int?, total: Int64?, totalNumberOfEntities: Int64?, firstUri: String?, previousUri: String?, nextUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.totalNumberOfEntities = totalNumberOfEntities
        self.firstUri = firstUri
        self.previousUri = previousUri
        self.nextUri = nextUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class ExternalContactReference: Codable {





    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, selfUri: String?) {
        self._id = _id
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
    }


}




public class ExternalContactsContactChangedTopicDivision: Codable {



    public var _id: String?

    public init(_id: String?) {
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
    }


}




public class ExternalContactsContactChangedTopicFacebookId: Codable {





    public var ids: [ExternalContactsContactChangedTopicFacebookScopedId]?
    public var displayName: String?

    public init(ids: [ExternalContactsContactChangedTopicFacebookScopedId]?, displayName: String?) {
        self.ids = ids
        self.displayName = displayName
    }


}




public class ExternalContactsContactChangedTopicInstagramId: Codable {







    public var ids: [ExternalContactsContactChangedTopicInstagramScopedId]?
    public var displayName: String?
    public var handle: String?

    public init(ids: [ExternalContactsContactChangedTopicInstagramScopedId]?, displayName: String?, handle: String?) {
        self.ids = ids
        self.displayName = displayName
        self.handle = handle
    }


}




public class ExternalContactsContactNoteChangedTopicNote: Codable {







    public enum EntityType: String, Codable { 
        case contact = "Contact"
        case organization = "Organization"
    }









    public var _id: String?
    public var division: ExternalContactsContactNoteChangedTopicDivision?
    public var entityId: String?
    public var entityType: EntityType?
    public var noteText: String?
    public var createdBy: ExternalContactsContactNoteChangedTopicUser?
    public var createDate: Date?
    public var modifyDate: Date?

    public init(_id: String?, division: ExternalContactsContactNoteChangedTopicDivision?, entityId: String?, entityType: EntityType?, noteText: String?, createdBy: ExternalContactsContactNoteChangedTopicUser?, createDate: Date?, modifyDate: Date?) {
        self._id = _id
        self.division = division
        self.entityId = entityId
        self.entityType = entityType
        self.noteText = noteText
        self.createdBy = createdBy
        self.createDate = createDate
        self.modifyDate = modifyDate
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case division
        case entityId
        case entityType
        case noteText
        case createdBy
        case createDate
        case modifyDate
    }


}




public class ExternalContactsOrganizationChangedTopicExternalOrganization: Codable {







































    public var _id: String?
    public var division: ExternalContactsOrganizationChangedTopicDivision?
    public var name: String?
    public var companyType: String?
    public var industry: String?
    public var primaryContactId: String?
    public var address: ExternalContactsOrganizationChangedTopicContactAddress?
    public var phoneNumber: ExternalContactsOrganizationChangedTopicPhoneNumber?
    public var faxNumber: ExternalContactsOrganizationChangedTopicPhoneNumber?
    public var employeeCount: Int64?
    public var revenue: Int64?
    public var tags: [String]?
    public var websites: [String]?
    public var tickers: [ExternalContactsOrganizationChangedTopicTicker]?
    public var twitterId: ExternalContactsOrganizationChangedTopicTwitterId?
    public var externalSystemUrl: String?
    public var customFields: [String:JSON]?
    public var createDate: Date?
    public var modifyDate: Date?

    public init(_id: String?, division: ExternalContactsOrganizationChangedTopicDivision?, name: String?, companyType: String?, industry: String?, primaryContactId: String?, address: ExternalContactsOrganizationChangedTopicContactAddress?, phoneNumber: ExternalContactsOrganizationChangedTopicPhoneNumber?, faxNumber: ExternalContactsOrganizationChangedTopicPhoneNumber?, employeeCount: Int64?, revenue: Int64?, tags: [String]?, websites: [String]?, tickers: [ExternalContactsOrganizationChangedTopicTicker]?, twitterId: ExternalContactsOrganizationChangedTopicTwitterId?, externalSystemUrl: String?, customFields: [String:JSON]?, createDate: Date?, modifyDate: Date?) {
        self._id = _id
        self.division = division
        self.name = name
        self.companyType = companyType
        self.industry = industry
        self.primaryContactId = primaryContactId
        self.address = address
        self.phoneNumber = phoneNumber
        self.faxNumber = faxNumber
        self.employeeCount = employeeCount
        self.revenue = revenue
        self.tags = tags
        self.websites = websites
        self.tickers = tickers
        self.twitterId = twitterId
        self.externalSystemUrl = externalSystemUrl
        self.customFields = customFields
        self.createDate = createDate
        self.modifyDate = modifyDate
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case division
        case name
        case companyType
        case industry
        case primaryContactId
        case address
        case phoneNumber
        case faxNumber
        case employeeCount
        case revenue
        case tags
        case websites
        case tickers
        case twitterId
        case externalSystemUrl
        case customFields
        case createDate
        case modifyDate
    }


}




public class ExternalContactsRelationshipChangedTopicDivision: Codable {



    public var _id: String?

    public init(_id: String?) {
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
    }


}




public class ExternalContactsUnresolvedContactChangedTopicExternalOrganization: Codable {







































    public var _id: String?
    public var division: ExternalContactsUnresolvedContactChangedTopicDivision?
    public var name: String?
    public var companyType: String?
    public var industry: String?
    public var primaryContactId: String?
    public var address: ExternalContactsUnresolvedContactChangedTopicContactAddress?
    public var phoneNumber: ExternalContactsUnresolvedContactChangedTopicPhoneNumber?
    public var faxNumber: ExternalContactsUnresolvedContactChangedTopicPhoneNumber?
    public var employeeCount: Int64?
    public var revenue: Int64?
    public var tags: [String]?
    public var websites: [String]?
    public var tickers: [ExternalContactsUnresolvedContactChangedTopicTicker]?
    public var twitterId: ExternalContactsUnresolvedContactChangedTopicTwitterId?
    public var externalSystemUrl: String?
    public var customFields: [String:JSON]?
    public var createDate: Date?
    public var modifyDate: Date?

    public init(_id: String?, division: ExternalContactsUnresolvedContactChangedTopicDivision?, name: String?, companyType: String?, industry: String?, primaryContactId: String?, address: ExternalContactsUnresolvedContactChangedTopicContactAddress?, phoneNumber: ExternalContactsUnresolvedContactChangedTopicPhoneNumber?, faxNumber: ExternalContactsUnresolvedContactChangedTopicPhoneNumber?, employeeCount: Int64?, revenue: Int64?, tags: [String]?, websites: [String]?, tickers: [ExternalContactsUnresolvedContactChangedTopicTicker]?, twitterId: ExternalContactsUnresolvedContactChangedTopicTwitterId?, externalSystemUrl: String?, customFields: [String:JSON]?, createDate: Date?, modifyDate: Date?) {
        self._id = _id
        self.division = division
        self.name = name
        self.companyType = companyType
        self.industry = industry
        self.primaryContactId = primaryContactId
        self.address = address
        self.phoneNumber = phoneNumber
        self.faxNumber = faxNumber
        self.employeeCount = employeeCount
        self.revenue = revenue
        self.tags = tags
        self.websites = websites
        self.tickers = tickers
        self.twitterId = twitterId
        self.externalSystemUrl = externalSystemUrl
        self.customFields = customFields
        self.createDate = createDate
        self.modifyDate = modifyDate
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case division
        case name
        case companyType
        case industry
        case primaryContactId
        case address
        case phoneNumber
        case faxNumber
        case employeeCount
        case revenue
        case tags
        case websites
        case tickers
        case twitterId
        case externalSystemUrl
        case customFields
        case createDate
        case modifyDate
    }


}




public class ExternalEstablishedEvent: Codable {





















    /** A unique (V4 UUID) eventId for this event */
    public var eventId: String?
    /** A Date Time representing the time this event occurred. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var eventDateTime: Date?
    /** A unique Id (V4 UUID) identifying this conversation */
    public var conversationId: String?
    /** A unique Id (V4 UUID) identifying this communication */
    public var communicationId: String?
    /** The automatic number identification if it is available for this conversation. */
    public var ani: String?
    /** The automatic number identification name if it is available for this conversation. */
    public var aniName: String?
    /** The dialed number identification if it is available for this conversation. */
    public var dnis: String?
    /** The dialed number identification name if it is available for this conversation. */
    public var dnisName: String?
    /** Metadata about this communication. */
    public var initialConfiguration: InitialConfiguration?
    /** Metadata about the source of this communication's interaction. */
    public var sourceConfiguration: SourceConfiguration?

    public init(eventId: String?, eventDateTime: Date?, conversationId: String?, communicationId: String?, ani: String?, aniName: String?, dnis: String?, dnisName: String?, initialConfiguration: InitialConfiguration?, sourceConfiguration: SourceConfiguration?) {
        self.eventId = eventId
        self.eventDateTime = eventDateTime
        self.conversationId = conversationId
        self.communicationId = communicationId
        self.ani = ani
        self.aniName = aniName
        self.dnis = dnis
        self.dnisName = dnisName
        self.initialConfiguration = initialConfiguration
        self.sourceConfiguration = sourceConfiguration
    }


}




public class ExternalMetricDataUnprocessedItem: Codable {













    public enum ModelType: String, Codable { 
        case total = "Total"
        case cumulative = "Cumulative"
    }





    /** The user ID. Must provide either userId or userEmail, but not both. */
    public var userId: String?
    /** The user main email used in user's GenesysCloud account. Must provide either userId or userEmail, but not both. */
    public var userEmail: String?
    /** The ID of the external metric definition */
    public var metricId: String?
    /** The date of the metric data. Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd */
    public var dateOccurred: Date?
    /** The value of the metric data. When value is null, the metric data will be deleted. */
    public var value: Double?
    /** The number of data points. The default value is 0 when type is Cumulative and the metric data already exists, otherwise 1. When total count reaches 0, the metric data will be deleted. */
    public var count: Int?
    /** The type of the metric data. The default value is Total. */
    public var type: ModelType?
    /** The error message */
    public var message: String?
    /** The error code */
    public var code: String?

    public init(userId: String?, userEmail: String?, metricId: String?, dateOccurred: Date?, value: Double?, count: Int?, type: ModelType?, message: String?, code: String?) {
        self.userId = userId
        self.userEmail = userEmail
        self.metricId = metricId
        self.dateOccurred = dateOccurred
        self.value = value
        self.count = count
        self.type = type
        self.message = message
        self.code = code
    }


}




public class ExternalOrganizationIdentifierClaimRequest: Codable {

    public enum Operation: String, Codable { 
        case claim = "Claim"
        case release = "Release"
    }



    /** The operation to perform claim/release */
    public var operation: Operation?
    /** The identifier that should be claimed/released from an external org */
    public var identifier: ExternalOrganizationIdentifier?

    public init(operation: Operation?, identifier: ExternalOrganizationIdentifier?) {
        self.operation = operation
        self.identifier = identifier
    }


}




public class ExternalPageMetadata: Codable {





    /** The name of the external page */
    public var name: String?
    /** The profile picture URL of the external page */
    public var profilePictureUrl: String?

    public init(name: String?, profilePictureUrl: String?) {
        self.name = name
        self.profilePictureUrl = profilePictureUrl
    }


}




public class FacebookAppCredentials: Codable {



    /** Genesys Cloud Facebook App Id */
    public var _id: String?

    public init(_id: String?) {
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
    }


}



/** User information for a Facebook user interacting with a page or app */

public class FacebookId: Codable {





    /** The set of scopedIds that this person has. Each scopedId is specific to a page or app that the user interacts with. */
    public var ids: [FacebookScopedId]?
    /** The displayName of this person's Facebook account. Roughly translates to user.first_name + ' ' + user.last_name in the Facebook API. */
    public var displayName: String?

    public init(ids: [FacebookScopedId]?, displayName: String?) {
        self.ids = ids
        self.displayName = displayName
    }


}




public class FacebookIntegrationEntityListing: Codable {





















    public var entities: [FacebookIntegration]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var previousUri: String?
    public var nextUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [FacebookIntegration]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, previousUri: String?, nextUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.previousUri = previousUri
        self.nextUri = nextUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class FaxSummary: Codable {







    public var readCount: Int?
    public var unreadCount: Int?
    public var totalCount: Int?

    public init(readCount: Int?, unreadCount: Int?, totalCount: Int?) {
        self.readCount = readCount
        self.unreadCount = unreadCount
        self.totalCount = totalCount
    }


}




public class FieldConfig: Codable {





    public enum EntityType: String, Codable { 
        case person = "person"
        case group = "group"
        case org = "org"
    }











    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    public var entityType: EntityType?
    public var state: String?
    public var sections: [Section]?
    public var version: String?
    public var schemaVersion: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, entityType: EntityType?, state: String?, sections: [Section]?, version: String?, schemaVersion: String?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.entityType = entityType
        self.state = state
        self.sections = sections
        self.version = version
        self.schemaVersion = schemaVersion
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case entityType
        case state
        case sections
        case version
        case schemaVersion
        case selfUri
    }


}




public class FieldConfigs: Codable {







    public var org: FieldConfig?
    public var person: FieldConfig?
    public var group: FieldConfig?

    public init(org: FieldConfig?, person: FieldConfig?, group: FieldConfig?) {
        self.org = org
        self.person = person
        self.group = group
    }


}




public class FileSpecificationTemplate: Codable {













    public enum Format: String, Codable { 
        case fixedLength = "FixedLength"
        case delimited = "Delimited"
    }







    public enum Delimiter: String, Codable { 
        case comma = "Comma"
        case pipe = "Pipe"
        case colon = "Colon"
        case tab = "Tab"
        case semicolon = "Semicolon"
        case custom = "Custom"
    }









    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The name of the File Specification template. */
    public var name: String?
    /** Creation time of the entity. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** Last modified time of the entity. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** Required for updates, must match the version number of the most recent update */
    public var version: Int?
    /** Description of the file specification template */
    public var _description: String?
    /** File format */
    public var format: Format?
    /** Number of heading lines to be skipped */
    public var numberOfHeadingLinesSkipped: Int?
    /** Number of trailing lines to be skipped */
    public var numberOfTrailingLinesSkipped: Int?
    /** If true indicates that delimited file has a header row, which can provide column names */
    public var header: Bool?
    /** Kind of delimiter */
    public var delimiter: Delimiter?
    /** Delimiter character, used only when delimiter=\"Custom\" */
    public var delimiterValue: String?
    /** Columns specification */
    public var columnInformation: [Column]?
    /** Preprocessing rules */
    public var preprocessingRules: [PreprocessingRule]?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, dateCreated: Date?, dateModified: Date?, version: Int?, _description: String?, format: Format?, numberOfHeadingLinesSkipped: Int?, numberOfTrailingLinesSkipped: Int?, header: Bool?, delimiter: Delimiter?, delimiterValue: String?, columnInformation: [Column]?, preprocessingRules: [PreprocessingRule]?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.version = version
        self._description = _description
        self.format = format
        self.numberOfHeadingLinesSkipped = numberOfHeadingLinesSkipped
        self.numberOfTrailingLinesSkipped = numberOfTrailingLinesSkipped
        self.header = header
        self.delimiter = delimiter
        self.delimiterValue = delimiterValue
        self.columnInformation = columnInformation
        self.preprocessingRules = preprocessingRules
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case dateCreated
        case dateModified
        case version
        case _description = "description"
        case format
        case numberOfHeadingLinesSkipped
        case numberOfTrailingLinesSkipped
        case header
        case delimiter
        case delimiterValue
        case columnInformation
        case preprocessingRules
        case selfUri
    }


}




public class FlowActivityQuery: Codable {




    public enum GroupBy: String, Codable { 
        case activerouting = "activeRouting"
        case addressfrom = "addressFrom"
        case addressto = "addressTo"
        case agentscore = "agentScore"
        case ani = "ani"
        case conversationid = "conversationId"
        case convertedfrom = "convertedFrom"
        case convertedto = "convertedTo"
        case direction = "direction"
        case dnis = "dnis"
        case flowid = "flowId"
        case flowtype = "flowType"
        case mediatype = "mediaType"
        case participantname = "participantName"
        case queueid = "queueId"
        case requestedlanguageid = "requestedLanguageId"
        case requestedrouting = "requestedRouting"
        case requestedroutingskillid = "requestedRoutingSkillId"
        case routingpriority = "routingPriority"
        case scoredagentid = "scoredAgentId"
        case sessionid = "sessionId"
        case teamid = "teamId"
        case usedrouting = "usedRouting"
        case userid = "userId"
    }


    public enum Order: String, Codable { 
        case asc = "asc"
        case desc = "desc"
        case unordered = "unordered"
    }

    /** List of requested metrics */
    public var metrics: [FlowActivityQueryMetric]?
    /** Dimension(s) to group by */
    public var groupBy: [GroupBy]?
    /** Filter to return a subset of observations. Expresses boolean logical predicates as well as dimensional filters */
    public var filter: FlowActivityQueryFilter?
    /** Sort the result set in ascending/descending order. Default is ascending */
    public var order: Order?

    public init(metrics: [FlowActivityQueryMetric]?, groupBy: [GroupBy]?, filter: FlowActivityQueryFilter?, order: Order?) {
        self.metrics = metrics
        self.groupBy = groupBy
        self.filter = filter
        self.order = order
    }


}




public class FlowActivityQueryClause: Codable {

    public enum ModelType: String, Codable { 
        case and = "and"
        case or = "or"
    }



    /** Boolean operation to apply to the provided predicates */
    public var type: ModelType?
    /** Like a three-word sentence: (attribute-name) (operator) (target-value). */
    public var predicates: [FlowActivityQueryPredicate]?

    public init(type: ModelType?, predicates: [FlowActivityQueryPredicate]?) {
        self.type = type
        self.predicates = predicates
    }


}




public class FlowAggregateQueryResponse: Codable {



    public var results: [FlowAggregateDataContainer]?

    public init(results: [FlowAggregateDataContainer]?) {
        self.results = results
    }


}




public class FlowAggregationView: Codable {

    public enum Target: String, Codable { 
        case nflow = "nFlow"
        case nflowmilestone = "nFlowMilestone"
        case nflowoutcome = "nFlowOutcome"
        case nflowoutcomefailed = "nFlowOutcomeFailed"
        case oflowmilestone = "oFlowMilestone"
        case tflow = "tFlow"
        case tflowdisconnect = "tFlowDisconnect"
        case tflowexit = "tFlowExit"
        case tflowoutcome = "tFlowOutcome"
    }



    public enum Function: String, Codable { 
        case rangebound = "rangeBound"
    }



    /** Target metric name */
    public var target: Target?
    /** A unique name for this view. Must be distinct from other views and built-in metric names. */
    public var name: String?
    /** Type of view you wish to create */
    public var function: Function?
    /** Range of numbers for slicing up data */
    public var range: AggregationRange?

    public init(target: Target?, name: String?, function: Function?, range: AggregationRange?) {
        self.target = target
        self.name = name
        self.function = function
        self.range = range
    }


}



/** This is a set of enabled characteristics for the loglevel */

public class FlowCharacteristics: Codable {

















    /** Whether to report execution data about individual actions, menus, states, tasks, etc. etc. that ran during execution of the flow. */
    public var executionItems: Bool?
    /** Whether to report input setting input setting values and output data values for individual execution items above.  For example, if you have FlowExecutionInputOutputs and a Call Data Action ran in a flow, if FlowExecutionItems was enabled you'd see the fact a Call Data Action ran and the output path it took but nothing about which Data Action it ran, the input data sent to it at flow runtime and the data returned from it.  If you enable this characteristic, execution data will contain this additional detail. */
    public var executionInputOutputs: Bool?
    /** Communications are either audio or digital communications sent to or received from a participant.  An example here would be the initial greeting in an inbound call flow where it plays a greeting message to the participant. */
    public var communications: Bool?
    /** Whether to report flow error events. */
    public var eventError: Bool?
    /** Whether to report flow warning events. */
    public var eventWarning: Bool?
    /** Whether to report events other than errors or warnings such as a language change, loop event. */
    public var eventOther: Bool?
    /** Whether to report assignment of values to variables in flow execution data. It's important to remember there is a difference between variable value assignments and output data from an action.  If you have a Call Digital Bot flow action in an Inbound Message flow and there is no variable bound to the Exit Reason output but FlowExecutionInputOutputs is enabled, you will still be able to see the exit reason from the digital bot flow in execution data even though it is not bound to a variable. */
    public var variables: Bool?
    /** This characteristic specifies whether or not name information should be emitted in execution data such as action, task, state or even the flow name itself.  Names are very handy from a readability standpoint but they do take up additional space in flow execution data instances. */
    public var names: Bool?

    public init(executionItems: Bool?, executionInputOutputs: Bool?, communications: Bool?, eventError: Bool?, eventWarning: Bool?, eventOther: Bool?, variables: Bool?, names: Bool?) {
        self.executionItems = executionItems
        self.executionInputOutputs = executionInputOutputs
        self.communications = communications
        self.eventError = eventError
        self.eventWarning = eventWarning
        self.eventOther = eventOther
        self.variables = variables
        self.names = names
    }


}




public class FlowExecutionAggregateQueryFilter: Codable {

    public enum ModelType: String, Codable { 
        case and = "and"
        case or = "or"
    }





    /** Boolean operation to apply to the provided predicates and clauses */
    public var type: ModelType?
    /** Boolean 'and/or' logic with up to two-levels of nesting */
    public var clauses: [FlowExecutionAggregateQueryClause]?
    /** Like a three-word sentence: (attribute-name) (operator) (target-value). */
    public var predicates: [FlowExecutionAggregateQueryPredicate]?

    public init(type: ModelType?, clauses: [FlowExecutionAggregateQueryClause]?, predicates: [FlowExecutionAggregateQueryPredicate]?) {
        self.type = type
        self.clauses = clauses
        self.predicates = predicates
    }


}



/** This is the metadata of an executionData entry for a flow. */

public class FlowExecutionDataQueryResult: Codable {

















    public enum FlowType: String, Codable { 
        case bot = "bot"
        case commonmodule = "commonmodule"
        case digitalbot = "digitalbot"
        case inboundcall = "inboundcall"
        case inboundchat = "inboundchat"
        case inboundemail = "inboundemail"
        case inboundshortmessage = "inboundshortmessage"
        case inqueuecall = "inqueuecall"
        case inqueueshortmessage = "inqueueshortmessage"
        case inqueueemail = "inqueueemail"
        case outboundcall = "outboundcall"
        case securecall = "securecall"
        case surveyinvite = "surveyinvite"
        case voice = "voice"
        case voicemail = "voicemail"
        case voicesurvey = "voicesurvey"
        case workflow = "workflow"
        case workitem = "workitem"
    }









    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** The start time for the execution of this flow. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var startDateTime: Date?
    /** The end time for the execution of this flow. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var endDateTime: Date?
    /** The id of the flow that was executed. */
    public var flowId: String?
    /** The version of the flow that was executed. */
    public var flowVersion: String?
    /** The id of the conversation that executed this flow. */
    public var conversationId: String?
    /** The id of the workitem that executed this flow. */
    public var workitemId: String?
    /** The type of flow. */
    public var flowType: FlowType?
    /** If the flow errored out this is the reason. */
    public var flowErrorReason: String?
    /** If the flow had a warning, this is the reason. */
    public var flowWarningReason: String?
    /** The name of the flow. */
    public var flowName: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, startDateTime: Date?, endDateTime: Date?, flowId: String?, flowVersion: String?, conversationId: String?, workitemId: String?, flowType: FlowType?, flowErrorReason: String?, flowWarningReason: String?, flowName: String?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.startDateTime = startDateTime
        self.endDateTime = endDateTime
        self.flowId = flowId
        self.flowVersion = flowVersion
        self.conversationId = conversationId
        self.workitemId = workitemId
        self.flowType = flowType
        self.flowErrorReason = flowErrorReason
        self.flowWarningReason = flowWarningReason
        self.flowName = flowName
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case startDateTime
        case endDateTime
        case flowId
        case flowVersion
        case conversationId
        case workitemId
        case flowType
        case flowErrorReason
        case flowWarningReason
        case flowName
        case selfUri
    }


}




public class FlowHealthIntent: Codable {







    public enum Language: String, Codable { 
        case enUs = "en-us"
        case enGb = "en-gb"
        case enAu = "en-au"
        case enZa = "en-za"
        case enNz = "en-nz"
        case enIe = "en-ie"
        case frCa = "fr-ca"
        case frFr = "fr-fr"
        case esUs = "es-us"
        case esEs = "es-es"
        case esMx = "es-mx"
        case deDe = "de-de"
        case itIt = "it-it"
        case ptBr = "pt-br"
        case ptPt = "pt-pt"
        case nlNl = "nl-nl"
    }





    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** Info about given flow version. */
    public var flowVersionInfo: FlowHealthIntentVersionInfo?
    /** Language provided for this intent's health. */
    public var language: Language?
    /** Health computation details for given language. */
    public var health: HealthInfo?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, flowVersionInfo: FlowHealthIntentVersionInfo?, language: Language?, health: HealthInfo?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.flowVersionInfo = flowVersionInfo
        self.language = language
        self.health = health
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case flowVersionInfo
        case language
        case health
        case selfUri
    }


}



/** This is a table of settings per a loglevel that define what will be logged in executionData when enabled (true) */

public class FlowLogLevel: Codable {

    public enum Level: String, Codable { 
        case unknown = "Unknown"
        case disabled = "Disabled"
        case base = "Base"
        case notes = "Notes"
        case verboseNotes = "VerboseNotes"
        case all = "All"
    }



    /** The logLevel for this characteristics set */
    public var level: Level?
    /** Shows what characteristics are enabled for this log level */
    public var characteristics: FlowCharacteristics?

    public init(level: Level?, characteristics: FlowCharacteristics?) {
        self.level = level
        self.characteristics = characteristics
    }


}



/** Used to set the log level of a particular flow */

public class FlowLogLevelRequest: Codable {



    /** The log level characteristics currently set for this flow */
    public var logLevelCharacteristics: FlowLogLevel?

    public init(logLevelCharacteristics: FlowLogLevel?) {
        self.logLevelCharacteristics = logLevelCharacteristics
    }


}




public class FlowMetricsTopicFlowScoredAgent: Codable {





    /** Assigned agent score for this conversation (0 - 100, higher being better) */
    public var agentScore: Int64?
    /** Unique identifier for the agent that was scored for this conversation */
    public var scoredAgentId: String?

    public init(agentScore: Int64?, scoredAgentId: String?) {
        self.agentScore = agentScore
        self.scoredAgentId = scoredAgentId
    }


}




public class FlowMilestone: Codable {











    /** The flow milestone identifier */
    public var _id: String?
    /** The flow milestone name. */
    public var name: String?
    /** The division to which this entity belongs. */
    public var division: WritableDivision?
    /** The flow milestone description. */
    public var _description: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, division: WritableDivision?, _description: String?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.division = division
        self._description = _description
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case division
        case _description = "description"
        case selfUri
    }


}




public class FlowMilestoneDivisionViewEntityListing: Codable {





















    public var entities: [FlowMilestoneDivisionView]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var previousUri: String?
    public var nextUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [FlowMilestoneDivisionView]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, previousUri: String?, nextUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.previousUri = previousUri
        self.nextUri = nextUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class FlowMilestoneListing: Codable {





















    public var entities: [FlowMilestone]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var previousUri: String?
    public var nextUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [FlowMilestone]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, previousUri: String?, nextUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.previousUri = previousUri
        self.nextUri = nextUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class FlowOutcomeDetailEventTopicFlowMilestone: Codable {





    public var milestoneId: UUID?
    public var milestoneTime: Int64?

    public init(milestoneId: UUID?, milestoneTime: Int64?) {
        self.milestoneId = milestoneId
        self.milestoneTime = milestoneTime
    }


}




public class FlowPathsFlowFilter: Codable {



    /** The identifier of the flow. */
    public var _id: String?

    public init(_id: String?) {
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
    }


}




public class FlowStartDetailEventTopicFlowStartEvent: Codable {









    public enum MediaType: String, Codable { 
        case unknown = "UNKNOWN"
        case voice = "VOICE"
        case chat = "CHAT"
        case email = "EMAIL"
        case callback = "CALLBACK"
        case cobrowse = "COBROWSE"
        case video = "VIDEO"
        case screenshare = "SCREENSHARE"
        case message = "MESSAGE"
        case internalmessage = "INTERNALMESSAGE"
        case screenmonitoring = "SCREENMONITORING"
    }



    public enum Direction: String, Codable { 
        case unknown = "UNKNOWN"
        case inbound = "INBOUND"
        case outbound = "OUTBOUND"
    }











    public enum MessageType: String, Codable { 
        case unknown = "UNKNOWN"
        case sms = "SMS"
        case twitter = "TWITTER"
        case facebook = "FACEBOOK"
        case line = "LINE"
        case whatsapp = "WHATSAPP"
        case webmessaging = "WEBMESSAGING"
        case _open = "OPEN"
        case instagram = "INSTAGRAM"
        case apple = "APPLE"
    }

    public enum FlowType: String, Codable { 
        case unknown = "UNKNOWN"
        case inboundcall = "INBOUNDCALL"
        case outboundcall = "OUTBOUNDCALL"
        case inqueuecall = "INQUEUECALL"
        case securecall = "SECURECALL"
        case inboundemail = "INBOUNDEMAIL"
        case surveyinvite = "SURVEYINVITE"
        case inboundshortmessage = "INBOUNDSHORTMESSAGE"
        case inboundchat = "INBOUNDCHAT"
        case workflow = "WORKFLOW"
        case bot = "BOT"
        case digitalbot = "DIGITALBOT"
        case commonmodule = "COMMONMODULE"
        case inqueueemail = "INQUEUEEMAIL"
        case inqueueshortmessage = "INQUEUESHORTMESSAGE"
        case voice = "VOICE"
        case voicemail = "VOICEMAIL"
        case workitem = "WORKITEM"
        case voicesurvey = "VOICESURVEY"
    }











    public var eventTime: Int64?
    public var conversationId: String?
    public var participantId: String?
    public var sessionId: String?
    public var mediaType: MediaType?
    public var provider: String?
    public var direction: Direction?
    public var ani: String?
    public var dnis: String?
    public var addressTo: String?
    public var addressFrom: String?
    public var subject: String?
    public var messageType: MessageType?
    public var flowType: FlowType?
    public var flowId: String?
    public var divisionId: String?
    public var flowVersion: String?
    public var conversationExternalContactIds: [String]?
    public var conversationExternalOrganizationIds: [String]?

    public init(eventTime: Int64?, conversationId: String?, participantId: String?, sessionId: String?, mediaType: MediaType?, provider: String?, direction: Direction?, ani: String?, dnis: String?, addressTo: String?, addressFrom: String?, subject: String?, messageType: MessageType?, flowType: FlowType?, flowId: String?, divisionId: String?, flowVersion: String?, conversationExternalContactIds: [String]?, conversationExternalOrganizationIds: [String]?) {
        self.eventTime = eventTime
        self.conversationId = conversationId
        self.participantId = participantId
        self.sessionId = sessionId
        self.mediaType = mediaType
        self.provider = provider
        self.direction = direction
        self.ani = ani
        self.dnis = dnis
        self.addressTo = addressTo
        self.addressFrom = addressFrom
        self.subject = subject
        self.messageType = messageType
        self.flowType = flowType
        self.flowId = flowId
        self.divisionId = divisionId
        self.flowVersion = flowVersion
        self.conversationExternalContactIds = conversationExternalContactIds
        self.conversationExternalOrganizationIds = conversationExternalOrganizationIds
    }


}




public class FlowVersionEntityListing: Codable {





















    public var entities: [FlowVersion]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var previousUri: String?
    public var nextUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [FlowVersion]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, previousUri: String?, nextUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.previousUri = previousUri
        self.nextUri = nextUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class ForecastAbandonRateResponse: Codable {



    /** The target percent abandon rate goal */
    public var percent: Int?

    public init(percent: Int?) {
        self.percent = percent
    }


}



/** Date picker component for form input */

public class FormDatePicker: Codable {









    /** Unique identifier for the date picker */
    public var _id: String?
    /** Title of the date picker */
    public var title: String?
    /** Subtitle of the date picker */
    public var subtitle: String?
    /** Date display format */
    public var dateDisplayFormat: String?

    public init(_id: String?, title: String?, subtitle: String?, dateDisplayFormat: String?) {
        self._id = _id
        self.title = title
        self.subtitle = subtitle
        self.dateDisplayFormat = dateDisplayFormat
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case title
        case subtitle
        case dateDisplayFormat
    }


}



/** List picker component configuration */

public class FormListPicker: Codable {





    /** Unique identifier for the list picker */
    public var _id: String?
    /** Sections in the list picker */
    public var sections: [FormListPickerSection]?

    public init(_id: String?, sections: [FormListPickerSection]?) {
        self._id = _id
        self.sections = sections
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case sections
    }


}



/** Section within a list picker */

public class FormListPickerSection: Codable {







    /** Title of the section */
    public var title: String?
    /** Whether multiple items can be selected */
    public var multipleSelection: Bool?
    /** Items in this section */
    public var items: [FormListPickerItem]?

    public init(title: String?, multipleSelection: Bool?, items: [FormListPickerItem]?) {
        self.title = title
        self.multipleSelection = multipleSelection
        self.items = items
    }


}



/** A component within a form page */

public class FormPageComponent: Codable {

    public enum FormComponentType: String, Codable { 
        case listPicker = "ListPicker"
        case datePicker = "DatePicker"
        case input = "Input"
        case wheelPicker = "WheelPicker"
    }









    /** Type of the component */
    public var formComponentType: FormComponentType?
    /** List picker configuration */
    public var listPicker: FormListPicker?
    /** Date picker configuration */
    public var datePicker: FormDatePicker?
    /** Input field configuration */
    public var input: Input?
    /** Wheel picker configuration */
    public var wheelPicker: WheelPicker?

    public init(formComponentType: FormComponentType?, listPicker: FormListPicker?, datePicker: FormDatePicker?, input: Input?, wheelPicker: WheelPicker?) {
        self.formComponentType = formComponentType
        self.listPicker = listPicker
        self.datePicker = datePicker
        self.input = input
        self.wheelPicker = wheelPicker
    }


}




public class Format: Codable {


    public enum Flags: String, Codable { 
        case boolPlayYesNo = "BoolPlayYesNo"
        case currencyAsMinorUnits = "CurrencyAsMinorUnits"
        case currencyMajorUnitsOnly = "CurrencyMajorUnitsOnly"
        case currencyMinorUnitsOnly = "CurrencyMinorUnitsOnly"
        case currencyPlayDigits = "CurrencyPlayDigits"
        case dateLongYear = "DateLongYear"
        case dateShortYear = "DateShortYear"
        case dateShortMonthAndDay = "DateShortMonthAndDay"
        case dateDayOfWeekOnly = "DateDayOfWeekOnly"
        case dateDayOnly = "DateDayOnly"
        case dateMonthOnly = "DateMonthOnly"
        case dateShortYearOnly = "DateShortYearOnly"
        case dateLongYearOnly = "DateLongYearOnly"
        case timeTwentyFourHours = "TimeTwentyFourHours"
        case timeTwelveHours = "TimeTwelveHours"
        case timePartDays = "TimePartDays"
        case timePartHours = "TimePartHours"
        case timePartMinutes = "TimePartMinutes"
        case timePartSeconds = "TimePartSeconds"
        case stringPlayChars = "StringPlayChars"
        case numberPlayDigits = "NumberPlayDigits"
        case numberOrdinal = "NumberOrdinal"
        case languageCaseArticle = "LanguageCaseArticle"
        case languageCaseAccusative = "LanguageCaseAccusative"
        case languageCaseDative = "LanguageCaseDative"
        case languageCaseGenitive = "LanguageCaseGenitive"
        case languageCaseNominative = "LanguageCaseNominative"
        case languageQuantityPlural = "LanguageQuantityPlural"
        case languageQuantitySingular = "LanguageQuantitySingular"
        case languageGenderCommon = "LanguageGenderCommon"
        case languageGenderFeminine = "LanguageGenderFeminine"
        case languageGenderMasculine = "LanguageGenderMasculine"
        case languageGenderNeuter = "LanguageGenderNeuter"
        case caseArticle = "CaseArticle"
        case caseAccusative = "CaseAccusative"
        case caseDative = "CaseDative"
        case caseGenitive = "CaseGenitive"
        case caseNominative = "CaseNominative"
        case quantityPlural = "QuantityPlural"
        case quantitySingular = "QuantitySingular"
        case genderCommon = "GenderCommon"
        case genderFeminine = "GenderFeminine"
        case genderMasculine = "GenderMasculine"
        case genderNeuter = "GenderNeuter"
    }
    /** The Set of prompt segment format flags i.e. each entry is a part of describing the overall format. E.g. \"format\": { \"flags\": [StringPlayChars] } */
    public var flags: [Flags]?

    public init(flags: [Flags]?) {
        self.flags = flags
    }


}




public class FromEmailAddress: Codable {







    /** The OutboundDomain used for the email address. */
    public var domain: DomainEntityRef?
    /** The friendly name of the email address. */
    public var friendlyName: String?
    /** The local part of the email address. */
    public var localPart: String?

    public init(domain: DomainEntityRef?, friendlyName: String?, localPart: String?) {
        self.domain = domain
        self.friendlyName = friendlyName
        self.localPart = localPart
    }


}




public class GKNDocumentationSearchRequest: Codable {

    public enum SortOrder: String, Codable { 
        case asc = "ASC"
        case desc = "DESC"
        case score = "SCORE"
    }











    /** The sort order for results */
    public var sortOrder: SortOrder?
    /** The field in the resource that you want to sort the results by */
    public var sortBy: String?
    /** The number of results per page */
    public var pageSize: Int?
    /** The page of resources you want to retrieve */
    public var pageNumber: Int?
    /** Multi-value sort order, list of multiple sort values */
    public var sort: [SearchSort]?
    public var query: [GKNDocumentationSearchCriteria]?

    public init(sortOrder: SortOrder?, sortBy: String?, pageSize: Int?, pageNumber: Int?, sort: [SearchSort]?, query: [GKNDocumentationSearchCriteria]?) {
        self.sortOrder = sortOrder
        self.sortBy = sortBy
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.sort = sort
        self.query = query
    }


}




public class GenerateBuForecastRequest: Codable {







    /** The description for the forecast */
    public var _description: String?
    /** The number of weeks this forecast covers */
    public var weekCount: Int?
    /** Whether this forecast can be used for scheduling */
    public var canUseForScheduling: Bool?

    public init(_description: String?, weekCount: Int?, canUseForScheduling: Bool?) {
        self._description = _description
        self.weekCount = weekCount
        self.canUseForScheduling = canUseForScheduling
    }

    public enum CodingKeys: String, CodingKey { 
        case _description = "description"
        case weekCount
        case canUseForScheduling
    }


}




public class GenerateMeetingIdRequest: Codable {







    /** The conferenceId for which to generate a meetingId */
    public var conferenceId: String?
    /** Boolean flag for ephemeral status of the created record */
    public var ephemeral: Bool?
    /** Number of days the meetingId record will remain active */
    public var expireTimeDays: Int?

    public init(conferenceId: String?, ephemeral: Bool?, expireTimeDays: Int?) {
        self.conferenceId = conferenceId
        self.ephemeral = ephemeral
        self.expireTimeDays = expireTimeDays
    }


}




public class GenericSAML: Codable {























    public enum NameIdentifierFormat: String, Codable { 
        case urnOasisNamesTcSaml11NameidFormatUnspecified = "urn:oasis:names:tc:SAML:1.1:nameid-format:unspecified"
        case urnOasisNamesTcSaml11NameidFormatEmailaddress = "urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress"
        case urnOasisNamesTcSaml11NameidFormatX509subjectname = "urn:oasis:names:tc:SAML:1.1:nameid-format:X509SubjectName"
        case urnOasisNamesTcSaml11NameidFormatWindowsdomainqualifiedname = "urn:oasis:names:tc:SAML:1.1:nameid-format:WindowsDomainQualifiedName"
        case urnOasisNamesTcSaml20NameidFormatKerberos = "urn:oasis:names:tc:SAML:2.0:nameid-format:kerberos"
        case urnOasisNamesTcSaml20NameidFormatEntity = "urn:oasis:names:tc:SAML:2.0:nameid-format:entity"
        case urnOasisNamesTcSaml20NameidFormatPersistent = "urn:oasis:names:tc:SAML:2.0:nameid-format:persistent"
        case urnOasisNamesTcSaml20NameidFormatTransient = "urn:oasis:names:tc:SAML:2.0:nameid-format:transient"
    }

    public enum SsoBinding: String, Codable { 
        case urnOasisNamesTcSaml20BindingsHttpPost = "urn:oasis:names:tc:SAML:2.0:bindings:HTTP-POST"
        case urnOasisNamesTcSaml20BindingsHttpRedirect = "urn:oasis:names:tc:SAML:2.0:bindings:HTTP-Redirect"
    }













    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    public var disabled: Bool?
    public var issuerURI: String?
    public var ssoTargetURI: String?
    public var sloURI: String?
    public var sloBinding: String?
    public var relyingPartyIdentifier: String?
    public var certificate: String?
    public var certificates: [String]?
    public var logoImageData: String?
    public var nameIdentifierFormat: NameIdentifierFormat?
    public var ssoBinding: SsoBinding?
    public var signAuthnRequests: Bool?
    public var providerName: String?
    public var displayOnLogin: Bool?
    public var metadataURL: String?
    public var endpointCompression: Bool?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, disabled: Bool?, issuerURI: String?, ssoTargetURI: String?, sloURI: String?, sloBinding: String?, relyingPartyIdentifier: String?, certificate: String?, certificates: [String]?, logoImageData: String?, nameIdentifierFormat: NameIdentifierFormat?, ssoBinding: SsoBinding?, signAuthnRequests: Bool?, providerName: String?, displayOnLogin: Bool?, metadataURL: String?, endpointCompression: Bool?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.disabled = disabled
        self.issuerURI = issuerURI
        self.ssoTargetURI = ssoTargetURI
        self.sloURI = sloURI
        self.sloBinding = sloBinding
        self.relyingPartyIdentifier = relyingPartyIdentifier
        self.certificate = certificate
        self.certificates = certificates
        self.logoImageData = logoImageData
        self.nameIdentifierFormat = nameIdentifierFormat
        self.ssoBinding = ssoBinding
        self.signAuthnRequests = signAuthnRequests
        self.providerName = providerName
        self.displayOnLogin = displayOnLogin
        self.metadataURL = metadataURL
        self.endpointCompression = endpointCompression
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case disabled
        case issuerURI
        case ssoTargetURI
        case sloURI
        case sloBinding
        case relyingPartyIdentifier
        case certificate
        case certificates
        case logoImageData
        case nameIdentifierFormat
        case ssoBinding
        case signAuthnRequests
        case providerName
        case displayOnLogin
        case metadataURL
        case endpointCompression
        case selfUri
    }


}




public class GetAgentsWorkPlansRequest: Codable {







    /** The list of agent IDs */
    public var agentIds: [String]?
    /** The start of a date in yyyy-MM-dd format. Response contains values rolled back to nearest BU start day of week. Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd */
    public var startDate: Date?
    /** The number of weeks to query */
    public var weekCount: Int?

    public init(agentIds: [String]?, startDate: Date?, weekCount: Int?) {
        self.agentIds = agentIds
        self.startDate = startDate
        self.weekCount = weekCount
    }


}




public class GetMetricResponse: Codable {







    public var total: Int64?
    public var entities: [Metric]?
    public var selfUri: String?

    public init(total: Int64?, entities: [Metric]?, selfUri: String?) {
        self.total = total
        self.entities = entities
        self.selfUri = selfUri
    }


}




public class GetMetricsResponse: Codable {







    public var total: Int64?
    public var entities: [Metrics]?
    public var selfUri: String?

    public init(total: Int64?, entities: [Metrics]?, selfUri: String?) {
        self.total = total
        self.entities = entities
        self.selfUri = selfUri
    }


}




public class GetUploadSourceUrlJobStatusResponse: Codable {



    public enum Status: String, Codable { 
        case created = "Created"
        case inProgress = "InProgress"
        case completed = "Completed"
        case failed = "Failed"
    }







    /** Id of the upload from URL job. */
    public var _id: String?
    /** Status of the upload job */
    public var status: Status?
    /** Key that identifies the file in the storage including the file name */
    public var uploadKey: String?
    /** Any error information, or null of the processing is not in failed state. */
    public var errorInformation: ErrorBody?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, status: Status?, uploadKey: String?, errorInformation: ErrorBody?, selfUri: String?) {
        self._id = _id
        self.status = status
        self.uploadKey = uploadKey
        self.errorInformation = errorInformation
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case status
        case uploadKey
        case errorInformation
        case selfUri
    }


}




public class GreetingMediaInfo: Codable {







    /** The globally unique identifier for the object. */
    public var _id: String?
    public var mediaFileUri: String?
    public var mediaImageUri: String?

    public init(_id: String?, mediaFileUri: String?, mediaImageUri: String?) {
        self._id = _id
        self.mediaFileUri = mediaFileUri
        self.mediaImageUri = mediaImageUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case mediaFileUri
        case mediaImageUri
    }


}




public class GroupEmailPolicy: Codable {





    public var emailMembers: Bool?
    public var emailGroup: Bool?

    public init(emailMembers: Bool?, emailGroup: Bool?) {
        self.emailMembers = emailMembers
        self.emailGroup = emailGroup
    }


}




public class GroupEntityListing: Codable {





















    public var entities: [Group]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var previousUri: String?
    public var nextUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [Group]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, previousUri: String?, nextUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.previousUri = previousUri
        self.nextUri = nextUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class GroupSearchCriteria: Codable {









    public enum Operator: String, Codable { 
        case and = "AND"
        case or = "OR"
        case not = "NOT"
    }





    public enum ModelType: String, Codable { 
        case exact = "EXACT"
        case startsWith = "STARTS_WITH"
        case contains = "CONTAINS"
        case regex = "REGEX"
        case term = "TERM"
        case terms = "TERMS"
        case requiredFields = "REQUIRED_FIELDS"
        case matchAll = "MATCH_ALL"
    }



    /** The end value of the range. This field is used for range search types. */
    public var endValue: String?
    /** A list of values for the search to match against */
    public var values: [String]?
    /** The start value of the range. This field is used for range search types. */
    public var startValue: String?
    /** A value for the search to match against */
    public var value: String?
    /** How to apply this search criteria against other criteria */
    public var _operator: Operator?
    /** Groups multiple conditions */
    public var group: [GroupSearchCriteria]?
    /** Set date format for criteria values when using date range search type.  Supports Java date format syntax, example yyyy-MM-dd'T'HH:mm:ss.SSSX. */
    public var dateFormat: String?
    /** Search Type */
    public var type: ModelType?
    /** Field names to search against */
    public var fields: [String]?

    public init(endValue: String?, values: [String]?, startValue: String?, value: String?, _operator: Operator?, group: [GroupSearchCriteria]?, dateFormat: String?, type: ModelType?, fields: [String]?) {
        self.endValue = endValue
        self.values = values
        self.startValue = startValue
        self.value = value
        self._operator = _operator
        self.group = group
        self.dateFormat = dateFormat
        self.type = type
        self.fields = fields
    }

    public enum CodingKeys: String, CodingKey { 
        case endValue
        case values
        case startValue
        case value
        case _operator = "operator"
        case group
        case dateFormat
        case type
        case fields
    }


}




public class GuestCategoryResponseListing: Codable {











    public var entities: [GuestResponseCategory]?
    public var nextUri: String?
    public var selfUri: String?
    public var previousUri: String?
    public var sessionId: String?

    public init(entities: [GuestResponseCategory]?, nextUri: String?, selfUri: String?, previousUri: String?, sessionId: String?) {
        self.entities = entities
        self.nextUri = nextUri
        self.selfUri = selfUri
        self.previousUri = previousUri
        self.sessionId = sessionId
    }


}




public class GuestResponseCategory: Codable {

















    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    public var _description: String?
    public var externalId: String?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** The reference to category to which this category belongs. */
    public var parentCategory: GuestCategoryReference?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, _description: String?, externalId: String?, dateCreated: Date?, dateModified: Date?, parentCategory: GuestCategoryReference?, selfUri: String?) {
        self._id = _id
        self.name = name
        self._description = _description
        self.externalId = externalId
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.parentCategory = parentCategory
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case _description = "description"
        case externalId
        case dateCreated
        case dateModified
        case parentCategory
        case selfUri
    }


}




public class GuideSessionTurnInvocationData: Codable {







    /** The action group of the invocation data. */
    public var group: String?
    /** The action name of the invocation data. */
    public var actionName: String?
    /** The output of the invocation data. */
    public var output: String?

    public init(group: String?, actionName: String?, output: String?) {
        self.group = group
        self.actionName = actionName
        self.output = output
    }


}




public class HelpSettings: Codable {





    /** List of keywords for compliance */
    public var keyword: [String]?
    /** The response configuration for the keywords */
    public var response: ComplianceResponse?

    public init(keyword: [String]?, response: ComplianceResponse?) {
        self.keyword = keyword
        self.response = response
    }


}




public class HistoricalDataDeleteEntity: Codable {



    public enum Status: String, Codable { 
        case inProgress = "InProgress"
        case success = "Success"
    }

    public var requestId: String?
    public var status: Status?

    public init(requestId: String?, status: Status?) {
        self.requestId = requestId
        self.status = status
    }


}




public class HistoricalShrinkageActivityCodeResponse: Codable {





    /** The ID of the activity code for which shrinkage data is provided */
    public var activityCodeId: String?
    /** Aggregated shrinkage data for the activity code */
    public var shrinkageForActivityCode: HistoricalShrinkageAggregateResponse?

    public init(activityCodeId: String?, shrinkageForActivityCode: HistoricalShrinkageAggregateResponse?) {
        self.activityCodeId = activityCodeId
        self.shrinkageForActivityCode = shrinkageForActivityCode
    }


}




public class IVRIdentityResolutionConfig: Codable {









    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The division to use when performing identity resolution. */
    public var division: WritableStarrableDivision?
    /** Whether the channel should resolve identities */
    public var resolveIdentities: Bool?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, division: WritableStarrableDivision?, resolveIdentities: Bool?, selfUri: String?) {
        self._id = _id
        self.division = division
        self.resolveIdentities = resolveIdentities
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case division
        case resolveIdentities
        case selfUri
    }


}




public class IdentityProviderEntityListing: Codable {





















    public var entities: [SAMLProvider]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var previousUri: String?
    public var nextUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [SAMLProvider]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, previousUri: String?, nextUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.previousUri = previousUri
        self.nextUri = nextUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class IgnoredActivityCategories: Codable {

    public enum Values: String, Codable { 
        case onQueueWork = "OnQueueWork"
        case _break = "Break"
        case meal = "Meal"
        case meeting = "Meeting"
        case offQueueWork = "OffQueueWork"
        case timeOff = "TimeOff"
        case training = "Training"
        case unavailable = "Unavailable"
    }

    /** Activity categories list */
    public var values: [Values]?

    public init(values: [Values]?) {
        self.values = values
    }


}




public class IgnoredMinedEntity: Codable {





    public enum Participant: String, Codable { 
        case customer = "Customer"
        case agent = "Agent"
        case both = "Both"
    }





    public enum MediaType: String, Codable { 
        case chat = "Chat"
        case call = "Call"
        case message = "Message"
        case email = "Email"
    }

    /** Unique identifier for the ignored entity */
    public var _id: String?
    /** Text of the ignored entity */
    public var text: String?
    /** Type of participant */
    public var participant: Participant?
    /** Date when the ignored entity was created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** Date when the ignored entity was last modified. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** Media Type for the entity (Optional) */
    public var mediaType: MediaType?

    public init(_id: String?, text: String?, participant: Participant?, dateCreated: Date?, dateModified: Date?, mediaType: MediaType?) {
        self._id = _id
        self.text = text
        self.participant = participant
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.mediaType = mediaType
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case text
        case participant
        case dateCreated
        case dateModified
        case mediaType
    }


}




public class InactivityTimeoutSettings: Codable {



    public enum ActionType: String, Codable { 
        case disconnect = "DISCONNECT"
        case sendToArchitectFlow = "SEND_TO_ARCHITECT_FLOW"
    }



    /** Timeout in seconds for inactivity on the interaction */
    public var timeoutSeconds: Int?
    /** Action to take when timeout occurs */
    public var actionType: ActionType?
    /** Flow ID for architect flow action */
    public var flowId: DomainEntityRef?

    public init(timeoutSeconds: Int?, actionType: ActionType?, flowId: DomainEntityRef?) {
        self.timeoutSeconds = timeoutSeconds
        self.actionType = actionType
        self.flowId = flowId
    }


}




public class InitialConfiguration: Codable {













    /** Indicates the initial audio state for the communication. */
    public var audioState: AudioState?
    /** Indicates that this communication's initial state is alerting. If false, the communication started in a connected state. */
    public var alerting: Bool?
    /** Indicates the direction of this communication with respect to the contact center. `true` means the communication is INBOUND. `false` means the communication is OUTBOUND. */
    public var inbound: Bool?
    /** The id of the communication (the \"peer\") that \"invited\" this communication, if this occurred. */
    public var invitedBy: String?
    /** Indicates whether recording is active for this communication at creation. */
    public var recordingActive: Bool?
    /** Additional metadata about this session which should be recorded by the platform but which will not be indexed or searchable. Primarily for diagnostic value. Any information that needs to be accessible through other components like Analytics should be moved to dedicated fields. */
    public var additionalInfo: [String:String]?

    public init(audioState: AudioState?, alerting: Bool?, inbound: Bool?, invitedBy: String?, recordingActive: Bool?, additionalInfo: [String:String]?) {
        self.audioState = audioState
        self.alerting = alerting
        self.inbound = inbound
        self.invitedBy = invitedBy
        self.recordingActive = recordingActive
        self.additionalInfo = additionalInfo
    }


}




public class InsightsDetailsMetricItem: Codable {











    /** The gamification metric for the data */
    public var metric: AddressableEntityRef?
    /** Insights data in the comparative period */
    public var comparativePeriod: InsightsDetailsMetricPeriodPoints?
    /** Insights data in the primary period */
    public var primaryPeriod: InsightsDetailsMetricPeriodPoints?
    /** Percent of goal change */
    public var percentOfGoalChange: Double?
    /** Value change */
    public var valueChange: Double?

    public init(metric: AddressableEntityRef?, comparativePeriod: InsightsDetailsMetricPeriodPoints?, primaryPeriod: InsightsDetailsMetricPeriodPoints?, percentOfGoalChange: Double?, valueChange: Double?) {
        self.metric = metric
        self.comparativePeriod = comparativePeriod
        self.primaryPeriod = primaryPeriod
        self.percentOfGoalChange = percentOfGoalChange
        self.valueChange = valueChange
    }


}




public class InsightsSummaryMetricItem: Codable {











    /** The gamification metric for the data */
    public var metric: AddressableEntityRef?
    /** Insights data in the comparative period */
    public var comparativePeriod: InsightsSummaryMetricPeriodPoints?
    /** Insights data in the primary period */
    public var primaryPeriod: InsightsSummaryMetricPeriodPoints?
    /** Percent of goal change */
    public var percentOfGoalChange: Double?
    /** Value change */
    public var valueChange: Double?

    public init(metric: AddressableEntityRef?, comparativePeriod: InsightsSummaryMetricPeriodPoints?, primaryPeriod: InsightsSummaryMetricPeriodPoints?, percentOfGoalChange: Double?, valueChange: Double?) {
        self.metric = metric
        self.comparativePeriod = comparativePeriod
        self.primaryPeriod = primaryPeriod
        self.percentOfGoalChange = percentOfGoalChange
        self.valueChange = valueChange
    }


}



/** User information for an Instagram account */

public class InstagramId: Codable {







    /** The set of scopedIds that this person has. Each scopedId is specific to an Instagram page or app that the user interacts with. */
    public var ids: [InstagramScopedId]?
    /** The displayName of the person who owns this Instagram account */
    public var displayName: String?
    /** The handle of the person who owns this Instagram account */
    public var handle: String?

    public init(ids: [InstagramScopedId]?, displayName: String?, handle: String?) {
        self.ids = ids
        self.displayName = displayName
        self.handle = handle
    }


}




public class InstagramIntegrationEntityListing: Codable {





















    public var entities: [InstagramIntegration]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var previousUri: String?
    public var nextUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [InstagramIntegration]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, previousUri: String?, nextUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.previousUri = previousUri
        self.nextUri = nextUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class IntegrationAction: Codable {





    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, selfUri: String?) {
        self._id = _id
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
    }


}




public class IntentReference: Codable {





    /** ID of the intent. */
    public var _id: String?
    /** The name of the intent. */
    public var name: String?

    public init(_id: String?, name: String?) {
        self._id = _id
        self.name = name
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
    }


}




public class IpAddressAuthentication: Codable {



    public var networkWhitelist: [String]?

    public init(networkWhitelist: [String]?) {
        self.networkWhitelist = networkWhitelist
    }


}




public class IvrEstablishedEvent: Codable {





















    /** A unique (V4 UUID) eventId for this event */
    public var eventId: String?
    /** A Date Time representing the time this event occurred. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var eventDateTime: Date?
    /** A unique Id (V4 UUID) identifying this conversation */
    public var conversationId: String?
    /** A unique Id (V4 UUID) identifying this communication */
    public var communicationId: String?
    /** The phone number for this IVR, if any is known */
    public var ivrPhoneNumber: String?
    /** A displayable name for this IVR, if any is known. */
    public var ivrName: String?
    /** The automatic number identification if it is available for this conversation. */
    public var ani: String?
    /** The dialed number identification if it is available for this conversation. */
    public var dnis: String?
    /** Metadata about this communication. */
    public var initialConfiguration: InitialConfiguration?
    /** Metadata about the source of this communication's interaction. */
    public var sourceConfiguration: SourceConfiguration?

    public init(eventId: String?, eventDateTime: Date?, conversationId: String?, communicationId: String?, ivrPhoneNumber: String?, ivrName: String?, ani: String?, dnis: String?, initialConfiguration: InitialConfiguration?, sourceConfiguration: SourceConfiguration?) {
        self.eventId = eventId
        self.eventDateTime = eventDateTime
        self.conversationId = conversationId
        self.communicationId = communicationId
        self.ivrPhoneNumber = ivrPhoneNumber
        self.ivrName = ivrName
        self.ani = ani
        self.dnis = dnis
        self.initialConfiguration = initialConfiguration
        self.sourceConfiguration = sourceConfiguration
    }


}




public class JourneyAggregateQueryResponse: Codable {



    public var results: [JourneyAggregateDataContainer]?

    public init(results: [JourneyAggregateDataContainer]?) {
        self.results = results
    }


}




public class JourneyAggregationView: Codable {

    public enum Target: String, Codable { 
        case ndistinctjourneyactions = "nDistinctJourneyActions"
        case ndistinctjourneysessions = "nDistinctJourneySessions"
        case njourneyactionsblocked = "nJourneyActionsBlocked"
        case njourneyoutcomesachieved = "nJourneyOutcomesAchieved"
        case njourneyoutcomesattributed = "nJourneyOutcomesAttributed"
        case njourneysegmentsassigned = "nJourneySegmentsAssigned"
        case njourneysessions = "nJourneySessions"
        case nwebactionsabandoned = "nWebActionsAbandoned"
        case nwebactionsaccepted = "nWebActionsAccepted"
        case nwebactionsengaged = "nWebActionsEngaged"
        case nwebactionserrored = "nWebActionsErrored"
        case nwebactionsfrequencycapreached = "nWebActionsFrequencyCapReached"
        case nwebactionsignored = "nWebActionsIgnored"
        case nwebactionsoffered = "nWebActionsOffered"
        case nwebactionsofferedoutsideschedule = "nWebActionsOfferedOutsideSchedule"
        case nwebactionsqualified = "nWebActionsQualified"
        case nwebactionsqualifiedoutsideschedule = "nWebActionsQualifiedOutsideSchedule"
        case nwebactionsrejected = "nWebActionsRejected"
        case nwebactionsstarted = "nWebActionsStarted"
        case nwebactionstimedout = "nWebActionsTimedout"
        case ojourneyoutcometouchpointvalue = "oJourneyOutcomeTouchpointValue"
        case ojourneyoutcomevalue = "oJourneyOutcomeValue"
    }



    public enum Function: String, Codable { 
        case rangebound = "rangeBound"
    }



    /** Target metric name */
    public var target: Target?
    /** A unique name for this view. Must be distinct from other views and built-in metric names. */
    public var name: String?
    /** Type of view you wish to create */
    public var function: Function?
    /** Range of numbers for slicing up data */
    public var range: AggregationRange?

    public init(target: Target?, name: String?, function: Function?, range: AggregationRange?) {
        self.target = target
        self.name = name
        self.function = function
        self.range = range
    }


}




public class JourneyApp: Codable {









    /** Name of the application (e.g. mybankingapp). */
    public var name: String?
    /** Namespace of the application (e.g. com.genesys.bancodinero). */
    public var namespace: String?
    /** Version of the application (e.g. 5.9.27). */
    public var version: String?
    /** Build number of the application (e.g. 701). */
    public var buildNumber: String?

    public init(name: String?, namespace: String?, version: String?, buildNumber: String?) {
        self.name = name
        self.namespace = namespace
        self.version = version
        self.buildNumber = buildNumber
    }


}




public class JourneyAppEventsNotificationActionTarget: Codable {





    public var _id: String?
    public var selfUri: String?

    public init(_id: String?, selfUri: String?) {
        self._id = _id
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
    }


}




public class JourneyAppEventsNotificationExternalContact: Codable {





    public var _id: String?
    public var selfUri: String?

    public init(_id: String?, selfUri: String?) {
        self._id = _id
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
    }


}




public class JourneyAppEventsNotificationSegmentAssignmentMessage: Codable {



    public enum AssignmentState: String, Codable { 
        case unknown = "Unknown"
        case assigned = "Assigned"
        case unassigned = "Unassigned"
    }





    public var segment: JourneyAppEventsNotificationSegment?
    public var assignmentState: AssignmentState?
    public var dateAssigned: Date?
    public var dateForUnassignment: Date?

    public init(segment: JourneyAppEventsNotificationSegment?, assignmentState: AssignmentState?, dateAssigned: Date?, dateForUnassignment: Date?) {
        self.segment = segment
        self.assignmentState = assignmentState
        self.dateAssigned = dateAssigned
        self.dateForUnassignment = dateForUnassignment
    }


}




public class JourneyAppEventsNotificationWebActionMessage: Codable {





























    public var action: JourneyAppEventsNotificationEventAction?
    public var actionTarget: JourneyAppEventsNotificationActionTarget?
    public var actionMap: JourneyAppEventsNotificationActionMap?
    public var errorCode: String?
    public var errorMessage: String?
    public var userAgentString: String?
    public var ipAddress: String?
    public var ipOrganization: String?
    public var browser: JourneyAppEventsNotificationBrowser?
    public var device: JourneyAppEventsNotificationDevice?
    public var geolocation: JourneyAppEventsNotificationGeoLocation?
    public var mktCampaign: JourneyAppEventsNotificationMktCampaign?
    public var visitReferrer: JourneyAppEventsNotificationReferrer?
    public var timeToDisposition: Int64?

    public init(action: JourneyAppEventsNotificationEventAction?, actionTarget: JourneyAppEventsNotificationActionTarget?, actionMap: JourneyAppEventsNotificationActionMap?, errorCode: String?, errorMessage: String?, userAgentString: String?, ipAddress: String?, ipOrganization: String?, browser: JourneyAppEventsNotificationBrowser?, device: JourneyAppEventsNotificationDevice?, geolocation: JourneyAppEventsNotificationGeoLocation?, mktCampaign: JourneyAppEventsNotificationMktCampaign?, visitReferrer: JourneyAppEventsNotificationReferrer?, timeToDisposition: Int64?) {
        self.action = action
        self.actionTarget = actionTarget
        self.actionMap = actionMap
        self.errorCode = errorCode
        self.errorMessage = errorMessage
        self.userAgentString = userAgentString
        self.ipAddress = ipAddress
        self.ipOrganization = ipOrganization
        self.browser = browser
        self.device = device
        self.geolocation = geolocation
        self.mktCampaign = mktCampaign
        self.visitReferrer = visitReferrer
        self.timeToDisposition = timeToDisposition
    }


}



/** The representation of a case association on a journey session. */

public class JourneyCaseAssociation: Codable {











    /** The ID of the association. */
    public var _id: String?
    /** The case that was associated with the journey session. */
    public var associatedCase: AddressableEntityRef?
    /** The reference for the case that was associated with the journey session. */
    public var caseReference: String?
    /** The date of the association. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateAssociated: Date?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, associatedCase: AddressableEntityRef?, caseReference: String?, dateAssociated: Date?, selfUri: String?) {
        self._id = _id
        self.associatedCase = associatedCase
        self.caseReference = caseReference
        self.dateAssociated = dateAssociated
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case associatedCase
        case caseReference
        case dateAssociated
        case selfUri
    }


}




public class JourneyOutcomeEventsNotificationAssociatedValue: Codable {

    public enum DataType: String, Codable { 
        case number = "Number"
        case integer = "Integer"
    }



    public var dataType: DataType?
    public var value: Double?

    public init(dataType: DataType?, value: Double?) {
        self.dataType = dataType
        self.value = value
    }


}




public class JourneyOutcomeEventsNotificationGeoLocation: Codable {





















    public var country: String?
    public var countryName: String?
    public var latitude: Double?
    public var longitude: Double?
    public var locality: String?
    public var postalCode: String?
    public var region: String?
    public var regionName: String?
    public var timezone: String?
    public var source: String?

    public init(country: String?, countryName: String?, latitude: Double?, longitude: Double?, locality: String?, postalCode: String?, region: String?, regionName: String?, timezone: String?, source: String?) {
        self.country = country
        self.countryName = countryName
        self.latitude = latitude
        self.longitude = longitude
        self.locality = locality
        self.postalCode = postalCode
        self.region = region
        self.regionName = regionName
        self.timezone = timezone
        self.source = source
    }


}




public class JourneyOutcomeEventsNotificationOutcomeTouchpointChannel: Codable {

    public enum ModelType: String, Codable { 
        case unknown = "Unknown"
        case contentOffer = "ContentOffer"
        case webchat = "Webchat"
    }

    public var type: ModelType?

    public init(type: ModelType?) {
        self.type = type
    }


}




public class JourneyOutcomeEventsNotificationSegment: Codable {







    public var _id: UUID?
    public var selfUri: String?
    public var assignedDate: Date?

    public init(_id: UUID?, selfUri: String?, assignedDate: Date?) {
        self._id = _id
        self.selfUri = selfUri
        self.assignedDate = assignedDate
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
        case assignedDate
    }


}




public class JourneyPattern: Codable {





    public enum StreamType: String, Codable { 
        case web = "Web"
        case custom = "Custom"
        case conversation = "Conversation"
        case app = "App"
    }





    /** A list of one or more criteria to satisfy. */
    public var criteria: [Criteria]?
    /** The number of times the pattern must match. */
    public var count: Int?
    /** The stream type for which this pattern can be matched on. */
    public var streamType: StreamType?
    /** The session type for which this pattern can be matched on. */
    public var sessionType: String?
    /** The name of the event for which this pattern can be matched on. */
    public var eventName: String?

    public init(criteria: [Criteria]?, count: Int?, streamType: StreamType?, sessionType: String?, eventName: String?) {
        self.criteria = criteria
        self.count = count
        self.streamType = streamType
        self.sessionType = sessionType
        self.eventName = eventName
    }


}




public class JourneySegmentAssignmentEventsNotificationSegment: Codable {





    public var _id: UUID?
    public var selfUri: String?

    public init(_id: UUID?, selfUri: String?) {
        self._id = _id
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
    }


}




public class JourneySessionEventsNotificationBrowser: Codable {





















    public var family: String?
    public var version: String?
    public var lang: String?
    public var fingerprint: String?
    public var viewHeight: Int64?
    public var viewWidth: Int64?
    public var featuresFlash: Bool?
    public var featuresJava: Bool?
    public var featuresPdf: Bool?
    public var featuresWebrtc: Bool?

    public init(family: String?, version: String?, lang: String?, fingerprint: String?, viewHeight: Int64?, viewWidth: Int64?, featuresFlash: Bool?, featuresJava: Bool?, featuresPdf: Bool?, featuresWebrtc: Bool?) {
        self.family = family
        self.version = version
        self.lang = lang
        self.fingerprint = fingerprint
        self.viewHeight = viewHeight
        self.viewWidth = viewWidth
        self.featuresFlash = featuresFlash
        self.featuresJava = featuresJava
        self.featuresPdf = featuresPdf
        self.featuresWebrtc = featuresWebrtc
    }


}




public class JourneySessionEventsNotificationConversation: Codable {





    public var _id: UUID?
    public var selfUri: String?

    public init(_id: UUID?, selfUri: String?) {
        self._id = _id
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
    }


}




public class JourneySessionEventsNotificationMktCampaign: Codable {















    public var content: String?
    public var medium: String?
    public var name: String?
    public var source: String?
    public var term: String?
    public var clickId: String?
    public var network: String?

    public init(content: String?, medium: String?, name: String?, source: String?, term: String?, clickId: String?, network: String?) {
        self.content = content
        self.medium = medium
        self.name = name
        self.source = source
        self.term = term
        self.clickId = clickId
        self.network = network
    }


}




public class JourneySessionEventsNotificationNetworkConnectivity: Codable {









    public var carrier: String?
    public var bluetoothEnabled: Bool?
    public var cellularEnabled: Bool?
    public var wifiEnabled: Bool?

    public init(carrier: String?, bluetoothEnabled: Bool?, cellularEnabled: Bool?, wifiEnabled: Bool?) {
        self.carrier = carrier
        self.bluetoothEnabled = bluetoothEnabled
        self.cellularEnabled = cellularEnabled
        self.wifiEnabled = wifiEnabled
    }


}




public class JourneySessionEventsNotificationSdkLibrary: Codable {





    public var name: String?
    public var version: String?

    public init(name: String?, version: String?) {
        self.name = name
        self.version = version
    }


}




public class JourneySessionEventsNotificationUser: Codable {





    public var _id: String?
    public var selfUri: String?

    public init(_id: String?, selfUri: String?) {
        self._id = _id
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
    }


}



/** A chart within the context of the elements of the the journey view */

public class JourneyViewChart: Codable {







    public enum GroupByTime: String, Codable { 
        case day = "Day"
        case week = "Week"
        case month = "Month"
        case year = "Year"
    }











    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** The version of the journey view chart */
    public var version: Int?
    /** A time unit to group the metrics by. There is a limit on the number of groupBy properties which can be specified. */
    public var groupByTime: GroupByTime?
    /** A list of attributes to group the metrics by. There is a limit on the number of groupBy properties which can be specified. */
    public var groupByAttributes: [JourneyViewChartGroupByAttribute]?
    /** A list of metrics to calculate within the chart by (aka the y axis) */
    public var metrics: [JourneyViewChartMetric]?
    /** Optional display attributes for rendering the chart */
    public var displayAttributes: JourneyViewChartDisplayAttributes?
    /** A maximum on the number of values being grouped by */
    public var groupByMax: Int64?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, version: Int?, groupByTime: GroupByTime?, groupByAttributes: [JourneyViewChartGroupByAttribute]?, metrics: [JourneyViewChartMetric]?, displayAttributes: JourneyViewChartDisplayAttributes?, groupByMax: Int64?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.version = version
        self.groupByTime = groupByTime
        self.groupByAttributes = groupByAttributes
        self.metrics = metrics
        self.displayAttributes = displayAttributes
        self.groupByMax = groupByMax
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case version
        case groupByTime
        case groupByAttributes
        case metrics
        case displayAttributes
        case groupByMax
        case selfUri
    }


}



/** A journey element attribute to group by within the chart */

public class JourneyViewChartGroupByAttribute: Codable {





    /** The element in the list of elements which is being grouped by */
    public var elementId: String?
    /** The attribute of the element being grouped by */
    public var attribute: String?

    public init(elementId: String?, attribute: String?) {
        self.elementId = elementId
        self.attribute = attribute
    }


}




public class JourneyViewChartMetricResultValue: Codable {





    /** Value for this metric */
    public var value: Int?
    /** Group by attributes for this metric */
    public var groupByAttributes: [GroupByAttribute]?

    public init(value: Int?, groupByAttributes: [GroupByAttribute]?) {
        self.value = value
        self.groupByAttributes = groupByAttributes
    }


}



/** Display attributes for an element in a journey view */

public class JourneyViewElementDisplayAttributes: Codable {







    /** The horizontal position (x-coordinate) of the element on the journey view canvas */
    public var x: Int?
    /** The vertical position (y-coordinate) of the element on the journey view canvas */
    public var y: Int?
    /** The column position for the element in the journey view canvas */
    public var col: Int?

    public init(x: Int?, y: Int?, col: Int?) {
        self.x = x
        self.y = y
        self.col = col
    }


}



/** A set of filters on an element within a journey view */

public class JourneyViewElementFilter: Codable {

    public enum ModelType: String, Codable { 
        case and = "And"
    }





    /** Boolean operation to apply to the provided predicates and clauses. Valid values: And */
    public var type: ModelType?
    /** predicates */
    public var predicates: [JourneyViewElementFilterPredicate]?
    /** numberPredicates */
    public var numberPredicates: [JourneyViewElementFilterNumberPredicate]?

    public init(type: ModelType?, predicates: [JourneyViewElementFilterPredicate]?, numberPredicates: [JourneyViewElementFilterNumberPredicate]?) {
        self.type = type
        self.predicates = predicates
        self.numberPredicates = numberPredicates
    }


}



/** A numeric filter on an element within a journey view */

public class JourneyViewElementFilterNumberPredicate: Codable {



    public enum Operator: String, Codable { 
        case matches = "Matches"
        case notMatches = "NotMatches"
    }





    /** the element's attribute being filtered on */
    public var dimension: String?
    /** Optional operator, default is Matches. Valid values: Matches */
    public var _operator: Operator?
    /** set this to true if no specific value to be considered */
    public var noValue: Bool?
    /** the range of comparators to filter on */
    public var range: JourneyViewElementFilterRange?

    public init(dimension: String?, _operator: Operator?, noValue: Bool?, range: JourneyViewElementFilterRange?) {
        self.dimension = dimension
        self._operator = _operator
        self.noValue = noValue
        self.range = range
    }

    public enum CodingKeys: String, CodingKey { 
        case dimension
        case _operator = "operator"
        case noValue
        case range
    }


}




public class JourneyViewJob: Codable {







    public enum Status: String, Codable { 
        case accepted = "Accepted"
        case executing = "Executing"
        case complete = "Complete"
        case failed = "Failed"
        case cancelled = "Cancelled"
        case scheduled = "Scheduled"
    }











    /** The globally unique identifier for the object. */
    public var _id: String?
    /** Timestamp of execution. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** Timestamp of completion. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCompleted: Date?
    /** The status of the job */
    public var status: Status?
    /** The journey view for which the job is executed */
    public var journeyView: JourneyView?
    /** Timestamp for the estimated time of completion. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCompletionEstimated: Date?
    /** Margin of error of the estimated time of completion */
    public var estimatedCompletionMargin: Int64?
    /** Id of the user who submitted the request */
    public var userId: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, dateCreated: Date?, dateCompleted: Date?, status: Status?, journeyView: JourneyView?, dateCompletionEstimated: Date?, estimatedCompletionMargin: Int64?, userId: String?, selfUri: String?) {
        self._id = _id
        self.dateCreated = dateCreated
        self.dateCompleted = dateCompleted
        self.status = status
        self.journeyView = journeyView
        self.dateCompletionEstimated = dateCompletionEstimated
        self.estimatedCompletionMargin = estimatedCompletionMargin
        self.userId = userId
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case dateCreated
        case dateCompleted
        case status
        case journeyView
        case dateCompletionEstimated
        case estimatedCompletionMargin
        case userId
        case selfUri
    }


}




public class JourneyViewJobListing: Codable {





















    public var entities: [JourneyViewJob]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var previousUri: String?
    public var nextUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [JourneyViewJob]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, previousUri: String?, nextUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.previousUri = previousUri
        self.nextUri = nextUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class JourneyViewJobNotificationTopicJourneyView: Codable {





    public var _id: UUID?
    public var version: Int64?

    public init(_id: UUID?, version: Int64?) {
        self._id = _id
        self.version = version
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case version
    }


}



/** A link between elements in a journey view */

public class JourneyViewLink: Codable {







    public enum EventCountType: String, Codable { 
        case all = "All"
        case concurrent = "Concurrent"
        case sequential = "Sequential"
    }



    /** The identifier of the element downstream */
    public var _id: String?
    /** A time constraint on this link, which requires a customer to complete the downstream element within this amount of time to be counted. */
    public var constraintWithin: JourneyViewLinkTimeConstraint?
    /** A time constraint on this link, which requires a customer must complete the downstream element after this amount of time to be counted. */
    public var constraintAfter: JourneyViewLinkTimeConstraint?
    /** The type of events that will be counted. Note: Concurrent will override any JourneyViewLinkTimeConstraint. Default is Sequential. */
    public var eventCountType: EventCountType?
    /** Other (secondary) attributes on which this link should join the customers being counted */
    public var joinAttributes: [String]?

    public init(_id: String?, constraintWithin: JourneyViewLinkTimeConstraint?, constraintAfter: JourneyViewLinkTimeConstraint?, eventCountType: EventCountType?, joinAttributes: [String]?) {
        self._id = _id
        self.constraintWithin = constraintWithin
        self.constraintAfter = constraintAfter
        self.eventCountType = eventCountType
        self.joinAttributes = joinAttributes
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case constraintWithin
        case constraintAfter
        case eventCountType
        case joinAttributes
    }


}




public class JourneyViewLinkTimeConstraint: Codable {

    public enum Unit: String, Codable { 
        case seconds = "Seconds"
        case minutes = "Minutes"
        case hours = "Hours"
        case days = "Days"
        case weeks = "Weeks"
        case months = "Months"
    }



    /** The unit for the link's time constraint */
    public var unit: Unit?
    /** The value for the link's time constraint */
    public var value: Int?

    public init(unit: Unit?, value: Int?) {
        self.unit = unit
        self.value = value
    }


}



/** An element within a journey view result */

public class JourneyViewResultElement: Codable {









    /** The globally unique identifier for the object. */
    public var _id: String?
    /** the metrics of the current element */
    public var metrics: JourneyViewResultMetrics?
    /** the list of links following the current element in the journey */
    public var followedBy: [JourneyViewResultLink]?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, metrics: JourneyViewResultMetrics?, followedBy: [JourneyViewResultLink]?, selfUri: String?) {
        self._id = _id
        self.metrics = metrics
        self.followedBy = followedBy
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case metrics
        case followedBy
        case selfUri
    }


}




public class JourneyViewSchedule: Codable {



    public enum Frequency: String, Codable { 
        case daily = "Daily"
        case weekly = "Weekly"
        case monthly = "Monthly"
    }







    /** The globally unique identifier for the object. */
    public var _id: String?
    /** Frequency of execution */
    public var frequency: Frequency?
    /** Timestamp of last update. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** Last modified user */
    public var user: AddressableEntityRef?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, frequency: Frequency?, dateModified: Date?, user: AddressableEntityRef?, selfUri: String?) {
        self._id = _id
        self.frequency = frequency
        self.dateModified = dateModified
        self.user = user
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case frequency
        case dateModified
        case user
        case selfUri
    }


}




public class JourneyViewScheduleListing: Codable {





















    public var entities: [JourneyViewSchedule]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var previousUri: String?
    public var nextUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [JourneyViewSchedule]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, previousUri: String?, nextUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.previousUri = previousUri
        self.nextUri = nextUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class JourneyWebActionEventsNotificationGeoLocation: Codable {





















    public var country: String?
    public var countryName: String?
    public var latitude: Double?
    public var longitude: Double?
    public var locality: String?
    public var postalCode: String?
    public var region: String?
    public var regionName: String?
    public var timezone: String?
    public var source: String?

    public init(country: String?, countryName: String?, latitude: Double?, longitude: Double?, locality: String?, postalCode: String?, region: String?, regionName: String?, timezone: String?, source: String?) {
        self.country = country
        self.countryName = countryName
        self.latitude = latitude
        self.longitude = longitude
        self.locality = locality
        self.postalCode = postalCode
        self.region = region
        self.regionName = regionName
        self.timezone = timezone
        self.source = source
    }


}




public class JourneyWebActionEventsNotificationScheduleGroup: Codable {





    public var _id: String?
    public var selfUri: String?

    public init(_id: String?, selfUri: String?) {
        self._id = _id
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
    }


}




public class JourneyWebEventsNotificationOutcomeAchievedMessage: Codable {























    public var outcome: JourneyWebEventsNotificationOutcome?
    public var browser: JourneyWebEventsNotificationBrowser?
    public var visitCreatedDate: Date?
    public var ipAddress: String?
    public var ipOrganization: String?
    public var userAgentString: String?
    public var device: JourneyWebEventsNotificationDevice?
    public var geolocation: JourneyWebEventsNotificationGeoLocation?
    public var mktCampaign: JourneyWebEventsNotificationMktCampaign?
    public var visitReferrer: JourneyWebEventsNotificationReferrer?
    public var associatedValue: JourneyWebEventsNotificationAssociatedValue?

    public init(outcome: JourneyWebEventsNotificationOutcome?, browser: JourneyWebEventsNotificationBrowser?, visitCreatedDate: Date?, ipAddress: String?, ipOrganization: String?, userAgentString: String?, device: JourneyWebEventsNotificationDevice?, geolocation: JourneyWebEventsNotificationGeoLocation?, mktCampaign: JourneyWebEventsNotificationMktCampaign?, visitReferrer: JourneyWebEventsNotificationReferrer?, associatedValue: JourneyWebEventsNotificationAssociatedValue?) {
        self.outcome = outcome
        self.browser = browser
        self.visitCreatedDate = visitCreatedDate
        self.ipAddress = ipAddress
        self.ipOrganization = ipOrganization
        self.userAgentString = userAgentString
        self.device = device
        self.geolocation = geolocation
        self.mktCampaign = mktCampaign
        self.visitReferrer = visitReferrer
        self.associatedValue = associatedValue
    }


}




public class JourneyWebEventsNotificationReferrer: Codable {

















    public enum Medium: String, Codable { 
        case _internal = "internal"
        case search = "search"
        case social = "social"
        case email = "email"
        case unknown = "unknown"
        case paid = "paid"
    }

    public var url: String?
    public var domain: String?
    public var hostname: String?
    public var keywords: String?
    public var pathname: String?
    public var queryString: String?
    public var fragment: String?
    public var name: String?
    public var medium: Medium?

    public init(url: String?, domain: String?, hostname: String?, keywords: String?, pathname: String?, queryString: String?, fragment: String?, name: String?, medium: Medium?) {
        self.url = url
        self.domain = domain
        self.hostname = hostname
        self.keywords = keywords
        self.pathname = pathname
        self.queryString = queryString
        self.fragment = fragment
        self.name = name
        self.medium = medium
    }


}




public class KeyPerformanceIndicatorAssessment: Codable {



    public enum AssessmentResult: String, Codable { 
        case unknown = "Unknown"
        case notSupported = "NotSupported"
        case high = "High"
        case low = "Low"
        case error = "Error"
    }



    /** Name of the key performance indicator assessed. */
    public var kpi: String?
    /** The overall result of the assessment for a key performance indicator. */
    public var assessmentResult: AssessmentResult?
    /** Set of checks executed as part of an assessment. */
    public var checks: [Check]?

    public init(kpi: String?, assessmentResult: AssessmentResult?, checks: [Check]?) {
        self.kpi = kpi
        self.assessmentResult = assessmentResult
        self.checks = checks
    }


}




public class KnowledgeAggregateQueryResponse: Codable {



    public var results: [KnowledgeAggregateDataContainer]?

    public init(results: [KnowledgeAggregateDataContainer]?) {
        self.results = results
    }


}




public class KnowledgeAggregationView: Codable {

    public enum Target: String, Codable { 
        case ndistinctknowledgesessions = "nDistinctKnowledgeSessions"
        case nknowledgedocumentcopied = "nKnowledgeDocumentCopied"
        case nknowledgedocumentfeedback = "nKnowledgeDocumentFeedback"
        case nknowledgedocumentpresented = "nKnowledgeDocumentPresented"
        case nknowledgedocumentsurfaced = "nKnowledgeDocumentSurfaced"
        case nknowledgedocumentviewed = "nKnowledgeDocumentViewed"
        case nknowledgesearch = "nKnowledgeSearch"
        case nknowledgesearchanswered = "nKnowledgeSearchAnswered"
        case nknowledgesearchfeedback = "nKnowledgeSearchFeedback"
        case nknowledgesearchunanswered = "nKnowledgeSearchUnanswered"
        case nknowledgesessions = "nKnowledgeSessions"
        case oknowledgedocumentquery = "oKnowledgeDocumentQuery"
        case oknowledgedocumentqueryselfserved = "oKnowledgeDocumentQuerySelfServed"
        case oknowledgesearch = "oKnowledgeSearch"
    }



    public enum Function: String, Codable { 
        case rangebound = "rangeBound"
    }



    /** Target metric name */
    public var target: Target?
    /** A unique name for this view. Must be distinct from other views and built-in metric names. */
    public var name: String?
    /** Type of view you wish to create */
    public var function: Function?
    /** Range of numbers for slicing up data */
    public var range: AggregationRange?

    public init(target: Target?, name: String?, function: Function?, range: AggregationRange?) {
        self.target = target
        self.name = name
        self.function = function
        self.range = range
    }


}




public class KnowledgeBase: Codable {







    public enum CoreLanguage: String, Codable { 
        case enUs = "en-US"
        case enUk = "en-UK"
        case enAu = "en-AU"
        case enCa = "en-CA"
        case enHk = "en-HK"
        case enIn = "en-IN"
        case enIe = "en-IE"
        case enNz = "en-NZ"
        case enPh = "en-PH"
        case enSg = "en-SG"
        case enZa = "en-ZA"
        case deDe = "de-DE"
        case deAt = "de-AT"
        case deCh = "de-CH"
        case esAr = "es-AR"
        case esCo = "es-CO"
        case esMx = "es-MX"
        case esUs = "es-US"
        case esEs = "es-ES"
        case frFr = "fr-FR"
        case frBe = "fr-BE"
        case frCa = "fr-CA"
        case frCh = "fr-CH"
        case ptBr = "pt-BR"
        case ptPt = "pt-PT"
        case nlNl = "nl-NL"
        case nlBe = "nl-BE"
        case itIt = "it-IT"
        case caEs = "ca-ES"
        case trTr = "tr-TR"
        case svSe = "sv-SE"
        case fiFi = "fi-FI"
        case nbNo = "nb-NO"
        case daDk = "da-DK"
        case jaJp = "ja-JP"
        case arAe = "ar-AE"
        case zhCn = "zh-CN"
        case zhTw = "zh-TW"
        case zhHk = "zh-HK"
        case koKr = "ko-KR"
        case plPl = "pl-PL"
        case hiIn = "hi-IN"
        case thTh = "th-TH"
        case huHu = "hu-HU"
        case viVn = "vi-VN"
        case ukUa = "uk-UA"
        case csCz = "cs-CZ"
        case filPh = "fil-PH"
        case msMy = "ms-MY"
        case heIl = "he-IL"
        case elGr = "el-GR"
    }















    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** Knowledge base description */
    public var _description: String?
    /** Core language for knowledge base in which initial content must be created, language codes [en-US, en-UK, en-AU, de-DE] are supported currently. However, the new DX knowledge will support all these language codes, along with 'early preview' language codes [ca-ES, tr-TR, sv-SE, fi-FI, nb-NO, da-DK, ja-JP, ar-AE, zh-CN, zh-TW, zh-HK, ko-KR, pl-PL, hi-IN, th-TH, hu-HU, vi-VN, uk-UA] which might have a lower accuracy. */
    public var coreLanguage: CoreLanguage?
    /** Knowledge base creation date-time. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** Knowledge base last modification date-time. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** The count representing the number of documents of type FAQ in the KnowledgeBase */
    public var faqCount: Int?
    /** The date representing when the last document is modified. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateDocumentLastModified: Date?
    /** The count representing the number of documents of type Article in the KnowledgeBase */
    public var articleCount: Int?
    /** Flag that indicates the knowledge base is published */
    public var published: Bool?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, _description: String?, coreLanguage: CoreLanguage?, dateCreated: Date?, dateModified: Date?, faqCount: Int?, dateDocumentLastModified: Date?, articleCount: Int?, published: Bool?, selfUri: String?) {
        self._id = _id
        self.name = name
        self._description = _description
        self.coreLanguage = coreLanguage
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.faqCount = faqCount
        self.dateDocumentLastModified = dateDocumentLastModified
        self.articleCount = articleCount
        self.published = published
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case _description = "description"
        case coreLanguage
        case dateCreated
        case dateModified
        case faqCount
        case dateDocumentLastModified
        case articleCount
        case published
        case selfUri
    }


}




public class KnowledgeBaseListing: Codable {









    public var entities: [KnowledgeBase]?
    public var nextUri: String?
    public var selfUri: String?
    public var previousUri: String?

    public init(entities: [KnowledgeBase]?, nextUri: String?, selfUri: String?, previousUri: String?) {
        self.entities = entities
        self.nextUri = nextUri
        self.selfUri = selfUri
        self.previousUri = previousUri
    }


}




public class KnowledgeDocumentFeedback: Codable {





    public enum Rating: String, Codable { 
        case negative = "Negative"
        case positive = "Positive"
    }

    public enum Reason: String, Codable { 
        case documentContent = "DocumentContent"
        case searchResults = "SearchResults"
    }









    public enum QueryType: String, Codable { 
        case unknown = "Unknown"
        case article = "Article"
        case autoSearch = "AutoSearch"
        case category = "Category"
        case manualSearch = "ManualSearch"
        case recommendation = "Recommendation"
        case suggestion = "Suggestion"
        case expandedArticle = "ExpandedArticle"
    }

    public enum SurfacingMethod: String, Codable { 
        case unknown = "Unknown"
        case article = "Article"
        case snippet = "Snippet"
        case highlight = "Highlight"
        case generative = "Generative"
    }

    public enum State: String, Codable { 
        case draft = "Draft"
        case _final = "Final"
    }











    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The variation of the document on which feedback was given. */
    public var documentVariation: EntityReference?
    /** Feedback rating. */
    public var rating: Rating?
    /** Feedback reason. */
    public var reason: Reason?
    /** Free-text comment of the feedback. Maximum length: 2000 characters. */
    public var comment: String?
    /** The search that surfaced the document on which feedback was given. */
    public var search: EntityReference?
    /** Knowledge guest session ID. */
    public var sessionId: String?
    /** The date and time of the feedback. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** The type of the query that surfaced the document on which the feedback was given. */
    public var queryType: QueryType?
    /** The method how knowledge was surfaced. Article: Full article was shown. Snippet: A snippet from the article was shown. Highlight: A highlighted answer in a snippet was shown.Generative: A generated answer in a snippet was shown. */
    public var surfacingMethod: SurfacingMethod?
    /** The state of the feedback. */
    public var state: State?
    /** The document on which feedback was given. */
    public var document: KnowledgeDocumentVersionReference?
    /** The client application from which feedback was given. */
    public var application: KnowledgeSearchClientApplication?
    /** Conversation context information if the feedback is given in the context of a conversation. */
    public var conversationContext: KnowledgeConversationContext?
    /** The ID of the user who created the feedback. */
    public var userId: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, documentVariation: EntityReference?, rating: Rating?, reason: Reason?, comment: String?, search: EntityReference?, sessionId: String?, dateCreated: Date?, queryType: QueryType?, surfacingMethod: SurfacingMethod?, state: State?, document: KnowledgeDocumentVersionReference?, application: KnowledgeSearchClientApplication?, conversationContext: KnowledgeConversationContext?, userId: String?, selfUri: String?) {
        self._id = _id
        self.documentVariation = documentVariation
        self.rating = rating
        self.reason = reason
        self.comment = comment
        self.search = search
        self.sessionId = sessionId
        self.dateCreated = dateCreated
        self.queryType = queryType
        self.surfacingMethod = surfacingMethod
        self.state = state
        self.document = document
        self.application = application
        self.conversationContext = conversationContext
        self.userId = userId
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case documentVariation
        case rating
        case reason
        case comment
        case search
        case sessionId
        case dateCreated
        case queryType
        case surfacingMethod
        case state
        case document
        case application
        case conversationContext
        case userId
        case selfUri
    }


}




public class KnowledgeDocumentGuestSearch: Codable {













    public enum QueryType: String, Codable { 
        case autoSearch = "AutoSearch"
        case manualSearch = "ManualSearch"
        case suggestion = "Suggestion"
    }





    /** Query to search content in the knowledge base. Maximum of 30 records per query can be fetched. */
    public var query: String?
    /** Page size of the returned results. */
    public var pageSize: Int?
    /** Page number of the returned results. */
    public var pageNumber: Int?
    /** The globally unique identifier for the search. */
    public var searchId: String?
    /** The total number of documents matching the query. */
    public var total: Int?
    /** Number of pages returned in the result calculated according to the pageSize and the total */
    public var pageCount: Int?
    /** The type of the query that initiates the search. */
    public var queryType: QueryType?
    /** Session ID of the search. */
    public var sessionId: String?
    /** Documents that matched the search query. */
    public var results: [KnowledgeDocumentGuestSearchResult]?

    public init(query: String?, pageSize: Int?, pageNumber: Int?, searchId: String?, total: Int?, pageCount: Int?, queryType: QueryType?, sessionId: String?, results: [KnowledgeDocumentGuestSearchResult]?) {
        self.query = query
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.searchId = searchId
        self.total = total
        self.pageCount = pageCount
        self.queryType = queryType
        self.sessionId = sessionId
        self.results = results
    }


}




public class KnowledgeDocumentGuestSearchRequest: Codable {













    public enum QueryType: String, Codable { 
        case autoSearch = "AutoSearch"
        case manualSearch = "ManualSearch"
        case suggestion = "Suggestion"
    }







    /** Query to search content in the knowledge base. Maximum of 30 records per query can be fetched. */
    public var query: String?
    /** Page size of the returned results. */
    public var pageSize: Int?
    /** Page number of the returned results. */
    public var pageNumber: Int?
    /** The globally unique identifier for the search. */
    public var searchId: String?
    /** The total number of documents matching the query. */
    public var total: Int?
    /** Number of pages returned in the result calculated according to the pageSize and the total */
    public var pageCount: Int?
    /** The type of the query that initiates the search. */
    public var queryType: QueryType?
    /** Session ID of the search. */
    public var sessionId: String?
    /** The number of articles to be sent for answer-highlighting. Can range from 1-5. */
    public var answerHighlightTopResults: Int?
    /** Indicates whether the search results would also include draft documents. */
    public var includeDraftDocuments: Bool?

    public init(query: String?, pageSize: Int?, pageNumber: Int?, searchId: String?, total: Int?, pageCount: Int?, queryType: QueryType?, sessionId: String?, answerHighlightTopResults: Int?, includeDraftDocuments: Bool?) {
        self.query = query
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.searchId = searchId
        self.total = total
        self.pageCount = pageCount
        self.queryType = queryType
        self.sessionId = sessionId
        self.answerHighlightTopResults = answerHighlightTopResults
        self.includeDraftDocuments = includeDraftDocuments
    }


}




public class KnowledgeDocumentQueryResult: Codable {









    public enum State: String, Codable { 
        case draft = "Draft"
        case published = "Published"
        case archived = "Archived"
    }



































    /** The globally unique identifier for the object. */
    public var _id: String?
    /** Document title, having a limit of 500 words. */
    public var title: String?
    /** Indicates if the knowledge document should be included in search results. */
    public var visible: Bool?
    /** List of alternate phrases related to the title which improves search results. */
    public var alternatives: [KnowledgeDocumentAlternative]?
    /** State of the document. */
    public var state: State?
    /** Document creation date-time. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** Document last modification date-time. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** Document import date-time, or null if was not imported. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateImported: Date?
    /** The last published version number of the document. */
    public var lastPublishedVersionNumber: Int?
    /** The date on which the document was last published. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var datePublished: Date?
    /** The user who created the document. */
    public var createdBy: UserReference?
    /** The user who modified the document. */
    public var modifiedBy: UserReference?
    /** The version of the document. */
    public var documentVersion: AddressableEntityRef?
    /** The reference to category associated with the document. */
    public var category: CategoryResponse?
    /** The references to labels associated with the document. */
    public var labels: [LabelResponse]?
    /** Knowledge base to which the document belongs to. */
    public var knowledgeBase: KnowledgeBaseReference?
    /** The reference to external id associated with the document. */
    public var externalId: String?
    /** The URL to external document. */
    public var externalUrl: String?
    /** The reference to source associated with the document. */
    public var source: AddressableEntityRef?
    /** Whether the document is read-only. */
    public var readonly: Bool?
    /** Variations of the document. */
    public var variations: [KnowledgeDocumentQueryVariation]?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, title: String?, visible: Bool?, alternatives: [KnowledgeDocumentAlternative]?, state: State?, dateCreated: Date?, dateModified: Date?, dateImported: Date?, lastPublishedVersionNumber: Int?, datePublished: Date?, createdBy: UserReference?, modifiedBy: UserReference?, documentVersion: AddressableEntityRef?, category: CategoryResponse?, labels: [LabelResponse]?, knowledgeBase: KnowledgeBaseReference?, externalId: String?, externalUrl: String?, source: AddressableEntityRef?, readonly: Bool?, variations: [KnowledgeDocumentQueryVariation]?, selfUri: String?) {
        self._id = _id
        self.title = title
        self.visible = visible
        self.alternatives = alternatives
        self.state = state
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.dateImported = dateImported
        self.lastPublishedVersionNumber = lastPublishedVersionNumber
        self.datePublished = datePublished
        self.createdBy = createdBy
        self.modifiedBy = modifiedBy
        self.documentVersion = documentVersion
        self.category = category
        self.labels = labels
        self.knowledgeBase = knowledgeBase
        self.externalId = externalId
        self.externalUrl = externalUrl
        self.source = source
        self.readonly = readonly
        self.variations = variations
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case title
        case visible
        case alternatives
        case state
        case dateCreated
        case dateModified
        case dateImported
        case lastPublishedVersionNumber
        case datePublished
        case createdBy
        case modifiedBy
        case documentVersion
        case category
        case labels
        case knowledgeBase
        case externalId
        case externalUrl
        case source
        case readonly
        case variations
        case selfUri
    }


}




public class KnowledgeDocumentSearch: Codable {













    public enum QueryType: String, Codable { 
        case autoSearch = "AutoSearch"
        case manualSearch = "ManualSearch"
        case suggestion = "Suggestion"
    }













    /** Query to search content in the knowledge base. Maximum of 30 records per query can be fetched. */
    public var query: String?
    /** Page size of the returned results. */
    public var pageSize: Int?
    /** Page number of the returned results. */
    public var pageNumber: Int?
    /** The globally unique identifier for the search. */
    public var searchId: String?
    /** The total number of documents matching the query. */
    public var total: Int?
    /** Number of pages returned in the result calculated according to the pageSize and the total */
    public var pageCount: Int?
    /** The type of the query that initiates the search. */
    public var queryType: QueryType?
    /** Documents matching the search query. */
    public var results: [KnowledgeDocumentSearchResult]?
    /** The client application details from which search happened. */
    public var application: KnowledgeSearchClientApplication?
    /** Conversation context information if the search is initiated in the context of a conversation. */
    public var conversationContext: KnowledgeConversationContextResponse?
    /** The confidence threshold for the search results. If applied, the returned results will have an equal or higher confidence than the threshold. */
    public var confidenceThreshold: Float?
    /** The results with AI-generated answer if the answerMode request property contains \"AnswerGeneration\". */
    public var answerGeneration: KnowledgeAnswerGenerationResponse?
    /** Indicates whether the search query should be preprocessed. */
    public var preprocessQuery: Bool?

    public init(query: String?, pageSize: Int?, pageNumber: Int?, searchId: String?, total: Int?, pageCount: Int?, queryType: QueryType?, results: [KnowledgeDocumentSearchResult]?, application: KnowledgeSearchClientApplication?, conversationContext: KnowledgeConversationContextResponse?, confidenceThreshold: Float?, answerGeneration: KnowledgeAnswerGenerationResponse?, preprocessQuery: Bool?) {
        self.query = query
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.searchId = searchId
        self.total = total
        self.pageCount = pageCount
        self.queryType = queryType
        self.results = results
        self.application = application
        self.conversationContext = conversationContext
        self.confidenceThreshold = confidenceThreshold
        self.answerGeneration = answerGeneration
        self.preprocessQuery = preprocessQuery
    }


}




public class KnowledgeDocumentSearchRequest: Codable {













    public enum QueryType: String, Codable { 
        case autoSearch = "AutoSearch"
        case manualSearch = "ManualSearch"
        case suggestion = "Suggestion"
    }







    public enum SortOrder: String, Codable { 
        case asc = "Asc"
        case desc = "Desc"
    }

    public enum SortBy: String, Codable { 
        case confidenceScore = "ConfidenceScore"
        case dateCreated = "DateCreated"
        case dateModified = "DateModified"
        case categoryName = "CategoryName"
        case labelName = "LabelName"
    }









    public enum AnswerMode: String, Codable { 
        case answerHighlight = "AnswerHighlight"
        case answerGeneration = "AnswerGeneration"
    }



    /** Query to search content in the knowledge base. Maximum of 30 records per query can be fetched. */
    public var query: String?
    /** Page size of the returned results. */
    public var pageSize: Int?
    /** Page number of the returned results. */
    public var pageNumber: Int?
    /** The globally unique identifier for the search. */
    public var searchId: String?
    /** The total number of documents matching the query. */
    public var total: Int?
    /** Number of pages returned in the result calculated according to the pageSize and the total */
    public var pageCount: Int?
    /** The type of the query that initiates the search. */
    public var queryType: QueryType?
    /** Indicates whether the search results would also include draft documents. */
    public var includeDraftDocuments: Bool?
    /** Retrieves the documents created/modified/published in specified date and time range. */
    public var interval: DocumentQueryInterval?
    /** Filter for the document search. */
    public var filter: DocumentQuery?
    /** The sort order for search results. */
    public var sortOrder: SortOrder?
    /** The field in the documents that you want to sort the search results by. */
    public var sortBy: SortBy?
    /** The client application details from which search request was sent. */
    public var application: KnowledgeSearchClientApplication?
    /** Conversation context information if the search is initiated in the context of a conversation. */
    public var conversationContext: KnowledgeConversationContext?
    /** The confidence threshold for the search results. If applied, the returned results will have an equal or higher confidence than the threshold. The value should be between 0 to 1. */
    public var confidenceThreshold: Float?
    /** The number of articles to be sent for answer-highlighting. Can range from 1-5. */
    public var answerHighlightTopResults: Int?
    /** Allows extracted answers from an article (AnswerHighlight) and/or AI-generated answers (AnswerGeneration). Default mode: AnswerHighlight. Use this property with answerHighlightTopResults. */
    public var answerMode: [AnswerMode]?
    /** Indicates whether the search query should be preprocessed. */
    public var preprocessQuery: Bool?

    public init(query: String?, pageSize: Int?, pageNumber: Int?, searchId: String?, total: Int?, pageCount: Int?, queryType: QueryType?, includeDraftDocuments: Bool?, interval: DocumentQueryInterval?, filter: DocumentQuery?, sortOrder: SortOrder?, sortBy: SortBy?, application: KnowledgeSearchClientApplication?, conversationContext: KnowledgeConversationContext?, confidenceThreshold: Float?, answerHighlightTopResults: Int?, answerMode: [AnswerMode]?, preprocessQuery: Bool?) {
        self.query = query
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.searchId = searchId
        self.total = total
        self.pageCount = pageCount
        self.queryType = queryType
        self.includeDraftDocuments = includeDraftDocuments
        self.interval = interval
        self.filter = filter
        self.sortOrder = sortOrder
        self.sortBy = sortBy
        self.application = application
        self.conversationContext = conversationContext
        self.confidenceThreshold = confidenceThreshold
        self.answerHighlightTopResults = answerHighlightTopResults
        self.answerMode = answerMode
        self.preprocessQuery = preprocessQuery
    }


}




public class KnowledgeDocumentSuggestionResult: Codable {





    /** Matched phrase to the autocomplete suggestions query. */
    public var matchedPhrase: String?
    public var document: KnowledgeDocumentSuggestionResultDocument?

    public init(matchedPhrase: String?, document: KnowledgeDocumentSuggestionResultDocument?) {
        self.matchedPhrase = matchedPhrase
        self.document = document
    }


}




public class KnowledgeDocumentVersionReference: Codable {









    /** The globally unique identifier for the document. */
    public var _id: String?
    /** The knowledge base that the document belongs to. */
    public var knowledgeBase: KnowledgeBaseReference?
    /** The globally unique identifier for the version of the document. */
    public var versionId: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, knowledgeBase: KnowledgeBaseReference?, versionId: String?, selfUri: String?) {
        self._id = _id
        self.knowledgeBase = knowledgeBase
        self.versionId = versionId
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case knowledgeBase
        case versionId
        case selfUri
    }


}




public class KnowledgeDocumentVersionVariation: Codable {



















    /** The globally unique identifier for the variation. */
    public var _id: String?
    /** The creation date-time for the document variation. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** The last modification date-time for the document variation. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** The context values associated with the variation. */
    public var contexts: [DocumentVariationContext]?
    /** The priority of the variation. */
    public var priority: Int?
    /** The name of the variation. */
    public var name: String?
    /** The content for the variation. */
    public var body: DocumentBodyResponse?
    /** The URI for this object */
    public var selfUri: String?
    /** Reference to the document version to which the variation is associated with. */
    public var documentVersion: AddressableEntityRef?

    public init(_id: String?, dateCreated: Date?, dateModified: Date?, contexts: [DocumentVariationContext]?, priority: Int?, name: String?, body: DocumentBodyResponse?, selfUri: String?, documentVersion: AddressableEntityRef?) {
        self._id = _id
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.contexts = contexts
        self.priority = priority
        self.name = name
        self.body = body
        self.selfUri = selfUri
        self.documentVersion = documentVersion
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case dateCreated
        case dateModified
        case contexts
        case priority
        case name
        case body
        case selfUri
        case documentVersion
    }


}




public class KnowledgeDocumentVersionVariationListing: Codable {









    public var entities: [KnowledgeDocumentVersionVariation]?
    public var nextUri: String?
    public var selfUri: String?
    public var previousUri: String?

    public init(entities: [KnowledgeDocumentVersionVariation]?, nextUri: String?, selfUri: String?, previousUri: String?) {
        self.entities = entities
        self.nextUri = nextUri
        self.selfUri = selfUri
        self.previousUri = previousUri
    }


}




public class KnowledgeDocumentsAnswerFilter: Codable {



    public enum Language: String, Codable { 
        case enUs = "en-US"
        case enUk = "en-UK"
        case enAu = "en-AU"
        case enCa = "en-CA"
        case enHk = "en-HK"
        case enIn = "en-IN"
        case enIe = "en-IE"
        case enNz = "en-NZ"
        case enPh = "en-PH"
        case enSg = "en-SG"
        case enZa = "en-ZA"
        case deDe = "de-DE"
        case deAt = "de-AT"
        case deCh = "de-CH"
        case esAr = "es-AR"
        case esCo = "es-CO"
        case esMx = "es-MX"
        case esUs = "es-US"
        case esEs = "es-ES"
        case frFr = "fr-FR"
        case frBe = "fr-BE"
        case frCa = "fr-CA"
        case frCh = "fr-CH"
        case ptBr = "pt-BR"
        case ptPt = "pt-PT"
        case nlNl = "nl-NL"
        case nlBe = "nl-BE"
        case itIt = "it-IT"
        case caEs = "ca-ES"
        case trTr = "tr-TR"
        case svSe = "sv-SE"
        case fiFi = "fi-FI"
        case nbNo = "nb-NO"
        case daDk = "da-DK"
        case jaJp = "ja-JP"
        case arAe = "ar-AE"
        case zhCn = "zh-CN"
        case zhTw = "zh-TW"
        case zhHk = "zh-HK"
        case koKr = "ko-KR"
        case plPl = "pl-PL"
        case hiIn = "hi-IN"
        case thTh = "th-TH"
        case huHu = "hu-HU"
        case viVn = "vi-VN"
        case ukUa = "uk-UA"
        case csCz = "cs-CZ"
        case filPh = "fil-PH"
        case msMy = "ms-MY"
        case heIl = "he-IL"
        case elGr = "el-GR"
    }

    public enum AppType: String, Codable { 
        case assistant = "Assistant"
        case botFlow = "BotFlow"
        case messengerKnowledgeApp = "MessengerKnowledgeApp"
        case smartAdvisor = "SmartAdvisor"
        case supportCenter = "SupportCenter"
    }

    public enum QueryType: String, Codable { 
        case unknown = "Unknown"
        case article = "Article"
        case autoSearch = "AutoSearch"
        case category = "Category"
        case manualSearch = "ManualSearch"
        case recommendation = "Recommendation"
        case suggestion = "Suggestion"
        case expandedArticle = "ExpandedArticle"
    }





    public enum AnswerMode: String, Codable { 
        case answerHighlight = "AnswerHighlight"
        case answerGeneration = "AnswerGeneration"
    }



    /** The search query. */
    public var query: String?
    /** The language of the documents. */
    public var language: Language?
    /** The appType */
    public var appType: AppType?
    /** The query type */
    public var queryType: QueryType?
    /** The search id. */
    public var searchId: String?
    /** If specified - insert highlight data into the variation content. */
    public var insertHighlightIntoVariationContent: Bool?
    /** Allows extracted answers from an article (AnswerHighlight) and/or AI-generated answers (AnswerGeneration). Default mode: AnswerHighlight */
    public var answerMode: [AnswerMode]?
    /** The variation Ids to answer. */
    public var variationIds: [String]?

    public init(query: String?, language: Language?, appType: AppType?, queryType: QueryType?, searchId: String?, insertHighlightIntoVariationContent: Bool?, answerMode: [AnswerMode]?, variationIds: [String]?) {
        self.query = query
        self.language = language
        self.appType = appType
        self.queryType = queryType
        self.searchId = searchId
        self.insertHighlightIntoVariationContent = insertHighlightIntoVariationContent
        self.answerMode = answerMode
        self.variationIds = variationIds
    }


}




public class KnowledgeExportJobFilter: Codable {



    public enum VersionFilter: String, Codable { 
        case all = "All"
        case latest = "Latest"
    }


    public enum Exclude: String, Codable { 
        case categories = "Categories"
        case labels = "Labels"
        case variations = "Variations"
    }
    /** Filters for narrowing down which documents to export. */
    public var documentsFilter: KnowledgeExportJobDocumentsFilter?
    /** Specifies what version should be exported. */
    public var versionFilter: VersionFilter?
    /** Reduce the size of the export file by excluding certain items. */
    public var exclude: [Exclude]?

    public init(documentsFilter: KnowledgeExportJobDocumentsFilter?, versionFilter: VersionFilter?, exclude: [Exclude]?) {
        self.documentsFilter = documentsFilter
        self.versionFilter = versionFilter
        self.exclude = exclude
    }


}




public class KnowledgeGuestDocumentFeedback: Codable {





    public enum Rating: String, Codable { 
        case negative = "Negative"
        case positive = "Positive"
    }

    public enum Reason: String, Codable { 
        case documentContent = "DocumentContent"
        case searchResults = "SearchResults"
    }









    public enum QueryType: String, Codable { 
        case unknown = "Unknown"
        case article = "Article"
        case autoSearch = "AutoSearch"
        case category = "Category"
        case manualSearch = "ManualSearch"
        case recommendation = "Recommendation"
        case suggestion = "Suggestion"
        case expandedArticle = "ExpandedArticle"
    }

    public enum SurfacingMethod: String, Codable { 
        case unknown = "Unknown"
        case article = "Article"
        case snippet = "Snippet"
        case highlight = "Highlight"
        case generative = "Generative"
    }

    public enum State: String, Codable { 
        case draft = "Draft"
        case _final = "Final"
    }





    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The variation of the document on which feedback was given. */
    public var documentVariation: EntityReference?
    /** Feedback rating. */
    public var rating: Rating?
    /** Feedback reason. */
    public var reason: Reason?
    /** Free-text comment of the feedback. Maximum length: 2000 characters. */
    public var comment: String?
    /** The search that surfaced the document on which feedback was given. */
    public var search: EntityReference?
    /** Knowledge guest session ID. */
    public var sessionId: String?
    /** The date and time of the feedback. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** The type of the query that surfaced the document on which the feedback was given. */
    public var queryType: QueryType?
    /** The method how knowledge was surfaced. Article: Full article was shown. Snippet: A snippet from the article was shown. Highlight: A highlighted answer in a snippet was shown.Generative: A generated answer in a snippet was shown. */
    public var surfacingMethod: SurfacingMethod?
    /** The state of the feedback. */
    public var state: State?
    /** The document on which feedback was given. */
    public var document: KnowledgeGuestDocumentVersionReference?
    /** The client application from which feedback was given. */
    public var application: KnowledgeGuestSearchClientApplication?

    public init(_id: String?, documentVariation: EntityReference?, rating: Rating?, reason: Reason?, comment: String?, search: EntityReference?, sessionId: String?, dateCreated: Date?, queryType: QueryType?, surfacingMethod: SurfacingMethod?, state: State?, document: KnowledgeGuestDocumentVersionReference?, application: KnowledgeGuestSearchClientApplication?) {
        self._id = _id
        self.documentVariation = documentVariation
        self.rating = rating
        self.reason = reason
        self.comment = comment
        self.search = search
        self.sessionId = sessionId
        self.dateCreated = dateCreated
        self.queryType = queryType
        self.surfacingMethod = surfacingMethod
        self.state = state
        self.document = document
        self.application = application
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case documentVariation
        case rating
        case reason
        case comment
        case search
        case sessionId
        case dateCreated
        case queryType
        case surfacingMethod
        case state
        case document
        case application
    }


}




public class KnowledgeGuestDocumentSuggestionResult: Codable {



    /** Matched phrase to the autocomplete suggestions query. */
    public var matchedPhrase: String?

    public init(matchedPhrase: String?) {
        self.matchedPhrase = matchedPhrase
    }


}




public class KnowledgeGuestDocumentVersionReference: Codable {





    /** The globally unique identifier for the document. */
    public var _id: String?
    /** The globally unique identifier for the version of the document. */
    public var versionId: String?

    public init(_id: String?, versionId: String?) {
        self._id = _id
        self.versionId = versionId
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case versionId
    }


}




public class KnowledgeGuestSessionApp: Codable {



    public enum ModelType: String, Codable { 
        case messengerKnowledgeApp = "MessengerKnowledgeApp"
        case supportCenter = "SupportCenter"
    }

    /** App deployment ID. */
    public var deploymentId: String?
    /** App type. */
    public var type: ModelType?

    public init(deploymentId: String?, type: ModelType?) {
        self.deploymentId = deploymentId
        self.type = type
    }


}




public class KnowledgeImportJobReport: Codable {





    /** List of errors occurred during processing import. */
    public var errors: [KnowledgeImportJobError]?
    /** Statistics related to the import job. */
    public var statistics: KnowledgeImportJobStatistics?

    public init(errors: [KnowledgeImportJobError]?, statistics: KnowledgeImportJobStatistics?) {
        self.errors = errors
        self.statistics = statistics
    }


}




public class KnowledgeIntegrationDefaultSettings: Codable {



    /** The default base URL setting for the integration. */
    public var baseUrl: String?

    public init(baseUrl: String?) {
        self.baseUrl = baseUrl
    }


}




public class KnowledgeIntegrationFilterValue: Codable {





    /** The key that can be used as a value of a filter setting in a knowledge source. */
    public var key: String?
    /** The display label of the filter value. */
    public var value: String?

    public init(key: String?, value: String?) {
        self.key = key
        self.value = value
    }


}




public class KnowledgeParseRecord: Codable {







    /** Unique id for the parsed data. */
    public var _id: String?
    /** Parsed article title. */
    public var title: String?
    /** Parsed article content. */
    public var body: DocumentBody?

    public init(_id: String?, title: String?, body: DocumentBody?) {
        self._id = _id
        self.title = title
        self.body = body
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case title
        case body
    }


}




public class KnowledgeSetting: Codable {





    /** The globally unique identifier for the knowledge setting. */
    public var _id: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, selfUri: String?) {
        self._id = _id
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
    }


}




public class LabelEntity: Codable {





    /** The Id of the label. */
    public var _id: String?
    /** The selfUri of the label. */
    public var selfUri: String?

    public init(_id: String?, selfUri: String?) {
        self._id = _id
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
    }


}




public class LabelResponse: Codable {

















    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The name of the label. */
    public var name: String?
    /** The color of the label. */
    public var color: String?
    /** The creation date and time of the label. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** The last modification date and time of the label. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** Number of documents assigned to this label. */
    public var documentCount: Int?
    /** The external id associated with the label. */
    public var externalId: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, color: String?, dateCreated: Date?, dateModified: Date?, documentCount: Int?, externalId: String?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.color = color
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.documentCount = documentCount
        self.externalId = externalId
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case color
        case dateCreated
        case dateModified
        case documentCount
        case externalId
        case selfUri
    }


}




public class LabelUtilizationResponse: Codable {







    /** Defines the maximum number of interactions with this label that an agent can handle at one time. */
    public var maximumCapacity: Int?
    /** Defines other labels that can interrupt an interaction with this label. */
    public var interruptingLabelIds: [String]?
    /** Name of the label this utilization relates to. */
    public var labelName: String?

    public init(maximumCapacity: Int?, interruptingLabelIds: [String]?, labelName: String?) {
        self.maximumCapacity = maximumCapacity
        self.interruptingLabelIds = interruptingLabelIds
        self.labelName = labelName
    }


}




public class LanguageSupportInfoRecord: Codable {





    /** Language of the copilot, e.g. 'en-US'. */
    public var language: String?
    /** Information about the support of features. */
    public var featureSupport: [FeatureSupport]?

    public init(language: String?, featureSupport: [FeatureSupport]?) {
        self.language = language
        self.featureSupport = featureSupport
    }


}




public class LastAttemptByColumnConditionSettings: Codable {





    public enum Operator: String, Codable { 
        case before = "Before"
        case after = "After"
    }



    /** The name of the contact column to evaluate for Email. */
    public var emailColumnName: String?
    /** The name of the contact column to evaluate for SMS. */
    public var smsColumnName: String?
    /** The operator to use when comparing values. */
    public var _operator: Operator?
    /** The period value to compare against the contact's data. */
    public var value: String?

    public init(emailColumnName: String?, smsColumnName: String?, _operator: Operator?, value: String?) {
        self.emailColumnName = emailColumnName
        self.smsColumnName = smsColumnName
        self._operator = _operator
        self.value = value
    }

    public enum CodingKeys: String, CodingKey { 
        case emailColumnName
        case smsColumnName
        case _operator = "operator"
        case value
    }


}




public class LastResultOverallConditionSettings: Codable {





    /** A list of wrapup code identifiers to match for Email. */
    public var emailWrapupCodes: [String]?
    /** A list of wrapup code identifiers to match for SMS. */
    public var smsWrapupCodes: [String]?

    public init(emailWrapupCodes: [String]?, smsWrapupCodes: [String]?) {
        self.emailWrapupCodes = emailWrapupCodes
        self.smsWrapupCodes = smsWrapupCodes
    }


}




public class LearningAssignmentAggregateQueryRequestClause: Codable {

    public enum ModelType: String, Codable { 
        case and = "And"
        case or = "Or"
    }



    /** The logic used to combine the predicates */
    public var type: ModelType?
    /** The list of predicates used to filter the data */
    public var predicates: [LearningAssignmentAggregateQueryRequestPredicate]?

    public init(type: ModelType?, predicates: [LearningAssignmentAggregateQueryRequestPredicate]?) {
        self.type = type
        self.predicates = predicates
    }


}




public class LearningAssignmentAggregateQueryResponseData: Codable {





    /** Specifies the range of due dates to be used for filtering. A maximum of 1 year can be specified in the range. Intervals are represented as an ISO-8601 string. For example: YYYY-MM-DDThh:mm:ss/YYYY-MM-DDThh:mm:ss */
    public var interval: String?
    /** The list of aggregated metrics */
    public var metrics: [LearningAssignmentAggregateQueryResponseMetric]?

    public init(interval: String?, metrics: [LearningAssignmentAggregateQueryResponseMetric]?) {
        self.interval = interval
        self.metrics = metrics
    }


}




public class LearningAssignmentBulkRemoveResponse: Codable {





    /** The learning assignments that were removed successfully */
    public var entities: [LearningAssignmentEntity]?
    /** The learning assignments that were not removed due to missing permissions */
    public var disallowedEntities: [DisallowedEntityLearningAssignmentReference]?

    public init(entities: [LearningAssignmentEntity]?, disallowedEntities: [DisallowedEntityLearningAssignmentReference]?) {
        self.entities = entities
        self.disallowedEntities = disallowedEntities
    }


}




public class LearningAssignmentEntity: Codable {



    public var assignmentId: String?

    public init(assignmentId: String?) {
        self.assignmentId = assignmentId
    }


}



/** Learning assignment step */

public class LearningAssignmentStep: Codable {







    public enum SuccessStatus: String, Codable { 
        case passed = "Passed"
        case failed = "Failed"
        case unknown = "Unknown"
    }

    public enum CompletionStatus: String, Codable { 
        case completed = "Completed"
        case incomplete = "Incomplete"
        case notAttempted = "NotAttempted"
        case unknown = "Unknown"
    }











    /** The ID of the learning assignment step */
    public var _id: String?
    /** The module step data for this step */
    public var moduleStep: LearningModuleInformStep?
    /** The structure for any SCO associated with this step */
    public var structure: [LearningAssignmentStepScoStructure]?
    /** The success status of this step */
    public var successStatus: SuccessStatus?
    /** The completion status of the assignment step */
    public var completionStatus: CompletionStatus?
    /** The completion percentage for this step */
    public var completionPercentage: Float?
    /** The percentage score for this step */
    public var percentageScore: Float?
    /** The SCO (Shareable Content Object) data */
    public var shareableContentObject: LearningShareableContentObject?
    /** The signed cookie information needed to access the content of this step (if required) */
    public var signedCookie: LearningAssignmentStepSignedCookie?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, moduleStep: LearningModuleInformStep?, structure: [LearningAssignmentStepScoStructure]?, successStatus: SuccessStatus?, completionStatus: CompletionStatus?, completionPercentage: Float?, percentageScore: Float?, shareableContentObject: LearningShareableContentObject?, signedCookie: LearningAssignmentStepSignedCookie?, selfUri: String?) {
        self._id = _id
        self.moduleStep = moduleStep
        self.structure = structure
        self.successStatus = successStatus
        self.completionStatus = completionStatus
        self.completionPercentage = completionPercentage
        self.percentageScore = percentageScore
        self.shareableContentObject = shareableContentObject
        self.signedCookie = signedCookie
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case moduleStep
        case structure
        case successStatus
        case completionStatus
        case completionPercentage
        case percentageScore
        case shareableContentObject
        case signedCookie
        case selfUri
    }


}




public class LearningAssignmentStepScoStructure: Codable {





    public enum SuccessStatus: String, Codable { 
        case passed = "Passed"
        case failed = "Failed"
        case unknown = "Unknown"
    }

    public enum CompletionStatus: String, Codable { 
        case completed = "Completed"
        case incomplete = "Incomplete"
        case notAttempted = "NotAttempted"
        case unknown = "Unknown"
    }



    /** The id of this SCO in the course manifest */
    public var _id: String?
    /** The name of this SCO in the course manifest */
    public var name: String?
    /** The success status of this SCO */
    public var successStatus: SuccessStatus?
    /** The completion status of this SCO */
    public var completionStatus: CompletionStatus?
    /** Child items belonging to this SCO in the course manifest */
    public var children: [LearningAssignmentStepScoStructure]?

    public init(_id: String?, name: String?, successStatus: SuccessStatus?, completionStatus: CompletionStatus?, children: [LearningAssignmentStepScoStructure]?) {
        self._id = _id
        self.name = name
        self.successStatus = successStatus
        self.completionStatus = completionStatus
        self.children = children
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case successStatus
        case completionStatus
        case children
    }


}




public class LearningAssignmentTopicLearningModuleReference: Codable {





    public var _id: String?
    public var name: String?

    public init(_id: String?, name: String?) {
        self._id = _id
        self.name = name
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
    }


}




public class LearningAssignmentTopicUserReference: Codable {



    public var _id: String?

    public init(_id: String?) {
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
    }


}




public class LearningAssignmentsDomainEntity: Codable {





















    public var entities: [LearningAssignment]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var previousUri: String?
    public var nextUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [LearningAssignment]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, previousUri: String?, nextUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.previousUri = previousUri
        self.nextUri = nextUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class LearningCoverArtUploadUrlRequest: Codable {







    public enum ContentType: String, Codable { 
        case imageBmp = "image/bmp"
        case imageGif = "image/gif"
        case imageJpeg = "image/jpeg"
        case imageJpg = "image/jpg"
        case imagePng = "image/png"
    }

    public enum ServerSideEncryption: String, Codable { 
        case aes256 = "AES256"
    }

    /** Name of the file to upload. It must not start with a dot and not end with a forward slash. Whitespace and the following characters are not allowed: \\{^}%`]\">[~<#| */
    public var fileName: String?
    /** Content MD5 of the file to upload */
    public var contentMd5: String?
    /** The number of seconds the presigned URL is valid for (from 1 to 604800 seconds). If none provided, defaults to 600 seconds */
    public var signedUrlTimeoutSeconds: Int?
    /** The content type of the file to upload. */
    public var contentType: ContentType?
    public var serverSideEncryption: ServerSideEncryption?

    public init(fileName: String?, contentMd5: String?, signedUrlTimeoutSeconds: Int?, contentType: ContentType?, serverSideEncryption: ServerSideEncryption?) {
        self.fileName = fileName
        self.contentMd5 = contentMd5
        self.signedUrlTimeoutSeconds = signedUrlTimeoutSeconds
        self.contentType = contentType
        self.serverSideEncryption = serverSideEncryption
    }


}



/** Auto assign request */

public class LearningModuleAutoAssignRequest: Codable {





    /** The id of the rule */
    public var ruleId: String?
    /** Whether the rule is enabled for the module */
    public var enabled: Bool?

    public init(ruleId: String?, enabled: Bool?) {
        self.ruleId = ruleId
        self.enabled = enabled
    }


}



/** Learning module list */

public class LearningModuleList: Codable {























    public var entities: [LearningModule]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    /** The total number of unmigrated rules */
    public var totalLegacyRules: Int64?
    public var firstUri: String?
    public var previousUri: String?
    public var nextUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [LearningModule]?, pageSize: Int?, pageNumber: Int?, total: Int64?, totalLegacyRules: Int64?, firstUri: String?, previousUri: String?, nextUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.totalLegacyRules = totalLegacyRules
        self.firstUri = firstUri
        self.previousUri = previousUri
        self.nextUri = nextUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}



/** Learning module preview get response assignment */

public class LearningModulePreviewGetResponseAssignment: Codable {

    public enum State: String, Codable { 
        case assigned = "Assigned"
        case inProgress = "InProgress"
        case completed = "Completed"
        case deleted = "Deleted"
        case notCompleted = "NotCompleted"
        case invalidSchedule = "InvalidSchedule"
    }













    /** The Learning Assignment state */
    public var state: State?
    /** The user's percentage score for this assignment */
    public var percentageScore: Float?
    /** The user's percentage score for this assignment's assessment */
    public var assessmentPercentageScore: Float?
    /** True if the assessment was passed */
    public var isPassed: Bool?
    /** The assessment completion percentage of assignment */
    public var assessmentCompletionPercentage: Float?
    /** The overall completion percentage of assignment */
    public var completionPercentage: Float?
    /** List of assignment steps */
    public var steps: [LearningModulePreviewGetResponseStep]?

    public init(state: State?, percentageScore: Float?, assessmentPercentageScore: Float?, isPassed: Bool?, assessmentCompletionPercentage: Float?, completionPercentage: Float?, steps: [LearningModulePreviewGetResponseStep]?) {
        self.state = state
        self.percentageScore = percentageScore
        self.assessmentPercentageScore = assessmentPercentageScore
        self.isPassed = isPassed
        self.assessmentCompletionPercentage = assessmentCompletionPercentage
        self.completionPercentage = completionPercentage
        self.steps = steps
    }


}



/** Learning module preview update response current step */

public class LearningModulePreviewUpdateResponseCurrentStep: Codable {



    /** The SCO (Shareable Content Object) data */
    public var shareableContentObject: LearningShareableContentObject?

    public init(shareableContentObject: LearningShareableContentObject?) {
        self.shareableContentObject = shareableContentObject
    }


}



/** Learning module publish request */

public class LearningModulePublishRequest: Codable {



    /** Whether the terms and conditions were accepted */
    public var termsAndConditionsAccepted: Bool?

    public init(termsAndConditionsAccepted: Bool?) {
        self.termsAndConditionsAccepted = termsAndConditionsAccepted
    }


}




public class LearningScheduleSlotsJobResponse: Codable {











    public enum SlotsType: String, Codable { 
        case bestTime = "BestTime"
    }





    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The user IDs to fetch the slots for. */
    public var userIds: [String]?
    /** The length in minutes of the slots. */
    public var lengthInMinutes: Int?
    /** The Business Unit Id of the users. */
    public var businessUnitId: String?
    /** The Activity Code Id of the slots. */
    public var activityCodeId: String?
    /** The type of slots fetched in the job. */
    public var slotsType: SlotsType?
    /** The results of the job. */
    public var results: [LearningScheduleSlotsJobResult]?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, userIds: [String]?, lengthInMinutes: Int?, businessUnitId: String?, activityCodeId: String?, slotsType: SlotsType?, results: [LearningScheduleSlotsJobResult]?, selfUri: String?) {
        self._id = _id
        self.userIds = userIds
        self.lengthInMinutes = lengthInMinutes
        self.businessUnitId = businessUnitId
        self.activityCodeId = activityCodeId
        self.slotsType = slotsType
        self.results = results
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case userIds
        case lengthInMinutes
        case businessUnitId
        case activityCodeId
        case slotsType
        case results
        case selfUri
    }


}



/** Learning SCORM upload response */

public class LearningScormUploadResponse: Codable {



    public enum Status: String, Codable { 
        case uploadPending = "UploadPending"
        case unpacking = "Unpacking"
        case error = "Error"
        case ready = "Ready"
    }







    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The status of the SCORM package */
    public var status: Status?
    /** The pre-signed URL. Use it with headers below to upload file to S3 */
    public var uploadUrl: String?
    /** The additional headers that need to be included in the upload request */
    public var headers: [String:String]?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, status: Status?, uploadUrl: String?, headers: [String:String]?, selfUri: String?) {
        self._id = _id
        self.status = status
        self.uploadUrl = uploadUrl
        self.headers = headers
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case status
        case uploadUrl
        case headers
        case selfUri
    }


}




public class LearningSlotScheduleActivity: Codable {















    public enum ExternalActivityType: String, Codable { 
        case activityPlan = "ActivityPlan"
        case coaching = "Coaching"
        case learning = "Learning"
        case opportunity = "Opportunity"
    }

    /** The start date/time of this activity. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateStart: Date?
    /** The length of this activity in minutes */
    public var lengthMinutes: Int?
    /** The description of this activity */
    public var _description: String?
    /** The ID of the activity code associated with this activity */
    public var activityCodeId: String?
    /** Whether this activity is paid */
    public var paid: Bool?
    /** The ID of the time off request associated with this activity, if applicable */
    public var timeOffRequestId: String?
    /** The ID of the external activity associated with this activity, if applicable */
    public var externalActivityId: String?
    /** The type of the external activity associated with this activity, if applicable */
    public var externalActivityType: ExternalActivityType?

    public init(dateStart: Date?, lengthMinutes: Int?, _description: String?, activityCodeId: String?, paid: Bool?, timeOffRequestId: String?, externalActivityId: String?, externalActivityType: ExternalActivityType?) {
        self.dateStart = dateStart
        self.lengthMinutes = lengthMinutes
        self._description = _description
        self.activityCodeId = activityCodeId
        self.paid = paid
        self.timeOffRequestId = timeOffRequestId
        self.externalActivityId = externalActivityId
        self.externalActivityType = externalActivityType
    }

    public enum CodingKeys: String, CodingKey { 
        case dateStart
        case lengthMinutes
        case _description = "description"
        case activityCodeId
        case paid
        case timeOffRequestId
        case externalActivityId
        case externalActivityType
    }


}




public class LexBotAliasEntityListing: Codable {





















    public var entities: [LexBotAlias]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var previousUri: String?
    public var nextUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [LexBotAlias]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, previousUri: String?, nextUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.previousUri = previousUri
        self.nextUri = nextUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class LexBotEntityListing: Codable {





















    public var entities: [LexBot]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var previousUri: String?
    public var nextUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [LexBot]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, previousUri: String?, nextUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.previousUri = previousUri
        self.nextUri = nextUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class LibraryBatchRequest: Codable {



    /** List of Library IDs */
    public var libraryIds: [String]?

    public init(libraryIds: [String]?) {
        self.libraryIds = libraryIds
    }


}




public class LibraryEntityListing: Codable {





















    public var entities: [Library]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var previousUri: String?
    public var nextUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [Library]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, previousUri: String?, nextUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.previousUri = previousUri
        self.nextUri = nextUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class LicenseUpdateStatus: Codable {







    public var userId: String?
    public var licenseId: String?
    public var result: String?

    public init(userId: String?, licenseId: String?, result: String?) {
        self.userId = userId
        self.licenseId = licenseId
        self.result = result
    }


}




public class LicenseUser: Codable {







    /** The globally unique identifier for the object. */
    public var _id: String?
    public var licenses: [LicenseDefinition]?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, licenses: [LicenseDefinition]?, selfUri: String?) {
        self._id = _id
        self.licenses = licenses
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case licenses
        case selfUri
    }


}




public class Line: Codable {



















    public enum State: String, Codable { 
        case active = "active"
        case inactive = "inactive"
        case deleted = "deleted"
    }

























    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The name of the entity. */
    public var name: String?
    /** The division to which this entity belongs. */
    public var division: Division?
    /** The resource's description. */
    public var _description: String?
    /** The current version of the resource. */
    public var version: Int?
    /** The date the resource was created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** The date of the last modification to the resource. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** The ID of the user that last modified the resource. */
    public var modifiedBy: String?
    /** The ID of the user that created the resource. */
    public var createdBy: String?
    /** Indicates if the resource is active, inactive, or deleted. */
    public var state: State?
    /** The application that last modified the resource. */
    public var modifiedByApp: String?
    /** The application that created the resource. */
    public var createdByApp: String?
    public var properties: [String:JSON]?
    /** The edge group associated with the line. (Deprecated) */
    public var edgeGroup: DomainEntityRef?
    /** The station base/template. (Deprecated - Please use the lineBaseSettings field instead, as it contains the same data) */
    public var template: DomainEntityRef?
    public var site: DomainEntityRef?
    /** The station base/template. */
    public var lineBaseSettings: DomainEntityRef?
    /** The primary edge associated to the line. (Deprecated) */
    public var primaryEdge: Edge?
    /** The secondary edge associated to the line. (Deprecated) */
    public var secondaryEdge: Edge?
    public var loggedInUser: DomainEntityRef?
    public var defaultForUser: DomainEntityRef?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, division: Division?, _description: String?, version: Int?, dateCreated: Date?, dateModified: Date?, modifiedBy: String?, createdBy: String?, state: State?, modifiedByApp: String?, createdByApp: String?, properties: [String:JSON]?, edgeGroup: DomainEntityRef?, template: DomainEntityRef?, site: DomainEntityRef?, lineBaseSettings: DomainEntityRef?, primaryEdge: Edge?, secondaryEdge: Edge?, loggedInUser: DomainEntityRef?, defaultForUser: DomainEntityRef?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.division = division
        self._description = _description
        self.version = version
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.modifiedBy = modifiedBy
        self.createdBy = createdBy
        self.state = state
        self.modifiedByApp = modifiedByApp
        self.createdByApp = createdByApp
        self.properties = properties
        self.edgeGroup = edgeGroup
        self.template = template
        self.site = site
        self.lineBaseSettings = lineBaseSettings
        self.primaryEdge = primaryEdge
        self.secondaryEdge = secondaryEdge
        self.loggedInUser = loggedInUser
        self.defaultForUser = defaultForUser
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case division
        case _description = "description"
        case version
        case dateCreated
        case dateModified
        case modifiedBy
        case createdBy
        case state
        case modifiedByApp
        case createdByApp
        case properties
        case edgeGroup
        case template
        case site
        case lineBaseSettings
        case primaryEdge
        case secondaryEdge
        case loggedInUser
        case defaultForUser
        case selfUri
    }


}




public class ListPickerItem: Codable {









    /** Unique identifier for the list picker item */
    public var _id: String?
    /** Additional text providing more details about the item. */
    public var subtitle: String?
    /** The main text displayed for the item. */
    public var title: String?
    /** Whether the item is selected. */
    public var selected: Bool?

    public init(_id: String?, subtitle: String?, title: String?, selected: Bool?) {
        self._id = _id
        self.subtitle = subtitle
        self.title = title
        self.selected = selected
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case subtitle
        case title
        case selected
    }


}




public class ListWrapperAgentWorkPlanField: Codable {

    public enum Values: String, Codable { 
        case name = "Name"
        case paidHours = "PaidHours"
    }

    public var values: [Values]?

    public init(values: [Values]?) {
        self.values = values
    }


}




public class ListWrapperAlternativeShiftBuSettingsActivityCategory: Codable {

    public enum Values: String, Codable { 
        case _break = "Break"
        case meal = "Meal"
        case meeting = "Meeting"
        case offQueueWork = "OffQueueWork"
        case timeOff = "TimeOff"
        case training = "Training"
        case unavailable = "Unavailable"
    }

    public var values: [Values]?

    public init(values: [Values]?) {
        self.values = values
    }


}




public class ListWrapperAlternativeShiftBuSettingsGranularity: Codable {

    public enum Values: String, Codable { 
        case daily = "Daily"
    }

    public var values: [Values]?

    public init(values: [Values]?) {
        self.values = values
    }


}




public class ListedDictionaryFeedback: Codable {









    public enum Source: String, Codable { 
        case manual = "Manual"
    }











    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The dictionary term which needs to be added to dictionary feedback system */
    public var term: String?
    /** The dialect for the given term, dialect format is {language}-{country} where language follows ISO 639-1 standard and country follows ISO 3166-1 alpha 2 standard */
    public var dialect: String?
    /** A weighted value assigned to a phrase. The higher the value, the higher the likelihood that the system will choose the word or phrase from the possible alternatives. Boost range is from 1.0 to 10.0. Default is 2.0 */
    public var boostValue: Float?
    /** The source of the given dictionary feedback */
    public var source: Source?
    /** The Timestamp when dictionary feedback created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** The Id of the user who created the dictionary feedback */
    public var createdBy: UserReference?
    /** The Timestamp when dictionary feedback modified. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** The Id of the user who modified the dictionary feedback */
    public var modifiedBy: UserReference?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, term: String?, dialect: String?, boostValue: Float?, source: Source?, dateCreated: Date?, createdBy: UserReference?, dateModified: Date?, modifiedBy: UserReference?, selfUri: String?) {
        self._id = _id
        self.term = term
        self.dialect = dialect
        self.boostValue = boostValue
        self.source = source
        self.dateCreated = dateCreated
        self.createdBy = createdBy
        self.dateModified = dateModified
        self.modifiedBy = modifiedBy
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case term
        case dialect
        case boostValue
        case source
        case dateCreated
        case createdBy
        case dateModified
        case modifiedBy
        case selfUri
    }


}




public class Literal: Codable {











    public enum Special: String, Codable { 
        case wildcard = "Wildcard"
        case null = "Null"
        case empty = "Empty"
        case currentTime = "CurrentTime"
    }





    /** A string value */
    public var string: String?
    /** A positive or negative whole number, including zero */
    public var integer: Int64?
    /** A positive or negative decimal number, including zero */
    public var number: Double?
    /** A date value, must be in the format of yyyy-MM-dd, e.g. 2024-09-23. Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd */
    public var date: Date?
    /** A date time value, must be in the format of yyyy-MM-dd'T'HH:mm:ss.SSSZ, e.g. 2024-10-02T01:01:01.111Z. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var datetime: Date?
    /** A special value enum, such as Wildcard, Null, etc */
    public var special: Special?
    /** A string list value */
    public var strings: [String]?
    /** A boolean value */
    public var boolean: Bool?

    public init(string: String?, integer: Int64?, number: Double?, date: Date?, datetime: Date?, special: Special?, strings: [String]?, boolean: Bool?) {
        self.string = string
        self.integer = integer
        self.number = number
        self.date = date
        self.datetime = datetime
        self.special = special
        self.strings = strings
        self.boolean = boolean
    }


}




public class LocationEntityListing: Codable {





















    public var entities: [LocationDefinition]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var previousUri: String?
    public var nextUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [LocationDefinition]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, previousUri: String?, nextUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.previousUri = previousUri
        self.nextUri = nextUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class LocationSearchCriteria: Codable {









    public enum Operator: String, Codable { 
        case and = "AND"
        case or = "OR"
        case not = "NOT"
    }





    public enum ModelType: String, Codable { 
        case exact = "EXACT"
        case startsWith = "STARTS_WITH"
        case contains = "CONTAINS"
        case regex = "REGEX"
        case term = "TERM"
        case terms = "TERMS"
        case requiredFields = "REQUIRED_FIELDS"
        case matchAll = "MATCH_ALL"
    }



    /** The end value of the range. This field is used for range search types. */
    public var endValue: String?
    /** A list of values for the search to match against */
    public var values: [String]?
    /** The start value of the range. This field is used for range search types. */
    public var startValue: String?
    /** A value for the search to match against */
    public var value: String?
    /** How to apply this search criteria against other criteria */
    public var _operator: Operator?
    /** Groups multiple conditions */
    public var group: [LocationSearchCriteria]?
    /** Set date format for criteria values when using date range search type.  Supports Java date format syntax, example yyyy-MM-dd'T'HH:mm:ss.SSSX. */
    public var dateFormat: String?
    /** Search Type */
    public var type: ModelType?
    /** Field names to search against */
    public var fields: [String]?

    public init(endValue: String?, values: [String]?, startValue: String?, value: String?, _operator: Operator?, group: [LocationSearchCriteria]?, dateFormat: String?, type: ModelType?, fields: [String]?) {
        self.endValue = endValue
        self.values = values
        self.startValue = startValue
        self.value = value
        self._operator = _operator
        self.group = group
        self.dateFormat = dateFormat
        self.type = type
        self.fields = fields
    }

    public enum CodingKeys: String, CodingKey { 
        case endValue
        case values
        case startValue
        case value
        case _operator = "operator"
        case group
        case dateFormat
        case type
        case fields
    }


}




public class LogCaptureUserConfiguration: Codable {







    public enum CaptureMethod: String, Codable { 
        case onDemand = "OnDemand"
        case scheduled = "Scheduled"
    }



    /** The ID of the user for which log capture is configured. */
    public var _id: String?
    /** Indicates when log capture was enabled for the user. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateStarted: Date?
    /** Indicates when log capture will be turned off for the user. (Must be within 24 hours). Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateExpired: Date?
    /** Indicates the method by which the logs were captured. */
    public var captureMethod: CaptureMethod?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, dateStarted: Date?, dateExpired: Date?, captureMethod: CaptureMethod?, selfUri: String?) {
        self._id = _id
        self.dateStarted = dateStarted
        self.dateExpired = dateExpired
        self.captureMethod = captureMethod
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case dateStarted
        case dateExpired
        case captureMethod
        case selfUri
    }


}



/** List of log capture user configurations including total count and entities */

public class LogCaptureUserConfigurationListing: Codable {







    public var total: Int64?
    public var entities: [LogCaptureUserConfiguration]?
    public var selfUri: String?

    public init(total: Int64?, entities: [LogCaptureUserConfiguration]?, selfUri: String?) {
        self.total = total
        self.entities = entities
        self.selfUri = selfUri
    }


}




public class LongTermForecastPlanningGroupData: Codable {







    /** The ID of the planning group to which this data applies. Note this is a snapshot of the planning group at the time of forecast creation and may not correspond to the current configuration */
    public var planningGroupId: String?
    /** Forecast offered counts per day for this planning group */
    public var offeredPerDay: [Double]?
    /** Forecast average handle time per day in seconds */
    public var averageHandleTimeSecondsPerDay: [Double]?

    public init(planningGroupId: String?, offeredPerDay: [Double]?, averageHandleTimeSecondsPerDay: [Double]?) {
        self.planningGroupId = planningGroupId
        self.offeredPerDay = offeredPerDay
        self.averageHandleTimeSecondsPerDay = averageHandleTimeSecondsPerDay
    }


}




public class LongTermForecastResultResponse: Codable {





    /** The result of the operation.  Populated whenever the result is small enough to pass through the api directly */
    public var result: LongTermForecastResult?
    /** The download url to fetch the result.  Only populated if the result is too large to pass through the api directly */
    public var downloadUrl: String?

    public init(result: LongTermForecastResult?, downloadUrl: String?) {
        self.result = result
        self.downloadUrl = downloadUrl
    }


}




public class LongTermRequirements: Codable {







    /** Forecast metadata */
    public var forecastMetadata: ForecastMetadata?
    /** Date the generation of the requirements started. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateGenerationStarted: Date?
    /** List of planning group outputs */
    public var requirementResults: [PlanningGroupRequirementOutput]?

    public init(forecastMetadata: ForecastMetadata?, dateGenerationStarted: Date?, requirementResults: [PlanningGroupRequirementOutput]?) {
        self.forecastMetadata = forecastMetadata
        self.dateGenerationStarted = dateGenerationStarted
        self.requirementResults = requirementResults
    }


}




public class ManagementUnit: Codable {







    public enum StartDayOfWeek: String, Codable { 
        case sunday = "Sunday"
        case monday = "Monday"
        case tuesday = "Tuesday"
        case wednesday = "Wednesday"
        case thursday = "Thursday"
        case friday = "Friday"
        case saturday = "Saturday"
    }

















    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** The business unit to which this management unit belongs */
    public var businessUnit: BusinessUnitReference?
    /** Start day of week for scheduling and forecasting purposes. Moving to Business Unit */
    public var startDayOfWeek: StartDayOfWeek?
    /** The time zone for the management unit in standard Olson format.  Moving to Business Unit */
    public var timeZone: String?
    /** The configuration settings for this management unit */
    public var settings: ManagementUnitSettingsResponse?
    /** Version info metadata for this management unit. Deprecated, use settings.metadata */
    public var metadata: WfmVersionedEntityMetadata?
    /** The division to which this entity belongs. */
    public var division: DivisionReference?
    /** The version of the underlying entity.  Deprecated, use field from settings.metadata instead */
    public var version: Int?
    /** The date and time at which this entity was last modified.  Deprecated, use field from settings.metadata instead. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** The user who last modified this entity.  Deprecated, use field from settings.metadata instead */
    public var modifiedBy: UserReference?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, businessUnit: BusinessUnitReference?, startDayOfWeek: StartDayOfWeek?, timeZone: String?, settings: ManagementUnitSettingsResponse?, metadata: WfmVersionedEntityMetadata?, division: DivisionReference?, version: Int?, dateModified: Date?, modifiedBy: UserReference?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.businessUnit = businessUnit
        self.startDayOfWeek = startDayOfWeek
        self.timeZone = timeZone
        self.settings = settings
        self.metadata = metadata
        self.division = division
        self.version = version
        self.dateModified = dateModified
        self.modifiedBy = modifiedBy
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case businessUnit
        case startDayOfWeek
        case timeZone
        case settings
        case metadata
        case division
        case version
        case dateModified
        case modifiedBy
        case selfUri
    }


}




public class ManagementUnitListing: Codable {





















    public var entities: [ManagementUnit]?
    /** Deprecated, paging is not supported */
    public var pageSize: Int?
    /** Deprecated, paging is not supported */
    public var pageNumber: Int?
    /** Deprecated, paging is not supported */
    public var total: Int64?
    /** Deprecated, paging is not supported */
    public var firstUri: String?
    /** Deprecated, paging is not supported */
    public var previousUri: String?
    /** Deprecated, paging is not supported */
    public var nextUri: String?
    /** Deprecated, paging is not supported */
    public var lastUri: String?
    /** Deprecated, paging is not supported */
    public var pageCount: Int?
    public var selfUri: String?

    public init(entities: [ManagementUnit]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, previousUri: String?, nextUri: String?, lastUri: String?, pageCount: Int?, selfUri: String?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.previousUri = previousUri
        self.nextUri = nextUri
        self.lastUri = lastUri
        self.pageCount = pageCount
        self.selfUri = selfUri
    }


}




public class ManualSearchConfig: Codable {





    /** Articles with answer highlights. */
    public var articlesWithAnswerHighlights: Bool?
    /** Answer generation. */
    public var answerGeneration: Bool?

    public init(articlesWithAnswerHighlights: Bool?, answerGeneration: Bool?) {
        self.articlesWithAnswerHighlights = articlesWithAnswerHighlights
        self.answerGeneration = answerGeneration
    }


}




public class MaskingRule: Codable {













    public enum ModelType: String, Codable { 
        case custom = "Custom"
        case predefined = "Predefined"
        case _default = "Default"
    }

    public enum Direction: String, Codable { 
        case inbound = "inbound"
        case outbound = "outbound"
    }







    /** The globally unique identifier for the object. */
    public var _id: String?
    /** Masking rule name. */
    public var name: String?
    /** Description about masking rule. */
    public var _description: String?
    /** Replacement character for masked text character. */
    public var substituteCharacter: String?
    /** Definition of masking rule (a valid regex or builtin AI based mask name). */
    public var definition: String?
    /** True/False */
    public var enabled: Bool?
    /** Masking rule type */
    public var type: ModelType?
    /** inbound/outbound */
    public var direction: Direction?
    /** Associated integration channels */
    public var integrations: [String]?
    /** Date when the rule was created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** Date when the rule was modified. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?

    public init(_id: String?, name: String?, _description: String?, substituteCharacter: String?, definition: String?, enabled: Bool?, type: ModelType?, direction: Direction?, integrations: [String]?, dateCreated: Date?, dateModified: Date?) {
        self._id = _id
        self.name = name
        self._description = _description
        self.substituteCharacter = substituteCharacter
        self.definition = definition
        self.enabled = enabled
        self.type = type
        self.direction = direction
        self.integrations = integrations
        self.dateCreated = dateCreated
        self.dateModified = dateModified
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case _description = "description"
        case substituteCharacter
        case definition
        case enabled
        case type
        case direction
        case integrations
        case dateCreated
        case dateModified
    }


}




public class MaskingRuleListing: Codable {



    public var entities: [MaskingRule]?

    public init(entities: [MaskingRule]?) {
        self.entities = entities
    }


}




public class MaskingRuleValidateRequest: Codable {





    /** Text to mask. */
    public var text: String?
    /** Regex to be applied */
    public var definition: String?

    public init(text: String?, definition: String?) {
        self.text = text
        self.definition = definition
    }


}



/** Defines a simple matching condition */

public class MatchCriteria: Codable {



    public enum Operator: String, Codable { 
        case greaterThanOrEqual = "GreaterThanOrEqual"
        case lessThanOrEqual = "LessThanOrEqual"
        case equal = "Equal"
        case notEqual = "NotEqual"
        case lessThan = "LessThan"
        case greaterThan = "GreaterThan"
        case notIn = "NotIn"
        case _in = "In"
        case contains = "Contains"
        case all = "All"
        case exists = "Exists"
        case size = "Size"
    }





    /** The Goessner json path of the field to match */
    public var jsonPath: String?
    /** The type of operation to perform for matching check */
    public var _operator: Operator?
    /** The value to match on. Only one of value and values can be included */
    public var value: JSON?
    /** The list of values to match on. Only one of value and values can be included */
    public var values: [JSON]?

    public init(jsonPath: String?, _operator: Operator?, value: JSON?, values: [JSON]?) {
        self.jsonPath = jsonPath
        self._operator = _operator
        self.value = value
        self.values = values
    }

    public enum CodingKeys: String, CodingKey { 
        case jsonPath
        case _operator = "operator"
        case value
        case values
    }


}



/** Results of a matching expression */

public class MatchCriteriaTestResult: Codable {



    public enum Operator: String, Codable { 
        case greaterThanOrEqual = "GreaterThanOrEqual"
        case lessThanOrEqual = "LessThanOrEqual"
        case equal = "Equal"
        case notEqual = "NotEqual"
        case lessThan = "LessThan"
        case greaterThan = "GreaterThan"
        case notIn = "NotIn"
        case _in = "In"
        case contains = "Contains"
        case all = "All"
        case exists = "Exists"
        case size = "Size"
    }











    /** The Goessner json path of the field to match */
    public var jsonPath: String?
    /** The type of operation to perform for matching check */
    public var _operator: Operator?
    /** The value to match on. Only one of value and values can be included */
    public var value: JSON?
    /** The list of values to match on. Only one of value and values can be included */
    public var values: [JSON]?
    /** The generated json path condition */
    public var generatedJsonPathCondition: String?
    /** Did the generated json path condition match */
    public var match: Bool?
    /** The json paths and their values that were compared */
    public var jsonPathExtraction: [MatchTestResult]?

    public init(jsonPath: String?, _operator: Operator?, value: JSON?, values: [JSON]?, generatedJsonPathCondition: String?, match: Bool?, jsonPathExtraction: [MatchTestResult]?) {
        self.jsonPath = jsonPath
        self._operator = _operator
        self.value = value
        self.values = values
        self.generatedJsonPathCondition = generatedJsonPathCondition
        self.match = match
        self.jsonPathExtraction = jsonPathExtraction
    }

    public enum CodingKeys: String, CodingKey { 
        case jsonPath
        case _operator = "operator"
        case value
        case values
        case generatedJsonPathCondition
        case match
        case jsonPathExtraction
    }


}




public class MediaRegions: Codable {







    /** The AWS region your organization is in. */
    public var awsHomeRegion: String?
    /** The list of AWS regions to which Genesys Cloud is deployed with full functionality including media streaming. */
    public var awsCoreRegions: [String]?
    /** The list of AWS regions that Genesys Cloud uses only for media streaming. */
    public var awsSatelliteRegions: [String]?

    public init(awsHomeRegion: String?, awsCoreRegions: [String]?, awsSatelliteRegions: [String]?) {
        self.awsHomeRegion = awsHomeRegion
        self.awsCoreRegions = awsCoreRegions
        self.awsSatelliteRegions = awsSatelliteRegions
    }


}




public class MediaTranscription: Codable {



    public enum TranscriptionProvider: String, Codable { 
        case voci = "VOCI"
        case calljourney = "CALLJOURNEY"
    }



    public var displayName: String?
    public var transcriptionProvider: TranscriptionProvider?
    public var integrationId: String?

    public init(displayName: String?, transcriptionProvider: TranscriptionProvider?, integrationId: String?) {
        self.displayName = displayName
        self.transcriptionProvider = transcriptionProvider
        self.integrationId = integrationId
    }


}



/** Media type access definitions */

public class MediaTypeAccess: Codable {





    /** List of media types allowed for inbound messages from customers. If inbound messages from a customer contain media that is not in this list, the media will be dropped from the outbound message. */
    public var inbound: [MediaType]?
    /** List of media types allowed for outbound messages to customers. If an outbound message is sent that contains media that is not in this list, the message will not be sent. */
    public var outbound: [MediaType]?

    public init(inbound: [MediaType]?, outbound: [MediaType]?) {
        self.inbound = inbound
        self.outbound = outbound
    }


}




public class MemberEntity: Codable {



    public var _id: String?

    public init(_id: String?) {
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
    }


}




public class MergeContactsRequest: Codable {





    /** The IDs of all contacts involved in the merge operation (must be between 2 and 25). */
    public var contactIds: [String]?
    /** Override data to set for specific Contact fields after a merge. Any null fields in `valueOverride` will not replace existing data. */
    public var valueOverride: ExternalContact?

    public init(contactIds: [String]?, valueOverride: ExternalContact?) {
        self.contactIds = contactIds
        self.valueOverride = valueOverride
    }


}




public class MessageData: Codable {













    public enum Direction: String, Codable { 
        case inbound = "inbound"
        case outbound = "outbound"
    }

    public enum MessengerType: String, Codable { 
        case sms = "sms"
        case facebook = "facebook"
        case twitter = "twitter"
        case whatsapp = "whatsapp"
        case webmessaging = "webmessaging"
        case instagram = "instagram"
        case _open = "open"
        case apple = "apple"
    }



    public enum Status: String, Codable { 
        case queued = "queued"
        case sent = "sent"
        case failed = "failed"
        case received = "received"
        case deliverySuccess = "delivery-success"
        case deliveryFailed = "delivery-failed"
        case read = "read"
        case removed = "removed"
        case published = "published"
    }













    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** The unique identifier of the message from provider */
    public var providerMessageId: String?
    /** The time when the message was received or sent. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var timestamp: Date?
    /** The sender of the text message. */
    public var fromAddress: String?
    /** The recipient of the text message. */
    public var toAddress: String?
    /** The direction of the message. */
    public var direction: Direction?
    /** Type of text messenger. */
    public var messengerType: MessengerType?
    /** The body of the text message. (Deprecated - Instead use normalizedMessage.text) */
    public var textBody: String?
    /** The status of the message. */
    public var status: Status?
    /** The media details associated to a message. (Deprecated - Instead use normalizedMessage.content[index].attachment) */
    public var media: [MessageMedia]?
    /** The message into normalized format */
    public var normalizedMessage: ConversationNormalizedMessage?
    /** The delivery event associated with this message in normalized format, if the message direction was outbound */
    public var normalizedReceipts: [ConversationNormalizedMessage]?
    /** User who sent this message. */
    public var createdBy: User?
    /** The id of the conversation of this message. */
    public var conversationId: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, providerMessageId: String?, timestamp: Date?, fromAddress: String?, toAddress: String?, direction: Direction?, messengerType: MessengerType?, textBody: String?, status: Status?, media: [MessageMedia]?, normalizedMessage: ConversationNormalizedMessage?, normalizedReceipts: [ConversationNormalizedMessage]?, createdBy: User?, conversationId: String?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.providerMessageId = providerMessageId
        self.timestamp = timestamp
        self.fromAddress = fromAddress
        self.toAddress = toAddress
        self.direction = direction
        self.messengerType = messengerType
        self.textBody = textBody
        self.status = status
        self.media = media
        self.normalizedMessage = normalizedMessage
        self.normalizedReceipts = normalizedReceipts
        self.createdBy = createdBy
        self.conversationId = conversationId
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case providerMessageId
        case timestamp
        case fromAddress
        case toAddress
        case direction
        case messengerType
        case textBody
        case status
        case media
        case normalizedMessage
        case normalizedReceipts
        case createdBy
        case conversationId
        case selfUri
    }


}




public class MessageEvaluation: Codable {





    public enum MessageType: String, Codable { 
        case sms = "Sms"
        case email = "Email"
        case whatsApp = "WhatsApp"
    }





    /** The name of the contact column that was wrapped up */
    public var contactColumn: String?
    /** The address (phone or email) that was wrapped up */
    public var contactAddress: String?
    /** The type of message sent */
    public var messageType: MessageType?
    /** The id of the wrap-up code */
    public var wrapupCodeId: String?
    /** The time that the wrap-up was applied. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var timestamp: Date?

    public init(contactColumn: String?, contactAddress: String?, messageType: MessageType?, wrapupCodeId: String?, timestamp: Date?) {
        self.contactColumn = contactColumn
        self.contactAddress = contactAddress
        self.messageType = messageType
        self.wrapupCodeId = wrapupCodeId
        self.timestamp = timestamp
    }


}




public class MessageFooter: Codable {

    public enum ModelType: String, Codable { 
        case text = "Text"
    }



    /** Defines the content type of the footer in message */
    public var type: ModelType?
    /** Content associated with the footer in the message */
    public var content: String?

    public init(type: ModelType?, content: String?) {
        self.type = type
        self.content = content
    }


}




public class MessageMediaAttachment: Codable {



    public enum MediaType: String, Codable { 
        case imagePng = "image/png"
        case imageJpeg = "image/jpeg"
        case imageGif = "image/gif"
    }







    /** The location of the media, useful for retrieving it */
    public var url: String?
    /** The optional internet media type of the the media object.If null then the media type should be dictated by the url. */
    public var mediaType: MediaType?
    /** The optional content length of the the media object, in bytes. */
    public var contentLength: Int64?
    /** The name of the media object. */
    public var name: String?
    /** A globally unique identifier for the media object. */
    public var _id: String?

    public init(url: String?, mediaType: MediaType?, contentLength: Int64?, name: String?, _id: String?) {
        self.url = url
        self.mediaType = mediaType
        self.contentLength = contentLength
        self.name = name
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case url
        case mediaType
        case contentLength
        case name
        case _id = "id"
    }


}




public class MessageMediaData: Codable {













    public enum Status: String, Codable { 
        case uploading = "uploading"
        case valid = "valid"
        case invalid = "invalid"
    }







    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** The location of the media, useful for retrieving it */
    public var url: String?
    /** The detected internet media type of the the media object.  If null then the media type should be dictated by the url. */
    public var mediaType: String?
    /** The optional content length of the the media object, in bytes. */
    public var contentLengthBytes: Int?
    /** The URL returned to upload an attachment */
    public var uploadUrl: String?
    /** The status of the media, indicates if the media is in the process of uploading. If the upload fails, the media becomes invalid */
    public var status: Status?
    public var conversationId: String?
    public var communicationId: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, url: String?, mediaType: String?, contentLengthBytes: Int?, uploadUrl: String?, status: Status?, conversationId: String?, communicationId: String?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.url = url
        self.mediaType = mediaType
        self.contentLengthBytes = contentLengthBytes
        self.uploadUrl = uploadUrl
        self.status = status
        self.conversationId = conversationId
        self.communicationId = communicationId
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case url
        case mediaType
        case contentLengthBytes
        case uploadUrl
        case status
        case conversationId
        case communicationId
        case selfUri
    }


}




public class MessageStickerAttachment: Codable {





    /** The location of the media, useful for retrieving it */
    public var url: String?
    /** A globally unique identifier for the media object. */
    public var _id: String?

    public init(url: String?, _id: String?) {
        self.url = url
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case url
        case _id = "id"
    }


}




public class MessagingCommunicationDispositionAppliedEvent: Codable {















    /** A unique (V4 UUID) eventId for this event */
    public var eventId: String?
    /** A Date Time representing the time this event occurred. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var eventDateTime: Date?
    /** A unique Id (V4 UUID) identifying this conversation */
    public var conversationId: String?
    /** A unique Id (V4 UUID) identifying this communication */
    public var communicationId: String?
    /** The wrapup-code (V4 UUID) used to disposition this interaction. If this value is not provided the disposition is considered skipped. */
    public var code: String?
    /** Text entered by the agent to describe the interaction or disposition. Ignored if the disposition is considered skipped. */
    public var notes: String?
    /** The list of tags selected by the agent to describe the interaction or disposition. Ignored if the disposition is considered skipped. */
    public var tags: [String]?

    public init(eventId: String?, eventDateTime: Date?, conversationId: String?, communicationId: String?, code: String?, notes: String?, tags: [String]?) {
        self.eventId = eventId
        self.eventDateTime = eventDateTime
        self.conversationId = conversationId
        self.communicationId = communicationId
        self.code = code
        self.notes = notes
        self.tags = tags
    }


}




public class MessagingHoldUpdatedEvent: Codable {











    /** A unique (V4 UUID) eventId for this event */
    public var eventId: String?
    /** A Date Time representing the time this event occurred. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var eventDateTime: Date?
    /** A unique Id (V4 UUID) identifying this conversation */
    public var conversationId: String?
    /** A unique Id (V4 UUID) identifying this communication */
    public var communicationId: String?
    /** Indicates whether this communication is held. */
    public var held: Bool?

    public init(eventId: String?, eventDateTime: Date?, conversationId: String?, communicationId: String?, held: Bool?) {
        self.eventId = eventId
        self.eventDateTime = eventDateTime
        self.conversationId = conversationId
        self.communicationId = communicationId
        self.held = held
    }


}




public class MessagingIdentityResolutionConfig: Codable {









    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The division to use when performing identity resolution. */
    public var division: WritableStarrableDivision?
    /** Whether the channel should resolve identities */
    public var resolveIdentities: Bool?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, division: WritableStarrableDivision?, resolveIdentities: Bool?, selfUri: String?) {
        self._id = _id
        self.division = division
        self.resolveIdentities = resolveIdentities
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case division
        case resolveIdentities
        case selfUri
    }


}




public class MessagingIntegration: Codable {









    public enum Status: String, Codable { 
        case active = "Active"
        case inactive = "Inactive"
        case error = "Error"
        case starting = "Starting"
        case incomplete = "Incomplete"
        case deleting = "Deleting"
        case deletionFailed = "DeletionFailed"
        case failed = "Failed"
    }

    public enum MessengerType: String, Codable { 
        case sms = "sms"
        case facebook = "facebook"
        case twitter = "twitter"
        case whatsapp = "whatsapp"
        case webmessaging = "webmessaging"
        case instagram = "instagram"
        case _open = "open"
        case apple = "apple"
    }















    /** A unique Integration Id */
    public var _id: String?
    /** The name of the Integration */
    public var name: String?
    /** Defines the SupportedContent profile configured for an integration */
    public var supportedContent: SupportedContentReference?
    public var messagingSetting: MessagingSettingReference?
    /** The status of the Integration */
    public var status: Status?
    /** The type of Messaging Integration */
    public var messengerType: MessengerType?
    /** The recipient associated to the Integration. This recipient is used to associate a flow to an integration */
    public var recipient: DomainEntityRef?
    /** Date this Integration was created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** Date this Integration was modified. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** User reference that created this Integration */
    public var createdBy: DomainEntityRef?
    /** User reference that last modified this Integration */
    public var modifiedBy: DomainEntityRef?
    /** Version number required for updates. */
    public var version: Int?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, supportedContent: SupportedContentReference?, messagingSetting: MessagingSettingReference?, status: Status?, messengerType: MessengerType?, recipient: DomainEntityRef?, dateCreated: Date?, dateModified: Date?, createdBy: DomainEntityRef?, modifiedBy: DomainEntityRef?, version: Int?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.supportedContent = supportedContent
        self.messagingSetting = messagingSetting
        self.status = status
        self.messengerType = messengerType
        self.recipient = recipient
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.createdBy = createdBy
        self.modifiedBy = modifiedBy
        self.version = version
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case supportedContent
        case messagingSetting
        case status
        case messengerType
        case recipient
        case dateCreated
        case dateModified
        case createdBy
        case modifiedBy
        case version
        case selfUri
    }


}




public class MessagingRoutingEstablishedEvent: Codable {





















    /** A unique (V4 UUID) eventId for this event */
    public var eventId: String?
    /** A Date Time representing the time this event occurred. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var eventDateTime: Date?
    /** A unique Id (V4 UUID) identifying this conversation */
    public var conversationId: String?
    /** A unique Id (V4 UUID) identifying this communication. */
    public var communicationId: String?
    /** The id of the queue that is routing this conversation. */
    public var queueId: String?
    /** The unique identifiers for the skills that should be used to determine the destination for the conversation. */
    public var skillIds: [String]?
    /** The unique identifier for the language that should be used to determine the destination for the conversation. */
    public var languageId: String?
    /** An optional label that categorizes the conversation. Max-utilization settings can be configured at a per-label level. */
    public var label: String?
    /** Metadata about this communication. */
    public var initialConfiguration: MessagingInitialConfiguration?
    /** Metadata about the source of this communication's interaction. */
    public var sourceConfiguration: SourceConfiguration?

    public init(eventId: String?, eventDateTime: Date?, conversationId: String?, communicationId: String?, queueId: String?, skillIds: [String]?, languageId: String?, label: String?, initialConfiguration: MessagingInitialConfiguration?, sourceConfiguration: SourceConfiguration?) {
        self.eventId = eventId
        self.eventDateTime = eventDateTime
        self.conversationId = conversationId
        self.communicationId = communicationId
        self.queueId = queueId
        self.skillIds = skillIds
        self.languageId = languageId
        self.label = label
        self.initialConfiguration = initialConfiguration
        self.sourceConfiguration = sourceConfiguration
    }


}




public class MessagingUserTransferEvent: Codable {







    public enum TransferType: String, Codable { 
        case attended = "Attended"
        case unattended = "Unattended"
    }











    /** A unique (V4 UUID) eventId for this event */
    public var eventId: String?
    /** A Date Time representing the time this event occurred. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var eventDateTime: Date?
    /** A unique Id (V4 UUID) identifying this conversation */
    public var conversationId: String?
    /** Indicates the desired type of transfer. */
    public var transferType: TransferType?
    /** The id (V4 UUID) used by the external platform to refer to the transfer in subsequent Transfer events. */
    public var commandId: String?
    /** The id (V4 UUID) of the communication representing the participant that is initiating the transfer. */
    public var initiatingCommunicationId: String?
    /** The id (V4 UUID) of the communication that is being transferred away from. In many cases this will be the same as the `initiatingCommunicationId`. */
    public var targetCommunicationId: String?
    /** The id (V4 UUID) of the communication that is being transferred. */
    public var objectCommunicationId: String?
    /** The id (V4 UUID) of the desired destination user that the object communication should be transferred to. */
    public var destinationUserId: String?

    public init(eventId: String?, eventDateTime: Date?, conversationId: String?, transferType: TransferType?, commandId: String?, initiatingCommunicationId: String?, targetCommunicationId: String?, objectCommunicationId: String?, destinationUserId: String?) {
        self.eventId = eventId
        self.eventDateTime = eventDateTime
        self.conversationId = conversationId
        self.transferType = transferType
        self.commandId = commandId
        self.initiatingCommunicationId = initiatingCommunicationId
        self.targetCommunicationId = targetCommunicationId
        self.objectCommunicationId = objectCommunicationId
        self.destinationUserId = destinationUserId
    }


}




public class Metabase: Codable {



















    public enum State: String, Codable { 
        case active = "active"
        case inactive = "inactive"
        case deleted = "deleted"
    }





    public enum ModelType: String, Codable { 
        case external = "EXTERNAL"
        case externalPcv = "EXTERNAL_PCV"
        case externalPcvAws = "EXTERNAL_PCV_AWS"
        case externalByocCarrier = "EXTERNAL_BYOC_CARRIER"
        case externalByocPbx = "EXTERNAL_BYOC_PBX"
        case stationCdm = "STATION_CDM"
        case stationCdmWebrtc = "STATION_CDM_WEBRTC"
        case station = "STATION"
        case tie = "TIE"
        case tieDirect = "TIE_DIRECT"
        case tieIndirect = "TIE_INDIRECT"
        case tieCloudProxy = "TIE_CLOUD_PROXY"
        case tieCloudProxyCallsession = "TIE_CLOUD_PROXY_CALLSESSION"
    }



    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The name of the entity. */
    public var name: String?
    /** The division to which this entity belongs. */
    public var division: Division?
    public var _description: String?
    /** The current version of the resource. */
    public var version: Int?
    /** The date the resource was created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** The date of the last modification to the resource. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** The ID of the user that last modified the resource. */
    public var modifiedBy: String?
    /** The ID of the user that created the resource. */
    public var createdBy: String?
    /** Indicates if the resource is active, inactive, or deleted. */
    public var state: State?
    /** The application that last modified the resource. */
    public var modifiedByApp: String?
    /** The application that created the resource. */
    public var createdByApp: String?
    public var type: ModelType?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, division: Division?, _description: String?, version: Int?, dateCreated: Date?, dateModified: Date?, modifiedBy: String?, createdBy: String?, state: State?, modifiedByApp: String?, createdByApp: String?, type: ModelType?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.division = division
        self._description = _description
        self.version = version
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.modifiedBy = modifiedBy
        self.createdBy = createdBy
        self.state = state
        self.modifiedByApp = modifiedByApp
        self.createdByApp = createdByApp
        self.type = type
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case division
        case _description = "description"
        case version
        case dateCreated
        case dateModified
        case modifiedBy
        case createdBy
        case state
        case modifiedByApp
        case createdByApp
        case type
        case selfUri
    }


}



/** A representation of data fields to be gathered for installing the accelerator */

public class MetadataPresentation: Codable {





    /** title for a set of data to be gathered */
    public var title: String?
    /** description of the contents of the data gathering interface */
    public var schema: MetadataSchema?

    public init(title: String?, schema: MetadataSchema?) {
        self.title = title
        self.schema = schema
    }


}



/** A Genesys Cloud resource created or modified as a result of running an accelerator */

public class MetadataResultEntity: Codable {





    public enum Visibility: String, Codable { 
        case visible = "Visible"
        case hidden = "Hidden"
    }

    /** object type of the modified resource */
    public var type: String?
    /** description of the modified resource */
    public var _description: String?
    /** whether the modified resource is visible or hidden */
    public var visibility: Visibility?

    public init(type: String?, _description: String?, visibility: Visibility?) {
        self.type = type
        self._description = _description
        self.visibility = visibility
    }

    public enum CodingKeys: String, CodingKey { 
        case type
        case _description = "description"
        case visibility
    }


}




public class MeteredEvaluationAssignment: Codable {













    public var evaluationContextId: String?
    public var evaluators: [User]?
    public var maxNumberEvaluations: Int?
    public var evaluationForm: EvaluationForm?
    public var assignToActiveUser: Bool?
    public var timeInterval: TimeInterval?

    public init(evaluationContextId: String?, evaluators: [User]?, maxNumberEvaluations: Int?, evaluationForm: EvaluationForm?, assignToActiveUser: Bool?, timeInterval: TimeInterval?) {
        self.evaluationContextId = evaluationContextId
        self.evaluators = evaluators
        self.maxNumberEvaluations = maxNumberEvaluations
        self.evaluationForm = evaluationForm
        self.assignToActiveUser = assignToActiveUser
        self.timeInterval = timeInterval
    }


}




public class Metric: Codable {





















    public enum TimeDisplayUnit: String, Codable { 
        case _none = "None"
        case seconds = "Seconds"
        case minutes = "Minutes"
        case hours = "Hours"
    }





    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The name of this metric */
    public var name: String?
    /** The id of associated metric definition */
    public var metricDefinitionId: String?
    /** The id of associated external metric definition */
    public var externalMetricDefinitionId: String?
    /** Associated objective for this metric */
    public var objective: Objective?
    /** Performance profile id of this metric */
    public var performanceProfileId: String?
    /** The linked metric entity reference */
    public var linkedMetric: AddressableEntityRef?
    /** The created date of this metric. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** The unlinked workday for this metric if this metric was ever unlinked. Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd */
    public var dateUnlinked: Date?
    /** The precision of the metric, must be between 0 and 5 */
    public var precision: Int?
    /** The time unit in which the metric should be displayed -- this parameter is ignored when displaying non-time values */
    public var timeDisplayUnit: TimeDisplayUnit?
    /** The source performance profile when this metric is linked */
    public var sourcePerformanceProfile: PerformanceProfile?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, metricDefinitionId: String?, externalMetricDefinitionId: String?, objective: Objective?, performanceProfileId: String?, linkedMetric: AddressableEntityRef?, dateCreated: Date?, dateUnlinked: Date?, precision: Int?, timeDisplayUnit: TimeDisplayUnit?, sourcePerformanceProfile: PerformanceProfile?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.metricDefinitionId = metricDefinitionId
        self.externalMetricDefinitionId = externalMetricDefinitionId
        self.objective = objective
        self.performanceProfileId = performanceProfileId
        self.linkedMetric = linkedMetric
        self.dateCreated = dateCreated
        self.dateUnlinked = dateUnlinked
        self.precision = precision
        self.timeDisplayUnit = timeDisplayUnit
        self.sourcePerformanceProfile = sourcePerformanceProfile
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case metricDefinitionId
        case externalMetricDefinitionId
        case objective
        case performanceProfileId
        case linkedMetric
        case dateCreated
        case dateUnlinked
        case precision
        case timeDisplayUnit
        case sourcePerformanceProfile
        case selfUri
    }


}




public class Metrics: Codable {













    public enum UnitType: String, Codable { 
        case _none = "None"
        case percent = "Percent"
        case currency = "Currency"
        case seconds = "Seconds"
        case number = "Number"
        case attendanceStatus = "AttendanceStatus"
        case unit = "Unit"
    }





















    public enum TimeDisplayUnit: String, Codable { 
        case _none = "None"
        case seconds = "Seconds"
        case minutes = "Minutes"
        case hours = "Hours"
    }



    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** The order of metric within a performance profile */
    public var order: Int?
    /** The name of associated metric definition */
    public var metricDefinitionName: String?
    /** The id of associated metric definition */
    public var metricDefinitionId: String?
    /** The id of associated external metric definition */
    public var externalMetricDefinitionId: String?
    /** Corresponding unit type for this metric */
    public var unitType: UnitType?
    /** A flag for whether this metric is enabled for a performance profile */
    public var enabled: Bool?
    /** The name of associated objective template */
    public var templateName: String?
    /** Achievable maximum points for this metric */
    public var maxPoints: Int?
    /** Performance profile id of this metric */
    public var performanceProfileId: String?
    /** The linked metric entity reference */
    public var linkedMetric: AddressableEntityRef?
    /** The created date of this metric. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** The unlinked workday for this metric if this metric was ever unlinked. Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd */
    public var dateUnlinked: Date?
    /** The source performance profile when this metric is linked */
    public var sourcePerformanceProfile: PerformanceProfile?
    /** Unit definition of linked external metric */
    public var unitDefinition: String?
    /** Precision of linked external metric */
    public var precision: Int?
    /** The time unit in which the metric should be displayed -- this parameter is ignored when displaying non-time values */
    public var timeDisplayUnit: TimeDisplayUnit?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, order: Int?, metricDefinitionName: String?, metricDefinitionId: String?, externalMetricDefinitionId: String?, unitType: UnitType?, enabled: Bool?, templateName: String?, maxPoints: Int?, performanceProfileId: String?, linkedMetric: AddressableEntityRef?, dateCreated: Date?, dateUnlinked: Date?, sourcePerformanceProfile: PerformanceProfile?, unitDefinition: String?, precision: Int?, timeDisplayUnit: TimeDisplayUnit?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.order = order
        self.metricDefinitionName = metricDefinitionName
        self.metricDefinitionId = metricDefinitionId
        self.externalMetricDefinitionId = externalMetricDefinitionId
        self.unitType = unitType
        self.enabled = enabled
        self.templateName = templateName
        self.maxPoints = maxPoints
        self.performanceProfileId = performanceProfileId
        self.linkedMetric = linkedMetric
        self.dateCreated = dateCreated
        self.dateUnlinked = dateUnlinked
        self.sourcePerformanceProfile = sourcePerformanceProfile
        self.unitDefinition = unitDefinition
        self.precision = precision
        self.timeDisplayUnit = timeDisplayUnit
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case order
        case metricDefinitionName
        case metricDefinitionId
        case externalMetricDefinitionId
        case unitType
        case enabled
        case templateName
        case maxPoints
        case performanceProfileId
        case linkedMetric
        case dateCreated
        case dateUnlinked
        case sourcePerformanceProfile
        case unitDefinition
        case precision
        case timeDisplayUnit
        case selfUri
    }


}




public class MinLength: Codable {





    /** A non-negative integer for a text-based schema field denoting the minimum smallest length a string field can contain for a schema instance. */
    public var min: Int64?
    /** A non-negative integer for a text-based schema field denoting the maximum smallest length string the field can contain for a schema instance. */
    public var max: Int64?

    public init(min: Int64?, max: Int64?) {
        self.min = min
        self.max = max
    }


}




public class Miner: Codable {





    public enum Language: String, Codable { 
        case enUs = "en-us"
        case enGb = "en-gb"
        case enAu = "en-au"
        case enIn = "en-in"
        case enZa = "en-za"
        case esUs = "es-us"
        case esEs = "es-es"
        case frFr = "fr-fr"
        case frCa = "fr-ca"
        case deDe = "de-de"
        case ptPt = "pt-pt"
        case ptBr = "pt-br"
        case itIt = "it-it"
        case nlNl = "nl-nl"
        case deCh = "de-ch"
        case jaJp = "ja-jp"
        case koKr = "ko-kr"
        case hiIn = "hi-in"
        case ar001 = "ar-001"
        case arAe = "ar-ae"
        case arBh = "ar-bh"
        case arEg = "ar-eg"
        case arIl = "ar-il"
        case arSa = "ar-sa"
        case arTn = "ar-tn"
    }

    public enum MinerType: String, Codable { 
        case intent = "Intent"
        case topic = "Topic"
    }





    public enum Status: String, Codable { 
        case notStarted = "NotStarted"
        case fetchingConversationIds = "FetchingConversationIds"
        case conversationIdsFetched = "ConversationIdsFetched"
        case conversationIdsFetchError = "ConversationIdsFetchError"
        case fetchingConversations = "FetchingConversations"
        case conversationsFetched = "ConversationsFetched"
        case conversationsFetchError = "ConversationsFetchError"
        case queued = "Queued"
        case queuingError = "QueuingError"
        case miningStarted = "MiningStarted"
        case maskingUtterances = "MaskingUtterances"
        case maskingError = "MaskingError"
        case computingAnalytics = "ComputingAnalytics"
        case computingAnalyticsError = "ComputingAnalyticsError"
        case miningCompleted = "MiningCompleted"
        case miningError = "MiningError"
        case modelValidationError = "ModelValidationError"
        case deleted = "Deleted"
    }















    public enum MediaType: String, Codable { 
        case chat = "Chat"
        case call = "Call"
        case message = "Message"
        case email = "Email"
    }

    public enum ParticipantType: String, Codable { 
        case customer = "Customer"
        case agent = "Agent"
        case both = "Both"
    }

















    /** The globally unique identifier for the object. */
    public var _id: String?
    /** Chat Corpus Name. */
    public var name: String?
    /** Language Localization code. */
    public var language: Language?
    /** Type of the miner, intent or topic. */
    public var minerType: MinerType?
    /** Flag to indicate whether seeding is supported for this miner. */
    public var seeding: Bool?
    /** Date when the miner was created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** Status of the miner. */
    public var status: Status?
    /** Date from which the conversations need to be taken for mining. Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd */
    public var conversationsDateRangeStart: Date?
    /** Date till which the conversations need to be taken for mining. Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd */
    public var conversationsDateRangeEnd: Date?
    /** Date when the mining process was completed. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCompleted: Date?
    /** Mining message if present. */
    public var message: String?
    /** Error Information */
    public var errorInfo: MinerErrorInfo?
    /** Warning Information */
    public var warningInfo: MinerErrorInfo?
    /** Flag to indicate whether data file to be mined was uploaded. */
    public var conversationDataUploaded: Bool?
    /** Media type for filtering conversations. */
    public var mediaType: MediaType?
    /** Type of the participant, either agent, customer or both. */
    public var participantType: ParticipantType?
    /** List of queue IDs for filtering conversations. */
    public var queueIds: [String]?
    /** Date when the miner started execution. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateTriggered: Date?
    /** Date when the miner was last modified. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** Latest draft details of the miner. */
    public var latestDraftVersion: Draft?
    /** Number of conversations/transcripts fetched. */
    public var conversationsFetchedCount: Int?
    /** Number of conversations/recordings/transcripts that were found valid for mining purposes. */
    public var conversationsValidCount: Int?
    /** Number of intents or topics based on the miner type. */
    public var getminedItemCount: Int?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, language: Language?, minerType: MinerType?, seeding: Bool?, dateCreated: Date?, status: Status?, conversationsDateRangeStart: Date?, conversationsDateRangeEnd: Date?, dateCompleted: Date?, message: String?, errorInfo: MinerErrorInfo?, warningInfo: MinerErrorInfo?, conversationDataUploaded: Bool?, mediaType: MediaType?, participantType: ParticipantType?, queueIds: [String]?, dateTriggered: Date?, dateModified: Date?, latestDraftVersion: Draft?, conversationsFetchedCount: Int?, conversationsValidCount: Int?, getminedItemCount: Int?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.language = language
        self.minerType = minerType
        self.seeding = seeding
        self.dateCreated = dateCreated
        self.status = status
        self.conversationsDateRangeStart = conversationsDateRangeStart
        self.conversationsDateRangeEnd = conversationsDateRangeEnd
        self.dateCompleted = dateCompleted
        self.message = message
        self.errorInfo = errorInfo
        self.warningInfo = warningInfo
        self.conversationDataUploaded = conversationDataUploaded
        self.mediaType = mediaType
        self.participantType = participantType
        self.queueIds = queueIds
        self.dateTriggered = dateTriggered
        self.dateModified = dateModified
        self.latestDraftVersion = latestDraftVersion
        self.conversationsFetchedCount = conversationsFetchedCount
        self.conversationsValidCount = conversationsValidCount
        self.getminedItemCount = getminedItemCount
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case language
        case minerType
        case seeding
        case dateCreated
        case status
        case conversationsDateRangeStart
        case conversationsDateRangeEnd
        case dateCompleted
        case message
        case errorInfo
        case warningInfo
        case conversationDataUploaded
        case mediaType
        case participantType
        case queueIds
        case dateTriggered
        case dateModified
        case latestDraftVersion
        case conversationsFetchedCount
        case conversationsValidCount
        case getminedItemCount
        case selfUri
    }


}




public class MinerListing: Codable {









    public var entities: [Miner]?
    public var nextUri: String?
    public var selfUri: String?
    public var previousUri: String?

    public init(entities: [Miner]?, nextUri: String?, selfUri: String?, previousUri: String?) {
        self.entities = entities
        self.nextUri = nextUri
        self.selfUri = selfUri
        self.previousUri = previousUri
    }


}




public class MoveAgentsRequest: Codable {





    /** The list of user ids to move */
    public var userIds: [String]?
    /** The id of the management unit for which the move will be performed. To remove users from their management unit this should be set to null. */
    public var destinationManagementUnitId: String?

    public init(userIds: [String]?, destinationManagementUnitId: String?) {
        self.userIds = userIds
        self.destinationManagementUnitId = destinationManagementUnitId
    }


}




public class MuAgentsWorkPlansResult: Codable {







    public var entities: [AgentWorkPlans]?
    /** The reference date in yyyy-MM-dd format rolled back to nearest BU start day of week. Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd */
    public var referenceStartWeekDate: Date?
    /** Map containing lookup values for agent work plans. The integer keys serves as lookup keys for effective work plan from workPlanLookupKeysPerWeek property */
    public var workPlanLookup: [String:WorkPlanReference]?

    public init(entities: [AgentWorkPlans]?, referenceStartWeekDate: Date?, workPlanLookup: [String:WorkPlanReference]?) {
        self.entities = entities
        self.referenceStartWeekDate = referenceStartWeekDate
        self.workPlanLookup = workPlanLookup
    }


}




public class NamedEntity: Codable {





    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The name of the object. */
    public var name: String?

    public init(_id: String?, name: String?) {
        self._id = _id
        self.name = name
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
    }


}




public class NamedEntityTypeMechanism: Codable {





    public enum ModelType: String, Codable { 
        case ai = "AI"
        case dynamicDateTime = "DynamicDateTime"
        case dynamicList = "DynamicList"
        case list = "List"
        case regex = "Regex"
        case unknown = "Unknown"
    }

    public enum SubType: String, Codable { 
        case alphanumeric = "Alphanumeric"
        case numberSequence = "NumberSequence"
        case freeForm = "FreeForm"
    }









    /** The items that define the named entity type. */
    public var items: [NamedEntityTypeItem]?
    /** Whether the named entity type is restricted to the items provided. Default: false */
    public var restricted: Bool?
    /** The type of the mechanism. */
    public var type: ModelType?
    /** Subtype of detection mechanism */
    public var subType: SubType?
    /** The maximum length of the entity resolved value */
    public var maxLength: Int?
    /** The minimum length of the entity resolved value */
    public var minLength: Int?
    /** Flag whether to allow for special characters during AI slot capture */
    public var allowSpecialChars: Bool?
    /** Examples for entity detection */
    public var examples: [NamedEntityTypeMechanismExample]?

    public init(items: [NamedEntityTypeItem]?, restricted: Bool?, type: ModelType?, subType: SubType?, maxLength: Int?, minLength: Int?, allowSpecialChars: Bool?, examples: [NamedEntityTypeMechanismExample]?) {
        self.items = items
        self.restricted = restricted
        self.type = type
        self.subType = subType
        self.maxLength = maxLength
        self.minLength = minLength
        self.allowSpecialChars = allowSpecialChars
        self.examples = examples
    }


}




public class NamespaceDocs: Codable {







    public var name: String?
    public var friendlyName: String?
    public var limits: [LimitDocs]?

    public init(name: String?, friendlyName: String?, limits: [LimitDocs]?) {
        self.name = name
        self.friendlyName = friendlyName
        self.limits = limits
    }


}




public class NluConfusionMatrixColumn: Codable {





    /** The name of the intent for the column. */
    public var name: String?
    /** The confusion value between the intents */
    public var value: Float?

    public init(name: String?, value: Float?) {
        self.name = name
        self.value = value
    }


}




public class NluConfusionMatrixRow: Codable {





    /** The name of the intent for the row. */
    public var name: String?
    /** The columns of confusion matrix for the intent */
    public var columns: [NluConfusionMatrixColumn]?

    public init(name: String?, columns: [NluConfusionMatrixColumn]?) {
        self.name = name
        self.columns = columns
    }


}




public class NluDetectionOutput: Codable {





    /** The detected intents. */
    public var intents: [DetectedIntent]?
    /** The detected dialog acts. */
    public var dialogActs: [DetectedDialogAct]?

    public init(intents: [DetectedIntent]?, dialogActs: [DetectedDialogAct]?) {
        self.intents = intents
        self.dialogActs = dialogActs
    }


}




public class NluDetectionResponse: Codable {







    /** The NLU domain version which performed the detection. */
    public var version: NluDomainVersion?
    public var output: NluDetectionOutput?
    public var input: NluDetectionInput?

    public init(version: NluDomainVersion?, output: NluDetectionOutput?, input: NluDetectionInput?) {
        self.version = version
        self.output = output
        self.input = input
    }


}




public class NluOrganization: Codable {





    /** The NLU limits defined for this Organization */
    public var limits: [String:Int]?
    /** The list of Supported features for each languages for this Organization */
    public var supportedLanguagesInfo: [SupportedLanguagesInfoDefinition]?

    public init(limits: [String:Int]?, supportedLanguagesInfo: [SupportedLanguagesInfoDefinition]?) {
        self.limits = limits
        self.supportedLanguagesInfo = supportedLanguagesInfo
    }


}




public class NluUtterance: Codable {



    public enum Source: String, Codable { 
        case generated = "Generated"
        case user = "User"
    }



    /** ID of the utterance. */
    public var _id: String?
    /** The source of the utterance. */
    public var source: Source?
    /** The list of segments that that constitute this utterance for the given intent. */
    public var segments: [NluUtteranceSegment]?

    public init(_id: String?, source: Source?, segments: [NluUtteranceSegment]?) {
        self._id = _id
        self.source = source
        self.segments = segments
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case source
        case segments
    }


}




public class NotificationsResponse: Codable {



    public var entities: [WfmUserNotification]?

    public init(entities: [WfmUserNotification]?) {
        self.entities = entities
    }


}



/** Model for a Nuance bot application */

public class NuanceApplication: Codable {







    /** The application ID */
    public var _id: String?
    /** The application Tag */
    public var tag: String?
    /** The application name */
    public var name: String?

    public init(_id: String?, tag: String?, name: String?) {
        self._id = _id
        self.tag = tag
        self.name = name
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case tag
        case name
    }


}



/** Model for a paged listing of Nuance bots */

public class NuanceBotEntityListing: Codable {





















    public var entities: [NuanceBot]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var previousUri: String?
    public var nextUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [NuanceBot]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, previousUri: String?, nextUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.previousUri = previousUri
        self.nextUri = nextUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}



/** Model for setting the launch configuration for Nuance bots available to Genesys Cloud */

public class NuanceBotLaunchSettings: Codable {



    /** The list of Nuance bots that are configured as available to the Genesys Cloud system */
    public var botExecutionConfigurations: [BotExecutionConfiguration]?

    public init(botExecutionConfigurations: [BotExecutionConfiguration]?) {
        self.botExecutionConfigurations = botExecutionConfigurations
    }


}



/** Model for a Nuance bot transfer node */

public class NuanceBotTransferNode: Codable {





    public enum ModelType: String, Codable { 
        case end = "End"
        case escalate = "Escalate"
    }





    /** The transfer node ID */
    public var _id: String?
    /** The transfer node name */
    public var name: String?
    /** The transfer node type */
    public var type: ModelType?
    /** The transfer node description */
    public var _description: String?
    /** List of variables associated with this transfer node */
    public var requestVariables: [NuanceBotVariable]?

    public init(_id: String?, name: String?, type: ModelType?, _description: String?, requestVariables: [NuanceBotVariable]?) {
        self._id = _id
        self.name = name
        self.type = type
        self._description = _description
        self.requestVariables = requestVariables
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case type
        case _description = "description"
        case requestVariables
    }


}




public class NuanceMixDlgSettings: Codable {





    /** The Nuance channel ID to use when launching the Nuance bot, which must one of the code names of the bot's registered input channels. */
    public var channelId: String?
    /** Name/value pairs of input variables to be sent to the Nuance bot. The values must be in the appropriate format for the variable's type (see https://docs.mix.nuance.com/dialog-grpc/v1/#simple-variable-types for help) */
    public var inputParameters: [String:JSON]?

    public init(channelId: String?, inputParameters: [String:JSON]?) {
        self.channelId = channelId
        self.inputParameters = inputParameters
    }


}




public class Number: Codable {





    public var start: String?
    public var end: String?

    public init(start: String?, end: String?) {
        self.start = start
        self.end = end
    }


}




public class NumberPlan: Codable {



















    public enum State: String, Codable { 
        case active = "active"
        case inactive = "inactive"
        case deleted = "deleted"
    }





















    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The name of the entity. */
    public var name: String?
    /** The division to which this entity belongs. */
    public var division: Division?
    /** The resource's description. */
    public var _description: String?
    /** The current version of the resource. */
    public var version: Int?
    /** The date the resource was created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** The date of the last modification to the resource. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** The ID of the user that last modified the resource. */
    public var modifiedBy: String?
    /** The ID of the user that created the resource. */
    public var createdBy: String?
    /** Indicates if the resource is active, inactive, or deleted. */
    public var state: State?
    /** The application that last modified the resource. */
    public var modifiedByApp: String?
    /** The application that created the resource. */
    public var createdByApp: String?
    public var match: String?
    public var normalizedFormat: String?
    public var priority: Int?
    public var numbers: [Number]?
    public var digitLength: DigitLength?
    public var classification: String?
    public var matchType: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, division: Division?, _description: String?, version: Int?, dateCreated: Date?, dateModified: Date?, modifiedBy: String?, createdBy: String?, state: State?, modifiedByApp: String?, createdByApp: String?, match: String?, normalizedFormat: String?, priority: Int?, numbers: [Number]?, digitLength: DigitLength?, classification: String?, matchType: String?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.division = division
        self._description = _description
        self.version = version
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.modifiedBy = modifiedBy
        self.createdBy = createdBy
        self.state = state
        self.modifiedByApp = modifiedByApp
        self.createdByApp = createdByApp
        self.match = match
        self.normalizedFormat = normalizedFormat
        self.priority = priority
        self.numbers = numbers
        self.digitLength = digitLength
        self.classification = classification
        self.matchType = matchType
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case division
        case _description = "description"
        case version
        case dateCreated
        case dateModified
        case modifiedBy
        case createdBy
        case state
        case modifiedByApp
        case createdByApp
        case match
        case normalizedFormat
        case priority
        case numbers
        case digitLength
        case classification
        case matchType
        case selfUri
    }


}




public class OAuthScope: Codable {







    /** The globally unique identifier for the object. */
    public var _id: String?
    public var _description: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, _description: String?, selfUri: String?) {
        self._id = _id
        self._description = _description
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case _description = "description"
        case selfUri
    }


}




public class OAuthScopeListing: Codable {







    public var total: Int64?
    public var entities: [OAuthScope]?
    public var selfUri: String?

    public init(total: Int64?, entities: [OAuthScope]?, selfUri: String?) {
        self.total = total
        self.entities = entities
        self.selfUri = selfUri
    }


}




public class OpenActionFields: Codable {





    /** The specific type of the open action. */
    public var openAction: DomainEntityRef?
    /** Custom fields defined in the schema referenced by the open action type selected. */
    public var configurationFields: [String:JSON]?

    public init(openAction: DomainEntityRef?, configurationFields: [String:JSON]?) {
        self.openAction = openAction
        self.configurationFields = configurationFields
    }


}




public class OpenActionProperties: Codable {





    /** The specific type of the open action. */
    public var openActionName: String?
    /** Custom fields defined in the schema referenced by the open action type selected. */
    public var configurationFields: [String:JSON]?

    public init(openActionName: String?, configurationFields: [String:JSON]?) {
        self.openActionName = openActionName
        self.configurationFields = configurationFields
    }


}




public class OpenDataIngestionRuleRequest: Codable {







    /** The name of the data ingestion rule. */
    public var name: String?
    /** A description of the data ingestion rule. */
    public var _description: String?
    /** The external source associated with this open data ingestion rule, which will be used when performing identity resolution */
    public var externalSource: DomainEntityRef?

    public init(name: String?, _description: String?, externalSource: DomainEntityRef?) {
        self.name = name
        self._description = _description
        self.externalSource = externalSource
    }

    public enum CodingKeys: String, CodingKey { 
        case name
        case _description = "description"
        case externalSource
    }


}



/** Open Messaging rich media message structure */

public class OpenInboundNormalizedReceipt: Codable {





    public enum Status: String, Codable { 
        case sent = "Sent"
        case delivered = "Delivered"
        case failed = "Failed"
        case published = "Published"
        case removed = "Removed"
    }





    /** The original unique message Id generated by the messaging platform, that this receipt message is referencing. */
    public var _id: String?
    /** Channel-specific information that describes the message and the message channel/provider. */
    public var channel: OpenInboundMessagingReceiptChannel?
    /** Message receipt status. */
    public var status: Status?
    /** List of reasons for a message receipt that indicates the message has failed. Only used with Failed status. */
    public var reasons: [ConversationReason]?
    /** Indicates if this is the last message receipt for this message, or if another message receipt can be expected. */
    public var isFinalReceipt: Bool?

    public init(_id: String?, channel: OpenInboundMessagingReceiptChannel?, status: Status?, reasons: [ConversationReason]?, isFinalReceipt: Bool?) {
        self._id = _id
        self.channel = channel
        self.status = status
        self.reasons = reasons
        self.isFinalReceipt = isFinalReceipt
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case channel
        case status
        case reasons
        case isFinalReceipt
    }


}



/** Message content element. */

public class OpenMessageContent: Codable {

    public enum ContentType: String, Codable { 
        case attachment = "Attachment"
    }



    /** Type of this content element. If contentType = \"Attachment\" only one item is allowed. */
    public var contentType: ContentType?
    /** Attachment content. */
    public var attachment: ConversationContentAttachment?

    public init(contentType: ContentType?, attachment: ConversationContentAttachment?) {
        self.contentType = contentType
        self.attachment = attachment
    }


}



/** Open Messaging rich media message structure */

public class OpenReceiptNormalizedMessage: Codable {





    public enum ModelType: String, Codable { 
        case receipt = "Receipt"
    }

    public enum Status: String, Codable { 
        case sent = "Sent"
        case delivered = "Delivered"
        case failed = "Failed"
        case published = "Published"
        case removed = "Removed"
    }





    public enum Direction: String, Codable { 
        case inbound = "Inbound"
        case outbound = "Outbound"
    }

    /** The original unique message Id generated by the messaging platform, that this receipt message is referencing. */
    public var _id: String?
    /** Channel-specific information that describes the message and the message channel/provider. */
    public var channel: OpenMessagingChannel?
    /** Message type. */
    public var type: ModelType?
    /** Message receipt status. */
    public var status: Status?
    /** List of reasons for a message receipt that indicates the message has failed. Only used with Failed status. */
    public var reasons: [ConversationReason]?
    /** Indicates if this is the last message receipt for this message, or if another message receipt can be expected. */
    public var isFinalReceipt: Bool?
    /** The direction of the message. */
    public var direction: Direction?

    public init(_id: String?, channel: OpenMessagingChannel?, type: ModelType?, status: Status?, reasons: [ConversationReason]?, isFinalReceipt: Bool?, direction: Direction?) {
        self._id = _id
        self.channel = channel
        self.type = type
        self.status = status
        self.reasons = reasons
        self.isFinalReceipt = isFinalReceipt
        self.direction = direction
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case channel
        case type
        case status
        case reasons
        case isFinalReceipt
        case direction
    }


}



/** Channel-specific information that describes the message and the message channel/provider. */

public class OpenSocialMediaChannel: Codable {



    public enum Platform: String, Codable { 
        case _open = "Open"
    }

    public enum ModelType: String, Codable { 
        case _public = "Public"
    }













    /** The topic ID. */
    public var _id: String?
    /** The provider type. */
    public var platform: Platform?
    /** Specifies if this message is part of a private or public conversation. */
    public var type: ModelType?
    /** Unique provider ID of the message such as a Facebook message ID. */
    public var messageId: String?
    /** Information about the recipient the message is sent to. */
    public var to: OpenSocialMediaRecipient?
    /** Information about the recipient the message is received from. */
    public var from: OpenSocialMediaRecipient?
    /** Original time of the event. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var time: Date?
    /** Information about the channel. */
    public var metadata: JSON?
    /** Meta data of this public post. For example, used to define where in the thread the post exists. */
    public var publicMetadata: OpenSocialMediaPublicMetadata?

    public init(_id: String?, platform: Platform?, type: ModelType?, messageId: String?, to: OpenSocialMediaRecipient?, from: OpenSocialMediaRecipient?, time: Date?, metadata: JSON?, publicMetadata: OpenSocialMediaPublicMetadata?) {
        self._id = _id
        self.platform = platform
        self.type = type
        self.messageId = messageId
        self.to = to
        self.from = from
        self.time = time
        self.metadata = metadata
        self.publicMetadata = publicMetadata
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case platform
        case type
        case messageId
        case to
        case from
        case time
        case metadata
        case publicMetadata
    }


}




public class OpenSocialReactionsNormalizedEventEntityListing: Codable {





















    public var entities: [OpenSocialMediaReactionsNormalizedEvent]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var previousUri: String?
    public var nextUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [OpenSocialMediaReactionsNormalizedEvent]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, previousUri: String?, nextUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.previousUri = previousUri
        self.nextUri = nextUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class OperationCreatorUserResponse: Codable {



    public enum ModelType: String, Codable { 
        case user = "User"
        case oauthclient = "OAuthClient"
    }



    /** The globally unique identifier for the object. */
    public var _id: String?
    /** Type of the operation creator entity: User or OAuthClient */
    public var type: ModelType?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, type: ModelType?, selfUri: String?) {
        self._id = _id
        self.type = type
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case type
        case selfUri
    }


}




public class OperationResponse: Codable {





    public enum ModelType: String, Codable { 
        case _import = "Import"
        case export = "Export"
        case parse = "Parse"
        case sync = "Sync"
    }











    /** The globally unique identifier for the object. */
    public var _id: String?
    /** Status of the operation. */
    public var status: String?
    /** Type of the operation. */
    public var type: ModelType?
    /** The user who created the operation. */
    public var createdBy: UserReference?
    /** Operation creation date-time. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** Operation last modification date-time. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** Source of the operation. */
    public var source: KnowledgeOperationSource?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, status: String?, type: ModelType?, createdBy: UserReference?, dateCreated: Date?, dateModified: Date?, source: KnowledgeOperationSource?, selfUri: String?) {
        self._id = _id
        self.status = status
        self.type = type
        self.createdBy = createdBy
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.source = source
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case status
        case type
        case createdBy
        case dateCreated
        case dateModified
        case source
        case selfUri
    }


}




public class OperatorPosition: Codable {





    /** Number of seconds (for voice interactions) from operand match */
    public var voiceSecondsPosition: Int?
    /** Number of words (for digital interactions) from operand match */
    public var digitalWordsPosition: Int?

    public init(voiceSecondsPosition: Int?, digitalWordsPosition: Int?) {
        self.voiceSecondsPosition = voiceSecondsPosition
        self.digitalWordsPosition = digitalWordsPosition
    }


}




public class OrgAuthSettings: Codable {













    /** Indicates whether multi-factor authentication is required. */
    public var multifactorAuthenticationRequired: Bool?
    /** Indicates whether the domain allowlist is enabled. */
    public var domainAllowlistEnabled: Bool?
    /** The list of domains that will be allowed to embed Genesys Cloud applications. */
    public var domainAllowlist: [String]?
    /** The list of IP addresses that will be allowed to authenticate with Genesys Cloud. */
    public var ipAddressAllowlist: [String]?
    /** The password requirements for the organization. */
    public var passwordRequirements: PasswordRequirements?
    /** The list of exempt apis from inactivity timeout. */
    public var inactivityTimeoutExclusions: [String]?

    public init(multifactorAuthenticationRequired: Bool?, domainAllowlistEnabled: Bool?, domainAllowlist: [String]?, ipAddressAllowlist: [String]?, passwordRequirements: PasswordRequirements?, inactivityTimeoutExclusions: [String]?) {
        self.multifactorAuthenticationRequired = multifactorAuthenticationRequired
        self.domainAllowlistEnabled = domainAllowlistEnabled
        self.domainAllowlist = domainAllowlist
        self.ipAddressAllowlist = ipAddressAllowlist
        self.passwordRequirements = passwordRequirements
        self.inactivityTimeoutExclusions = inactivityTimeoutExclusions
    }


}




public class OrgWhitelistSettings: Codable {





    public var enableWhitelist: Bool?
    public var domainWhitelist: [String]?

    public init(enableWhitelist: Bool?, domainWhitelist: [String]?) {
        self.enableWhitelist = enableWhitelist
        self.domainWhitelist = domainWhitelist
    }


}




public class OrganizationPresenceEntityListing: Codable {





















    public var entities: [OrganizationPresence]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var previousUri: String?
    public var nextUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [OrganizationPresence]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, previousUri: String?, nextUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.previousUri = previousUri
        self.nextUri = nextUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class OrphanUpdateRequest: Codable {











    /** The orphan recording's archive date. Must be greater than 1 day from now if set. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var archiveDate: Date?
    /** The orphan recording's delete date. Must be greater than archiveDate and exportDate if set, otherwise one day from now. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var deleteDate: Date?
    /** The orphan recording's export date. Must be greater than 1 day from now if set. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var exportDate: Date?
    /** IntegrationId to access AWS S3 bucket for export. This field is required if exportDate is set. */
    public var integrationId: String?
    /** A conversation Id that this orphan's recording is to be attached to. If not present, the conversationId will be deduced from the recording media. */
    public var conversationId: String?

    public init(archiveDate: Date?, deleteDate: Date?, exportDate: Date?, integrationId: String?, conversationId: String?) {
        self.archiveDate = archiveDate
        self.deleteDate = deleteDate
        self.exportDate = exportDate
        self.integrationId = integrationId
        self.conversationId = conversationId
    }


}




public class OutboundMessagingCampaignPreContactWhatsappEventTopicOutboundMessagingCampaignPreContactWhatsAppEvent: Codable {



    public enum OutboundCampaignType: String, Codable { 
        case unknown = "UNKNOWN"
        case email = "EMAIL"
        case sms = "SMS"
        case whatsapp = "WHATSAPP"
    }



    public enum WrapupCode: String, Codable { 
        case unknown = "UNKNOWN"
        case ininOutboundNumbersInvalid = "ININ_OUTBOUND_NUMBERS_INVALID"
        case ininOutboundInternalErrorSkipped = "ININ_OUTBOUND_INTERNAL_ERROR_SKIPPED"
        case ininOutboundDncSkipped = "ININ_OUTBOUND_DNC_SKIPPED"
        case ininOutboundZoneBlockedSkipped = "ININ_OUTBOUND_ZONE_BLOCKED_SKIPPED"
        case outboundContactUncontactableSkipped = "OUTBOUND_CONTACT_UNCONTACTABLE_SKIPPED"
        case outboundNumberUncontactableSkipped = "OUTBOUND_NUMBER_UNCONTACTABLE_SKIPPED"
        case outboundInvalidPhoneNumber = "OUTBOUND_INVALID_PHONE_NUMBER"
        case ininOutboundDncAuthenticationFailed = "ININ_OUTBOUND_DNC_AUTHENTICATION_FAILED"
        case ininOutboundOnDoNotCallList = "ININ_OUTBOUND_ON_DO_NOT_CALL_LIST"
        case outboundMaxMessageLengthExceeded = "OUTBOUND_MAX_MESSAGE_LENGTH_EXCEEDED"
        case outboundStuckContact = "OUTBOUND_STUCK_CONTACT"
        case outboundMessageHeaderParameterValueTooLong = "OUTBOUND_MESSAGE_HEADER_PARAMETER_VALUE_TOO_LONG"
        case outboundMessageButtonUrlParameterValueTooLong = "OUTBOUND_MESSAGE_BUTTON_URL_PARAMETER_VALUE_TOO_LONG"
    }













    public var eventTime: Int64?
    public var outboundCampaignType: OutboundCampaignType?
    public var whatsAppAttributes: OutboundMessagingCampaignPreContactWhatsappEventTopicWhatsAppAttributes?
    public var wrapupCode: WrapupCode?
    public var outboundCampaignId: UUID?
    public var divisionId: UUID?
    public var contentTemplateId: UUID?
    public var outboundContactListId: UUID?
    public var outboundContactId: String?
    public var isCampaignAlwaysRunning: Bool?

    public init(eventTime: Int64?, outboundCampaignType: OutboundCampaignType?, whatsAppAttributes: OutboundMessagingCampaignPreContactWhatsappEventTopicWhatsAppAttributes?, wrapupCode: WrapupCode?, outboundCampaignId: UUID?, divisionId: UUID?, contentTemplateId: UUID?, outboundContactListId: UUID?, outboundContactId: String?, isCampaignAlwaysRunning: Bool?) {
        self.eventTime = eventTime
        self.outboundCampaignType = outboundCampaignType
        self.whatsAppAttributes = whatsAppAttributes
        self.wrapupCode = wrapupCode
        self.outboundCampaignId = outboundCampaignId
        self.divisionId = divisionId
        self.contentTemplateId = contentTemplateId
        self.outboundContactListId = outboundContactListId
        self.outboundContactId = outboundContactId
        self.isCampaignAlwaysRunning = isCampaignAlwaysRunning
    }


}




public class OutboundMessagingEmailCampaignConfigChangeContactSort: Codable {



    public enum Direction: String, Codable { 
        case asc = "ASC"
        case desc = "DESC"
    }







    public var fieldName: String?
    public var direction: Direction?
    /** Whether that column contains numeric data */
    public var numeric: Bool?
    public var additionalProperties: [String:JSON]?
    public var getAdditionalProperties: [String:JSON]?

    public init(fieldName: String?, direction: Direction?, numeric: Bool?, additionalProperties: [String:JSON]?, getAdditionalProperties: [String:JSON]?) {
        self.fieldName = fieldName
        self.direction = direction
        self.numeric = numeric
        self.additionalProperties = additionalProperties
        self.getAdditionalProperties = getAdditionalProperties
    }


}



/** An outbound-messaging messaging campaign SMS Config */

public class OutboundMessagingEmailCampaignConfigChangeSmsConfig: Codable {









    /** The Contact List column specifying the message to send to the contact. */
    public var messageColumn: String?
    /** The Contact List column specifying the phone number to send a message to. */
    public var phoneColumn: String?
    public var senderSmsPhoneNumber: OutboundMessagingEmailCampaignConfigChangeSmsPhoneNumberRef?
    public var contentTemplate: OutboundMessagingEmailCampaignConfigChangeResponseRef?

    public init(messageColumn: String?, phoneColumn: String?, senderSmsPhoneNumber: OutboundMessagingEmailCampaignConfigChangeSmsPhoneNumberRef?, contentTemplate: OutboundMessagingEmailCampaignConfigChangeResponseRef?) {
        self.messageColumn = messageColumn
        self.phoneColumn = phoneColumn
        self.senderSmsPhoneNumber = senderSmsPhoneNumber
        self.contentTemplate = contentTemplate
    }


}



/** A reference for an SmsPhoneNumber */

public class OutboundMessagingEmailCampaignConfigChangeSmsPhoneNumberRef: Codable {



    /** The unique phone number */
    public var phoneNumber: String?

    public init(phoneNumber: String?) {
        self.phoneNumber = phoneNumber
    }


}



/** A UriReference for a resource */

public class OutboundMessagingEmailCampaignConfigChangeUriReference: Codable {





    /** The ID of the resource */
    public var _id: String?
    /** The name of the resource */
    public var name: String?

    public init(_id: String?, name: String?) {
        self._id = _id
        self.name = name
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
    }


}




public class OutboundMessagingEmailCampaignProgressEventCampaignProgress: Codable {

















    public var campaign: OutboundMessagingEmailCampaignProgressEventUriReference?
    /** The number of contacts that have been called so far */
    public var numberOfContactsCalled: Double?
    /** The number of contacts that have been messaged so far */
    public var numberOfContactsMessaged: Double?
    /** The total number of contacts in the contact list */
    public var totalNumberOfContacts: Double?
    /** numberOfContactsContacted/totalNumberOfContacts*100 */
    public var percentage: Int64?
    /** A map of skipped reasons and the number of contacts associated with each. */
    public var numberOfContactsSkipped: [String:Int64]?
    public var additionalProperties: [String:JSON]?
    public var getAdditionalProperties: [String:JSON]?

    public init(campaign: OutboundMessagingEmailCampaignProgressEventUriReference?, numberOfContactsCalled: Double?, numberOfContactsMessaged: Double?, totalNumberOfContacts: Double?, percentage: Int64?, numberOfContactsSkipped: [String:Int64]?, additionalProperties: [String:JSON]?, getAdditionalProperties: [String:JSON]?) {
        self.campaign = campaign
        self.numberOfContactsCalled = numberOfContactsCalled
        self.numberOfContactsMessaged = numberOfContactsMessaged
        self.totalNumberOfContacts = totalNumberOfContacts
        self.percentage = percentage
        self.numberOfContactsSkipped = numberOfContactsSkipped
        self.additionalProperties = additionalProperties
        self.getAdditionalProperties = getAdditionalProperties
    }


}




public class OutboundMessagingMessagingCampaignConfigChangeErrorDetail: Codable {





    /** The name of the error code. */
    public var error: String?
    /** The additional information regarding the error message. */
    public var details: String?

    public init(error: String?, details: String?) {
        self.error = error
        self.details = details
    }


}



/** An outbound-messaging messaging campaign email address */

public class OutboundMessagingMessagingCampaignConfigChangeFromEmailAddress: Codable {







    /** The friendly name of the email address. */
    public var friendlyName: String?
    /** The local part of the email address. */
    public var localPart: String?
    /** A UriReference for a resource */
    public var domain: OutboundMessagingMessagingCampaignConfigChangeUriReference?

    public init(friendlyName: String?, localPart: String?, domain: OutboundMessagingMessagingCampaignConfigChangeUriReference?) {
        self.friendlyName = friendlyName
        self.localPart = localPart
        self.domain = domain
    }


}



/** An outbound-messaging messaging campaign email address */

public class OutboundMessagingMessagingCampaignConfigChangeReplyToEmailAddress: Codable {





    /** A UriReference for a resource */
    public var domain: OutboundMessagingMessagingCampaignConfigChangeUriReference?
    /** A UriReference for a resource */
    public var route: OutboundMessagingMessagingCampaignConfigChangeUriReference?

    public init(domain: OutboundMessagingMessagingCampaignConfigChangeUriReference?, route: OutboundMessagingMessagingCampaignConfigChangeUriReference?) {
        self.domain = domain
        self.route = route
    }


}



/** A reference for a Response */

public class OutboundMessagingMessagingCampaignConfigChangeResponseRef: Codable {



    /** The unique response id */
    public var _id: String?

    public init(_id: String?) {
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
    }


}



/** A UriReference for a resource */

public class OutboundMessagingMessagingCampaignProgressEventUriReference: Codable {





    /** The ID of the resource */
    public var _id: String?
    /** The name of the resource */
    public var name: String?

    public init(_id: String?, name: String?) {
        self._id = _id
        self.name = name
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
    }


}




public class OutboundPreviewCampaignPostContactOutboundPreviewCampaignPostContactEvent: Codable {









    public enum DialingMode: String, Codable { 
        case unknown = "UNKNOWN"
        case preview = "PREVIEW"
        case power = "POWER"
        case predictive = "PREDICTIVE"
        case agentless = "AGENTLESS"
        case external = "EXTERNAL"
        case progressive = "PROGRESSIVE"
    }



































    public var eventTime: Int64?
    public var voiceAttributes: OutboundPreviewCampaignPostContactVoiceAttributes?
    public var wrapupCode: String?
    public var outboundCampaignId: UUID?
    public var dialingMode: DialingMode?
    public var agentScriptId: UUID?
    public var divisionId: UUID?
    public var outboundContactListId: UUID?
    public var outboundContactListFilterId: UUID?
    public var outboundQueueId: UUID?
    public var outboundContactId: String?
    public var isCampaignAlwaysRunning: Bool?
    public var isCampaignSkillBased: Bool?
    public var isCampaignDynamicSorting: Bool?
    public var isCampaignDynamicFiltering: Bool?
    public var outboundCampaignHealthMask: Int64?
    public var isReCall: Bool?
    public var scheduledDateTime: String?
    public var conversationId: UUID?
    public var isRightPartyContact: Bool?
    public var callAnalysisDisposition: String?
    public var agentId: String?

    public init(eventTime: Int64?, voiceAttributes: OutboundPreviewCampaignPostContactVoiceAttributes?, wrapupCode: String?, outboundCampaignId: UUID?, dialingMode: DialingMode?, agentScriptId: UUID?, divisionId: UUID?, outboundContactListId: UUID?, outboundContactListFilterId: UUID?, outboundQueueId: UUID?, outboundContactId: String?, isCampaignAlwaysRunning: Bool?, isCampaignSkillBased: Bool?, isCampaignDynamicSorting: Bool?, isCampaignDynamicFiltering: Bool?, outboundCampaignHealthMask: Int64?, isReCall: Bool?, scheduledDateTime: String?, conversationId: UUID?, isRightPartyContact: Bool?, callAnalysisDisposition: String?, agentId: String?) {
        self.eventTime = eventTime
        self.voiceAttributes = voiceAttributes
        self.wrapupCode = wrapupCode
        self.outboundCampaignId = outboundCampaignId
        self.dialingMode = dialingMode
        self.agentScriptId = agentScriptId
        self.divisionId = divisionId
        self.outboundContactListId = outboundContactListId
        self.outboundContactListFilterId = outboundContactListFilterId
        self.outboundQueueId = outboundQueueId
        self.outboundContactId = outboundContactId
        self.isCampaignAlwaysRunning = isCampaignAlwaysRunning
        self.isCampaignSkillBased = isCampaignSkillBased
        self.isCampaignDynamicSorting = isCampaignDynamicSorting
        self.isCampaignDynamicFiltering = isCampaignDynamicFiltering
        self.outboundCampaignHealthMask = outboundCampaignHealthMask
        self.isReCall = isReCall
        self.scheduledDateTime = scheduledDateTime
        self.conversationId = conversationId
        self.isRightPartyContact = isRightPartyContact
        self.callAnalysisDisposition = callAnalysisDisposition
        self.agentId = agentId
    }


}




public class OutboundPreviewCampaignPreContactVoiceAttributes: Codable {



    public enum ContactPhoneType: String, Codable { 
        case unknown = "UNKNOWN"
        case cell = "CELL"
        case daytime = "DAYTIME"
        case evening = "EVENING"
        case home = "HOME"
        case work = "WORK"
    }











    public var contactPhoneNumber: String?
    public var contactPhoneType: ContactPhoneType?
    public var callerIdPhoneNumber: String?
    public var callerIdName: String?
    public var agentOwnedColumnName: String?
    public var previewModeColumnName: String?
    public var isDeliveredAsPreview: Bool?

    public init(contactPhoneNumber: String?, contactPhoneType: ContactPhoneType?, callerIdPhoneNumber: String?, callerIdName: String?, agentOwnedColumnName: String?, previewModeColumnName: String?, isDeliveredAsPreview: Bool?) {
        self.contactPhoneNumber = contactPhoneNumber
        self.contactPhoneType = contactPhoneType
        self.callerIdPhoneNumber = callerIdPhoneNumber
        self.callerIdName = callerIdName
        self.agentOwnedColumnName = agentOwnedColumnName
        self.previewModeColumnName = previewModeColumnName
        self.isDeliveredAsPreview = isDeliveredAsPreview
    }


}




public class OutboundRouteEntityListing: Codable {























    public var entities: [OutboundRoute]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    /** The total organization-wide number of entities. */
    public var totalNumberOfEntities: Int64?
    public var firstUri: String?
    public var previousUri: String?
    public var nextUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [OutboundRoute]?, pageSize: Int?, pageNumber: Int?, total: Int64?, totalNumberOfEntities: Int64?, firstUri: String?, previousUri: String?, nextUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.totalNumberOfEntities = totalNumberOfEntities
        self.firstUri = firstUri
        self.previousUri = previousUri
        self.nextUri = nextUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class OutboundSettings: Codable {





















    public enum ComplianceAbandonRateDenominator: String, Codable { 
        case allCalls = "ALL_CALLS"
        case callsThatReachedQueue = "CALLS_THAT_REACHED_QUEUE"
    }







    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** Creation time of the entity. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** Last modified time of the entity. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** Required for updates, must match the version number of the most recent update */
    public var version: Int?
    /** The maximum number of calls that can be placed per agent on any campaign */
    public var maxCallsPerAgent: Int?
    /** The maximum number of calls that can be placed per agent on any campaign with decimal precision */
    public var maxCallsPerAgentDecimal: Double?
    /** The maximum number of calls that can be configured to be placed per agent on any campaign */
    public var maxConfigurableCallsPerAgent: Int?
    /** The maximum percentage of lines that should be used for Outbound, expressed as a decimal in the range [0.0, 1.0] */
    public var maxLineUtilization: Double?
    /** The number of seconds used to determine if a call is abandoned */
    public var abandonSeconds: Double?
    /** The denominator to be used in determining the compliance abandon rate */
    public var complianceAbandonRateDenominator: ComplianceAbandonRateDenominator?
    /** The settings for automatic time zone mapping. Note that changing these settings will change them for both voice and messaging campaigns. */
    public var automaticTimeZoneMapping: AutomaticTimeZoneMappingSettings?
    /** Whether or not to reschedule time-zone blocked contacts */
    public var rescheduleTimeZoneSkippedContacts: Bool?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, dateCreated: Date?, dateModified: Date?, version: Int?, maxCallsPerAgent: Int?, maxCallsPerAgentDecimal: Double?, maxConfigurableCallsPerAgent: Int?, maxLineUtilization: Double?, abandonSeconds: Double?, complianceAbandonRateDenominator: ComplianceAbandonRateDenominator?, automaticTimeZoneMapping: AutomaticTimeZoneMappingSettings?, rescheduleTimeZoneSkippedContacts: Bool?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.version = version
        self.maxCallsPerAgent = maxCallsPerAgent
        self.maxCallsPerAgentDecimal = maxCallsPerAgentDecimal
        self.maxConfigurableCallsPerAgent = maxConfigurableCallsPerAgent
        self.maxLineUtilization = maxLineUtilization
        self.abandonSeconds = abandonSeconds
        self.complianceAbandonRateDenominator = complianceAbandonRateDenominator
        self.automaticTimeZoneMapping = automaticTimeZoneMapping
        self.rescheduleTimeZoneSkippedContacts = rescheduleTimeZoneSkippedContacts
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case dateCreated
        case dateModified
        case version
        case maxCallsPerAgent
        case maxCallsPerAgentDecimal
        case maxConfigurableCallsPerAgent
        case maxLineUtilization
        case abandonSeconds
        case complianceAbandonRateDenominator
        case automaticTimeZoneMapping
        case rescheduleTimeZoneSkippedContacts
        case selfUri
    }


}




public class Outcome: Codable {

























    /** ID of the outcome. */
    public var _id: String?
    /** Whether or not the outcome is active. */
    public var isActive: Bool?
    /** The display name of the outcome. */
    public var displayName: String?
    /** The version of the outcome. */
    public var version: Int?
    /** A description of the outcome. */
    public var _description: String?
    /** Whether or not the outcome is positive. */
    public var isPositive: Bool?
    /** The context of the outcome. */
    public var context: Context?
    /** The pattern of rules defining the filter of the outcome. */
    public var journey: Journey?
    /** The field from the event indicating the associated value. */
    public var associatedValueField: AssociatedValueField?
    /** The URI for this object */
    public var selfUri: String?
    /** Timestamp indicating when the outcome was created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var createdDate: Date?
    /** Timestamp indicating when the outcome was last updated. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var modifiedDate: Date?

    public init(_id: String?, isActive: Bool?, displayName: String?, version: Int?, _description: String?, isPositive: Bool?, context: Context?, journey: Journey?, associatedValueField: AssociatedValueField?, selfUri: String?, createdDate: Date?, modifiedDate: Date?) {
        self._id = _id
        self.isActive = isActive
        self.displayName = displayName
        self.version = version
        self._description = _description
        self.isPositive = isPositive
        self.context = context
        self.journey = journey
        self.associatedValueField = associatedValueField
        self.selfUri = selfUri
        self.createdDate = createdDate
        self.modifiedDate = modifiedDate
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case isActive
        case displayName
        case version
        case _description = "description"
        case isPositive
        case context
        case journey
        case associatedValueField
        case selfUri
        case createdDate
        case modifiedDate
    }


}




public class OutcomeListing: Codable {





















    public var entities: [Outcome]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var previousUri: String?
    public var nextUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [Outcome]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, previousUri: String?, nextUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.previousUri = previousUri
        self.nextUri = nextUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class OutcomePercentileCondition: Codable {







    /** The outcome ID. */
    public var outcomeId: String?
    /** Percentile value for the selected outcome, at or above which the action map will trigger. */
    public var maximumPercentile: Float?
    /** Additional percentile condition, where if set, the action map will trigger if the current outcome percentile is lower or equal to the value. */
    public var fallbackPercentile: Float?

    public init(outcomeId: String?, maximumPercentile: Float?, fallbackPercentile: Float?) {
        self.outcomeId = outcomeId
        self.maximumPercentile = maximumPercentile
        self.fallbackPercentile = fallbackPercentile
    }


}




public class OutcomePredictor: Codable {







    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The outcome for which this predictor will provide predictions. */
    public var outcome: OutcomeRef?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, outcome: OutcomeRef?, selfUri: String?) {
        self._id = _id
        self.outcome = outcome
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case outcome
        case selfUri
    }


}




public class OutcomePredictorListing: Codable {



    public var entities: [OutcomePredictor]?

    public init(entities: [OutcomePredictor]?) {
        self.entities = entities
    }


}




public class OutcomePredictorRequest: Codable {



    /** The outcome for which this predictor will provide predictions. */
    public var outcome: OutcomeRefRequest?

    public init(outcome: OutcomeRefRequest?) {
        self.outcome = outcome
    }


}




public class OutcomeQuantileCondition: Codable {







    /** The outcome ID. */
    public var outcomeId: String?
    /** This Outcome Quantile Condition is met when sessionMaxQuantile of the OutcomeScore is above this value, (unless fallbackQuantile is set). Range 0.00-1.00 */
    public var maxQuantileThreshold: Float?
    /** (Optional) If set, this Condition is met when maxQuantileThreshold is met, AND the current quantile of the OutcomeScore is below this fallbackQuantileThreshold. Range 0.00-1.00 */
    public var fallbackQuantileThreshold: Float?

    public init(outcomeId: String?, maxQuantileThreshold: Float?, fallbackQuantileThreshold: Float?) {
        self.outcomeId = outcomeId
        self.maxQuantileThreshold = maxQuantileThreshold
        self.fallbackQuantileThreshold = fallbackQuantileThreshold
    }


}




public class OutcomeRef: Codable {





    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, selfUri: String?) {
        self._id = _id
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
    }


}




public class OutcomeRefRequest: Codable {



    /** ID of outcome. */
    public var _id: String?

    public init(_id: String?) {
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
    }


}




public class OutcomeRequest: Codable {

















    /** Whether or not the outcome is active. */
    public var isActive: Bool?
    /** The display name of the outcome. */
    public var displayName: String?
    /** The version of the outcome. */
    public var version: Int?
    /** A description of the outcome. */
    public var _description: String?
    /** Whether or not the outcome is positive. */
    public var isPositive: Bool?
    /** The context of the outcome. */
    public var context: RequestContext?
    /** The pattern of rules defining the filter of the outcome. */
    public var journey: RequestJourney?
    /** The field from the event indicating the associated value. */
    public var associatedValueField: AssociatedValueField?

    public init(isActive: Bool?, displayName: String?, version: Int?, _description: String?, isPositive: Bool?, context: RequestContext?, journey: RequestJourney?, associatedValueField: AssociatedValueField?) {
        self.isActive = isActive
        self.displayName = displayName
        self.version = version
        self._description = _description
        self.isPositive = isPositive
        self.context = context
        self.journey = journey
        self.associatedValueField = associatedValueField
    }

    public enum CodingKeys: String, CodingKey { 
        case isActive
        case displayName
        case version
        case _description = "description"
        case isPositive
        case context
        case journey
        case associatedValueField
    }


}




public class PagelessDomainEntityListingEvaluationVersion: Codable {







    public var total: Int64?
    public var entities: [EvaluationVersion]?
    public var selfUri: String?

    public init(total: Int64?, entities: [EvaluationVersion]?, selfUri: String?) {
        self.total = total
        self.entities = entities
        self.selfUri = selfUri
    }


}




public class PatchAction: Codable {

    public enum MediaType: String, Codable { 
        case webchat = "webchat"
        case webmessagingoffer = "webMessagingOffer"
        case contentoffer = "contentOffer"
        case integrationaction = "integrationAction"
        case architectflow = "architectFlow"
        case openaction = "openAction"
    }















    /** Media type of action. */
    public var mediaType: MediaType?
    /** Action template associated with the action map. */
    public var actionTemplate: ActionMapActionTemplate?
    /** Action target ID. */
    public var actionTargetId: String?
    /** Whether this action should be throttled. */
    public var isPacingEnabled: Bool?
    /** Additional properties. */
    public var props: PatchActionProperties?
    /** Architect Flow Id and input contract. */
    public var architectFlowFields: ArchitectFlowFields?
    /** Admin-configurable fields of a web messaging offer action. */
    public var webMessagingOfferFields: PatchWebMessagingOfferFields?
    /** Admin-configurable fields of an open action. */
    public var openActionFields: OpenActionFields?

    public init(mediaType: MediaType?, actionTemplate: ActionMapActionTemplate?, actionTargetId: String?, isPacingEnabled: Bool?, props: PatchActionProperties?, architectFlowFields: ArchitectFlowFields?, webMessagingOfferFields: PatchWebMessagingOfferFields?, openActionFields: OpenActionFields?) {
        self.mediaType = mediaType
        self.actionTemplate = actionTemplate
        self.actionTargetId = actionTargetId
        self.isPacingEnabled = isPacingEnabled
        self.props = props
        self.architectFlowFields = architectFlowFields
        self.webMessagingOfferFields = webMessagingOfferFields
        self.openActionFields = openActionFields
    }


}




public class PatchActionTarget: Codable {











    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** Service Level of the action target. Chat offers for the target will be throttled with the aim of achieving this service level. */
    public var serviceLevel: ServiceLevel?
    /** Indicates the non-default short abandon threshold */
    public var shortAbandonThreshold: Int?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, serviceLevel: ServiceLevel?, shortAbandonThreshold: Int?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.serviceLevel = serviceLevel
        self.shortAbandonThreshold = shortAbandonThreshold
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case serviceLevel
        case shortAbandonThreshold
        case selfUri
    }


}




public class PatchBuReschedulingOptionsRequest: Codable {



    /** Per-management unit rescheduling options to update */
    public var managementUnits: [PatchBuReschedulingOptionsManagementUnitRequest]?

    public init(managementUnits: [PatchBuReschedulingOptionsManagementUnitRequest]?) {
        self.managementUnits = managementUnits
    }


}




public class PatchCallToAction: Codable {





    public enum Target: String, Codable { 
        case blank = "Blank"
        case _self = "Self"
    }

    /** Text displayed on the call to action button. */
    public var text: String?
    /** URL to open when user clicks on the call to action button. */
    public var url: String?
    /** Where the URL should be opened when the user clicks on the call to action button. */
    public var target: Target?

    public init(text: String?, url: String?, target: Target?) {
        self.text = text
        self.url = url
        self.target = target
    }


}




public class PatchCallbackRequest: Codable {















    /** The conversationId. */
    public var conversationId: String?
    /** The identifier of the queue to be used for the callback. */
    public var queueId: String?
    /** The agentId. */
    public var agentId: String?
    /** The scheduled date-time for the callback. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var callbackScheduledTime: Date?
    /** The countryCode */
    public var countryCode: String?
    /** The callbackNumbers */
    public var callbackNumbers: [String]?
    /** validateCallbackNumbers */
    public var validateCallbackNumbers: Bool?

    public init(conversationId: String?, queueId: String?, agentId: String?, callbackScheduledTime: Date?, countryCode: String?, callbackNumbers: [String]?, validateCallbackNumbers: Bool?) {
        self.conversationId = conversationId
        self.queueId = queueId
        self.agentId = agentId
        self.callbackScheduledTime = callbackScheduledTime
        self.countryCode = countryCode
        self.callbackNumbers = callbackNumbers
        self.validateCallbackNumbers = validateCallbackNumbers
    }


}




public class PatchCloseButtonStyleProperties: Codable {





    /** Color of button. (eg. #FF0000) */
    public var color: String?
    /** Opacity of button. */
    public var opacity: Float?

    public init(color: String?, opacity: Float?) {
        self.color = color
        self.opacity = opacity
    }


}




public class PatchContext: Codable {



    /** A list of one or more patterns to match. */
    public var patterns: [PatchContextPattern]?

    public init(patterns: [PatchContextPattern]?) {
        self.patterns = patterns
    }


}




public class PatchIntegrationActionFields: Codable {





    /** Reference to the Integration Action to be used when integrationAction type is qualified */
    public var integrationAction: PatchIntegrationAction?
    /** Collection of Request Mappings to use */
    public var requestMappings: [RequestMapping]?

    public init(integrationAction: PatchIntegrationAction?, requestMappings: [RequestMapping]?) {
        self.integrationAction = integrationAction
        self.requestMappings = requestMappings
    }


}




public class PatchShiftTradeRequest: Codable {









    /** Update the ID of the receiving user to direct the request at a specific user, or set the wrapped id to null to open up a trade to be matched by any user. */
    public var receivingUserId: ValueWrapperString?
    /** Update the expiration time for this shift trade. */
    public var expiration: ValueWrapperDate?
    /** Update the acceptable intervals the initiating user is willing to accept in trade. Setting the enclosed list to empty will make this a one sided trade request */
    public var acceptableIntervals: ListWrapperInterval?
    /** Version metadata */
    public var metadata: WfmVersionedEntityMetadata?

    public init(receivingUserId: ValueWrapperString?, expiration: ValueWrapperDate?, acceptableIntervals: ListWrapperInterval?, metadata: WfmVersionedEntityMetadata?) {
        self.receivingUserId = receivingUserId
        self.expiration = expiration
        self.acceptableIntervals = acceptableIntervals
        self.metadata = metadata
    }


}




public class PhoneBaseEntityListing: Codable {























    public var entities: [PhoneBase]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    /** The total organization-wide number of entities. */
    public var totalNumberOfEntities: Int64?
    public var firstUri: String?
    public var previousUri: String?
    public var nextUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [PhoneBase]?, pageSize: Int?, pageNumber: Int?, total: Int64?, totalNumberOfEntities: Int64?, firstUri: String?, previousUri: String?, nextUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.totalNumberOfEntities = totalNumberOfEntities
        self.firstUri = firstUri
        self.previousUri = previousUri
        self.nextUri = nextUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class PhoneCapabilities: Codable {















    public enum MediaCodecs: String, Codable { 
        case audioOpus = "audio/opus"
        case audioPcmu = "audio/pcmu"
        case audioPcma = "audio/pcma"
        case audioG729 = "audio/g729"
        case audioG722 = "audio/g722"
    }



    public var provisions: Bool?
    public var registers: Bool?
    public var dualRegisters: Bool?
    public var hardwareIdType: String?
    public var allowReboot: Bool?
    public var noRebalance: Bool?
    public var noCloudProvisioning: Bool?
    public var mediaCodecs: [MediaCodecs]?
    public var cdm: Bool?

    public init(provisions: Bool?, registers: Bool?, dualRegisters: Bool?, hardwareIdType: String?, allowReboot: Bool?, noRebalance: Bool?, noCloudProvisioning: Bool?, mediaCodecs: [MediaCodecs]?, cdm: Bool?) {
        self.provisions = provisions
        self.registers = registers
        self.dualRegisters = dualRegisters
        self.hardwareIdType = hardwareIdType
        self.allowReboot = allowReboot
        self.noRebalance = noRebalance
        self.noCloudProvisioning = noCloudProvisioning
        self.mediaCodecs = mediaCodecs
        self.cdm = cdm
    }


}




public class PhoneNumberStatus: Codable {



    /** Indicates whether or not a phone number is callable. */
    public var callable: Bool?

    public init(callable: Bool?) {
        self.callable = callable
    }


}




public class PhoneTransferEvent: Codable {







    public enum TransferType: String, Codable { 
        case attended = "Attended"
        case unattended = "Unattended"
    }











    /** A unique (V4 UUID) eventId for this event */
    public var eventId: String?
    /** A Date Time representing the time this event occurred. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var eventDateTime: Date?
    /** A unique Id (V4 UUID) identifying this conversation */
    public var conversationId: String?
    /** Indicates the desired type of transfer. */
    public var transferType: TransferType?
    /** The id (V4 UUID) used by the external platform to refer to the transfer in subsequent Transfer events. */
    public var commandId: String?
    /** The id (V4 UUID) of the communication representing the participant that is initiating the transfer. */
    public var initiatingCommunicationId: String?
    /** The id (V4 UUID) of the communication that is being transferred away from. In many cases this will be the same as the `initiatingCommunicationId`. */
    public var targetCommunicationId: String?
    /** The id (V4 UUID) of the communication that is being transferred. */
    public var objectCommunicationId: String?
    /** The desired destination phone number that the object communication should be transferred to. */
    public var destinationPhoneNumber: String?

    public init(eventId: String?, eventDateTime: Date?, conversationId: String?, transferType: TransferType?, commandId: String?, initiatingCommunicationId: String?, targetCommunicationId: String?, objectCommunicationId: String?, destinationPhoneNumber: String?) {
        self.eventId = eventId
        self.eventDateTime = eventDateTime
        self.conversationId = conversationId
        self.transferType = transferType
        self.commandId = commandId
        self.initiatingCommunicationId = initiatingCommunicationId
        self.targetCommunicationId = targetCommunicationId
        self.objectCommunicationId = objectCommunicationId
        self.destinationPhoneNumber = destinationPhoneNumber
    }


}




public class PolicyAttribute: Codable {



    public enum ModelType: String, Codable { 
        case boolean = "BOOLEAN"
        case number = "NUMBER"
        case string = "STRING"
        case stringList = "STRING_LIST"
        case time = "TIME"
        case relativeTime = "RELATIVE_TIME"
        case timeRange = "TIME_RANGE"
        case dayRange = "DAY_RANGE"
        case ipAddress = "IP_ADDRESS"
        case ipCidr = "IP_CIDR"
    }





    public var name: String?
    public var type: ModelType?
    public var _description: String?
    public var featureToggle: String?

    public init(name: String?, type: ModelType?, _description: String?, featureToggle: String?) {
        self.name = name
        self.type = type
        self._description = _description
        self.featureToggle = featureToggle
    }

    public enum CodingKeys: String, CodingKey { 
        case name
        case type
        case _description = "description"
        case featureToggle
    }


}




public class PolicyAttributeSet: Codable {











    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** A set of the attributes checked by the requested policy. */
    public var policyAttributes: [PolicyAttribute]?
    /** Map of names and values of preset attributes used in this policy. */
    public var presetAttributes: [String:TypedAttribute]?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, policyAttributes: [PolicyAttribute]?, presetAttributes: [String:TypedAttribute]?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.policyAttributes = policyAttributes
        self.presetAttributes = presetAttributes
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case policyAttributes
        case presetAttributes
        case selfUri
    }


}




public class Prompt: Codable {













    /** The prompt identifier */
    public var _id: String?
    /** The prompt name. */
    public var name: String?
    public var _description: String?
    /** List of resources associated with this prompt */
    public var resources: [PromptAsset]?
    /** Current prompt operation status */
    public var currentOperation: Operation?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, _description: String?, resources: [PromptAsset]?, currentOperation: Operation?, selfUri: String?) {
        self._id = _id
        self.name = name
        self._description = _description
        self.resources = resources
        self.currentOperation = currentOperation
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case _description = "description"
        case resources
        case currentOperation
        case selfUri
    }


}



/** Settings concerning position */

public class PositionSettings: Codable {

    public enum Alignment: String, Codable { 
        case auto = "Auto"
        case _left = "Left"
        case _right = "Right"
    }





    /** The alignment for position */
    public var alignment: Alignment?
    /** The sidespace value for position */
    public var sideSpace: Int?
    /** The bottomspace value for position */
    public var bottomSpace: Int?

    public init(alignment: Alignment?, sideSpace: Int?, bottomSpace: Int?) {
        self.alignment = alignment
        self.sideSpace = sideSpace
        self.bottomSpace = bottomSpace
    }


}




public class PostTextMessage: Codable {

    public enum ModelType: String, Codable { 
        case text = "Text"
        case structured = "Structured"
        case receipt = "Receipt"
        case event = "Event"
        case message = "Message"
        case unknown = "Unknown"
    }





    /** Message type */
    public var type: ModelType?
    /** Message text. If type is structured, used as fallback for clients that do not support particular structured content */
    public var text: String?
    /** A list of content elements in message */
    public var content: [ConversationMessageContent]?

    public init(type: ModelType?, text: String?, content: [ConversationMessageContent]?) {
        self.type = type
        self.text = text
        self.content = content
    }


}




public class PredictorModel: Codable {











    public enum MediaType: String, Codable { 
        case voice = "voice"
        case email = "email"
        case message = "message"
    }



    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The key performance indicator used in the model. */
    public var kpi: String?
    /** The List of Queues that are assessed for Predictive Routing. */
    public var queues: [AddressableEntityRef]?
    /** DateTime indicating when the model was created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** DateTime indicating when the model was last trained. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateTrained: Date?
    /** The media type of the model. */
    public var mediaType: MediaType?
    public var features: [PredictorModelFeature]?

    public init(_id: String?, kpi: String?, queues: [AddressableEntityRef]?, dateCreated: Date?, dateTrained: Date?, mediaType: MediaType?, features: [PredictorModelFeature]?) {
        self._id = _id
        self.kpi = kpi
        self.queues = queues
        self.dateCreated = dateCreated
        self.dateTrained = dateTrained
        self.mediaType = mediaType
        self.features = features
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case kpi
        case queues
        case dateCreated
        case dateTrained
        case mediaType
        case features
    }


}




public class PredictorModelRetrainingError: Codable {



    public enum ErrorCode: String, Codable { 
        case notEnoughData = "NotEnoughData"
        case serviceError = "ServiceError"
        case unknownError = "UnknownError"
    }



    /** The globally unique identifier for the object. */
    public var _id: String?
    /** Error code describing model training failure. */
    public var errorCode: ErrorCode?
    /** Date when the first retraining failure happened. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateOfFirstOccurrence: Date?

    public init(_id: String?, errorCode: ErrorCode?, dateOfFirstOccurrence: Date?) {
        self._id = _id
        self.errorCode = errorCode
        self.dateOfFirstOccurrence = dateOfFirstOccurrence
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case errorCode
        case dateOfFirstOccurrence
    }


}




public class PredictorModels: Codable {





    public var entities: [PredictorModel]?
    public var predictorModels: [PredictorModel]?

    public init(entities: [PredictorModel]?, predictorModels: [PredictorModel]?) {
        self.entities = entities
        self.predictorModels = predictorModels
    }


}




public class PresentedKnowledgeDocument: Codable {







    public enum SurfacingMethod: String, Codable { 
        case unknown = "Unknown"
        case article = "Article"
        case snippet = "Snippet"
        case highlight = "Highlight"
        case generative = "Generative"
    }

    /** The ID of the document. */
    public var documentId: String?
    /** The variation of the document. */
    public var documentVariationId: String?
    /** The version of the document. */
    public var documentVersionId: String?
    /** The method how knowledge was surfaced. Article: Full article was shown. Snippet: A snippet from the article was shown. Highlight: A highlighted answer in a snippet was shown.Generative: A generated answer in a snippet was shown. */
    public var surfacingMethod: SurfacingMethod?

    public init(documentId: String?, documentVariationId: String?, documentVersionId: String?, surfacingMethod: SurfacingMethod?) {
        self.documentId = documentId
        self.documentVariationId = documentVariationId
        self.documentVersionId = documentVersionId
        self.surfacingMethod = surfacingMethod
    }


}




public class ProcessScheduleUpdateUploadRequest: Codable {







    /** The uploadKey provided by the request to get an upload URL */
    public var uploadKey: String?
    /** The list of teams to which the users being modified belong. Only required if the requesting user has conditional permission to wfm:schedule:edit */
    public var teamIds: [String]?
    /** The set of muIds to which agents belong if agents are being newly added to the schedule, if the requesting user has conditional permission to wfm:schedule:edit */
    public var managementUnitIdsForAddedTeamUsers: [String]?

    public init(uploadKey: String?, teamIds: [String]?, managementUnitIdsForAddedTeamUsers: [String]?) {
        self.uploadKey = uploadKey
        self.teamIds = teamIds
        self.managementUnitIdsForAddedTeamUsers = managementUnitIdsForAddedTeamUsers
    }


}




public class ProgramTopicLinksTestPhraseDetectedPhrase: Codable {







    public var foundPhrase: String?
    public var snippet: String?
    public var confidence: Int64?

    public init(foundPhrase: String?, snippet: String?, confidence: Int64?) {
        self.foundPhrase = foundPhrase
        self.snippet = snippet
        self.confidence = confidence
    }


}




public class PropertyDefinition: Codable {















    public var title: String?
    public var _description: String?
    public var type: [String]?
    public var pattern: String?
    public var format: String?
    public var items: Items?
    public var properties: [String:PropertyDefinition]?

    public init(title: String?, _description: String?, type: [String]?, pattern: String?, format: String?, items: Items?, properties: [String:PropertyDefinition]?) {
        self.title = title
        self._description = _description
        self.type = type
        self.pattern = pattern
        self.format = format
        self.items = items
        self.properties = properties
    }

    public enum CodingKeys: String, CodingKey { 
        case title
        case _description = "description"
        case type
        case pattern
        case format
        case items
        case properties
    }


}



/** Draft to be published */

public class PublishDraftInput: Codable {



    /** The current draft version. */
    public var version: Int?

    public init(version: Int?) {
        self.version = version
    }


}




public class PublishProgramTestPhraseMatchedTranscript: Codable {









    public enum MediaType: String, Codable { 
        case unknown = "unknown"
        case call = "call"
        case message = "message"
        case email = "email"
        case chat = "chat"
        case callback = "callback"
        case all = "all"
    }



    public var timestamp: Int64?
    public var transcriptId: String?
    public var communicationId: String?
    public var conversationId: String?
    public var mediaType: MediaType?
    public var detectedPhrases: [PublishProgramTestPhraseDetectedPhrase]?

    public init(timestamp: Int64?, transcriptId: String?, communicationId: String?, conversationId: String?, mediaType: MediaType?, detectedPhrases: [PublishProgramTestPhraseDetectedPhrase]?) {
        self.timestamp = timestamp
        self.transcriptId = transcriptId
        self.communicationId = communicationId
        self.conversationId = conversationId
        self.mediaType = mediaType
        self.detectedPhrases = detectedPhrases
    }


}




public class PublishProgramTestTopicPhraseResults: Codable {







    public var processedTranscriptsCount: Int64?
    public var matchedTranscriptsCount: Int64?
    public var matchedTranscripts: [PublishProgramTestPhraseMatchedTranscript]?

    public init(processedTranscriptsCount: Int64?, matchedTranscriptsCount: Int64?, matchedTranscripts: [PublishProgramTestPhraseMatchedTranscript]?) {
        self.processedTranscriptsCount = processedTranscriptsCount
        self.matchedTranscriptsCount = matchedTranscriptsCount
        self.matchedTranscripts = matchedTranscripts
    }


}




public class PublishProgramTopicsDefinitionsJob: Codable {



    public enum State: String, Codable { 
        case completed = "Completed"
        case running = "Running"
        case failed = "Failed"
    }





    public var _id: String?
    public var state: State?
    public var testTopicPhraseResults: [PublishProgramTestTopicPhraseResults]?
    public var genAIPhrasesResults: [String]?

    public init(_id: String?, state: State?, testTopicPhraseResults: [PublishProgramTestTopicPhraseResults]?, genAIPhrasesResults: [String]?) {
        self._id = _id
        self.state = state
        self.testTopicPhraseResults = testTopicPhraseResults
        self.genAIPhrasesResults = genAIPhrasesResults
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case state
        case testTopicPhraseResults
        case genAIPhrasesResults
    }


}




public class PublishedSurveyFormReference: Codable {









    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** The context id of this form. */
    public var contextId: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, contextId: String?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.contextId = contextId
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case contextId
        case selfUri
    }


}




public class PushDeviceInsertRequest: Codable {



    public enum NotificationProvider: String, Codable { 
        case fcm = "FCM"
        case apns = "APNS"
    }



    public enum DeviceType: String, Codable { 
        case android = "android"
        case ios = "ios"
    }

    /** The device token generated by the network providers */
    public var deviceToken: String?
    /** The notification provider for the device (FCM / APNS) */
    public var notificationProvider: NotificationProvider?
    /** The preferred language of the user (eg. en-us, de, fr) */
    public var language: String?
    /** The type of the device (Android / IoS) */
    public var deviceType: DeviceType?

    public init(deviceToken: String?, notificationProvider: NotificationProvider?, language: String?, deviceType: DeviceType?) {
        self.deviceToken = deviceToken
        self.notificationProvider = notificationProvider
        self.language = language
        self.deviceType = deviceType
    }


}




public class PushIntegration: Codable {



    public enum Provider: String, Codable { 
        case apns = "APNS"
        case fcm = "FCM"
    }

    /** The mobile push integration id associated with the deployment */
    public var _id: String?
    /** The integration provider associated with the deployment */
    public var provider: Provider?

    public init(_id: String?, provider: Provider?) {
        self._id = _id
        self.provider = provider
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case provider
    }


}




public class PutDecisionTableRowRequest: Codable {





    /** The full updated input values of the row. The key for this map is the column ID the row value relates. Column IDs are available from the decision table entity */
    public var inputs: [String:DecisionTableRowParameterValue]?
    /** The full updated output values of the row. The key for this map is the column ID the row value relates. Column IDs are available from the decision table entity */
    public var outputs: [String:DecisionTableRowParameterValue]?

    public init(inputs: [String:DecisionTableRowParameterValue]?, outputs: [String:DecisionTableRowParameterValue]?) {
        self.inputs = inputs
        self.outputs = outputs
    }


}




public class QualityAuditLogMessage: Codable {













    public enum ServiceName: String, Codable { 
        case recordingService = "RecordingService"
        case recordingPlaybackService = "RecordingPlaybackService"
        case qualityService = "QualityService"
    }

    public enum Level: String, Codable { 
        case user = "User"
        case system = "System"
        case genesysInternal = "GENESYS_INTERNAL"
    }

    public enum Status: String, Codable { 
        case success = "Success"
        case failure = "Failure"
        case warning = "Warning"
    }





    public enum Action: String, Codable { 
        case read = "Read"
        case create = "Create"
        case update = "Update"
        case delete = "Delete"
        case abandon = "Abandon"
        case archive = "Archive"
        case export = "Export"
        case download = "Download"
        case restoreRequest = "RestoreRequest"
        case restoreComplete = "RestoreComplete"
        case applyProtection = "ApplyProtection"
        case revokeProtection = "RevokeProtection"
        case updateRetention = "UpdateRetention"
    }



    public enum EntityType: String, Codable { 
        case recording = "Recording"
        case evaluation = "Evaluation"
        case calibration = "Calibration"
        case annotation = "Annotation"
        case screenRecording = "ScreenRecording"
        case survey = "Survey"
        case snippetRecording = "SnippetRecording"
    }





    /** Id of the audit message. */
    public var _id: String?
    /** Home Organization Id associated with this audit message. */
    public var userHomeOrgId: String?
    /** Trustee Organization Id if this audit message is from trustee access. */
    public var userTrusteeOrgId: String?
    /** User associated with this audit message. */
    public var user: DomainEntityRef?
    /** Client associated with this audit message. */
    public var client: AddressableEntityRef?
    /** List of IP addresses of systems that originated or handled the request. */
    public var remoteIps: [String]?
    /** Name of the service that logged this audit message. */
    public var serviceName: ServiceName?
    /** The level of this audit message. */
    public var level: Level?
    /** The status of the action of this audit message. */
    public var status: Status?
    /** Date and time of when the audit message was logged. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var eventDate: Date?
    /** Message describing the event being audited. */
    public var messageInfo: MessageInfo?
    /** Action that took place. */
    public var action: Action?
    /** Entity that was impacted. */
    public var entity: DomainEntityRef?
    /** Type of the entity that was impacted. */
    public var entityType: EntityType?
    /** List of properties that were changed and changes made to those properties. */
    public var propertyChanges: [PropertyChange]?
    /** Additional context for this message. */
    public var context: [String:String]?

    public init(_id: String?, userHomeOrgId: String?, userTrusteeOrgId: String?, user: DomainEntityRef?, client: AddressableEntityRef?, remoteIps: [String]?, serviceName: ServiceName?, level: Level?, status: Status?, eventDate: Date?, messageInfo: MessageInfo?, action: Action?, entity: DomainEntityRef?, entityType: EntityType?, propertyChanges: [PropertyChange]?, context: [String:String]?) {
        self._id = _id
        self.userHomeOrgId = userHomeOrgId
        self.userTrusteeOrgId = userTrusteeOrgId
        self.user = user
        self.client = client
        self.remoteIps = remoteIps
        self.serviceName = serviceName
        self.level = level
        self.status = status
        self.eventDate = eventDate
        self.messageInfo = messageInfo
        self.action = action
        self.entity = entity
        self.entityType = entityType
        self.propertyChanges = propertyChanges
        self.context = context
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case userHomeOrgId
        case userTrusteeOrgId
        case user
        case client
        case remoteIps
        case serviceName
        case level
        case status
        case eventDate
        case messageInfo
        case action
        case entity
        case entityType
        case propertyChanges
        case context
    }


}




public class Queue: Codable {

































    public enum ScoringMethod: String, Codable { 
        case timestampAndPriority = "TimestampAndPriority"
        case priorityOnly = "PriorityOnly"
    }

    public enum LastAgentRoutingMode: String, Codable { 
        case disabled = "Disabled"
        case queueMembersOnly = "QueueMembersOnly"
        case anyAgent = "AnyAgent"
    }



    public enum SkillEvaluationMethod: String, Codable { 
        case _none = "NONE"
        case best = "BEST"
        case all = "ALL"
    }











































    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** The division to which this entity belongs. */
    public var division: Division?
    /** The queue description. */
    public var _description: String?
    /** The date the queue was created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** The date of the last modification to the queue. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** The ID of the user that last modified the queue. */
    public var modifiedBy: String?
    /** The ID of the user that created the queue. */
    public var createdBy: String?
    /** The total number of members in the queue. */
    public var memberCount: Int?
    /** The number of user members (i.e., non-group members) in the queue. */
    public var userMemberCount: Int?
    /** The number of joined members in the queue. */
    public var joinedMemberCount: Int?
    /** The media settings for the queue. */
    public var mediaSettings: QueueMediaSettings?
    /** The routing rules for the queue, used for Preferred Agent Routing. */
    public var routingRules: [RoutingRule]?
    /** The Conditional Group Routing settings for the queue. */
    public var conditionalGroupRouting: ConditionalGroupRouting?
    /** The Conditional Group Activation settings for the queue. */
    public var conditionalGroupActivation: ConditionalGroupActivation?
    /** The bullseye settings for the queue. */
    public var bullseye: Bullseye?
    /** The Scoring Method for the queue. */
    public var scoringMethod: ScoringMethod?
    /** The Last Agent Routing Mode for the queue. */
    public var lastAgentRoutingMode: LastAgentRoutingMode?
    /** The ACW settings for the queue. */
    public var acwSettings: AcwSettings?
    /** The skill evaluation method to use when routing conversations. */
    public var skillEvaluationMethod: SkillEvaluationMethod?
    /** The groups of agents associated with the queue, if any.  Queue membership will update to match group membership changes. */
    public var memberGroups: [MemberGroup]?
    /** The in-queue flow to use for call conversations waiting in queue. */
    public var queueFlow: DomainEntityRef?
    /** The in-queue flow to use for email conversations waiting in queue. */
    public var emailInQueueFlow: DomainEntityRef?
    /** The in-queue flow to use for message conversations waiting in queue. */
    public var messageInQueueFlow: DomainEntityRef?
    /** The prompt used for whisper on the queue, if configured. */
    public var whisperPrompt: DomainEntityRef?
    /** The audio to be played when calls on this queue are on hold. If not configured, the default on-hold music will play. */
    public var onHoldPrompt: DomainEntityRef?
    /** Specifies whether the configured whisper should play for all ACD calls, or only for those which are auto-answered. */
    public var autoAnswerOnly: Bool?
    /** Canned response library IDs and mode with which they are associated with the queue */
    public var cannedResponseLibraries: CannedResponseLibraries?
    /** Indicates whether voice transcription is enabled for this queue. */
    public var enableTranscription: Bool?
    /** Indicates whether audio monitoring is enabled for this queue. */
    public var enableAudioMonitoring: Bool?
    /** Indicates whether manual assignment is enabled for this queue. */
    public var enableManualAssignment: Bool?
    /** The Agent Owned Routing settings for the queue */
    public var agentOwnedRouting: AgentOwnedRouting?
    /** The Direct Routing settings for the queue */
    public var directRouting: DirectRouting?
    /** The name to use for caller identification for outbound calls from this queue. */
    public var callingPartyName: String?
    /** The phone number to use for caller identification for outbound calls from this queue. */
    public var callingPartyNumber: String?
    /** The default script Ids for the communication types. */
    public var defaultScripts: [String:Script]?
    /** The messaging addresses for the queue. */
    public var outboundMessagingAddresses: QueueMessagingAddresses?
    /** The default email address to use for outbound email from this queue. */
    public var outboundEmailAddress: QueueEmailAddress?
    /** The ID of an associated external queue. */
    public var peerId: String?
    /** Indicates whether recording in-queue calls is suppressed for this queue. */
    public var suppressInQueueCallRecording: Bool?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, division: Division?, _description: String?, dateCreated: Date?, dateModified: Date?, modifiedBy: String?, createdBy: String?, memberCount: Int?, userMemberCount: Int?, joinedMemberCount: Int?, mediaSettings: QueueMediaSettings?, routingRules: [RoutingRule]?, conditionalGroupRouting: ConditionalGroupRouting?, conditionalGroupActivation: ConditionalGroupActivation?, bullseye: Bullseye?, scoringMethod: ScoringMethod?, lastAgentRoutingMode: LastAgentRoutingMode?, acwSettings: AcwSettings?, skillEvaluationMethod: SkillEvaluationMethod?, memberGroups: [MemberGroup]?, queueFlow: DomainEntityRef?, emailInQueueFlow: DomainEntityRef?, messageInQueueFlow: DomainEntityRef?, whisperPrompt: DomainEntityRef?, onHoldPrompt: DomainEntityRef?, autoAnswerOnly: Bool?, cannedResponseLibraries: CannedResponseLibraries?, enableTranscription: Bool?, enableAudioMonitoring: Bool?, enableManualAssignment: Bool?, agentOwnedRouting: AgentOwnedRouting?, directRouting: DirectRouting?, callingPartyName: String?, callingPartyNumber: String?, defaultScripts: [String:Script]?, outboundMessagingAddresses: QueueMessagingAddresses?, outboundEmailAddress: QueueEmailAddress?, peerId: String?, suppressInQueueCallRecording: Bool?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.division = division
        self._description = _description
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.modifiedBy = modifiedBy
        self.createdBy = createdBy
        self.memberCount = memberCount
        self.userMemberCount = userMemberCount
        self.joinedMemberCount = joinedMemberCount
        self.mediaSettings = mediaSettings
        self.routingRules = routingRules
        self.conditionalGroupRouting = conditionalGroupRouting
        self.conditionalGroupActivation = conditionalGroupActivation
        self.bullseye = bullseye
        self.scoringMethod = scoringMethod
        self.lastAgentRoutingMode = lastAgentRoutingMode
        self.acwSettings = acwSettings
        self.skillEvaluationMethod = skillEvaluationMethod
        self.memberGroups = memberGroups
        self.queueFlow = queueFlow
        self.emailInQueueFlow = emailInQueueFlow
        self.messageInQueueFlow = messageInQueueFlow
        self.whisperPrompt = whisperPrompt
        self.onHoldPrompt = onHoldPrompt
        self.autoAnswerOnly = autoAnswerOnly
        self.cannedResponseLibraries = cannedResponseLibraries
        self.enableTranscription = enableTranscription
        self.enableAudioMonitoring = enableAudioMonitoring
        self.enableManualAssignment = enableManualAssignment
        self.agentOwnedRouting = agentOwnedRouting
        self.directRouting = directRouting
        self.callingPartyName = callingPartyName
        self.callingPartyNumber = callingPartyNumber
        self.defaultScripts = defaultScripts
        self.outboundMessagingAddresses = outboundMessagingAddresses
        self.outboundEmailAddress = outboundEmailAddress
        self.peerId = peerId
        self.suppressInQueueCallRecording = suppressInQueueCallRecording
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case division
        case _description = "description"
        case dateCreated
        case dateModified
        case modifiedBy
        case createdBy
        case memberCount
        case userMemberCount
        case joinedMemberCount
        case mediaSettings
        case routingRules
        case conditionalGroupRouting
        case conditionalGroupActivation
        case bullseye
        case scoringMethod
        case lastAgentRoutingMode
        case acwSettings
        case skillEvaluationMethod
        case memberGroups
        case queueFlow
        case emailInQueueFlow
        case messageInQueueFlow
        case whisperPrompt
        case onHoldPrompt
        case autoAnswerOnly
        case cannedResponseLibraries
        case enableTranscription
        case enableAudioMonitoring
        case enableManualAssignment
        case agentOwnedRouting
        case directRouting
        case callingPartyName
        case callingPartyNumber
        case defaultScripts
        case outboundMessagingAddresses
        case outboundEmailAddress
        case peerId
        case suppressInQueueCallRecording
        case selfUri
    }


}




public class QueryRequestPredicate: Codable {

    public enum Dimension: String, Codable { 
        case attendeeid = "attendeeId"
        case facilitatorid = "facilitatorId"
        case status = "status"
    }



    /** The dimension to be filtered */
    public var dimension: Dimension?
    /** The value to filter by */
    public var value: String?

    public init(dimension: Dimension?, value: String?) {
        self.dimension = dimension
        self.value = value
    }


}




public class QueueConversationCallEventTopicCallConversation: Codable {

















    public enum RecordingState: String, Codable { 
        case _none = "none"
        case active = "active"
        case paused = "paused"
    }





    public var _id: String?
    public var name: String?
    public var participants: [QueueConversationCallEventTopicCallMediaParticipant]?
    public var otherMediaUris: [String]?
    public var address: String?
    public var utilizationLabelId: String?
    public var inactivityTimeout: Date?
    public var divisions: [QueueConversationCallEventTopicConversationDivisionMembership]?
    public var recordingState: RecordingState?
    public var securePause: Bool?
    public var maxParticipants: Int64?

    public init(_id: String?, name: String?, participants: [QueueConversationCallEventTopicCallMediaParticipant]?, otherMediaUris: [String]?, address: String?, utilizationLabelId: String?, inactivityTimeout: Date?, divisions: [QueueConversationCallEventTopicConversationDivisionMembership]?, recordingState: RecordingState?, securePause: Bool?, maxParticipants: Int64?) {
        self._id = _id
        self.name = name
        self.participants = participants
        self.otherMediaUris = otherMediaUris
        self.address = address
        self.utilizationLabelId = utilizationLabelId
        self.inactivityTimeout = inactivityTimeout
        self.divisions = divisions
        self.recordingState = recordingState
        self.securePause = securePause
        self.maxParticipants = maxParticipants
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case participants
        case otherMediaUris
        case address
        case utilizationLabelId
        case inactivityTimeout
        case divisions
        case recordingState
        case securePause
        case maxParticipants
    }


}




public class QueueConversationCallEventTopicDetail: Codable {









    public var errorCode: String?
    public var fieldName: String?
    public var entityId: String?
    public var entityName: String?

    public init(errorCode: String?, fieldName: String?, entityId: String?, entityName: String?) {
        self.errorCode = errorCode
        self.fieldName = fieldName
        self.entityId = entityId
        self.entityName = entityName
    }


}



/** Answering Machine Detection timeout configuration. */

public class QueueConversationCallEventTopicDispositionAmdTimeout: Codable {









    /** Configured AMD timeout value. */
    public var timeoutMs: Int64?
    /** Configured option for when to start the AMD timer, such as on line connect or speech start. */
    public var timerStartEvent: String?
    /** Timer start time, measured in epoch milliseconds. */
    public var timerStartTime: Double?
    /** Timer end time, measured in epoch milliseconds. */
    public var timerEndTime: Double?

    public init(timeoutMs: Int64?, timerStartEvent: String?, timerStartTime: Double?, timerEndTime: Double?) {
        self.timeoutMs = timeoutMs
        self.timerStartEvent = timerStartEvent
        self.timerStartTime = timerStartTime
        self.timerEndTime = timerEndTime
    }


}




public class QueueConversationCallEventTopicErrorBody: Codable {























    public var message: String?
    public var code: String?
    public var status: Int64?
    public var entityId: String?
    public var entityName: String?
    public var messageWithParams: String?
    public var messageParams: [String:String]?
    public var contextId: String?
    public var details: [QueueConversationCallEventTopicDetail]?
    public var errors: [QueueConversationCallEventTopicErrorBody]?
    public var limit: QueueConversationCallEventTopicLimit?

    public init(message: String?, code: String?, status: Int64?, entityId: String?, entityName: String?, messageWithParams: String?, messageParams: [String:String]?, contextId: String?, details: [QueueConversationCallEventTopicDetail]?, errors: [QueueConversationCallEventTopicErrorBody]?, limit: QueueConversationCallEventTopicLimit?) {
        self.message = message
        self.code = code
        self.status = status
        self.entityId = entityId
        self.entityName = entityName
        self.messageWithParams = messageWithParams
        self.messageParams = messageParams
        self.contextId = contextId
        self.details = details
        self.errors = errors
        self.limit = limit
    }


}



/** Details about the action map from the Journey System which triggered this action */

public class QueueConversationCallEventTopicJourneyActionMap: Codable {





    /** The ID of the actionMap in the Journey System which triggered this action */
    public var _id: String?
    /** The version number of the actionMap in the Journey System at the time this action was triggered */
    public var version: Int64?

    public init(_id: String?, version: Int64?) {
        self._id = _id
        self.version = version
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case version
    }


}




public class QueueConversationCallEventTopicRecordersState: Codable {









    /** Indicates the state of the adhoc recorder. */
    public var adhocState: String?
    /** Indicates the state of the customer experience recorder. */
    public var customerExperienceState: String?
    /** Indicates the state of the agent experience recorder. */
    public var agentExperienceState: String?
    /** State of the snippet recording for this session. Note that snippets may never be paused. Valid values are in Constants.java with a prefix of RECORDER_STATE_*. */
    public var snippetState: String?

    public init(adhocState: String?, customerExperienceState: String?, agentExperienceState: String?, snippetState: String?) {
        self.adhocState = adhocState
        self.customerExperienceState = customerExperienceState
        self.agentExperienceState = agentExperienceState
        self.snippetState = snippetState
    }


}




public class QueueConversationCallEventTopicUriReference: Codable {





    /** The ID of the resource */
    public var _id: String?
    /** The name of the resource */
    public var name: String?

    public init(_id: String?, name: String?) {
        self._id = _id
        self.name = name
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
    }


}




public class QueueConversationCallbackEventTopicDivisionEntityRef: Codable {







    public var _id: String?
    public var selfUri: String?
    /** The time the entity division was last updated. */
    public var dateDivisionUpdated: Date?

    public init(_id: String?, selfUri: String?, dateDivisionUpdated: Date?) {
        self._id = _id
        self.selfUri = selfUri
        self.dateDivisionUpdated = dateDivisionUpdated
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
        case dateDivisionUpdated
    }


}



/** A subset of the Journey System's action data relevant to a part of a conversation (for external linkage and internal usage/context) */

public class QueueConversationCallbackEventTopicJourneyAction: Codable {





    /** The ID of an action from the Journey System (an action is spawned from an actionMap) */
    public var _id: String?
    public var actionMap: QueueConversationCallbackEventTopicJourneyActionMap?

    public init(_id: String?, actionMap: QueueConversationCallbackEventTopicJourneyActionMap?) {
        self._id = _id
        self.actionMap = actionMap
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case actionMap
    }


}




public class QueueConversationCallbackEventTopicJourneyContext: Codable {







    public var customer: QueueConversationCallbackEventTopicJourneyCustomer?
    public var customerSession: QueueConversationCallbackEventTopicJourneyCustomerSession?
    public var triggeringAction: QueueConversationCallbackEventTopicJourneyAction?

    public init(customer: QueueConversationCallbackEventTopicJourneyCustomer?, customerSession: QueueConversationCallbackEventTopicJourneyCustomerSession?, triggeringAction: QueueConversationCallbackEventTopicJourneyAction?) {
        self.customer = customer
        self.customerSession = customerSession
        self.triggeringAction = triggeringAction
    }


}




public class QueueConversationCallbackEventTopicWrapup: Codable {











    /** The user configured wrap up code name. */
    public var code: String?
    /** Text entered by the agent to describe the call or disposition. */
    public var notes: String?
    /** List of tags selected by the agent to describe the call or disposition. */
    public var tags: [String]?
    /** The length of time in seconds that the agent spent doing after call work., Note, the format of utc-millisec should be ignored, our code generator needs it to generate a Long for us internally */
    public var durationSeconds: Int64?
    /** The timestamp when the wrapup was finished. */
    public var endTime: Date?

    public init(code: String?, notes: String?, tags: [String]?, durationSeconds: Int64?, endTime: Date?) {
        self.code = code
        self.notes = notes
        self.tags = tags
        self.durationSeconds = durationSeconds
        self.endTime = endTime
    }


}




public class QueueConversationChatEventTopicLimit: Codable {



    public enum Namespace: String, Codable { 
        case agentAssistant = "agent.assistant"
        case analyticsAlerting = "analytics.alerting"
        case analytics = "analytics"
        case analyticsRealtime = "analytics.realtime"
        case analyticsReportingSettings = "analytics.reporting.settings"
        case architect = "architect"
        case audiohook = "audiohook"
        case audit = "audit"
        case authApi = "auth.api"
        case authorization = "authorization"
        case automationTesting = "automation.testing"
        case bots = "bots"
        case botsVoice = "bots.voice"
        case callback = "callback"
        case cobrowse = "cobrowse"
        case contentManagement = "content.management"
        case conversation = "conversation"
        case dataactions = "dataactions"
        case datatables = "datatables"
        case directory = "directory"
        case email = "email"
        case eventOrchestration = "event.orchestration"
        case externalContacts = "external.contacts"
        case gcv = "gcv"
        case gdpr = "gdpr"
        case groups = "groups"
        case historicalAdherence = "historical.adherence"
        case infrastructureascode = "infrastructureascode"
        case integrations = "integrations"
        case intentMiner = "intent.miner"
        case journey = "journey"
        case knowledge = "knowledge"
        case languageUnderstanding = "language.understanding"
        case learning = "learning"
        case limitRegistry = "limit.registry"
        case marketplace = "marketplace"
        case mediaCommunications = "media.communications"
        case messaging = "messaging"
        case notifications = "notifications"
        case onboarding = "onboarding"
        case outbound = "outbound"
        case platformApi = "platform.api"
        case predictiveRouting = "predictive.routing"
        case presence = "presence"
        case quality = "quality"
        case recording = "recording"
        case responseManagement = "response.management"
        case routing = "routing"
        case scim = "scim"
        case search = "search"
        case secondaryAutomationTesting = "secondary.automation.testing"
        case skills = "skills"
        case speechAndTextAnalytics = "speech.and.text.analytics"
        case speechIntegration = "speech.integration"
        case supportability = "supportability"
        case taskManagement = "task.management"
        case telephonyConfiguration = "telephony.configuration"
        case usage = "usage"
        case users = "users"
        case webDeployments = "web.deployments"
        case webMessaging = "web.messaging"
        case webchat = "webchat"
        case webhooks = "webhooks"
        case workforceManagement = "workforce.management"
    }





    public var key: String?
    public var namespace: Namespace?
    public var value: Int64?
    public var documented: Bool?

    public init(key: String?, namespace: Namespace?, value: Int64?, documented: Bool?) {
        self.key = key
        self.namespace = namespace
        self.value = value
        self.documented = documented
    }


}




public class QueueConversationChatEventTopicQueueMediaSettings: Codable {









    /** Specifies how long the agent has to answer an interaction before being marked as not responding. */
    public var alertingTimeoutSeconds: Int64?
    /** Specifies the duration of the alerting sound to be played for auto answered interactions. */
    public var autoAnswerAlertToneSeconds: Double?
    /** Specifies the duration of the alerting sound to be played for manually answered interactions */
    public var manualAnswerAlertToneSeconds: Double?
    /** Flag to indicate if auto answer is enabled for the given media type or media subtype. */
    public var enableAutoAnswer: Bool?

    public init(alertingTimeoutSeconds: Int64?, autoAnswerAlertToneSeconds: Double?, manualAnswerAlertToneSeconds: Double?, enableAutoAnswer: Bool?) {
        self.alertingTimeoutSeconds = alertingTimeoutSeconds
        self.autoAnswerAlertToneSeconds = autoAnswerAlertToneSeconds
        self.manualAnswerAlertToneSeconds = manualAnswerAlertToneSeconds
        self.enableAutoAnswer = enableAutoAnswer
    }


}




public class QueueConversationCobrowseEventTopicDivisionEntityRef: Codable {







    public var _id: String?
    public var selfUri: String?
    /** The time the entity division was last updated. */
    public var dateDivisionUpdated: Date?

    public init(_id: String?, selfUri: String?, dateDivisionUpdated: Date?) {
        self._id = _id
        self.selfUri = selfUri
        self.dateDivisionUpdated = dateDivisionUpdated
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
        case dateDivisionUpdated
    }


}



/** A subset of the Journey System's action data relevant to a part of a conversation (for external linkage and internal usage/context) */

public class QueueConversationCobrowseEventTopicJourneyAction: Codable {





    /** The ID of an action from the Journey System (an action is spawned from an actionMap) */
    public var _id: String?
    public var actionMap: QueueConversationCobrowseEventTopicJourneyActionMap?

    public init(_id: String?, actionMap: QueueConversationCobrowseEventTopicJourneyActionMap?) {
        self._id = _id
        self.actionMap = actionMap
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case actionMap
    }


}




public class QueueConversationCobrowseEventTopicJourneyContext: Codable {







    public var customer: QueueConversationCobrowseEventTopicJourneyCustomer?
    public var customerSession: QueueConversationCobrowseEventTopicJourneyCustomerSession?
    public var triggeringAction: QueueConversationCobrowseEventTopicJourneyAction?

    public init(customer: QueueConversationCobrowseEventTopicJourneyCustomer?, customerSession: QueueConversationCobrowseEventTopicJourneyCustomerSession?, triggeringAction: QueueConversationCobrowseEventTopicJourneyAction?) {
        self.customer = customer
        self.customerSession = customerSession
        self.triggeringAction = triggeringAction
    }


}




public class QueueConversationCobrowseEventTopicWrapup: Codable {











    /** The user configured wrap up code name. */
    public var code: String?
    /** Text entered by the agent to describe the call or disposition. */
    public var notes: String?
    /** List of tags selected by the agent to describe the call or disposition. */
    public var tags: [String]?
    /** The length of time in seconds that the agent spent doing after call work., Note, the format of utc-millisec should be ignored, our code generator needs it to generate a Long for us internally */
    public var durationSeconds: Int64?
    /** The timestamp when the wrapup was finished. */
    public var endTime: Date?

    public init(code: String?, notes: String?, tags: [String]?, durationSeconds: Int64?, endTime: Date?) {
        self.code = code
        self.notes = notes
        self.tags = tags
        self.durationSeconds = durationSeconds
        self.endTime = endTime
    }


}




public class QueueConversationEmailEventTopicConversationRoutingData: Codable {











    /** A UriReference for a resource */
    public var queue: QueueConversationEmailEventTopicUriReference?
    /** A UriReference for a resource */
    public var language: QueueConversationEmailEventTopicUriReference?
    /** The priority of the conversation to use for routing decisions */
    public var priority: Int64?
    /** The skills to use for routing decisions */
    public var skills: [QueueConversationEmailEventTopicUriReference]?
    /** A collection of agents and their assigned scores for this conversation (0 - 100, higher being better), for use in routing to preferred agents */
    public var scoredAgents: [QueueConversationEmailEventTopicScoredAgent]?

    public init(queue: QueueConversationEmailEventTopicUriReference?, language: QueueConversationEmailEventTopicUriReference?, priority: Int64?, skills: [QueueConversationEmailEventTopicUriReference]?, scoredAgents: [QueueConversationEmailEventTopicScoredAgent]?) {
        self.queue = queue
        self.language = language
        self.priority = priority
        self.skills = skills
        self.scoredAgents = scoredAgents
    }


}



/** A reference to another domain entity. */

public class QueueConversationEmailEventTopicDomainEntityRef: Codable {





    public var _id: String?
    public var selfUri: String?

    public init(_id: String?, selfUri: String?) {
        self._id = _id
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
    }


}



/** Address and name data for a call endpoint. */

public class QueueConversationEventTopicAddress: Codable {











    /** This will be nameRaw if present, or a locality lookup of the address field otherwise. */
    public var name: String?
    /** The name as close to the bits on the wire as possible. */
    public var nameRaw: String?
    /** The normalized address. This field is acquired from the Address Normalization Table.  The addressRaw could have gone through some transformations, such as only using the numeric portion, before being run through the Address Normalization Table. */
    public var addressNormalized: String?
    /** The address as close to the bits on the wire as possible. */
    public var addressRaw: String?
    /** The displayable address. This field is acquired from the Address Normalization Table.  The addressRaw could have gone through some transformations, such as only using the numeric portion, before being run through the Address Normalization Table. */
    public var addressDisplayable: String?

    public init(name: String?, nameRaw: String?, addressNormalized: String?, addressRaw: String?, addressDisplayable: String?) {
        self.name = name
        self.nameRaw = nameRaw
        self.addressNormalized = addressNormalized
        self.addressRaw = addressRaw
        self.addressDisplayable = addressDisplayable
    }


}




public class QueueConversationEventTopicCall: Codable {



    public enum State: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case uploading = "uploading"
        case converting = "converting"
        case transmitting = "transmitting"
        case _none = "none"
    }

    public enum InitialState: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case uploading = "uploading"
        case converting = "converting"
        case transmitting = "transmitting"
        case _none = "none"
    }



    public enum RecordingState: String, Codable { 
        case _none = "none"
        case active = "active"
        case paused = "paused"
    }













    public enum DisconnectType: String, Codable { 
        case endpoint = "endpoint"
        case endpointDnd = "endpoint.dnd"
        case client = "client"
        case system = "system"
        case timeout = "timeout"
        case transfer = "transfer"
        case transferConference = "transfer.conference"
        case transferConsult = "transfer.consult"
        case transferForward = "transfer.forward"
        case transferNoanswer = "transfer.noanswer"
        case transferNotavailable = "transfer.notavailable"
        case transferDnd = "transfer.dnd"
        case transportFailure = "transport.failure"
        case error = "error"
        case peer = "peer"
        case other = "other"
        case spam = "spam"
        case uncallable = "uncallable"
    }



    public enum Direction: String, Codable { 
        case outbound = "outbound"
        case inbound = "inbound"
    }







































    /** A globally unique identifier for this communication. */
    public var _id: String?
    public var state: State?
    public var initialState: InitialState?
    /** True if this call is being recorded. */
    public var recording: Bool?
    /** State of recording on this call. */
    public var recordingState: RecordingState?
    public var recordersState: QueueConversationEventTopicRecordersState?
    /** True if this call is muted so that remote participants can't hear any audio from this end. */
    public var muted: Bool?
    /** True if this call is held and the person on this side hears hold music. */
    public var confined: Bool?
    /** True if this call is held and the person on this side hears silence. */
    public var held: Bool?
    /** True when the recording of this call is in secure pause status. */
    public var securePause: Bool?
    public var errorInfo: QueueConversationEventTopicErrorDetails?
    /** System defined string indicating what caused the communication to disconnect. Will be null until the communication disconnects. */
    public var disconnectType: DisconnectType?
    /** The timestamp the call was placed on hold in the cloud clock if the call is currently on hold. */
    public var startHoldTime: Date?
    /** Whether a call is inbound or outbound. */
    public var direction: Direction?
    /** If call is a fax of a document in content management, the id of the document in content management. */
    public var documentId: String?
    public var _self: QueueConversationEventTopicAddress?
    /** Address and name data for a call endpoint. */
    public var other: QueueConversationEventTopicAddress?
    /** The source provider of the call. */
    public var provider: String?
    /** The UUID of the script to use. */
    public var scriptId: String?
    /** The id of the peer communication corresponding to a matching leg for this communication. */
    public var peerId: String?
    /** The timestamp when this communication was connected in the cloud clock. */
    public var connectedTime: Date?
    /** The timestamp when this communication disconnected from the conversation in the provider clock. */
    public var disconnectedTime: Date?
    /** List of reasons that this call was disconnected. This will be set once the call disconnects. */
    public var disconnectReasons: [QueueConversationEventTopicDisconnectReason]?
    public var faxStatus: QueueConversationEventTopicFaxStatus?
    /** User to User Information (UUI) data managed by SIP session application. */
    public var uuiData: String?
    /** The timestamp when this participant was connected to the barge conference in the provider clock. */
    public var bargedTime: Date?
    /** Call wrap up or disposition data. */
    public var wrapup: QueueConversationEventTopicWrapup?
    public var afterCallWork: QueueConversationEventTopicAfterCallWork?
    /** Indicates if after-call is required for a communication. Only used when the ACW Setting is Agent Requested. */
    public var afterCallWorkRequired: Bool?
    /** UUID of virtual agent assistant that provide suggestions to the agent participant during the conversation. */
    public var agentAssistantId: String?
    public var queueMediaSettings: QueueConversationEventTopicQueueMediaSettings?
    public var disposition: QueueConversationEventTopicDisposition?
    /** Indicates how call reaches the agent. */
    public var transferSource: String?

    public init(_id: String?, state: State?, initialState: InitialState?, recording: Bool?, recordingState: RecordingState?, recordersState: QueueConversationEventTopicRecordersState?, muted: Bool?, confined: Bool?, held: Bool?, securePause: Bool?, errorInfo: QueueConversationEventTopicErrorDetails?, disconnectType: DisconnectType?, startHoldTime: Date?, direction: Direction?, documentId: String?, _self: QueueConversationEventTopicAddress?, other: QueueConversationEventTopicAddress?, provider: String?, scriptId: String?, peerId: String?, connectedTime: Date?, disconnectedTime: Date?, disconnectReasons: [QueueConversationEventTopicDisconnectReason]?, faxStatus: QueueConversationEventTopicFaxStatus?, uuiData: String?, bargedTime: Date?, wrapup: QueueConversationEventTopicWrapup?, afterCallWork: QueueConversationEventTopicAfterCallWork?, afterCallWorkRequired: Bool?, agentAssistantId: String?, queueMediaSettings: QueueConversationEventTopicQueueMediaSettings?, disposition: QueueConversationEventTopicDisposition?, transferSource: String?) {
        self._id = _id
        self.state = state
        self.initialState = initialState
        self.recording = recording
        self.recordingState = recordingState
        self.recordersState = recordersState
        self.muted = muted
        self.confined = confined
        self.held = held
        self.securePause = securePause
        self.errorInfo = errorInfo
        self.disconnectType = disconnectType
        self.startHoldTime = startHoldTime
        self.direction = direction
        self.documentId = documentId
        self._self = _self
        self.other = other
        self.provider = provider
        self.scriptId = scriptId
        self.peerId = peerId
        self.connectedTime = connectedTime
        self.disconnectedTime = disconnectedTime
        self.disconnectReasons = disconnectReasons
        self.faxStatus = faxStatus
        self.uuiData = uuiData
        self.bargedTime = bargedTime
        self.wrapup = wrapup
        self.afterCallWork = afterCallWork
        self.afterCallWorkRequired = afterCallWorkRequired
        self.agentAssistantId = agentAssistantId
        self.queueMediaSettings = queueMediaSettings
        self.disposition = disposition
        self.transferSource = transferSource
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case state
        case initialState
        case recording
        case recordingState
        case recordersState
        case muted
        case confined
        case held
        case securePause
        case errorInfo
        case disconnectType
        case startHoldTime
        case direction
        case documentId
        case _self = "self"
        case other
        case provider
        case scriptId
        case peerId
        case connectedTime
        case disconnectedTime
        case disconnectReasons
        case faxStatus
        case uuiData
        case bargedTime
        case wrapup
        case afterCallWork
        case afterCallWorkRequired
        case agentAssistantId
        case queueMediaSettings
        case disposition
        case transferSource
    }


}




public class QueueConversationEventTopicConversation: Codable {



























    public var _id: String?
    public var maxParticipants: Int64?
    public var participants: [QueueConversationEventTopicParticipant]?
    public var recentTransfers: [QueueConversationEventTopicTransferResponse]?
    public var recordingState: String?
    public var address: String?
    public var externalTag: String?
    public var utilizationLabelId: String?
    public var securePause: Bool?
    public var inactivityTimeout: Date?
    public var associatedConversation: QueueConversationEventTopicDomainEntityRef?
    public var consultationConversations: [QueueConversationEventTopicDomainEntityRef]?
    public var divisions: [QueueConversationEventTopicConversationDivisionMembership]?

    public init(_id: String?, maxParticipants: Int64?, participants: [QueueConversationEventTopicParticipant]?, recentTransfers: [QueueConversationEventTopicTransferResponse]?, recordingState: String?, address: String?, externalTag: String?, utilizationLabelId: String?, securePause: Bool?, inactivityTimeout: Date?, associatedConversation: QueueConversationEventTopicDomainEntityRef?, consultationConversations: [QueueConversationEventTopicDomainEntityRef]?, divisions: [QueueConversationEventTopicConversationDivisionMembership]?) {
        self._id = _id
        self.maxParticipants = maxParticipants
        self.participants = participants
        self.recentTransfers = recentTransfers
        self.recordingState = recordingState
        self.address = address
        self.externalTag = externalTag
        self.utilizationLabelId = utilizationLabelId
        self.securePause = securePause
        self.inactivityTimeout = inactivityTimeout
        self.associatedConversation = associatedConversation
        self.consultationConversations = consultationConversations
        self.divisions = divisions
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case maxParticipants
        case participants
        case recentTransfers
        case recordingState
        case address
        case externalTag
        case utilizationLabelId
        case securePause
        case inactivityTimeout
        case associatedConversation
        case consultationConversations
        case divisions
    }


}




public class QueueConversationEventTopicDisconnectReason: Codable {

    public enum ModelType: String, Codable { 
        case q850 = "q850"
        case sip = "sip"
    }





    /** Disconnect reason protocol type. */
    public var type: ModelType?
    /** Protocol specific reason code. See the Q.850 and SIP specs. */
    public var code: Int64?
    /** Human readable English description of the disconnect reason. */
    public var phrase: String?

    public init(type: ModelType?, code: Int64?, phrase: String?) {
        self.type = type
        self.code = code
        self.phrase = phrase
    }


}



/** Answering Machine Detection timeout configuration. */

public class QueueConversationEventTopicDispositionAmdTimeout: Codable {









    /** Configured AMD timeout value. */
    public var timeoutMs: Int64?
    /** Configured option for when to start the AMD timer, such as on line connect or speech start. */
    public var timerStartEvent: String?
    /** Timer start time, measured in epoch milliseconds. */
    public var timerStartTime: Double?
    /** Timer end time, measured in epoch milliseconds. */
    public var timerEndTime: Double?

    public init(timeoutMs: Int64?, timerStartEvent: String?, timerStartTime: Double?, timerEndTime: Double?) {
        self.timeoutMs = timeoutMs
        self.timerStartEvent = timerStartEvent
        self.timerStartTime = timerStartTime
        self.timerEndTime = timerEndTime
    }


}



/** Details about the action map from the Journey System which triggered this action */

public class QueueConversationEventTopicJourneyActionMap: Codable {





    /** The ID of the actionMap in the Journey System which triggered this action */
    public var _id: String?
    /** The version number of the actionMap in the Journey System at the time this action was triggered */
    public var version: Int64?

    public init(_id: String?, version: Int64?) {
        self._id = _id
        self.version = version
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case version
    }


}



/** Metadata information about a message. */

public class QueueConversationEventTopicMessageMetadata: Codable {







    /** Message type. */
    public var type: String?
    /** List of message events, if any */
    public var events: [QueueConversationEventTopicMessageMetadataEvent]?
    /** List of message content, if any */
    public var content: [QueueConversationEventTopicMessageMetadataContent]?

    public init(type: String?, events: [QueueConversationEventTopicMessageMetadataEvent]?, content: [QueueConversationEventTopicMessageMetadataContent]?) {
        self.type = type
        self.events = events
        self.content = content
    }


}




public class QueueConversationEventTopicPhoneNumberColumn: Codable {





    public var columnName: String?
    public var type: String?

    public init(columnName: String?, type: String?) {
        self.columnName = columnName
        self.type = type
    }


}



/** Contains the states of different recorders. */

public class QueueConversationEventTopicRecordersState: Codable {









    /** Indicates the state of the adhoc recorder. */
    public var adhocState: String?
    /** Indicates the state of the customer experience recorder. */
    public var customerExperienceState: String?
    /** Indicates the state of the agent experience recorder. */
    public var agentExperienceState: String?
    /** State of the snippet recording for this session. Note that snippets may never be paused. Valid values are in Constants.java with a prefix of RECORDER_STATE_*. */
    public var snippetState: String?

    public init(adhocState: String?, customerExperienceState: String?, agentExperienceState: String?, snippetState: String?) {
        self.adhocState = adhocState
        self.customerExperienceState = customerExperienceState
        self.agentExperienceState = agentExperienceState
        self.snippetState = snippetState
    }


}




public class QueueConversationEventTopicSocialExpression: Codable {

    public enum State: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case _none = "none"
    }

    public enum InitialState: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case _none = "none"
    }





















    public enum DisconnectType: String, Codable { 
        case endpoint = "endpoint"
        case endpointDnd = "endpoint.dnd"
        case client = "client"
        case system = "system"
        case timeout = "timeout"
        case transfer = "transfer"
        case transferConference = "transfer.conference"
        case transferConsult = "transfer.consult"
        case transferForward = "transfer.forward"
        case transferNoanswer = "transfer.noanswer"
        case transferNotavailable = "transfer.notavailable"
        case transferDnd = "transfer.dnd"
        case transportFailure = "transport.failure"
        case error = "error"
        case peer = "peer"
        case other = "other"
        case spam = "spam"
        case uncallable = "uncallable"
    }













    public var state: State?
    public var initialState: InitialState?
    /** A globally unique identifier for this communication. */
    public var _id: String?
    /** A globally unique identifier for the social media. */
    public var socialMediaId: String?
    /** The social network of the communication */
    public var socialMediaHub: String?
    /** The social media user name of the communication */
    public var socialUserName: String?
    /** The text preview of the communication contents */
    public var previewText: String?
    /** A globally unique identifier for the recording associated with this chat. */
    public var recordingId: String?
    /** True if this call is held and the person on this side hears silence. */
    public var held: Bool?
    /** The source provider of the social expression. */
    public var provider: String?
    /** The UUID of the script to use. */
    public var scriptId: String?
    /** The id of the peer communication corresponding to a matching leg for this communication. */
    public var peerId: String?
    /** System defined string indicating what caused the communication to disconnect. Will be null until the communication disconnects. */
    public var disconnectType: DisconnectType?
    /** The timestamp the chat was placed on hold in the cloud clock if the chat is currently on hold. */
    public var startHoldTime: Date?
    /** The timestamp when this communication was connected in the cloud clock. */
    public var connectedTime: Date?
    /** The timestamp when this communication disconnected from the conversation in the provider clock. */
    public var disconnectedTime: Date?
    /** Call wrap up or disposition data. */
    public var wrapup: QueueConversationEventTopicWrapup?
    /** A communication's after-call work data. */
    public var afterCallWork: QueueConversationEventTopicAfterCallWork?
    /** Indicates if after-call is required for a communication. Only used when the ACW Setting is Agent Requested. */
    public var afterCallWorkRequired: Bool?

    public init(state: State?, initialState: InitialState?, _id: String?, socialMediaId: String?, socialMediaHub: String?, socialUserName: String?, previewText: String?, recordingId: String?, held: Bool?, provider: String?, scriptId: String?, peerId: String?, disconnectType: DisconnectType?, startHoldTime: Date?, connectedTime: Date?, disconnectedTime: Date?, wrapup: QueueConversationEventTopicWrapup?, afterCallWork: QueueConversationEventTopicAfterCallWork?, afterCallWorkRequired: Bool?) {
        self.state = state
        self.initialState = initialState
        self._id = _id
        self.socialMediaId = socialMediaId
        self.socialMediaHub = socialMediaHub
        self.socialUserName = socialUserName
        self.previewText = previewText
        self.recordingId = recordingId
        self.held = held
        self.provider = provider
        self.scriptId = scriptId
        self.peerId = peerId
        self.disconnectType = disconnectType
        self.startHoldTime = startHoldTime
        self.connectedTime = connectedTime
        self.disconnectedTime = disconnectedTime
        self.wrapup = wrapup
        self.afterCallWork = afterCallWork
        self.afterCallWorkRequired = afterCallWorkRequired
    }

    public enum CodingKeys: String, CodingKey { 
        case state
        case initialState
        case _id = "id"
        case socialMediaId
        case socialMediaHub
        case socialUserName
        case previewText
        case recordingId
        case held
        case provider
        case scriptId
        case peerId
        case disconnectType
        case startHoldTime
        case connectedTime
        case disconnectedTime
        case wrapup
        case afterCallWork
        case afterCallWorkRequired
    }


}



/** Fields identifying the entity that updated the command. */

public class QueueConversationEventTopicTransferModifedBy: Codable {





    /** The id of the user if the updater is an internal user. */
    public var _id: String?
    /** The URI for the user if the updater is an internal user. */
    public var selfUri: String?

    public init(_id: String?, selfUri: String?) {
        self._id = _id
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
    }


}



/** A UriReference for a resource */

public class QueueConversationEventTopicUriReference: Codable {





    /** The ID of the resource */
    public var _id: String?
    /** The name of the resource */
    public var name: String?

    public init(_id: String?, name: String?) {
        self._id = _id
        self.name = name
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
    }


}




public class QueueConversationMessageEventTopicLimit: Codable {



    public enum Namespace: String, Codable { 
        case agentAssistant = "agent.assistant"
        case analyticsAlerting = "analytics.alerting"
        case analytics = "analytics"
        case analyticsRealtime = "analytics.realtime"
        case analyticsReportingSettings = "analytics.reporting.settings"
        case architect = "architect"
        case audiohook = "audiohook"
        case audit = "audit"
        case authApi = "auth.api"
        case authorization = "authorization"
        case automationTesting = "automation.testing"
        case bots = "bots"
        case botsVoice = "bots.voice"
        case callback = "callback"
        case cobrowse = "cobrowse"
        case contentManagement = "content.management"
        case conversation = "conversation"
        case dataactions = "dataactions"
        case datatables = "datatables"
        case directory = "directory"
        case email = "email"
        case eventOrchestration = "event.orchestration"
        case externalContacts = "external.contacts"
        case gcv = "gcv"
        case gdpr = "gdpr"
        case groups = "groups"
        case historicalAdherence = "historical.adherence"
        case infrastructureascode = "infrastructureascode"
        case integrations = "integrations"
        case intentMiner = "intent.miner"
        case journey = "journey"
        case knowledge = "knowledge"
        case languageUnderstanding = "language.understanding"
        case learning = "learning"
        case limitRegistry = "limit.registry"
        case marketplace = "marketplace"
        case mediaCommunications = "media.communications"
        case messaging = "messaging"
        case notifications = "notifications"
        case onboarding = "onboarding"
        case outbound = "outbound"
        case platformApi = "platform.api"
        case predictiveRouting = "predictive.routing"
        case presence = "presence"
        case quality = "quality"
        case recording = "recording"
        case responseManagement = "response.management"
        case routing = "routing"
        case scim = "scim"
        case search = "search"
        case secondaryAutomationTesting = "secondary.automation.testing"
        case skills = "skills"
        case speechAndTextAnalytics = "speech.and.text.analytics"
        case speechIntegration = "speech.integration"
        case supportability = "supportability"
        case taskManagement = "task.management"
        case telephonyConfiguration = "telephony.configuration"
        case usage = "usage"
        case users = "users"
        case webDeployments = "web.deployments"
        case webMessaging = "web.messaging"
        case webchat = "webchat"
        case webhooks = "webhooks"
        case workforceManagement = "workforce.management"
    }





    public var key: String?
    public var namespace: Namespace?
    public var value: Int64?
    public var documented: Bool?

    public init(key: String?, namespace: Namespace?, value: Int64?, documented: Bool?) {
        self.key = key
        self.namespace = namespace
        self.value = value
        self.documented = documented
    }


}




public class QueueMember: Codable {

















    /** The queue member's id. */
    public var _id: String?
    public var name: String?
    public var user: User?
    public var ringNumber: Int?
    public var joined: Bool?
    public var memberBy: String?
    public var routingStatus: RoutingStatus?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, user: User?, ringNumber: Int?, joined: Bool?, memberBy: String?, routingStatus: RoutingStatus?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.user = user
        self.ringNumber = ringNumber
        self.joined = joined
        self.memberBy = memberBy
        self.routingStatus = routingStatus
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case user
        case ringNumber
        case joined
        case memberBy
        case routingStatus
        case selfUri
    }


}




public class QueueConversationMessageEventTopicMessageMetadataContent: Codable {





    /** Type of this content element. */
    public var contentType: String?
    /** Content subtype, if any */
    public var subType: String?

    public init(contentType: String?, subType: String?) {
        self.contentType = contentType
        self.subType = subType
    }


}




public class QueueConversationMessageEventTopicQueueMediaSettings: Codable {









    /** Specifies how long the agent has to answer an interaction before being marked as not responding. */
    public var alertingTimeoutSeconds: Int64?
    /** Specifies the duration of the alerting sound to be played for auto answered interactions. */
    public var autoAnswerAlertToneSeconds: Double?
    /** Specifies the duration of the alerting sound to be played for manually answered interactions */
    public var manualAnswerAlertToneSeconds: Double?
    /** Flag to indicate if auto answer is enabled for the given media type or media subtype. */
    public var enableAutoAnswer: Bool?

    public init(alertingTimeoutSeconds: Int64?, autoAnswerAlertToneSeconds: Double?, manualAnswerAlertToneSeconds: Double?, enableAutoAnswer: Bool?) {
        self.alertingTimeoutSeconds = alertingTimeoutSeconds
        self.autoAnswerAlertToneSeconds = autoAnswerAlertToneSeconds
        self.manualAnswerAlertToneSeconds = manualAnswerAlertToneSeconds
        self.enableAutoAnswer = enableAutoAnswer
    }


}




public class QueueConversationScreenShareEventTopicConversationDivisionMembership: Codable {





    public var division: QueueConversationScreenShareEventTopicDomainEntityRef?
    public var entities: [QueueConversationScreenShareEventTopicDivisionEntityRef]?

    public init(division: QueueConversationScreenShareEventTopicDomainEntityRef?, entities: [QueueConversationScreenShareEventTopicDivisionEntityRef]?) {
        self.division = division
        self.entities = entities
    }


}



/** A subset of the Journey System's customer data at a point-in-time (for external linkage and internal usage/context) */

public class QueueConversationScreenShareEventTopicJourneyCustomer: Codable {





    /** An ID of a customer within the Journey System at a point-in-time.  Note that a customer entity can have multiple customerIds based on the stitching process.  Depending on the context within the PureCloud conversation, this may or may not be mutable. */
    public var _id: String?
    /** The type of the customerId within the Journey System (e.g. cookie). */
    public var idType: String?

    public init(_id: String?, idType: String?) {
        self._id = _id
        self.idType = idType
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case idType
    }


}



/** A subset of the Journey System's tracked customer session data at a point-in-time (for external linkage and internal usage/context) */

public class QueueConversationScreenShareEventTopicJourneyCustomerSession: Codable {





    /** An ID of a Customer/User's session within the Journey System at a point-in-time */
    public var _id: String?
    /** The type of the Customer/User's session within the Journey System (e.g. web, app) */
    public var type: String?

    public init(_id: String?, type: String?) {
        self._id = _id
        self.type = type
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case type
    }


}




public class QueueConversationScreenShareEventTopicScoredAgent: Codable {





    /** A UriReference for a resource */
    public var agent: QueueConversationScreenShareEventTopicUriReference?
    /** Agent's score for the current conversation, from 0 - 100, higher being better */
    public var score: Int64?

    public init(agent: QueueConversationScreenShareEventTopicUriReference?, score: Int64?) {
        self.agent = agent
        self.score = score
    }


}




public class QueueConversationScreenShareEventTopicScreenShareMediaParticipant: Codable {

















    public enum State: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case converting = "converting"
        case uploading = "uploading"
        case transmitting = "transmitting"
        case scheduled = "scheduled"
        case parked = "parked"
        case _none = "none"
    }

    public enum InitialState: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case converting = "converting"
        case uploading = "uploading"
        case transmitting = "transmitting"
        case scheduled = "scheduled"
        case parked = "parked"
        case _none = "none"
    }

    public enum Direction: String, Codable { 
        case inbound = "inbound"
        case outbound = "outbound"
    }

    public enum DisconnectType: String, Codable { 
        case endpoint = "endpoint"
        case endpointDnd = "endpoint.dnd"
        case client = "client"
        case system = "system"
        case transfer = "transfer"
        case timeout = "timeout"
        case transferConference = "transfer.conference"
        case transferConsult = "transfer.consult"
        case transferForward = "transfer.forward"
        case transferNoanswer = "transfer.noanswer"
        case transferNotavailable = "transfer.notavailable"
        case transferDnd = "transfer.dnd"
        case transportFailure = "transport.failure"
        case error = "error"
        case peer = "peer"
        case other = "other"
        case spam = "spam"
        case uncallable = "uncallable"
        case inactivity = "inactivity"
        case sessionExpired = "session.expired"
    }









































    public enum FlaggedReason: String, Codable { 
        case general = "general"
    }





















    public var _id: String?
    public var name: String?
    public var address: String?
    public var startTime: Date?
    public var connectedTime: Date?
    public var endTime: Date?
    public var startHoldTime: Date?
    public var purpose: String?
    public var state: State?
    public var initialState: InitialState?
    public var direction: Direction?
    public var disconnectType: DisconnectType?
    public var held: Bool?
    public var wrapupRequired: Bool?
    public var wrapupPrompt: String?
    public var user: QueueConversationScreenShareEventTopicUriReference?
    public var queue: QueueConversationScreenShareEventTopicUriReference?
    public var team: QueueConversationScreenShareEventTopicUriReference?
    public var attributes: [String:String]?
    public var errorInfo: QueueConversationScreenShareEventTopicErrorBody?
    public var script: QueueConversationScreenShareEventTopicUriReference?
    public var wrapupTimeoutMs: Int64?
    public var wrapupSkipped: Bool?
    public var alertingTimeoutMs: Int64?
    public var provider: String?
    public var externalContact: QueueConversationScreenShareEventTopicUriReference?
    public var externalContactInitialDivisionId: String?
    public var externalOrganization: QueueConversationScreenShareEventTopicUriReference?
    public var wrapup: QueueConversationScreenShareEventTopicWrapup?
    public var conversationRoutingData: QueueConversationScreenShareEventTopicConversationRoutingData?
    public var peer: String?
    public var screenRecordingState: String?
    public var flaggedReason: FlaggedReason?
    public var journeyContext: QueueConversationScreenShareEventTopicJourneyContext?
    public var startAcwTime: Date?
    public var endAcwTime: Date?
    public var resumeTime: Date?
    public var parkTime: Date?
    public var mediaRoles: [String]?
    public var queueMediaSettings: QueueConversationScreenShareEventTopicQueueMediaSettings?
    public var context: String?
    public var peerCount: Int64?
    public var sharing: Bool?

    public init(_id: String?, name: String?, address: String?, startTime: Date?, connectedTime: Date?, endTime: Date?, startHoldTime: Date?, purpose: String?, state: State?, initialState: InitialState?, direction: Direction?, disconnectType: DisconnectType?, held: Bool?, wrapupRequired: Bool?, wrapupPrompt: String?, user: QueueConversationScreenShareEventTopicUriReference?, queue: QueueConversationScreenShareEventTopicUriReference?, team: QueueConversationScreenShareEventTopicUriReference?, attributes: [String:String]?, errorInfo: QueueConversationScreenShareEventTopicErrorBody?, script: QueueConversationScreenShareEventTopicUriReference?, wrapupTimeoutMs: Int64?, wrapupSkipped: Bool?, alertingTimeoutMs: Int64?, provider: String?, externalContact: QueueConversationScreenShareEventTopicUriReference?, externalContactInitialDivisionId: String?, externalOrganization: QueueConversationScreenShareEventTopicUriReference?, wrapup: QueueConversationScreenShareEventTopicWrapup?, conversationRoutingData: QueueConversationScreenShareEventTopicConversationRoutingData?, peer: String?, screenRecordingState: String?, flaggedReason: FlaggedReason?, journeyContext: QueueConversationScreenShareEventTopicJourneyContext?, startAcwTime: Date?, endAcwTime: Date?, resumeTime: Date?, parkTime: Date?, mediaRoles: [String]?, queueMediaSettings: QueueConversationScreenShareEventTopicQueueMediaSettings?, context: String?, peerCount: Int64?, sharing: Bool?) {
        self._id = _id
        self.name = name
        self.address = address
        self.startTime = startTime
        self.connectedTime = connectedTime
        self.endTime = endTime
        self.startHoldTime = startHoldTime
        self.purpose = purpose
        self.state = state
        self.initialState = initialState
        self.direction = direction
        self.disconnectType = disconnectType
        self.held = held
        self.wrapupRequired = wrapupRequired
        self.wrapupPrompt = wrapupPrompt
        self.user = user
        self.queue = queue
        self.team = team
        self.attributes = attributes
        self.errorInfo = errorInfo
        self.script = script
        self.wrapupTimeoutMs = wrapupTimeoutMs
        self.wrapupSkipped = wrapupSkipped
        self.alertingTimeoutMs = alertingTimeoutMs
        self.provider = provider
        self.externalContact = externalContact
        self.externalContactInitialDivisionId = externalContactInitialDivisionId
        self.externalOrganization = externalOrganization
        self.wrapup = wrapup
        self.conversationRoutingData = conversationRoutingData
        self.peer = peer
        self.screenRecordingState = screenRecordingState
        self.flaggedReason = flaggedReason
        self.journeyContext = journeyContext
        self.startAcwTime = startAcwTime
        self.endAcwTime = endAcwTime
        self.resumeTime = resumeTime
        self.parkTime = parkTime
        self.mediaRoles = mediaRoles
        self.queueMediaSettings = queueMediaSettings
        self.context = context
        self.peerCount = peerCount
        self.sharing = sharing
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case address
        case startTime
        case connectedTime
        case endTime
        case startHoldTime
        case purpose
        case state
        case initialState
        case direction
        case disconnectType
        case held
        case wrapupRequired
        case wrapupPrompt
        case user
        case queue
        case team
        case attributes
        case errorInfo
        case script
        case wrapupTimeoutMs
        case wrapupSkipped
        case alertingTimeoutMs
        case provider
        case externalContact
        case externalContactInitialDivisionId
        case externalOrganization
        case wrapup
        case conversationRoutingData
        case peer
        case screenRecordingState
        case flaggedReason
        case journeyContext
        case startAcwTime
        case endAcwTime
        case resumeTime
        case parkTime
        case mediaRoles
        case queueMediaSettings
        case context
        case peerCount
        case sharing
    }


}



/** Address and name data for a call endpoint. */

public class QueueConversationSocialExpressionEventTopicAddress: Codable {











    /** This will be nameRaw if present, or a locality lookup of the address field otherwise. */
    public var name: String?
    /** The name as close to the bits on the wire as possible. */
    public var nameRaw: String?
    /** The normalized address. This field is acquired from the Address Normalization Table.  The addressRaw could have gone through some transformations, such as only using the numeric portion, before being run through the Address Normalization Table. */
    public var addressNormalized: String?
    /** The address as close to the bits on the wire as possible. */
    public var addressRaw: String?
    /** The displayable address. This field is acquired from the Address Normalization Table.  The addressRaw could have gone through some transformations, such as only using the numeric portion, before being run through the Address Normalization Table. */
    public var addressDisplayable: String?

    public init(name: String?, nameRaw: String?, addressNormalized: String?, addressRaw: String?, addressDisplayable: String?) {
        self.name = name
        self.nameRaw = nameRaw
        self.addressNormalized = addressNormalized
        self.addressRaw = addressRaw
        self.addressDisplayable = addressDisplayable
    }


}




public class QueueConversationSocialExpressionEventTopicCall: Codable {



    public enum State: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case uploading = "uploading"
        case converting = "converting"
        case transmitting = "transmitting"
        case _none = "none"
    }

    public enum InitialState: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case uploading = "uploading"
        case converting = "converting"
        case transmitting = "transmitting"
        case _none = "none"
    }



    public enum RecordingState: String, Codable { 
        case _none = "none"
        case active = "active"
        case paused = "paused"
    }













    public enum DisconnectType: String, Codable { 
        case endpoint = "endpoint"
        case endpointDnd = "endpoint.dnd"
        case client = "client"
        case system = "system"
        case timeout = "timeout"
        case transfer = "transfer"
        case transferConference = "transfer.conference"
        case transferConsult = "transfer.consult"
        case transferForward = "transfer.forward"
        case transferNoanswer = "transfer.noanswer"
        case transferNotavailable = "transfer.notavailable"
        case transferDnd = "transfer.dnd"
        case transportFailure = "transport.failure"
        case error = "error"
        case peer = "peer"
        case other = "other"
        case spam = "spam"
        case uncallable = "uncallable"
    }



    public enum Direction: String, Codable { 
        case outbound = "outbound"
        case inbound = "inbound"
    }







































    /** A globally unique identifier for this communication. */
    public var _id: String?
    public var state: State?
    public var initialState: InitialState?
    /** True if this call is being recorded. */
    public var recording: Bool?
    /** State of recording on this call. */
    public var recordingState: RecordingState?
    public var recordersState: QueueConversationSocialExpressionEventTopicRecordersState?
    /** True if this call is muted so that remote participants can't hear any audio from this end. */
    public var muted: Bool?
    /** True if this call is held and the person on this side hears hold music. */
    public var confined: Bool?
    /** True if this call is held and the person on this side hears silence. */
    public var held: Bool?
    /** True when the recording of this call is in secure pause status. */
    public var securePause: Bool?
    public var errorInfo: QueueConversationSocialExpressionEventTopicErrorDetails?
    /** System defined string indicating what caused the communication to disconnect. Will be null until the communication disconnects. */
    public var disconnectType: DisconnectType?
    /** The timestamp the call was placed on hold in the cloud clock if the call is currently on hold. */
    public var startHoldTime: Date?
    /** Whether a call is inbound or outbound. */
    public var direction: Direction?
    /** If call is a fax of a document in content management, the id of the document in content management. */
    public var documentId: String?
    public var _self: QueueConversationSocialExpressionEventTopicAddress?
    /** Address and name data for a call endpoint. */
    public var other: QueueConversationSocialExpressionEventTopicAddress?
    /** The source provider of the call. */
    public var provider: String?
    /** The UUID of the script to use. */
    public var scriptId: String?
    /** The id of the peer communication corresponding to a matching leg for this communication. */
    public var peerId: String?
    /** The timestamp when this communication was connected in the cloud clock. */
    public var connectedTime: Date?
    /** The timestamp when this communication disconnected from the conversation in the provider clock. */
    public var disconnectedTime: Date?
    /** List of reasons that this call was disconnected. This will be set once the call disconnects. */
    public var disconnectReasons: [QueueConversationSocialExpressionEventTopicDisconnectReason]?
    public var faxStatus: QueueConversationSocialExpressionEventTopicFaxStatus?
    /** User to User Information (UUI) data managed by SIP session application. */
    public var uuiData: String?
    /** The timestamp when this participant was connected to the barge conference in the provider clock. */
    public var bargedTime: Date?
    /** Call wrap up or disposition data. */
    public var wrapup: QueueConversationSocialExpressionEventTopicWrapup?
    public var afterCallWork: QueueConversationSocialExpressionEventTopicAfterCallWork?
    /** Indicates if after-call is required for a communication. Only used when the ACW Setting is Agent Requested. */
    public var afterCallWorkRequired: Bool?
    /** UUID of virtual agent assistant that provide suggestions to the agent participant during the conversation. */
    public var agentAssistantId: String?
    public var queueMediaSettings: QueueConversationSocialExpressionEventTopicQueueMediaSettings?
    public var disposition: QueueConversationSocialExpressionEventTopicDisposition?
    /** Indicates how call reaches the agent. */
    public var transferSource: String?

    public init(_id: String?, state: State?, initialState: InitialState?, recording: Bool?, recordingState: RecordingState?, recordersState: QueueConversationSocialExpressionEventTopicRecordersState?, muted: Bool?, confined: Bool?, held: Bool?, securePause: Bool?, errorInfo: QueueConversationSocialExpressionEventTopicErrorDetails?, disconnectType: DisconnectType?, startHoldTime: Date?, direction: Direction?, documentId: String?, _self: QueueConversationSocialExpressionEventTopicAddress?, other: QueueConversationSocialExpressionEventTopicAddress?, provider: String?, scriptId: String?, peerId: String?, connectedTime: Date?, disconnectedTime: Date?, disconnectReasons: [QueueConversationSocialExpressionEventTopicDisconnectReason]?, faxStatus: QueueConversationSocialExpressionEventTopicFaxStatus?, uuiData: String?, bargedTime: Date?, wrapup: QueueConversationSocialExpressionEventTopicWrapup?, afterCallWork: QueueConversationSocialExpressionEventTopicAfterCallWork?, afterCallWorkRequired: Bool?, agentAssistantId: String?, queueMediaSettings: QueueConversationSocialExpressionEventTopicQueueMediaSettings?, disposition: QueueConversationSocialExpressionEventTopicDisposition?, transferSource: String?) {
        self._id = _id
        self.state = state
        self.initialState = initialState
        self.recording = recording
        self.recordingState = recordingState
        self.recordersState = recordersState
        self.muted = muted
        self.confined = confined
        self.held = held
        self.securePause = securePause
        self.errorInfo = errorInfo
        self.disconnectType = disconnectType
        self.startHoldTime = startHoldTime
        self.direction = direction
        self.documentId = documentId
        self._self = _self
        self.other = other
        self.provider = provider
        self.scriptId = scriptId
        self.peerId = peerId
        self.connectedTime = connectedTime
        self.disconnectedTime = disconnectedTime
        self.disconnectReasons = disconnectReasons
        self.faxStatus = faxStatus
        self.uuiData = uuiData
        self.bargedTime = bargedTime
        self.wrapup = wrapup
        self.afterCallWork = afterCallWork
        self.afterCallWorkRequired = afterCallWorkRequired
        self.agentAssistantId = agentAssistantId
        self.queueMediaSettings = queueMediaSettings
        self.disposition = disposition
        self.transferSource = transferSource
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case state
        case initialState
        case recording
        case recordingState
        case recordersState
        case muted
        case confined
        case held
        case securePause
        case errorInfo
        case disconnectType
        case startHoldTime
        case direction
        case documentId
        case _self = "self"
        case other
        case provider
        case scriptId
        case peerId
        case connectedTime
        case disconnectedTime
        case disconnectReasons
        case faxStatus
        case uuiData
        case bargedTime
        case wrapup
        case afterCallWork
        case afterCallWorkRequired
        case agentAssistantId
        case queueMediaSettings
        case disposition
        case transferSource
    }


}




public class QueueConversationSocialExpressionEventTopicConversation: Codable {



























    public var _id: String?
    public var maxParticipants: Int64?
    public var participants: [QueueConversationSocialExpressionEventTopicParticipant]?
    public var recentTransfers: [QueueConversationSocialExpressionEventTopicTransferResponse]?
    public var recordingState: String?
    public var address: String?
    public var externalTag: String?
    public var utilizationLabelId: String?
    public var securePause: Bool?
    public var inactivityTimeout: Date?
    public var associatedConversation: QueueConversationSocialExpressionEventTopicDomainEntityRef?
    public var consultationConversations: [QueueConversationSocialExpressionEventTopicDomainEntityRef]?
    public var divisions: [QueueConversationSocialExpressionEventTopicConversationDivisionMembership]?

    public init(_id: String?, maxParticipants: Int64?, participants: [QueueConversationSocialExpressionEventTopicParticipant]?, recentTransfers: [QueueConversationSocialExpressionEventTopicTransferResponse]?, recordingState: String?, address: String?, externalTag: String?, utilizationLabelId: String?, securePause: Bool?, inactivityTimeout: Date?, associatedConversation: QueueConversationSocialExpressionEventTopicDomainEntityRef?, consultationConversations: [QueueConversationSocialExpressionEventTopicDomainEntityRef]?, divisions: [QueueConversationSocialExpressionEventTopicConversationDivisionMembership]?) {
        self._id = _id
        self.maxParticipants = maxParticipants
        self.participants = participants
        self.recentTransfers = recentTransfers
        self.recordingState = recordingState
        self.address = address
        self.externalTag = externalTag
        self.utilizationLabelId = utilizationLabelId
        self.securePause = securePause
        self.inactivityTimeout = inactivityTimeout
        self.associatedConversation = associatedConversation
        self.consultationConversations = consultationConversations
        self.divisions = divisions
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case maxParticipants
        case participants
        case recentTransfers
        case recordingState
        case address
        case externalTag
        case utilizationLabelId
        case securePause
        case inactivityTimeout
        case associatedConversation
        case consultationConversations
        case divisions
    }


}




public class QueueConversationSocialExpressionEventTopicDisconnectReason: Codable {

    public enum ModelType: String, Codable { 
        case q850 = "q850"
        case sip = "sip"
    }





    /** Disconnect reason protocol type. */
    public var type: ModelType?
    /** Protocol specific reason code. See the Q.850 and SIP specs. */
    public var code: Int64?
    /** Human readable English description of the disconnect reason. */
    public var phrase: String?

    public init(type: ModelType?, code: Int64?, phrase: String?) {
        self.type = type
        self.code = code
        self.phrase = phrase
    }


}



/** Answering Machine Detection timeout configuration. */

public class QueueConversationSocialExpressionEventTopicDispositionAmdTimeout: Codable {









    /** Configured AMD timeout value. */
    public var timeoutMs: Int64?
    /** Configured option for when to start the AMD timer, such as on line connect or speech start. */
    public var timerStartEvent: String?
    /** Timer start time, measured in epoch milliseconds. */
    public var timerStartTime: Double?
    /** Timer end time, measured in epoch milliseconds. */
    public var timerEndTime: Double?

    public init(timeoutMs: Int64?, timerStartEvent: String?, timerStartTime: Double?, timerEndTime: Double?) {
        self.timeoutMs = timeoutMs
        self.timerStartEvent = timerStartEvent
        self.timerStartTime = timerStartTime
        self.timerEndTime = timerEndTime
    }


}



/** Details about the action map from the Journey System which triggered this action */

public class QueueConversationSocialExpressionEventTopicJourneyActionMap: Codable {





    /** The ID of the actionMap in the Journey System which triggered this action */
    public var _id: String?
    /** The version number of the actionMap in the Journey System at the time this action was triggered */
    public var version: Int64?

    public init(_id: String?, version: Int64?) {
        self._id = _id
        self.version = version
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case version
    }


}



/** Metadata information about a message. */

public class QueueConversationSocialExpressionEventTopicMessageMetadata: Codable {







    /** Message type. */
    public var type: String?
    /** List of message events, if any */
    public var events: [QueueConversationSocialExpressionEventTopicMessageMetadataEvent]?
    /** List of message content, if any */
    public var content: [QueueConversationSocialExpressionEventTopicMessageMetadataContent]?

    public init(type: String?, events: [QueueConversationSocialExpressionEventTopicMessageMetadataEvent]?, content: [QueueConversationSocialExpressionEventTopicMessageMetadataContent]?) {
        self.type = type
        self.events = events
        self.content = content
    }


}




public class QueueConversationSocialExpressionEventTopicPhoneNumberColumn: Codable {





    public var columnName: String?
    public var type: String?

    public init(columnName: String?, type: String?) {
        self.columnName = columnName
        self.type = type
    }


}



/** Contains the states of different recorders. */

public class QueueConversationSocialExpressionEventTopicRecordersState: Codable {









    /** Indicates the state of the adhoc recorder. */
    public var adhocState: String?
    /** Indicates the state of the customer experience recorder. */
    public var customerExperienceState: String?
    /** Indicates the state of the agent experience recorder. */
    public var agentExperienceState: String?
    /** State of the snippet recording for this session. Note that snippets may never be paused. Valid values are in Constants.java with a prefix of RECORDER_STATE_*. */
    public var snippetState: String?

    public init(adhocState: String?, customerExperienceState: String?, agentExperienceState: String?, snippetState: String?) {
        self.adhocState = adhocState
        self.customerExperienceState = customerExperienceState
        self.agentExperienceState = agentExperienceState
        self.snippetState = snippetState
    }


}




public class QueueConversationSocialExpressionEventTopicSocialExpression: Codable {

    public enum State: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case _none = "none"
    }

    public enum InitialState: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case _none = "none"
    }





















    public enum DisconnectType: String, Codable { 
        case endpoint = "endpoint"
        case endpointDnd = "endpoint.dnd"
        case client = "client"
        case system = "system"
        case timeout = "timeout"
        case transfer = "transfer"
        case transferConference = "transfer.conference"
        case transferConsult = "transfer.consult"
        case transferForward = "transfer.forward"
        case transferNoanswer = "transfer.noanswer"
        case transferNotavailable = "transfer.notavailable"
        case transferDnd = "transfer.dnd"
        case transportFailure = "transport.failure"
        case error = "error"
        case peer = "peer"
        case other = "other"
        case spam = "spam"
        case uncallable = "uncallable"
    }













    public var state: State?
    public var initialState: InitialState?
    /** A globally unique identifier for this communication. */
    public var _id: String?
    /** A globally unique identifier for the social media. */
    public var socialMediaId: String?
    /** The social network of the communication */
    public var socialMediaHub: String?
    /** The social media user name of the communication */
    public var socialUserName: String?
    /** The text preview of the communication contents */
    public var previewText: String?
    /** A globally unique identifier for the recording associated with this chat. */
    public var recordingId: String?
    /** True if this call is held and the person on this side hears silence. */
    public var held: Bool?
    /** The source provider of the social expression. */
    public var provider: String?
    /** The UUID of the script to use. */
    public var scriptId: String?
    /** The id of the peer communication corresponding to a matching leg for this communication. */
    public var peerId: String?
    /** System defined string indicating what caused the communication to disconnect. Will be null until the communication disconnects. */
    public var disconnectType: DisconnectType?
    /** The timestamp the chat was placed on hold in the cloud clock if the chat is currently on hold. */
    public var startHoldTime: Date?
    /** The timestamp when this communication was connected in the cloud clock. */
    public var connectedTime: Date?
    /** The timestamp when this communication disconnected from the conversation in the provider clock. */
    public var disconnectedTime: Date?
    /** Call wrap up or disposition data. */
    public var wrapup: QueueConversationSocialExpressionEventTopicWrapup?
    /** A communication's after-call work data. */
    public var afterCallWork: QueueConversationSocialExpressionEventTopicAfterCallWork?
    /** Indicates if after-call is required for a communication. Only used when the ACW Setting is Agent Requested. */
    public var afterCallWorkRequired: Bool?

    public init(state: State?, initialState: InitialState?, _id: String?, socialMediaId: String?, socialMediaHub: String?, socialUserName: String?, previewText: String?, recordingId: String?, held: Bool?, provider: String?, scriptId: String?, peerId: String?, disconnectType: DisconnectType?, startHoldTime: Date?, connectedTime: Date?, disconnectedTime: Date?, wrapup: QueueConversationSocialExpressionEventTopicWrapup?, afterCallWork: QueueConversationSocialExpressionEventTopicAfterCallWork?, afterCallWorkRequired: Bool?) {
        self.state = state
        self.initialState = initialState
        self._id = _id
        self.socialMediaId = socialMediaId
        self.socialMediaHub = socialMediaHub
        self.socialUserName = socialUserName
        self.previewText = previewText
        self.recordingId = recordingId
        self.held = held
        self.provider = provider
        self.scriptId = scriptId
        self.peerId = peerId
        self.disconnectType = disconnectType
        self.startHoldTime = startHoldTime
        self.connectedTime = connectedTime
        self.disconnectedTime = disconnectedTime
        self.wrapup = wrapup
        self.afterCallWork = afterCallWork
        self.afterCallWorkRequired = afterCallWorkRequired
    }

    public enum CodingKeys: String, CodingKey { 
        case state
        case initialState
        case _id = "id"
        case socialMediaId
        case socialMediaHub
        case socialUserName
        case previewText
        case recordingId
        case held
        case provider
        case scriptId
        case peerId
        case disconnectType
        case startHoldTime
        case connectedTime
        case disconnectedTime
        case wrapup
        case afterCallWork
        case afterCallWorkRequired
    }


}



/** Fields identifying the entity that updated the command. */

public class QueueConversationSocialExpressionEventTopicTransferModifedBy: Codable {





    /** The id of the user if the updater is an internal user. */
    public var _id: String?
    /** The URI for the user if the updater is an internal user. */
    public var selfUri: String?

    public init(_id: String?, selfUri: String?) {
        self._id = _id
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
    }


}



/** A UriReference for a resource */

public class QueueConversationSocialExpressionEventTopicUriReference: Codable {





    /** The ID of the resource */
    public var _id: String?
    /** The name of the resource */
    public var name: String?

    public init(_id: String?, name: String?) {
        self._id = _id
        self.name = name
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
    }


}



/** A communication's after-call work data. */

public class QueueConversationVideoEventTopicAfterCallWork: Codable {

    public enum State: String, Codable { 
        case unknown = "unknown"
        case skipped = "skipped"
        case pending = "pending"
        case complete = "complete"
        case notapplicable = "notApplicable"
    }





    /** The communication's after-call work state. */
    public var state: State?
    /** The timestamp when this communication started after-call work in the cloud clock. */
    public var startTime: Date?
    /** The timestamp when this communication ended after-call work in the cloud clock. */
    public var endTime: Date?

    public init(state: State?, startTime: Date?, endTime: Date?) {
        self.state = state
        self.startTime = startTime
        self.endTime = endTime
    }


}



/** Information on how a communication should be routed to an agent. */

public class QueueConversationVideoEventTopicConversationRoutingData: Codable {











    public var queue: QueueConversationVideoEventTopicUriReference?
    /** A UriReference for a resource */
    public var language: QueueConversationVideoEventTopicUriReference?
    /** The priority of the conversation to use for routing decisions */
    public var priority: Int64?
    /** The skills to use for routing decisions */
    public var skills: [QueueConversationVideoEventTopicUriReference]?
    /** A collection of agents and their assigned scores for this conversation (0 - 100, higher being better), for use in routing to preferred agents */
    public var scoredAgents: [QueueConversationVideoEventTopicScoredAgent]?

    public init(queue: QueueConversationVideoEventTopicUriReference?, language: QueueConversationVideoEventTopicUriReference?, priority: Int64?, skills: [QueueConversationVideoEventTopicUriReference]?, scoredAgents: [QueueConversationVideoEventTopicScoredAgent]?) {
        self.queue = queue
        self.language = language
        self.priority = priority
        self.skills = skills
        self.scoredAgents = scoredAgents
    }


}




public class QueueConversationVideoEventTopicDomainEntityRef: Codable {





    public var _id: String?
    public var selfUri: String?

    public init(_id: String?, selfUri: String?) {
        self._id = _id
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
    }


}



/** Detailed information about an error response. */

public class QueueConversationVideoEventTopicErrorDetails: Codable {















    /** The HTTP status code for this message (400, 401, 403, 404, 500, etc. */
    public var status: Int64?
    /** A code unique to this error. */
    public var code: String?
    /** Friendly description of this error. */
    public var message: String?
    /** This is the same as message except it uses template fields for variable replacement. For instance: 'User {username} was not found' */
    public var messageWithParams: String?
    /** Used in conjunction with messageWithParams. These are the template parameters. For instance: UserParam.key = 'username', UserParam.value = 'john.doe' */
    public var messageParams: [String:String]?
    /** The correlation Id or context Id for this message. If left blank the Public API will look at the HTTP response header 'ININ-Correlation-Id' instead. */
    public var contextId: String?
    public var uri: String?

    public init(status: Int64?, code: String?, message: String?, messageWithParams: String?, messageParams: [String:String]?, contextId: String?, uri: String?) {
        self.status = status
        self.code = code
        self.message = message
        self.messageWithParams = messageWithParams
        self.messageParams = messageParams
        self.contextId = contextId
        self.uri = uri
    }


}




public class QueueConversationVideoEventTopicScreenShare: Codable {

    public enum State: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case _none = "none"
    }

    public enum InitialState: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case _none = "none"
    }

















    public enum DisconnectType: String, Codable { 
        case endpoint = "endpoint"
        case endpointDnd = "endpoint.dnd"
        case client = "client"
        case system = "system"
        case timeout = "timeout"
        case transfer = "transfer"
        case transferConference = "transfer.conference"
        case transferConsult = "transfer.consult"
        case transferForward = "transfer.forward"
        case transferNoanswer = "transfer.noanswer"
        case transferNotavailable = "transfer.notavailable"
        case transferDnd = "transfer.dnd"
        case transportFailure = "transport.failure"
        case error = "error"
        case peer = "peer"
        case other = "other"
        case spam = "spam"
        case uncallable = "uncallable"
    }













    public var state: State?
    public var initialState: InitialState?
    /** Address and name data for a call endpoint. */
    public var _self: QueueConversationVideoEventTopicAddress?
    /** A globally unique identifier for this communication. */
    public var _id: String?
    /** The room id context (xmpp jid) for the conference session. */
    public var context: String?
    /** Indicates whether this participant is sharing their screen to the session. */
    public var sharing: Bool?
    /** The source provider of the screen share. */
    public var provider: String?
    /** The UUID of the script to use. */
    public var scriptId: String?
    /** The id of the peer communication corresponding to a matching leg for this communication. */
    public var peerId: String?
    /** The number of peer participants from the perspective of the participant in the conference. */
    public var peerCount: Int64?
    /** System defined string indicating what caused the communication to disconnect. Will be null until the communication disconnects. */
    public var disconnectType: DisconnectType?
    /** The timestamp when this communication was connected in the cloud clock. */
    public var connectedTime: Date?
    /** The timestamp when this communication disconnected from the conversation in the provider clock. */
    public var disconnectedTime: Date?
    /** Call wrap up or disposition data. */
    public var wrapup: QueueConversationVideoEventTopicWrapup?
    /** A communication's after-call work data. */
    public var afterCallWork: QueueConversationVideoEventTopicAfterCallWork?
    /** Indicates if after-call is required for a communication. Only used when the ACW Setting is Agent Requested. */
    public var afterCallWorkRequired: Bool?
    /** Represents the queue setting for this media. */
    public var queueMediaSettings: QueueConversationVideoEventTopicQueueMediaSettings?

    public init(state: State?, initialState: InitialState?, _self: QueueConversationVideoEventTopicAddress?, _id: String?, context: String?, sharing: Bool?, provider: String?, scriptId: String?, peerId: String?, peerCount: Int64?, disconnectType: DisconnectType?, connectedTime: Date?, disconnectedTime: Date?, wrapup: QueueConversationVideoEventTopicWrapup?, afterCallWork: QueueConversationVideoEventTopicAfterCallWork?, afterCallWorkRequired: Bool?, queueMediaSettings: QueueConversationVideoEventTopicQueueMediaSettings?) {
        self.state = state
        self.initialState = initialState
        self._self = _self
        self._id = _id
        self.context = context
        self.sharing = sharing
        self.provider = provider
        self.scriptId = scriptId
        self.peerId = peerId
        self.peerCount = peerCount
        self.disconnectType = disconnectType
        self.connectedTime = connectedTime
        self.disconnectedTime = disconnectedTime
        self.wrapup = wrapup
        self.afterCallWork = afterCallWork
        self.afterCallWorkRequired = afterCallWorkRequired
        self.queueMediaSettings = queueMediaSettings
    }

    public enum CodingKeys: String, CodingKey { 
        case state
        case initialState
        case _self = "self"
        case _id = "id"
        case context
        case sharing
        case provider
        case scriptId
        case peerId
        case peerCount
        case disconnectType
        case connectedTime
        case disconnectedTime
        case wrapup
        case afterCallWork
        case afterCallWorkRequired
        case queueMediaSettings
    }


}




public class QueueObservationQueryResponse: Codable {





    /** A mapping from system presence to a list of organization presence ids */
    public var systemToOrganizationMappings: [String:[String]]?
    public var results: [QueueObservationDataContainer]?

    public init(systemToOrganizationMappings: [String:[String]]?, results: [QueueObservationDataContainer]?) {
        self.systemToOrganizationMappings = systemToOrganizationMappings
        self.results = results
    }


}




public class QueueRequest: Codable {

































    public enum ScoringMethod: String, Codable { 
        case timestampAndPriority = "TimestampAndPriority"
        case priorityOnly = "PriorityOnly"
    }

    public enum LastAgentRoutingMode: String, Codable { 
        case disabled = "Disabled"
        case queueMembersOnly = "QueueMembersOnly"
        case anyAgent = "AnyAgent"
    }



    public enum SkillEvaluationMethod: String, Codable { 
        case _none = "NONE"
        case best = "BEST"
        case all = "ALL"
    }











































    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The queue name */
    public var name: String?
    /** The division to which this entity belongs. */
    public var division: WritableDivision?
    /** The queue description. */
    public var _description: String?
    /** The date the queue was created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** The date of the last modification to the queue. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** The ID of the user that last modified the queue. */
    public var modifiedBy: String?
    /** The ID of the user that created the queue. */
    public var createdBy: String?
    /** The total number of members in the queue. */
    public var memberCount: Int?
    /** The number of user members (i.e., non-group members) in the queue. */
    public var userMemberCount: Int?
    /** The number of joined members in the queue. */
    public var joinedMemberCount: Int?
    /** The media settings for the queue. */
    public var mediaSettings: QueueMediaSettings?
    /** The routing rules for the queue, used for Preferred Agent Routing. */
    public var routingRules: [RoutingRule]?
    /** The Conditional Group Routing settings for the queue. */
    public var conditionalGroupRouting: ConditionalGroupRouting?
    /** The Conditional Group Activation settings for the queue. */
    public var conditionalGroupActivation: ConditionalGroupActivation?
    /** The bullseye settings for the queue. */
    public var bullseye: Bullseye?
    /** The Scoring Method for the queue. */
    public var scoringMethod: ScoringMethod?
    /** The Last Agent Routing Mode for the queue. */
    public var lastAgentRoutingMode: LastAgentRoutingMode?
    /** The ACW settings for the queue. */
    public var acwSettings: AcwSettings?
    /** The skill evaluation method to use when routing conversations. */
    public var skillEvaluationMethod: SkillEvaluationMethod?
    /** The groups of agents associated with the queue, if any.  Queue membership will update to match group membership changes. */
    public var memberGroups: [MemberGroup]?
    /** The in-queue flow to use for call conversations waiting in queue. */
    public var queueFlow: DomainEntityRef?
    /** The in-queue flow to use for email conversations waiting in queue. */
    public var emailInQueueFlow: DomainEntityRef?
    /** The in-queue flow to use for message conversations waiting in queue. */
    public var messageInQueueFlow: DomainEntityRef?
    /** The prompt used for whisper on the queue, if configured. */
    public var whisperPrompt: DomainEntityRef?
    /** The audio to be played when calls on this queue are on hold. If not configured, the default on-hold music will play. */
    public var onHoldPrompt: DomainEntityRef?
    /** Specifies whether the configured whisper should play for all ACD calls, or only for those which are auto-answered. */
    public var autoAnswerOnly: Bool?
    /** Canned response library IDs and mode with which they are associated with the queue */
    public var cannedResponseLibraries: CannedResponseLibraries?
    /** Indicates whether voice transcription is enabled for this queue. */
    public var enableTranscription: Bool?
    /** Indicates whether audio monitoring is enabled for this queue. */
    public var enableAudioMonitoring: Bool?
    /** Indicates whether manual assignment is enabled for this queue. */
    public var enableManualAssignment: Bool?
    /** The Agent Owned Routing settings for the queue */
    public var agentOwnedRouting: AgentOwnedRouting?
    /** The Direct Routing settings for the queue */
    public var directRouting: DirectRouting?
    /** The name to use for caller identification for outbound calls from this queue. */
    public var callingPartyName: String?
    /** The phone number to use for caller identification for outbound calls from this queue. */
    public var callingPartyNumber: String?
    /** The default script Ids for the communication types. */
    public var defaultScripts: [String:Script]?
    /** The messaging addresses for the queue. */
    public var outboundMessagingAddresses: QueueMessagingAddresses?
    /** The default email address to use for outbound email from this queue. */
    public var outboundEmailAddress: QueueEmailAddress?
    /** The ID of an associated external queue. */
    public var peerId: String?
    /** Indicates whether recording in-queue calls is suppressed for this queue. */
    public var suppressInQueueCallRecording: Bool?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, division: WritableDivision?, _description: String?, dateCreated: Date?, dateModified: Date?, modifiedBy: String?, createdBy: String?, memberCount: Int?, userMemberCount: Int?, joinedMemberCount: Int?, mediaSettings: QueueMediaSettings?, routingRules: [RoutingRule]?, conditionalGroupRouting: ConditionalGroupRouting?, conditionalGroupActivation: ConditionalGroupActivation?, bullseye: Bullseye?, scoringMethod: ScoringMethod?, lastAgentRoutingMode: LastAgentRoutingMode?, acwSettings: AcwSettings?, skillEvaluationMethod: SkillEvaluationMethod?, memberGroups: [MemberGroup]?, queueFlow: DomainEntityRef?, emailInQueueFlow: DomainEntityRef?, messageInQueueFlow: DomainEntityRef?, whisperPrompt: DomainEntityRef?, onHoldPrompt: DomainEntityRef?, autoAnswerOnly: Bool?, cannedResponseLibraries: CannedResponseLibraries?, enableTranscription: Bool?, enableAudioMonitoring: Bool?, enableManualAssignment: Bool?, agentOwnedRouting: AgentOwnedRouting?, directRouting: DirectRouting?, callingPartyName: String?, callingPartyNumber: String?, defaultScripts: [String:Script]?, outboundMessagingAddresses: QueueMessagingAddresses?, outboundEmailAddress: QueueEmailAddress?, peerId: String?, suppressInQueueCallRecording: Bool?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.division = division
        self._description = _description
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.modifiedBy = modifiedBy
        self.createdBy = createdBy
        self.memberCount = memberCount
        self.userMemberCount = userMemberCount
        self.joinedMemberCount = joinedMemberCount
        self.mediaSettings = mediaSettings
        self.routingRules = routingRules
        self.conditionalGroupRouting = conditionalGroupRouting
        self.conditionalGroupActivation = conditionalGroupActivation
        self.bullseye = bullseye
        self.scoringMethod = scoringMethod
        self.lastAgentRoutingMode = lastAgentRoutingMode
        self.acwSettings = acwSettings
        self.skillEvaluationMethod = skillEvaluationMethod
        self.memberGroups = memberGroups
        self.queueFlow = queueFlow
        self.emailInQueueFlow = emailInQueueFlow
        self.messageInQueueFlow = messageInQueueFlow
        self.whisperPrompt = whisperPrompt
        self.onHoldPrompt = onHoldPrompt
        self.autoAnswerOnly = autoAnswerOnly
        self.cannedResponseLibraries = cannedResponseLibraries
        self.enableTranscription = enableTranscription
        self.enableAudioMonitoring = enableAudioMonitoring
        self.enableManualAssignment = enableManualAssignment
        self.agentOwnedRouting = agentOwnedRouting
        self.directRouting = directRouting
        self.callingPartyName = callingPartyName
        self.callingPartyNumber = callingPartyNumber
        self.defaultScripts = defaultScripts
        self.outboundMessagingAddresses = outboundMessagingAddresses
        self.outboundEmailAddress = outboundEmailAddress
        self.peerId = peerId
        self.suppressInQueueCallRecording = suppressInQueueCallRecording
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case division
        case _description = "description"
        case dateCreated
        case dateModified
        case modifiedBy
        case createdBy
        case memberCount
        case userMemberCount
        case joinedMemberCount
        case mediaSettings
        case routingRules
        case conditionalGroupRouting
        case conditionalGroupActivation
        case bullseye
        case scoringMethod
        case lastAgentRoutingMode
        case acwSettings
        case skillEvaluationMethod
        case memberGroups
        case queueFlow
        case emailInQueueFlow
        case messageInQueueFlow
        case whisperPrompt
        case onHoldPrompt
        case autoAnswerOnly
        case cannedResponseLibraries
        case enableTranscription
        case enableAudioMonitoring
        case enableManualAssignment
        case agentOwnedRouting
        case directRouting
        case callingPartyName
        case callingPartyNumber
        case defaultScripts
        case outboundMessagingAddresses
        case outboundEmailAddress
        case peerId
        case suppressInQueueCallRecording
        case selfUri
    }


}




public class RateLimitAggregateQueryPredicate: Codable {

    public enum ModelType: String, Codable { 
        case dimension = "dimension"
        case property = "property"
        case metric = "metric"
    }

    public enum Dimension: String, Codable { 
        case correlationid = "correlationId"
        case entityid = "entityId"
        case limitname = "limitName"
        case max = "max"
        case namespace = "namespace"
        case timeunit = "timeUnit"
        case userid = "userId"
    }

    public enum Operator: String, Codable { 
        case matches = "matches"
        case exists = "exists"
        case notexists = "notExists"
    }





    /** Optional type, can usually be inferred */
    public var type: ModelType?
    /** Left hand side for dimension predicates */
    public var dimension: Dimension?
    /** Optional operator, default is matches */
    public var _operator: Operator?
    /** Right hand side for dimension predicates */
    public var value: String?
    /** Right hand side for dimension predicates */
    public var range: NumericRange?

    public init(type: ModelType?, dimension: Dimension?, _operator: Operator?, value: String?, range: NumericRange?) {
        self.type = type
        self.dimension = dimension
        self._operator = _operator
        self.value = value
        self.range = range
    }

    public enum CodingKeys: String, CodingKey { 
        case type
        case dimension
        case _operator = "operator"
        case value
        case range
    }


}




public class RealTimeAdherenceExplanation: Codable {







    public enum Status: String, Codable { 
        case pending = "Pending"
        case approved = "Approved"
        case denied = "Denied"
    }



    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The start timestamp of the adherence explanation in ISO-8601 format */
    public var startDate: Date?
    /** The length of the adherence explanation in minutes */
    public var lengthMinutes: Int?
    /** The status of the adherence explanation */
    public var status: Status?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, startDate: Date?, lengthMinutes: Int?, status: Status?, selfUri: String?) {
        self._id = _id
        self.startDate = startDate
        self.lengthMinutes = lengthMinutes
        self.status = status
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case startDate
        case lengthMinutes
        case status
        case selfUri
    }


}




public class RecognitionBase: Codable {









    public enum ModelType: String, Codable { 
        case thankYou = "ThankYou"
        case congratulations = "Congratulations"
        case highPerformance = "HighPerformance"
        case companyValues = "CompanyValues"
    }





    public enum ContextType: String, Codable { 
        case interaction = "Interaction"
        case insights = "Insights"
        case development = "Development"
        case scorecard = "Scorecard"
    }





    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The recipient of the recognition */
    public var recipient: UserReference?
    /** The creator of the recognition */
    public var createdBy: UserReference?
    /** The creation date. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** The type of recognition */
    public var type: ModelType?
    /** The recognition title */
    public var title: String?
    /** The recognition note */
    public var note: String?
    /** The context type (optional) */
    public var contextType: ContextType?
    /** The context id (optional) */
    public var contextId: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, recipient: UserReference?, createdBy: UserReference?, dateCreated: Date?, type: ModelType?, title: String?, note: String?, contextType: ContextType?, contextId: String?, selfUri: String?) {
        self._id = _id
        self.recipient = recipient
        self.createdBy = createdBy
        self.dateCreated = dateCreated
        self.type = type
        self.title = title
        self.note = note
        self.contextType = contextType
        self.contextId = contextId
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case recipient
        case createdBy
        case dateCreated
        case type
        case title
        case note
        case contextType
        case contextId
        case selfUri
    }


}




public class Record: Codable {







    /** The name of the record. */
    public var name: String?
    /** The type of the record. (Example values:  MX, TXT, CNAME) */
    public var type: String?
    /** The value of the record. */
    public var value: String?

    public init(name: String?, type: String?, value: String?) {
        self.name = name
        self.type = type
        self.value = value
    }


}




public class RecordingArchiveRestoreTopicRecording: Codable {













    public var _id: String?
    public var conversationId: String?
    public var fileState: String?
    public var mediaUris: [RecordingArchiveRestoreTopicMediaResult]?
    public var estimatedTranscodeTimeMs: Int64?
    public var actualTranscodeTimeMs: Int64?

    public init(_id: String?, conversationId: String?, fileState: String?, mediaUris: [RecordingArchiveRestoreTopicMediaResult]?, estimatedTranscodeTimeMs: Int64?, actualTranscodeTimeMs: Int64?) {
        self._id = _id
        self.conversationId = conversationId
        self.fileState = fileState
        self.mediaUris = mediaUris
        self.estimatedTranscodeTimeMs = estimatedTranscodeTimeMs
        self.actualTranscodeTimeMs = actualTranscodeTimeMs
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case conversationId
        case fileState
        case mediaUris
        case estimatedTranscodeTimeMs
        case actualTranscodeTimeMs
    }


}



/** User actions available on the content. All actions are optional and all actions are executed simultaneously. */

public class RecordingContentActions: Codable {







    /** A URL of a web page to direct the user to. */
    public var url: String?
    /** The target window in which to open the URL. If empty will open a blank page or tab. */
    public var urlTarget: String?
    /** Text to be sent back in reply when the item is selected. */
    public var textback: String?

    public init(url: String?, urlTarget: String?, textback: String?) {
        self.url = url
        self.urlTarget = urlTarget
        self.textback = textback
    }


}




public class RecordingEmailMessage: Codable {





















    public var htmlBody: String?
    public var textBody: String?
    public var _id: String?
    public var to: [EmailAddress]?
    public var cc: [EmailAddress]?
    public var bcc: [EmailAddress]?
    public var from: EmailAddress?
    public var subject: String?
    public var attachments: [EmailAttachment]?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var time: Date?

    public init(htmlBody: String?, textBody: String?, _id: String?, to: [EmailAddress]?, cc: [EmailAddress]?, bcc: [EmailAddress]?, from: EmailAddress?, subject: String?, attachments: [EmailAttachment]?, time: Date?) {
        self.htmlBody = htmlBody
        self.textBody = textBody
        self._id = _id
        self.to = to
        self.cc = cc
        self.bcc = bcc
        self.from = from
        self.subject = subject
        self.attachments = attachments
        self.time = time
    }

    public enum CodingKeys: String, CodingKey { 
        case htmlBody
        case textBody
        case _id = "id"
        case to
        case cc
        case bcc
        case from
        case subject
        case attachments
        case time
    }


}




public class RecordingFormPageComponent: Codable {

    public enum FormComponentType: String, Codable { 
        case listPicker = "ListPicker"
        case datePicker = "DatePicker"
        case wheelPicker = "WheelPicker"
        case input = "Input"
    }









    /** Type of this form component element. */
    public var formComponentType: FormComponentType?
    /** Date Picker content. */
    public var datePicker: DatePicker?
    /** Wheel Picker content. */
    public var wheelPicker: RecordingWheelPicker?
    /** List Picker content. */
    public var listPicker: ListPicker?
    /** Input content. */
    public var input: RecordingInput?

    public init(formComponentType: FormComponentType?, datePicker: DatePicker?, wheelPicker: RecordingWheelPicker?, listPicker: ListPicker?, input: RecordingInput?) {
        self.formComponentType = formComponentType
        self.datePicker = datePicker
        self.wheelPicker = wheelPicker
        self.listPicker = listPicker
        self.input = input
    }


}




public class RecordingFormResponseContent: Codable {

    public enum ContentType: String, Codable { 
        case buttonResponse = "ButtonResponse"
    }



    /** Type of this content element. */
    public var contentType: ContentType?
    /** Button response content. */
    public var buttonResponse: ButtonResponse?

    public init(contentType: ContentType?, buttonResponse: ButtonResponse?) {
        self.contentType = contentType
        self.buttonResponse = buttonResponse
    }


}




public class RecordingIntroduction: Codable {





    /** Text to show in the title. */
    public var title: String?
    /** Text to show in the subtitle. */
    public var subtitle: String?

    public init(title: String?, subtitle: String?) {
        self.title = title
        self.subtitle = subtitle
    }


}




public class RecordingJobsQuery: Codable {

    public enum Action: String, Codable { 
        case archive = "ARCHIVE"
        case delete = "DELETE"
        case export = "EXPORT"
    }





















    /** Operation to perform bulk task. If the operation will cause the delete date of a recording to be older than the export date, the export date will be adjusted to the delete date. */
    public var action: Action?
    /** The date when the action will be performed. If screenRecordingActionDate is also provided, this value is only used for non-screen recordings. Otherwise this value is used for all recordings. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var actionDate: Date?
    /** The number of days after each recording's creation date when the action will be performed. If screenRecordingActionAge is also provided, this value is only used for non-screen recordings. Otherwise this value is used for all recordings. */
    public var actionAge: Int?
    /** The date when the action will be performed for screen recordings. If this is provided then includeScreenRecordings must be true. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var screenRecordingActionDate: Date?
    /** The number of days after each screen recording's creation date when the action will be performed. If this is provided then includeScreenRecordings must be true. */
    public var screenRecordingActionAge: Int?
    /** IntegrationId to Access AWS S3 bucket for bulk recording exports. This field is required and used only for EXPORT action. */
    public var integrationId: String?
    /** Whether to include recordings with PCI DSS and/or PII data, default value = false  */
    public var includeRecordingsWithSensitiveData: Bool?
    /** Whether to include Screen recordings for the action, default value = true  */
    public var includeScreenRecordings: Bool?
    /** For DELETE action, setting this to true will clear any pending exports for recordings. This field is only used for DELETE action. Default value = false */
    public var clearExport: Bool?
    /** Conversation Query. Note: After the recording is created, it might take up to 48 hours for the recording to be included in the submitted job query.  This result depends on the analytics data lake job completion. See also: https://developer.genesys.cloud/analyticsdatamanagement/analytics/jobs/conversation-details-job#data-availability. */
    public var conversationQuery: AsyncConversationQuery?
    /** As an alternative to conversationQuery, specify the date and time range of conversations that are older than 5 years to query.Results will include all conversations that had activity during the interval. This is supported only when querying for conversations older than 5 years;conversationQuery must not be provided when this is provided. Intervals are represented as an ISO-8601 string. For example: YYYY-MM-DDThh:mm:ss/YYYY-MM-DDThh:mm:ss.Interval duration must not exceed 6 months. Intervals are represented as an ISO-8601 string. For example: YYYY-MM-DDThh:mm:ss/YYYY-MM-DDThh:mm:ss */
    public var agedConversationInterval: String?

    public init(action: Action?, actionDate: Date?, actionAge: Int?, screenRecordingActionDate: Date?, screenRecordingActionAge: Int?, integrationId: String?, includeRecordingsWithSensitiveData: Bool?, includeScreenRecordings: Bool?, clearExport: Bool?, conversationQuery: AsyncConversationQuery?, agedConversationInterval: String?) {
        self.action = action
        self.actionDate = actionDate
        self.actionAge = actionAge
        self.screenRecordingActionDate = screenRecordingActionDate
        self.screenRecordingActionAge = screenRecordingActionAge
        self.integrationId = integrationId
        self.includeRecordingsWithSensitiveData = includeRecordingsWithSensitiveData
        self.includeScreenRecordings = includeScreenRecordings
        self.clearExport = clearExport
        self.conversationQuery = conversationQuery
        self.agedConversationInterval = agedConversationInterval
    }


}




public class RecordingRetention: Codable {







    public enum ArchiveMedium: String, Codable { 
        case cloudarchive = "CLOUDARCHIVE"
    }









    public var conversationId: String?
    public var recordingId: String?
    /** The date the recording will be archived. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var archiveDate: Date?
    /** The type of archive medium used. Example: CloudArchive */
    public var archiveMedium: ArchiveMedium?
    /** The date the recording will be deleted. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var deleteDate: Date?
    /** The date the recording will be exported. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var exportDate: Date?
    /** The date the recording was exported. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var exportedDate: Date?
    /** The creation time of the recording. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var creationTime: Date?

    public init(conversationId: String?, recordingId: String?, archiveDate: Date?, archiveMedium: ArchiveMedium?, deleteDate: Date?, exportDate: Date?, exportedDate: Date?, creationTime: Date?) {
        self.conversationId = conversationId
        self.recordingId = recordingId
        self.archiveDate = archiveDate
        self.archiveMedium = archiveMedium
        self.deleteDate = deleteDate
        self.exportDate = exportDate
        self.exportedDate = exportedDate
        self.creationTime = creationTime
    }


}




public class RecordingRetentionCursorEntityListing: Codable {









    public var entities: [RecordingRetention]?
    public var nextUri: String?
    public var selfUri: String?
    public var previousUri: String?

    public init(entities: [RecordingRetention]?, nextUri: String?, selfUri: String?, previousUri: String?) {
        self.entities = entities
        self.nextUri = nextUri
        self.selfUri = selfUri
        self.previousUri = previousUri
    }


}




public class RecordingTranscodeCompleteTopicRecording: Codable {













    public var _id: String?
    public var conversationId: String?
    public var fileState: String?
    public var mediaUris: [RecordingTranscodeCompleteTopicMediaResult]?
    public var estimatedTranscodeTimeMs: Int64?
    public var actualTranscodeTimeMs: Int64?

    public init(_id: String?, conversationId: String?, fileState: String?, mediaUris: [RecordingTranscodeCompleteTopicMediaResult]?, estimatedTranscodeTimeMs: Int64?, actualTranscodeTimeMs: Int64?) {
        self._id = _id
        self.conversationId = conversationId
        self.fileState = fileState
        self.mediaUris = mediaUris
        self.estimatedTranscodeTimeMs = estimatedTranscodeTimeMs
        self.actualTranscodeTimeMs = actualTranscodeTimeMs
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case conversationId
        case fileState
        case mediaUris
        case estimatedTranscodeTimeMs
        case actualTranscodeTimeMs
    }


}




public class RecordingWheelPicker: Codable {





    /** Optional unique identifier to help map component replies to form messages where multiple Wheel Pickers can be present. */
    public var _id: String?
    /** An array of options in the Wheel Picker. */
    public var items: [RecordingWheelPickerItem]?

    public init(_id: String?, items: [RecordingWheelPickerItem]?) {
        self._id = _id
        self.items = items
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case items
    }


}




public class RecurrenceSettings: Codable {







    /** The recurrence period of the activity plan */
    public var recurrencePeriod: RecurrencePeriod?
    /** Constraint indicating the minimum time in hours between recurrences of the activity plan */
    public var minimumTimeBetweenOccurrences: RecurrencePeriod?
    /** Settings controlling when to end the recurrence for the activity plan */
    public var endAfter: RecurrenceEndSettings?

    public init(recurrencePeriod: RecurrencePeriod?, minimumTimeBetweenOccurrences: RecurrencePeriod?, endAfter: RecurrenceEndSettings?) {
        self.recurrencePeriod = recurrencePeriod
        self.minimumTimeBetweenOccurrences = minimumTimeBetweenOccurrences
        self.endAfter = endAfter
    }


}




public class ReplaceResponse: Codable {











    public enum UploadMethod: String, Codable { 
        case singlePut = "SINGLE_PUT"
        case multipartPost = "MULTIPART_POST"
    }

    public var _id: String?
    public var name: String?
    public var changeNumber: Int?
    public var uploadStatus: DomainEntityRef?
    public var uploadDestinationUri: String?
    public var uploadMethod: UploadMethod?

    public init(_id: String?, name: String?, changeNumber: Int?, uploadStatus: DomainEntityRef?, uploadDestinationUri: String?, uploadMethod: UploadMethod?) {
        self._id = _id
        self.name = name
        self.changeNumber = changeNumber
        self.uploadStatus = uploadStatus
        self.uploadDestinationUri = uploadDestinationUri
        self.uploadMethod = uploadMethod
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case changeNumber
        case uploadStatus
        case uploadDestinationUri
        case uploadMethod
    }


}




public class ReplyToEmailAddress: Codable {





    /** The InboundDomain used for the email address. */
    public var domain: DomainEntityRef?
    /** The InboundRoute used for the email address. */
    public var route: DomainEntityRef?

    public init(domain: DomainEntityRef?, route: DomainEntityRef?) {
        self.domain = domain
        self.route = route
    }


}




public class ReportingExportMetadataJobResponse: Codable {





    public enum ViewType: String, Codable { 
        case queuePerformanceSummaryView = "QUEUE_PERFORMANCE_SUMMARY_VIEW"
        case queuePerformanceDetailView = "QUEUE_PERFORMANCE_DETAIL_VIEW"
        case interactionSearchView = "INTERACTION_SEARCH_VIEW"
        case agentPerformanceSummaryView = "AGENT_PERFORMANCE_SUMMARY_VIEW"
        case agentPerformanceDetailView = "AGENT_PERFORMANCE_DETAIL_VIEW"
        case agentStatusSummaryView = "AGENT_STATUS_SUMMARY_VIEW"
        case agentStatusDetailView = "AGENT_STATUS_DETAIL_VIEW"
        case agentEvaluationSummaryView = "AGENT_EVALUATION_SUMMARY_VIEW"
        case agentEvaluationDetailView = "AGENT_EVALUATION_DETAIL_VIEW"
        case agentQueueDetailView = "AGENT_QUEUE_DETAIL_VIEW"
        case agentInteractionDetailView = "AGENT_INTERACTION_DETAIL_VIEW"
        case abandonInsightsView = "ABANDON_INSIGHTS_VIEW"
        case skillsPerformanceView = "SKILLS_PERFORMANCE_VIEW"
        case surveyFormPerformanceSummaryView = "SURVEY_FORM_PERFORMANCE_SUMMARY_VIEW"
        case surveyFormPerformanceDetailView = "SURVEY_FORM_PERFORMANCE_DETAIL_VIEW"
        case dnisPerformanceSummaryView = "DNIS_PERFORMANCE_SUMMARY_VIEW"
        case dnisPerformanceDetailView = "DNIS_PERFORMANCE_DETAIL_VIEW"
        case wrapUpPerformanceSummaryView = "WRAP_UP_PERFORMANCE_SUMMARY_VIEW"
        case agentWrapUpPerformanceDetailView = "AGENT_WRAP_UP_PERFORMANCE_DETAIL_VIEW"
        case queueActivitySummaryView = "QUEUE_ACTIVITY_SUMMARY_VIEW"
        case queueActivityDetailView = "QUEUE_ACTIVITY_DETAIL_VIEW"
        case agentQueueActivitySummaryView = "AGENT_QUEUE_ACTIVITY_SUMMARY_VIEW"
        case queueAgentDetailView = "QUEUE_AGENT_DETAIL_VIEW"
        case queueInteractionDetailView = "QUEUE_INTERACTION_DETAIL_VIEW"
        case agentScheduleDetailView = "AGENT_SCHEDULE_DETAIL_VIEW"
        case ivrPerformanceSummaryView = "IVR_PERFORMANCE_SUMMARY_VIEW"
        case ivrPerformanceDetailView = "IVR_PERFORMANCE_DETAIL_VIEW"
        case answerInsightsView = "ANSWER_INSIGHTS_VIEW"
        case handleInsightsView = "HANDLE_INSIGHTS_VIEW"
        case talkInsightsView = "TALK_INSIGHTS_VIEW"
        case holdInsightsView = "HOLD_INSIGHTS_VIEW"
        case acwInsightsView = "ACW_INSIGHTS_VIEW"
        case waitInsightsView = "WAIT_INSIGHTS_VIEW"
        case agentWrapUpPerformanceIntervalDetailView = "AGENT_WRAP_UP_PERFORMANCE_INTERVAL_DETAIL_VIEW"
        case flowOutcomeSummaryView = "FLOW_OUTCOME_SUMMARY_VIEW"
        case flowOutcomePerformanceDetailView = "FLOW_OUTCOME_PERFORMANCE_DETAIL_VIEW"
        case flowOutcomePerformanceIntervalDetailView = "FLOW_OUTCOME_PERFORMANCE_INTERVAL_DETAIL_VIEW"
        case flowDestinationSummaryView = "FLOW_DESTINATION_SUMMARY_VIEW"
        case flowDestinationDetailView = "FLOW_DESTINATION_DETAIL_VIEW"
        case apiUsageView = "API_USAGE_VIEW"
        case scheduledCallbacksView = "SCHEDULED_CALLBACKS_VIEW"
        case contentSearchView = "CONTENT_SEARCH_VIEW"
        case landingPage = "LANDING_PAGE"
        case dashboardSummary = "DASHBOARD_SUMMARY"
        case dashboardDetail = "DASHBOARD_DETAIL"
        case dashboardUsers = "DASHBOARD_USERS"
        case dashboardUsersDetail = "DASHBOARD_USERS_DETAIL"
        case journeyActionMapSummaryView = "JOURNEY_ACTION_MAP_SUMMARY_VIEW"
        case journeyOutcomeSummaryView = "JOURNEY_OUTCOME_SUMMARY_VIEW"
        case journeySegmentSummaryView = "JOURNEY_SEGMENT_SUMMARY_VIEW"
        case agentDevelopmentDetailView = "AGENT_DEVELOPMENT_DETAIL_VIEW"
        case agentDevelopmentDetailMeView = "AGENT_DEVELOPMENT_DETAIL_ME_VIEW"
        case agentDevelopmentSummaryView = "AGENT_DEVELOPMENT_SUMMARY_VIEW"
        case agentPerformanceMeView = "AGENT_PERFORMANCE_ME_VIEW"
        case agentStatusMeView = "AGENT_STATUS_ME_VIEW"
        case agentEvaluationMeView = "AGENT_EVALUATION_ME_VIEW"
        case agentScorecardView = "AGENT_SCORECARD_VIEW"
        case agentScorecardMeView = "AGENT_SCORECARD_ME_VIEW"
        case agentGamificationLeadershipView = "AGENT_GAMIFICATION_LEADERSHIP_VIEW"
        case agentScheduleMeView = "AGENT_SCHEDULE_ME_VIEW"
        case botPerformanceSummaryView = "BOT_PERFORMANCE_SUMMARY_VIEW"
        case botPerformanceDetailView = "BOT_PERFORMANCE_DETAIL_VIEW"
        case scheduledExportsView = "SCHEDULED_EXPORTS_VIEW"
        case topicTrendSummaryView = "TOPIC_TREND_SUMMARY_VIEW"
        case topicTrendDetailView = "TOPIC_TREND_DETAIL_VIEW"
        case actionMapBlockedConstraintsDetailView = "ACTION_MAP_BLOCKED_CONSTRAINTS_DETAIL_VIEW"
        case actionMapBlockedConstraintsIntervalDetailView = "ACTION_MAP_BLOCKED_CONSTRAINTS_INTERVAL_DETAIL_VIEW"
        case flowMilestonePerformanceDetailView = "FLOW_MILESTONE_PERFORMANCE_DETAIL_VIEW"
        case flowMilestonePerformanceIntervalDetailView = "FLOW_MILESTONE_PERFORMANCE_INTERVAL_DETAIL_VIEW"
        case agentTopicSummaryView = "AGENT_TOPIC_SUMMARY_VIEW"
        case agentTopicDetailView = "AGENT_TOPIC_DETAIL_VIEW"
        case queueTopicSummaryView = "QUEUE_TOPIC_SUMMARY_VIEW"
        case queueTopicDetailView = "QUEUE_TOPIC_DETAIL_VIEW"
        case flowTopicSummaryView = "FLOW_TOPIC_SUMMARY_VIEW"
        case flowTopicDetailView = "FLOW_TOPIC_DETAIL_VIEW"
        case agentInteractionsMeView = "AGENT_INTERACTIONS_ME_VIEW"
        case alertRulesView = "ALERT_RULES_VIEW"
        case configureAlertRuleView = "CONFIGURE_ALERT_RULE_VIEW"
        case predictiveRoutingView = "PREDICTIVE_ROUTING_VIEW"
        case predictiveRoutingQueueOverview = "PREDICTIVE_ROUTING_QUEUE_OVERVIEW"
        case predictiveRoutingModelView = "PREDICTIVE_ROUTING_MODEL_VIEW"
        case predictiveRoutingImpactView = "PREDICTIVE_ROUTING_IMPACT_VIEW"
        case dataActionsPerformanceSummaryView = "DATA_ACTIONS_PERFORMANCE_SUMMARY_VIEW"
        case dataActionsPerformanceDetailView = "DATA_ACTIONS_PERFORMANCE_DETAIL_VIEW"
        case agentTimelineSummaryView = "AGENT_TIMELINE_SUMMARY_VIEW"
        case agentTimelineDetailView = "AGENT_TIMELINE_DETAIL_VIEW"
        case agentLoginLogoutSummaryView = "AGENT_LOGIN_LOGOUT_SUMMARY_VIEW"
        case agentLoginLogoutDetailView = "AGENT_LOGIN_LOGOUT_DETAIL_VIEW"
        case campaignPerformanceSummaryView = "CAMPAIGN_PERFORMANCE_SUMMARY_VIEW"
        case campaignPerformanceDetailView = "CAMPAIGN_PERFORMANCE_DETAIL_VIEW"
        case knowledgePerformanceView = "KNOWLEDGE_PERFORMANCE_VIEW"
        case agentScorecardInsightsSummaryView = "AGENT_SCORECARD_INSIGHTS_SUMMARY_VIEW"
        case agentScorecardInsightsDetailView = "AGENT_SCORECARD_INSIGHTS_DETAIL_VIEW"
        case queueWrapupDetailView = "QUEUE_WRAPUP_DETAIL_VIEW"
        case interactionDetailView = "INTERACTION_DETAIL_VIEW"
        case campaignInteractionDetailView = "CAMPAIGN_INTERACTION_DETAIL_VIEW"
        case campaignAttemptDetailView = "CAMPAIGN_ATTEMPT_DETAIL_VIEW"
        case workitemPerformanceSummaryView = "WORKITEM_PERFORMANCE_SUMMARY_VIEW"
        case agentAssistPerformanceView = "AGENT_ASSIST_PERFORMANCE_VIEW"
        case contactCenterPerformanceView = "CONTACT_CENTER_PERFORMANCE_VIEW"
        case queueRoutingPerformanceView = "QUEUE_ROUTING_PERFORMANCE_VIEW"
        case agentWorkitemPerformanceSummaryView = "AGENT_WORKITEM_PERFORMANCE_SUMMARY_VIEW"
        case agentWorkitemPerformanceDetailView = "AGENT_WORKITEM_PERFORMANCE_DETAIL_VIEW"
        case queueWorkitemPerformanceSummaryView = "QUEUE_WORKITEM_PERFORMANCE_SUMMARY_VIEW"
        case queueWorkitemPerformanceDetailView = "QUEUE_WORKITEM_PERFORMANCE_DETAIL_VIEW"
        case emailAgentPerformanceSummaryView = "EMAIL_AGENT_PERFORMANCE_SUMMARY_VIEW"
        case emailAgentPerformanceDetailView = "EMAIL_AGENT_PERFORMANCE_DETAIL_VIEW"
        case messagingAgentPerformanceSummaryView = "MESSAGING_AGENT_PERFORMANCE_SUMMARY_VIEW"
        case messagingAgentPerformanceDetailView = "MESSAGING_AGENT_PERFORMANCE_DETAIL_VIEW"
        case emailQueuePerformanceSummaryView = "EMAIL_QUEUE_PERFORMANCE_SUMMARY_VIEW"
        case emailQueuePerformanceDetailView = "EMAIL_QUEUE_PERFORMANCE_DETAIL_VIEW"
        case messagingQueuePerformanceSummaryView = "MESSAGING_QUEUE_PERFORMANCE_SUMMARY_VIEW"
        case messagingQueuePerformanceDetailView = "MESSAGING_QUEUE_PERFORMANCE_DETAIL_VIEW"
        case socialListeningView = "SOCIAL_LISTENING_VIEW"
        case socialListeningPostsView = "SOCIAL_LISTENING_POSTS_VIEW"
        case agentPerformanceTimelineDetailView = "AGENT_PERFORMANCE_TIMELINE_DETAIL_VIEW"
        case dashboardSlideshows = "DASHBOARD_SLIDESHOWS"
        case dashboardSlideshowsDetail = "DASHBOARD_SLIDESHOWS_DETAIL"
        case agentCopilotPerformanceView = "AGENT_COPILOT_PERFORMANCE_VIEW"
        case agentAssignedEvaluationMeView = "AGENT_ASSIGNED_EVALUATION_ME_VIEW"
        case virtualAgentPerformanceView = "VIRTUAL_AGENT_PERFORMANCE_VIEW"
        case contentExplorationView = "CONTENT_EXPLORATION_VIEW"
        case evaluationPerformanceSummaryView = "EVALUATION_PERFORMANCE_SUMMARY_VIEW"
        case evaluationPerformanceDetailView = "EVALUATION_PERFORMANCE_DETAIL_VIEW"
        case evaluationPerformanceQuestionGroupDetailView = "EVALUATION_PERFORMANCE_QUESTION_GROUP_DETAIL_VIEW"
        case evaluationPerformanceQuestionDetailView = "EVALUATION_PERFORMANCE_QUESTION_DETAIL_VIEW"
        case queueWorkitemActivitySummaryView = "QUEUE_WORKITEM_ACTIVITY_SUMMARY_VIEW"
        case queueWorkitemActivityDetailView = "QUEUE_WORKITEM_ACTIVITY_DETAIL_VIEW"
        case digitalAdoptionView = "DIGITAL_ADOPTION_VIEW"
        case digitalIntentView = "DIGITAL_INTENT_VIEW"
        case digitalPerformanceView = "DIGITAL_PERFORMANCE_VIEW"
        case copilotUsageView = "COPILOT_USAGE_VIEW"
        case predictiveRoutingThroughputView = "PREDICTIVE_ROUTING_THROUGHPUT_VIEW"
    }















    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** The view type of the export metadata */
    public var viewType: ViewType?
    /** The date limitations of the export metadata */
    public var dateLimitations: String?
    /** The list of required filters for the export metadata */
    public var requiredFilters: [String]?
    /** The list of supported filters for the export metadata */
    public var supportedFilters: [String]?
    /** The list of required column ids for the export metadata */
    public var requiredColumnIds: [String]?
    /** The list of dependent column ids for the export metadata */
    public var dependentColumnIds: [String:[String]]?
    /** The list of available column ids for the export metadata */
    public var availableColumnIds: [String]?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, viewType: ViewType?, dateLimitations: String?, requiredFilters: [String]?, supportedFilters: [String]?, requiredColumnIds: [String]?, dependentColumnIds: [String:[String]]?, availableColumnIds: [String]?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.viewType = viewType
        self.dateLimitations = dateLimitations
        self.requiredFilters = requiredFilters
        self.supportedFilters = supportedFilters
        self.requiredColumnIds = requiredColumnIds
        self.dependentColumnIds = dependentColumnIds
        self.availableColumnIds = availableColumnIds
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case viewType
        case dateLimitations
        case requiredFilters
        case supportedFilters
        case requiredColumnIds
        case dependentColumnIds
        case availableColumnIds
        case selfUri
    }


}




public class ReportingTurnKnowledge: Codable {







    /** The Knowledge Base ID that the captured knowledge data relates to. */
    public var knowledgeBaseId: String?
    /** The knowledge feedback data that was captured during this reporting turn. */
    public var feedback: ReportingTurnKnowledgeFeedback?
    /** The knowledge search data that was captured during this reporting turn. */
    public var search: ReportingTurnKnowledgeSearch?

    public init(knowledgeBaseId: String?, feedback: ReportingTurnKnowledgeFeedback?, search: ReportingTurnKnowledgeSearch?) {
        self.knowledgeBaseId = knowledgeBaseId
        self.feedback = feedback
        self.search = search
    }


}




public class RequestDevice: Codable {

    public enum Category: String, Codable { 
        case desktop = "desktop"
        case mobile = "mobile"
        case tablet = "tablet"
        case other = "other"
    }



















    /** Device category. */
    public var category: Category?
    /** Device type (e.g. iPad, iPhone, Other). */
    public var type: String?
    /** Flag that is true for mobile devices. */
    public var isMobile: Bool?
    /** Device's screen height. */
    public var screenHeight: Int?
    /** Device's screen width. */
    public var screenWidth: Int?
    /** Device's screen density, measured as a scale factor where a value of 1 represents a baseline 1:1 ratio of pixels to logical (device-independent) pixels. */
    public var screenDensity: Int?
    /** Fingerprint generated by looking at the individual device features. */
    public var fingerprint: String?
    /** Operating system family. */
    public var osFamily: String?
    /** Operating system version. */
    public var osVersion: String?
    /** Manufacturer of the device. */
    public var manufacturer: String?

    public init(category: Category?, type: String?, isMobile: Bool?, screenHeight: Int?, screenWidth: Int?, screenDensity: Int?, fingerprint: String?, osFamily: String?, osVersion: String?, manufacturer: String?) {
        self.category = category
        self.type = type
        self.isMobile = isMobile
        self.screenHeight = screenHeight
        self.screenWidth = screenWidth
        self.screenDensity = screenDensity
        self.fingerprint = fingerprint
        self.osFamily = osFamily
        self.osVersion = osVersion
        self.manufacturer = manufacturer
    }


}




public class RequestJourneyPattern: Codable {





    public enum StreamType: String, Codable { 
        case web = "Web"
        case custom = "Custom"
        case conversation = "Conversation"
        case app = "App"
    }





    /** A list of one or more criteria to satisfy. */
    public var criteria: [RequestCriteria]?
    /** The number of times the pattern must match. */
    public var count: Int?
    /** The stream type for which this pattern can be matched on. */
    public var streamType: StreamType?
    /** The session type for which this pattern can be matched on. */
    public var sessionType: String?
    /** The name of the event for which this pattern can be matched on. */
    public var eventName: String?

    public init(criteria: [RequestCriteria]?, count: Int?, streamType: StreamType?, sessionType: String?, eventName: String?) {
        self.criteria = criteria
        self.count = count
        self.streamType = streamType
        self.sessionType = sessionType
        self.eventName = eventName
    }


}




public class ResolutionAggregateQueryFilter: Codable {

    public enum ModelType: String, Codable { 
        case and = "and"
        case or = "or"
    }





    /** Boolean operation to apply to the provided predicates and clauses */
    public var type: ModelType?
    /** Boolean 'and/or' logic with up to two-levels of nesting */
    public var clauses: [ResolutionAggregateQueryClause]?
    /** Like a three-word sentence: (attribute-name) (operator) (target-value). */
    public var predicates: [ResolutionAggregateQueryPredicate]?

    public init(type: ModelType?, clauses: [ResolutionAggregateQueryClause]?, predicates: [ResolutionAggregateQueryPredicate]?) {
        self.type = type
        self.clauses = clauses
        self.predicates = predicates
    }


}




public class ResponseAssetSearchRequest: Codable {





    public enum SortOrder: String, Codable { 
        case asc = "ASC"
        case desc = "DESC"
    }





    /** The number of results per page. Default: 25, Maximum: 100. */
    public var pageSize: Int?
    /** The page of resources you want to retrieve */
    public var pageNumber: Int?
    /** The sort order for results */
    public var sortOrder: SortOrder?
    /** The field in the resource that you want to sort the results by */
    public var sortBy: String?
    /** Filter the query results. */
    public var query: [ResponseAssetFilter]?

    public init(pageSize: Int?, pageNumber: Int?, sortOrder: SortOrder?, sortBy: String?, query: [ResponseAssetFilter]?) {
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.sortOrder = sortOrder
        self.sortBy = sortBy
        self.query = query
    }


}




public class ResponseSet: Codable {

















    public enum LiveSpeakerDetectionMode: String, Codable { 
        case disabled = "Disabled"
        case low = "Low"
        case medium = "Medium"
        case high = "High"
    }



    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The name of the ResponseSet. */
    public var name: String?
    /** Creation time of the entity. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** Last modified time of the entity. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** Required for updates, must match the version number of the most recent update */
    public var version: Int?
    /** Map of disposition identifiers to reactions. For example: {\"disposition.classification.callable.person\": {\"reactionType\": \"transfer\"}}. */
    public var responses: [String:Reaction]?
    /** Whether to enable answering machine beep detection */
    public var beepDetectionEnabled: Bool?
    /** Whether to enable answering machine detection */
    public var amdSpeechDistinguishEnabled: Bool?
    /** Setting level of live speaker detection based on ringbacks */
    public var liveSpeakerDetectionMode: LiveSpeakerDetectionMode?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, dateCreated: Date?, dateModified: Date?, version: Int?, responses: [String:Reaction]?, beepDetectionEnabled: Bool?, amdSpeechDistinguishEnabled: Bool?, liveSpeakerDetectionMode: LiveSpeakerDetectionMode?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.version = version
        self.responses = responses
        self.beepDetectionEnabled = beepDetectionEnabled
        self.amdSpeechDistinguishEnabled = amdSpeechDistinguishEnabled
        self.liveSpeakerDetectionMode = liveSpeakerDetectionMode
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case dateCreated
        case dateModified
        case version
        case responses
        case beepDetectionEnabled
        case amdSpeechDistinguishEnabled
        case liveSpeakerDetectionMode
        case selfUri
    }


}




public class ReviewAssessmentResults: Codable {





    /** If true, learning assignment results can be seen in detail by assignees */
    public var byAssignees: Bool?
    /** If true, learning assignment results can be seen in detail by people who are eligible to view */
    public var byViewers: Bool?

    public init(byAssignees: Bool?, byViewers: Bool?) {
        self.byAssignees = byAssignees
        self.byViewers = byViewers
    }


}




public class RoleDivisionGrants: Codable {



    /** A list containing pairs of role and division IDs */
    public var grants: [RoleDivisionPair]?

    public init(grants: [RoleDivisionPair]?) {
        self.grants = grants
    }


}




public class RoutingActivityData: Codable {









    /** A mapping from grouping dimension to value */
    public var group: [String:String]?
    /** Data for metrics */
    public var data: [RoutingActivityMetricValue]?
    /** Flag for a truncated list of entities. If truncated, the first half of the list of entities will contain the oldest entities and the second half the newest entities. */
    public var truncated: Bool?
    /** Details for active entities */
    public var entities: [RoutingActivityEntityData]?

    public init(group: [String:String]?, data: [RoutingActivityMetricValue]?, truncated: Bool?, entities: [RoutingActivityEntityData]?) {
        self.group = group
        self.data = data
        self.truncated = truncated
        self.entities = entities
    }


}




public class RoutingActivityQueryFilter: Codable {

    public enum ModelType: String, Codable { 
        case and = "and"
        case or = "or"
    }





    /** Boolean operation to apply to the provided predicates and clauses */
    public var type: ModelType?
    /** Boolean 'and/or' logic with up to two-levels of nesting */
    public var clauses: [RoutingActivityQueryClause]?
    /** Like a three-word sentence: (attribute-name) (operator) (target-value). */
    public var predicates: [RoutingActivityQueryPredicate]?

    public init(type: ModelType?, clauses: [RoutingActivityQueryClause]?, predicates: [RoutingActivityQueryPredicate]?) {
        self.type = type
        self.clauses = clauses
        self.predicates = predicates
    }


}




public class RoutingConversationAttributesRequest: Codable {











    /** Priority for the conversation.  Each point of priority is equivalent to one minute of time in queue.  Range:[-25000000, 25000000].  To reset, specify 0. */
    public var priority: Int?
    /** Skill requirements for the conversation.  To remove all skill requirements, specify an empty list, i.e. []. */
    public var skillIds: [String]?
    /** Language requirement for the conversation.  To remove the language requirement, specify an empty string, i.e., \"\". */
    public var languageId: String?
    /** Label requirement for the conversation.  To remove the label requirement (setting it to System Default Label), specify an empty string, i.e., \"\". */
    public var labelId: String?
    public var requestScoredAgents: [RequestScoredAgent]?

    public init(priority: Int?, skillIds: [String]?, languageId: String?, labelId: String?, requestScoredAgents: [RequestScoredAgent]?) {
        self.priority = priority
        self.skillIds = skillIds
        self.languageId = languageId
        self.labelId = labelId
        self.requestScoredAgents = requestScoredAgents
    }


}




public class RoutingData: Codable {

















    /** The identifier of the routing queue */
    public var queueId: String?
    /** The identifier of a language to be considered in routing */
    public var languageId: String?
    /** An optional label that categorizes the conversation.  Max-utilization settings can be configured at a per-label level */
    public var label: String?
    /** The priority for routing */
    public var priority: Int?
    /** A list of skill identifiers to be considered in routing */
    public var skillIds: [String]?
    /** A list of agents to be preferred in routing */
    public var preferredAgentIds: [String]?
    /** A list of scored agents for routing decisions. For Agent Owned Callbacks use one scored agent with a score of 100. */
    public var scoredAgents: [ScoredAgent]?
    /** An array of flags indicating how the conversation should be routed. Use \"AGENT_OWNED_CALLBACK\" when creating an Agent Owned Callback. */
    public var routingFlags: [String]?

    public init(queueId: String?, languageId: String?, label: String?, priority: Int?, skillIds: [String]?, preferredAgentIds: [String]?, scoredAgents: [ScoredAgent]?, routingFlags: [String]?) {
        self.queueId = queueId
        self.languageId = languageId
        self.label = label
        self.priority = priority
        self.skillIds = skillIds
        self.preferredAgentIds = preferredAgentIds
        self.scoredAgents = scoredAgents
        self.routingFlags = routingFlags
    }


}




public class RoutingRule: Codable {

    public enum Operator: String, Codable { 
        case meetsThreshold = "MEETS_THRESHOLD"
        case any = "ANY"
    }





    /** matching operator.  MEETS_THRESHOLD matches any agent with a score at or above the rule's threshold.  ANY matches all specified agents, regardless of score. */
    public var _operator: Operator?
    /** threshold required for routing attempt (generally an agent score).  may be null for operator ANY. */
    public var threshold: Int?
    /** seconds to wait in this rule before moving to the next */
    public var waitSeconds: Double?

    public init(_operator: Operator?, threshold: Int?, waitSeconds: Double?) {
        self._operator = _operator
        self.threshold = threshold
        self.waitSeconds = waitSeconds
    }

    public enum CodingKeys: String, CodingKey { 
        case _operator = "operator"
        case threshold
        case waitSeconds
    }


}




public class RoutingStatusDetailQueryClause: Codable {

    public enum ModelType: String, Codable { 
        case and = "and"
        case or = "or"
    }



    /** Boolean operation to apply to the provided predicates */
    public var type: ModelType?
    /** Like a three-word sentence: (attribute-name) (operator) (target-value). */
    public var predicates: [RoutingStatusDetailQueryPredicate]?

    public init(type: ModelType?, predicates: [RoutingStatusDetailQueryPredicate]?) {
        self.type = type
        self.predicates = predicates
    }


}




public class RuleSetDiagnostic: Codable {



    public enum Warnings: String, Codable { 
        case wrapupCodeNotInQueue = "WRAPUP_CODE_NOT_IN_QUEUE"
        case contactAttributeNotInContactList = "CONTACT_ATTRIBUTE_NOT_IN_CONTACT_LIST"
        case noDncListForAppend = "NO_DNC_LIST_FOR_APPEND"
        case phoneConditionsWithMulticolumnPreview = "PHONE_CONDITIONS_WITH_MULTICOLUMN_PREVIEW"
    }

    /** A campaign rule set */
    public var ruleSet: DomainEntityRef?
    /** Diagnostic warnings for the rule set */
    public var warnings: [Warnings]?

    public init(ruleSet: DomainEntityRef?, warnings: [Warnings]?) {
        self.ruleSet = ruleSet
        self.warnings = warnings
    }


}




public class SchedulingTestingOptionsRequest: Codable {











    /** Whether to enable fast scheduling */
    public var fastScheduling: Bool?
    /** Whether to force delayed scheduling */
    public var delayScheduling: Bool?
    /** Whether to force scheduling to fail */
    public var failScheduling: Bool?
    /** Whether to populate warnings in the generated schedule */
    public var populateWarnings: Bool?
    /** Whether to populate deprecated warnings in the generated schedule */
    public var populateDeprecatedWarnings: Bool?

    public init(fastScheduling: Bool?, delayScheduling: Bool?, failScheduling: Bool?, populateWarnings: Bool?, populateDeprecatedWarnings: Bool?) {
        self.fastScheduling = fastScheduling
        self.delayScheduling = delayScheduling
        self.failScheduling = failScheduling
        self.populateWarnings = populateWarnings
        self.populateDeprecatedWarnings = populateDeprecatedWarnings
    }


}




public class SchemaQuantityLimits: Codable {





























    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** The minimum number of schema field name characters allowed. */
    public var minFieldNameCharacters: Int?
    /** The maximum number of schema field name characters allowed. */
    public var maxFieldNameCharacters: Int?
    /** The minimum number of schema field description characters allowed. */
    public var minFieldDescriptionCharacters: Int?
    /** The maximum number of schema field description characters allowed. */
    public var maxFieldDescriptionCharacters: Int?
    /** The minimum number of schema name characters allowed. */
    public var minSchemaNameCharacters: Int?
    /** The maximum number of schema name characters allowed. */
    public var maxSchemaNameCharacters: Int?
    /** The minimum number of schema description characters allowed. */
    public var minSchemaDescriptionCharacters: Int?
    /** The maximum number of schema description characters allowed. */
    public var maxSchemaDescriptionCharacters: Int?
    /** The maximum number of schema allowed per org. */
    public var maxNumberOfSchemasPerOrg: Int?
    /** The maximum number of schema fields allowed per schema. */
    public var maxNumberOfFieldsPerSchema: Int?
    /** The maximum number of schema fields allowed per organization across all of their schemas. */
    public var maxNumberOfFieldsPerOrg: Int?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, minFieldNameCharacters: Int?, maxFieldNameCharacters: Int?, minFieldDescriptionCharacters: Int?, maxFieldDescriptionCharacters: Int?, minSchemaNameCharacters: Int?, maxSchemaNameCharacters: Int?, minSchemaDescriptionCharacters: Int?, maxSchemaDescriptionCharacters: Int?, maxNumberOfSchemasPerOrg: Int?, maxNumberOfFieldsPerSchema: Int?, maxNumberOfFieldsPerOrg: Int?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.minFieldNameCharacters = minFieldNameCharacters
        self.maxFieldNameCharacters = maxFieldNameCharacters
        self.minFieldDescriptionCharacters = minFieldDescriptionCharacters
        self.maxFieldDescriptionCharacters = maxFieldDescriptionCharacters
        self.minSchemaNameCharacters = minSchemaNameCharacters
        self.maxSchemaNameCharacters = maxSchemaNameCharacters
        self.minSchemaDescriptionCharacters = minSchemaDescriptionCharacters
        self.maxSchemaDescriptionCharacters = maxSchemaDescriptionCharacters
        self.maxNumberOfSchemasPerOrg = maxNumberOfSchemasPerOrg
        self.maxNumberOfFieldsPerSchema = maxNumberOfFieldsPerSchema
        self.maxNumberOfFieldsPerOrg = maxNumberOfFieldsPerOrg
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case minFieldNameCharacters
        case maxFieldNameCharacters
        case minFieldDescriptionCharacters
        case maxFieldDescriptionCharacters
        case minSchemaNameCharacters
        case maxSchemaNameCharacters
        case minSchemaDescriptionCharacters
        case maxSchemaDescriptionCharacters
        case maxNumberOfSchemasPerOrg
        case maxNumberOfFieldsPerSchema
        case maxNumberOfFieldsPerOrg
        case selfUri
    }


}



/** Defines a SCIM resource. */

public class ScimConfigResourceType: Codable {

















    /** The ID of the SCIM resource. Set by the service provider. \"caseExact\" is set to \"true\". \"mutability\" is set to \"readOnly\". \"returned\" is set to \"always\". */
    public var _id: String?
    /** The list of supported schemas. */
    public var schemas: [String]?
    /** The name of the resource type. */
    public var name: String?
    /** The description of the resource type. */
    public var _description: String?
    /** The URI of the primary or base schema for the resource type. */
    public var schema: String?
    /** The list of schema extensions for the resource type. */
    public var schemaExtensions: [ScimConfigResourceTypeSchemaExtension]?
    /** The HTTP-addressable endpoint of the resource type. Appears after the base URL. */
    public var endpoint: String?
    /** The metadata of the SCIM resource. Only \"location\" and \"resourceType\" are set for \"ResourceType\" resources. */
    public var meta: ScimMetadata?

    public init(_id: String?, schemas: [String]?, name: String?, _description: String?, schema: String?, schemaExtensions: [ScimConfigResourceTypeSchemaExtension]?, endpoint: String?, meta: ScimMetadata?) {
        self._id = _id
        self.schemas = schemas
        self.name = name
        self._description = _description
        self.schema = schema
        self.schemaExtensions = schemaExtensions
        self.endpoint = endpoint
        self.meta = meta
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case schemas
        case name
        case _description = "description"
        case schema
        case schemaExtensions
        case endpoint
        case meta
    }


}



/** Defines a SCIM resource type's schema extension. */

public class ScimConfigResourceTypeSchemaExtension: Codable {





    /** The URI of an extended schema, for example, \"urn:edu:2.0:Staff\". Must be equal to the \"id\" attribute of a schema. */
    public var schema: String?
    /** Indicates whether a schema extension is required. */
    public var _required: Bool?

    public init(schema: String?, _required: Bool?) {
        self.schema = schema
        self._required = _required
    }

    public enum CodingKeys: String, CodingKey { 
        case schema
        case _required = "required"
    }


}



/** Defines the SCIM metadata. */

public class ScimMetadata: Codable {

    public enum ResourceType: String, Codable { 
        case user = "User"
        case group = "Group"
        case serviceProviderConfig = "ServiceProviderConfig"
        case resourceType = "ResourceType"
        case schema = "Schema"
    }







    /** The type of SCIM resource. */
    public var resourceType: ResourceType?
    /** The last time that the resource was modified. Date time is represented as an \"ISO-8601 string\", for example, yyyy-MM-ddTHH:mm:ss.SSSZ. Not included with \"Schema\" and \"ResourceType\" resources. */
    public var lastModified: Date?
    /** The URI of the resource. */
    public var location: String?
    /** The version of the resource. Matches the ETag HTTP response header. Not included with \"Schema\" and \"ResourceType\" resources. */
    public var version: String?

    public init(resourceType: ResourceType?, lastModified: Date?, location: String?, version: String?) {
        self.resourceType = resourceType
        self.lastModified = lastModified
        self.location = location
        self.version = version
    }


}



/** Defines an authentication scheme in the SCIM service provider's configuration. */

public class ScimServiceProviderConfigAuthenticationScheme: Codable {









    public enum ModelType: String, Codable { 
        case oauth = "oauth"
        case oauth2 = "oauth2"
        case oauthbearertoken = "oauthbearertoken"
        case httpbasic = "httpbasic"
        case httpdigest = "httpdigest"
    }



    /** The name of the authentication scheme, for example, HTTP Basic. */
    public var name: String?
    /** The description of the authentication scheme. */
    public var _description: String?
    /** The HTTP-addressable URL that points to the authentication scheme's specification. */
    public var specUri: String?
    /** The HTTP-addressable URL that points to the authentication scheme's usage documentation. */
    public var documentationUri: String?
    /** The type of authentication scheme. */
    public var type: ModelType?
    /** Indicates whether this authentication scheme is the primary method of authentication. */
    public var primary: Bool?

    public init(name: String?, _description: String?, specUri: String?, documentationUri: String?, type: ModelType?, primary: Bool?) {
        self.name = name
        self._description = _description
        self.specUri = specUri
        self.documentationUri = documentationUri
        self.type = type
        self.primary = primary
    }

    public enum CodingKeys: String, CodingKey { 
        case name
        case _description = "description"
        case specUri
        case documentationUri
        case type
        case primary
    }


}



/** Defines a \"bulk\" request in the SCIM service provider's configuration. */

public class ScimServiceProviderConfigBulkFeature: Codable {







    /** Indicates whether configuration options are supported. */
    public var supported: Bool?
    /** The maximum number of operations for each bulk request. */
    public var maxOperations: Int?
    /** The maximum payload size. */
    public var maxPayloadSize: Int?

    public init(supported: Bool?, maxOperations: Int?, maxPayloadSize: Int?) {
        self.supported = supported
        self.maxOperations = maxOperations
        self.maxPayloadSize = maxPayloadSize
    }


}



/** Defines a request in the SCIM service provider's configuration. */

public class ScimServiceProviderConfigSimpleFeature: Codable {



    /** Indicates whether configuration options are supported. */
    public var supported: Bool?

    public init(supported: Bool?) {
        self.supported = supported
    }


}



/** Defines a SCIM group. */

public class ScimV2Group: Codable {













    /** The ID of the SCIM resource. Set by the service provider. \"caseExact\" is set to \"true\". \"mutability\" is set to \"readOnly\". \"returned\" is set to \"always\". */
    public var _id: String?
    /** The list of supported schemas. */
    public var schemas: [String]?
    /** The display name of the group. */
    public var displayName: String?
    /** The external ID of the group. Set by the provisioning client. \"caseExact\" is set to \"true\". \"mutability\" is set to \"readWrite\". */
    public var externalId: String?
    /** The list of members in the group. */
    public var members: [ScimV2MemberReference]?
    /** The metadata of the SCIM resource. Metadata is defined as immutable per SCIM RFC. */
    public var meta: ScimMetadata?

    public init(_id: String?, schemas: [String]?, displayName: String?, externalId: String?, members: [ScimV2MemberReference]?, meta: ScimMetadata?) {
        self._id = _id
        self.schemas = schemas
        self.displayName = displayName
        self.externalId = externalId
        self.members = members
        self.meta = meta
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case schemas
        case displayName
        case externalId
        case members
        case meta
    }


}



/** Defines a SCIM user. */

public class ScimV2User: Codable {































    /** The ID of the SCIM resource. Set by the service provider. \"caseExact\" is set to \"true\". \"mutability\" is set to \"readOnly\". \"returned\" is set to \"always\". */
    public var _id: String?
    /** The list of supported schemas. */
    public var schemas: [String]?
    /** Indicates whether the user's administrative status is active. */
    public var active: Bool?
    /** The user's Genesys Cloud email address. Must be unique. */
    public var userName: String?
    /** The display name of the user. */
    public var displayName: String?
    /** The new password for the Genesys Cloud user. Does not return an existing password. When creating a user, if a password is not supplied, then a password will be randomly generated that is 40 characters in length and contains five characters from each of the password policy groups. */
    public var password: String?
    /** The user's title. */
    public var title: String?
    /** The list of the user's phone numbers. */
    public var phoneNumbers: [ScimPhoneNumber]?
    /** The list of the user's email addresses. */
    public var emails: [ScimEmail]?
    /** The external ID of the user. Set by the provisioning client. \"caseExact\" is set to \"true\". \"mutability\" is set to \"readWrite\". */
    public var externalId: String?
    /** The list of groups that the user is a member of. This list is immutable per SCIM RFC and may only be updated using the GROUPS resource endpoint. */
    public var groups: [ScimV2GroupReference]?
    /** The list of roles assigned to the user. */
    public var roles: [ScimUserRole]?
    /** The URI of the schema for the enterprise user. */
    public var urnietfparamsscimschemasextensionenterprise20User: ScimV2EnterpriseUser?
    /** The URI of the schema for the Genesys Cloud user. */
    public var urnietfparamsscimschemasextensiongenesyspurecloud20User: ScimUserExtensions?
    /** The metadata of the SCIM resource. Metadata is defined as immutable per SCIM RFC. */
    public var meta: ScimMetadata?

    public init(_id: String?, schemas: [String]?, active: Bool?, userName: String?, displayName: String?, password: String?, title: String?, phoneNumbers: [ScimPhoneNumber]?, emails: [ScimEmail]?, externalId: String?, groups: [ScimV2GroupReference]?, roles: [ScimUserRole]?, urnietfparamsscimschemasextensionenterprise20User: ScimV2EnterpriseUser?, urnietfparamsscimschemasextensiongenesyspurecloud20User: ScimUserExtensions?, meta: ScimMetadata?) {
        self._id = _id
        self.schemas = schemas
        self.active = active
        self.userName = userName
        self.displayName = displayName
        self.password = password
        self.title = title
        self.phoneNumbers = phoneNumbers
        self.emails = emails
        self.externalId = externalId
        self.groups = groups
        self.roles = roles
        self.urnietfparamsscimschemasextensionenterprise20User = urnietfparamsscimschemasextensionenterprise20User
        self.urnietfparamsscimschemasextensiongenesyspurecloud20User = urnietfparamsscimschemasextensiongenesyspurecloud20User
        self.meta = meta
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case schemas
        case active
        case userName
        case displayName
        case password
        case title
        case phoneNumbers
        case emails
        case externalId
        case groups
        case roles
        case urnietfparamsscimschemasextensionenterprise20User = "urn:ietf:params:scim:schemas:extension:enterprise:2.0:User"
        case urnietfparamsscimschemasextensiongenesyspurecloud20User = "urn:ietf:params:scim:schemas:extension:genesys:purecloud:2.0:User"
        case meta
    }


}




public class ScreenRecordingActiveSessions: Codable {



    /** Current concurrent active screen recordings count for organization */
    public var count: Int?

    public init(count: Int?) {
        self.count = count
    }


}




public class ScreenRecordingMetaData: Codable {















    public var trackId: String?
    public var mediaId: String?
    public var screenId: String?
    public var originX: Int?
    public var originY: Int?
    public var primary: Bool?
    public var main: Bool?

    public init(trackId: String?, mediaId: String?, screenId: String?, originX: Int?, originY: Int?, primary: Bool?, main: Bool?) {
        self.trackId = trackId
        self.mediaId = mediaId
        self.screenId = screenId
        self.originX = originX
        self.originY = originY
        self.primary = primary
        self.main = main
    }


}




public class ScreenRecordingMetaDataRequest: Codable {







    public var participantJid: String?
    public var roomId: String?
    public var metaData: [ScreenRecordingMetaData]?

    public init(participantJid: String?, roomId: String?, metaData: [ScreenRecordingMetaData]?) {
        self.participantJid = participantJid
        self.roomId = roomId
        self.metaData = metaData
    }


}




public class SearchCriteria: Codable {









    public enum Operator: String, Codable { 
        case and = "AND"
        case or = "OR"
        case not = "NOT"
    }





    public enum ModelType: String, Codable { 
        case exact = "EXACT"
        case contains = "CONTAINS"
        case startsWith = "STARTS_WITH"
        case requiredFields = "REQUIRED_FIELDS"
        case range = "RANGE"
        case dateRange = "DATE_RANGE"
        case lessThan = "LESS_THAN"
        case lessThanEqualTo = "LESS_THAN_EQUAL_TO"
        case greaterThan = "GREATER_THAN"
        case greaterThanEqualTo = "GREATER_THAN_EQUAL_TO"
        case simple = "SIMPLE"
        case term = "TERM"
        case terms = "TERMS"
        case queryString = "QUERY_STRING"
        case matchAll = "MATCH_ALL"
        case regex = "REGEX"
    }



    /** The end value of the range. This field is used for range search types. */
    public var endValue: String?
    /** A list of values for the search to match against */
    public var values: [String]?
    /** The start value of the range. This field is used for range search types. */
    public var startValue: String?
    /** A value for the search to match against */
    public var value: String?
    /** How to apply this search criteria against other criteria */
    public var _operator: Operator?
    /** Groups multiple conditions */
    public var group: [SearchCriteria]?
    /** Set date format for criteria values when using date range search type.  Supports Java date format syntax, example yyyy-MM-dd'T'HH:mm:ss.SSSX. */
    public var dateFormat: String?
    public var type: ModelType?
    /** Field names to search against */
    public var fields: [String]?

    public init(endValue: String?, values: [String]?, startValue: String?, value: String?, _operator: Operator?, group: [SearchCriteria]?, dateFormat: String?, type: ModelType?, fields: [String]?) {
        self.endValue = endValue
        self.values = values
        self.startValue = startValue
        self.value = value
        self._operator = _operator
        self.group = group
        self.dateFormat = dateFormat
        self.type = type
        self.fields = fields
    }

    public enum CodingKeys: String, CodingKey { 
        case endValue
        case values
        case startValue
        case value
        case _operator = "operator"
        case group
        case dateFormat
        case type
        case fields
    }


}




public class SearchDecisionTableRowsRequest: Codable {



    /** The filter criteria for searching decision table rows */
    public var filter: RowSearchFilter?

    public init(filter: RowSearchFilter?) {
        self.filter = filter
    }


}




public class SearchSort: Codable {

    public enum SortOrder: String, Codable { 
        case asc = "ASC"
        case desc = "DESC"
        case score = "SCORE"
    }



    /** The sort order for results */
    public var sortOrder: SortOrder?
    /** The field in the resource that you want to sort the results by */
    public var sortBy: String?

    public init(sortOrder: SortOrder?, sortBy: String?) {
        self.sortOrder = sortOrder
        self.sortBy = sortBy
    }


}




public class SecondaryPresence: Codable {





    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, selfUri: String?) {
        self._id = _id
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
    }


}




public class SecureSessionEntityListing: Codable {



    public var entities: [SecureSession]?

    public init(entities: [SecureSession]?) {
        self.entities = entities
    }


}




public class SecurityProfile: Codable {









    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    public var permissions: [String]?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, permissions: [String]?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.permissions = permissions
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case permissions
        case selfUri
    }


}




public class SegmentAssignment: Codable {











    /** Date when the segment was assigned. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateAssigned: Date?
    /** Date indicating when a segment is scheduled to be unassigned. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateForUnassignment: Date?
    /** The segment the assignment is for. */
    public var segment: SegmentAssignmentSegment?
    /** For session-scoped segments, the session for which the segment was assigned. */
    public var session: SegmentAssignmentSession?
    /** External contact of the customer to which the segment is assigned. */
    public var externalContact: AddressableEntityRef?

    public init(dateAssigned: Date?, dateForUnassignment: Date?, segment: SegmentAssignmentSegment?, session: SegmentAssignmentSession?, externalContact: AddressableEntityRef?) {
        self.dateAssigned = dateAssigned
        self.dateForUnassignment = dateForUnassignment
        self.segment = segment
        self.session = session
        self.externalContact = externalContact
    }


}




public class SegmentAssignmentListing: Codable {



    public var entities: [SegmentAssignment]?

    public init(entities: [SegmentAssignment]?) {
        self.entities = entities
    }


}




public class SegmentAssignmentSession: Codable {







    /** The ID of the session. */
    public var _id: String?
    /** The type or category of session (e.g. web, app). */
    public var type: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, type: String?, selfUri: String?) {
        self._id = _id
        self.type = type
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case type
        case selfUri
    }


}




public class SegmentAssignments: Codable {



    /** The segments to be assigned. */
    public var segments: [SegmentForAssignment]?

    public init(segments: [SegmentForAssignment]?) {
        self.segments = segments
    }


}




public class SegmentDetailQueryClause: Codable {

    public enum ModelType: String, Codable { 
        case and = "and"
        case or = "or"
    }



    /** Boolean operation to apply to the provided predicates */
    public var type: ModelType?
    /** Like a three-word sentence: (attribute-name) (operator) (target-value). */
    public var predicates: [SegmentDetailQueryPredicate]?

    public init(type: ModelType?, predicates: [SegmentDetailQueryPredicate]?) {
        self.type = type
        self.predicates = predicates
    }


}




public class SegmentEstimateCount: Codable {





    /** ID of Segment. */
    public var segmentId: String?
    /** Estimate count per segment. */
    public var count: Int?

    public init(segmentId: String?, count: Int?) {
        self.segmentId = segmentId
        self.count = count
    }


}




public class SegmentForAssignment: Codable {



    /** The ID of the segment to be assigned. */
    public var _id: String?

    public init(_id: String?) {
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
    }


}




public class SendAgentlessOutboundMessageResponse: Codable {









    public enum MessengerType: String, Codable { 
        case sms = "sms"
        case whatsapp = "whatsapp"
        case _open = "open"
    }















    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The identifier of the conversation. */
    public var conversationId: String?
    /** The sender of the message. */
    public var fromAddress: String?
    /** The recipient of the message. */
    public var toAddress: String?
    /** Type of messenger. */
    public var messengerType: MessengerType?
    /** The body of the text message. (Deprecated - Instead use message.normalizedMessage.text) */
    public var textBody: String?
    /** The messaging template sent. (Deprecated - Instead use message.normalizedMessage.content[#].template) */
    public var messagingTemplate: SendMessagingTemplateRequest?
    /** Use an existing active conversation to send the agentless outbound message. Set this parameter to 'true' to use active conversation. Default value: false */
    public var useExistingActiveConversation: Bool?
    /** Sent agentless outbound message in normalized format */
    public var message: MessageData?
    /** The time when the message was sent. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var timestamp: Date?
    /** The URI for this object */
    public var selfUri: String?
    /** Details of the user created the job */
    public var user: AddressableEntityRef?

    public init(_id: String?, conversationId: String?, fromAddress: String?, toAddress: String?, messengerType: MessengerType?, textBody: String?, messagingTemplate: SendMessagingTemplateRequest?, useExistingActiveConversation: Bool?, message: MessageData?, timestamp: Date?, selfUri: String?, user: AddressableEntityRef?) {
        self._id = _id
        self.conversationId = conversationId
        self.fromAddress = fromAddress
        self.toAddress = toAddress
        self.messengerType = messengerType
        self.textBody = textBody
        self.messagingTemplate = messagingTemplate
        self.useExistingActiveConversation = useExistingActiveConversation
        self.message = message
        self.timestamp = timestamp
        self.selfUri = selfUri
        self.user = user
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case conversationId
        case fromAddress
        case toAddress
        case messengerType
        case textBody
        case messagingTemplate
        case useExistingActiveConversation
        case message
        case timestamp
        case selfUri
        case user
    }


}




public class SentimentInsightEntry: Codable {





    /** The title given to the insight */
    public var title: String?
    /** A short description of the insight */
    public var _description: String?

    public init(title: String?, _description: String?) {
        self.title = title
        self._description = _description
    }

    public enum CodingKeys: String, CodingKey { 
        case title
        case _description = "description"
    }


}




public class SentimentInsights: Codable {





    /** The reasons for positive sentiment found in the conversation */
    public var positiveSentimentReasons: [SentimentInsightEntry]?
    /** The reasons for negative sentiment found in the conversation */
    public var negativeSentimentReasons: [SentimentInsightEntry]?

    public init(positiveSentimentReasons: [SentimentInsightEntry]?, negativeSentimentReasons: [SentimentInsightEntry]?) {
        self.positiveSentimentReasons = positiveSentimentReasons
        self.negativeSentimentReasons = negativeSentimentReasons
    }


}




public class ServiceGoalTemplateReference: Codable {





    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, selfUri: String?) {
        self._id = _id
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
    }


}




public class SessionSegmentAssignment: Codable {





    /** The segment that was assigned. */
    public var segment: AssignedSegment?
    /** Timestamp indicating when the segment was assigned. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var assignedDate: Date?

    public init(segment: AssignedSegment?, assignedDate: Date?) {
        self.segment = segment
        self.assignedDate = assignedDate
    }


}




public class SessionsResponse: Codable {









    public var entities: [BotFlowSession]?
    public var nextUri: String?
    public var selfUri: String?
    public var previousUri: String?

    public init(entities: [BotFlowSession]?, nextUri: String?, selfUri: String?, previousUri: String?) {
        self.entities = entities
        self.nextUri = nextUri
        self.selfUri = selfUri
        self.previousUri = previousUri
    }


}




public class SetTimeOffIntegrationStatusRequest: Codable {

    public enum IntegrationStatus: String, Codable { 
        case processing = "Processing"
        case error = "Error"
        case automaticallyComplete = "AutomaticallyComplete"
        case manuallyComplete = "ManuallyComplete"
    }

    /** The integration status value for the time off request */
    public var integrationStatus: IntegrationStatus?

    public init(integrationStatus: IntegrationStatus?) {
        self.integrationStatus = integrationStatus
    }


}




public class SetTimeOffLimitValuesRequest: Codable {





    public var values: [TimeOffLimitRange]?
    /** Version metadata for the time off limit */
    public var metadata: WfmVersionedEntityMetadata?

    public init(values: [TimeOffLimitRange]?, metadata: WfmVersionedEntityMetadata?) {
        self.values = values
        self.metadata = metadata
    }


}




public class ShiftTradeMatchReviewResponse: Codable {










    public enum UnevaluatedRules: String, Codable { 
        case planningPeriodMinPaidTime = "PlanningPeriodMinPaidTime"
        case planningPeriodMaxPaidTime = "PlanningPeriodMaxPaidTime"
        case minimumTimeBetweenShifts = "MinimumTimeBetweenShifts"
    }
    /** Details for the initiatingUser side of the shift trade */
    public var initiatingUser: ShiftTradeMatchReviewUserResponse?
    /** Details for the receivingUser side of the shift trade */
    public var receivingUser: ShiftTradeMatchReviewUserResponse?
    /** Constraint violations introduced after being matched that would normally disallow a trade, but which can still be overridden by the shift trade administrator */
    public var violations: [ShiftTradeMatchViolation]?
    /** Constraint violations associated with this shift trade which require shift trade administrator review */
    public var adminReviewViolations: [ShiftTradeMatchViolation]?
    /** Unevaluated rules for this shift trade which require shift trade administrator review */
    public var unevaluatedRules: [UnevaluatedRules]?

    public init(initiatingUser: ShiftTradeMatchReviewUserResponse?, receivingUser: ShiftTradeMatchReviewUserResponse?, violations: [ShiftTradeMatchViolation]?, adminReviewViolations: [ShiftTradeMatchViolation]?, unevaluatedRules: [UnevaluatedRules]?) {
        self.initiatingUser = initiatingUser
        self.receivingUser = receivingUser
        self.violations = violations
        self.adminReviewViolations = adminReviewViolations
        self.unevaluatedRules = unevaluatedRules
    }


}




public class ShiftTradeMatchReviewUserResponse: Codable {











    /** The minimum weekly paid minutes for this user per the work plan tied to the agent schedule */
    public var weeklyMinimumPaidMinutes: Int?
    /** The maximum weekly paid minutes for this user per the work plan tied to the agent schedule */
    public var weeklyMaximumPaidMinutes: Int?
    /** The paid minutes on the week schedule for this user prior to the shift trade */
    public var preTradeSchedulePaidMinutes: Int?
    /** The paid minutes on the week schedule for this user if the shift trade is approved */
    public var postTradeSchedulePaidMinutes: Int?
    /** Preview of what the shift will look like for the opposite side of this trade after the match is approved */
    public var postTradeNewShift: ShiftTradePreviewResponse?

    public init(weeklyMinimumPaidMinutes: Int?, weeklyMaximumPaidMinutes: Int?, preTradeSchedulePaidMinutes: Int?, postTradeSchedulePaidMinutes: Int?, postTradeNewShift: ShiftTradePreviewResponse?) {
        self.weeklyMinimumPaidMinutes = weeklyMinimumPaidMinutes
        self.weeklyMaximumPaidMinutes = weeklyMaximumPaidMinutes
        self.preTradeSchedulePaidMinutes = preTradeSchedulePaidMinutes
        self.postTradeSchedulePaidMinutes = postTradeSchedulePaidMinutes
        self.postTradeNewShift = postTradeNewShift
    }


}




public class ShiftTradeMatchesSummaryResponse: Codable {



    public var entities: [WeekShiftTradeMatchesSummaryResponse]?

    public init(entities: [WeekShiftTradeMatchesSummaryResponse]?) {
        self.entities = entities
    }


}




public class SipSearchResult: Codable {

















    /** The globally unique identifier for the object. */
    public var _id: String?
    /** Status of the search request */
    public var status: Int?
    /** Session id associated to the search request */
    public var sid: String?
    /** Auth token used for this search request */
    public var auth: String?
    /** Any messages returned from homer as part of the response */
    public var message: String?
    /** Homer search data that is returned */
    public var data: [HomerRecord]?
    /** Number of records returned */
    public var count: Int?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, status: Int?, sid: String?, auth: String?, message: String?, data: [HomerRecord]?, count: Int?, selfUri: String?) {
        self._id = _id
        self.status = status
        self.sid = sid
        self.auth = auth
        self.message = message
        self.data = data
        self.count = count
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case status
        case sid
        case auth
        case message
        case data
        case count
        case selfUri
    }


}




public class SiteEntityListing: Codable {























    public var entities: [Site]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    /** The total organization-wide number of entities. */
    public var totalNumberOfEntities: Int64?
    public var firstUri: String?
    public var previousUri: String?
    public var nextUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [Site]?, pageSize: Int?, pageNumber: Int?, total: Int64?, totalNumberOfEntities: Int64?, firstUri: String?, previousUri: String?, nextUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.totalNumberOfEntities = totalNumberOfEntities
        self.firstUri = firstUri
        self.previousUri = previousUri
        self.nextUri = nextUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class SiteSearchCriteria: Codable {









    public enum Operator: String, Codable { 
        case and = "AND"
        case or = "OR"
        case not = "NOT"
    }





    public enum ModelType: String, Codable { 
        case exact = "EXACT"
        case contains = "CONTAINS"
    }



    /** The end value of the range. This field is used for range search types. */
    public var endValue: String?
    /** A list of values for the search to match against */
    public var values: [String]?
    /** The start value of the range. This field is used for range search types. */
    public var startValue: String?
    /** A value for the search to match against */
    public var value: String?
    /** How to apply this search criteria against other criteria */
    public var _operator: Operator?
    /** Groups multiple conditions */
    public var group: [SiteSearchCriteria]?
    /** Set date format for criteria values when using date range search type.  Supports Java date format syntax, example yyyy-MM-dd'T'HH:mm:ss.SSSX. */
    public var dateFormat: String?
    /** Search Type */
    public var type: ModelType?
    /** Field names to search against */
    public var fields: [String]?

    public init(endValue: String?, values: [String]?, startValue: String?, value: String?, _operator: Operator?, group: [SiteSearchCriteria]?, dateFormat: String?, type: ModelType?, fields: [String]?) {
        self.endValue = endValue
        self.values = values
        self.startValue = startValue
        self.value = value
        self._operator = _operator
        self.group = group
        self.dateFormat = dateFormat
        self.type = type
        self.fields = fields
    }

    public enum CodingKeys: String, CodingKey { 
        case endValue
        case values
        case startValue
        case value
        case _operator = "operator"
        case group
        case dateFormat
        case type
        case fields
    }


}




public class SmsAddress: Codable {



















    /** The id of this address. */
    public var _id: String?
    public var name: String?
    /** The number and street address where this address is located. */
    public var street: String?
    /** The city in which this address is in */
    public var city: String?
    /** The state or region this address is in */
    public var region: String?
    /** The postal code this address is in */
    public var postalCode: String?
    /** The ISO country code of this address */
    public var countryCode: String?
    /** In some countries, addresses are validated to comply with local regulation. In those countries, if the address you provide does not pass validation, it will not be accepted as an Address. This value will be true if the Address has been validated, or false for countries that don't require validation or if the Address is non-compliant. */
    public var validated: Bool?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, street: String?, city: String?, region: String?, postalCode: String?, countryCode: String?, validated: Bool?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.street = street
        self.city = city
        self.region = region
        self.postalCode = postalCode
        self.countryCode = countryCode
        self.validated = validated
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case street
        case city
        case region
        case postalCode
        case countryCode
        case validated
        case selfUri
    }


}




public class SmsAvailablePhoneNumber: Codable {













    public enum Capabilities: String, Codable { 
        case sms = "sms"
        case mms = "mms"
        case voice = "voice"
    }

    public enum PhoneNumberType: String, Codable { 
        case local = "local"
        case mobile = "mobile"
        case tollfree = "tollfree"
        case shortcode = "shortcode"
        case alphanumeric = "alphanumeric"
    }

    public enum AddressRequirement: String, Codable { 
        case _none = "none"
        case any = "any"
        case local = "local"
        case foreign = "foreign"
    }



    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** A phone number available for provisioning in E.164 format. E.g. +13175555555 or +34234234234 */
    public var phoneNumber: String?
    /** The ISO 3166-1 alpha-2 country code of the country this phone number is associated with. */
    public var countryCode: String?
    /** The region/province/state the phone number is associated with. */
    public var region: String?
    /** The city the phone number is associated with. */
    public var city: String?
    /** The capabilities of the phone number available for provisioning. */
    public var capabilities: [Capabilities]?
    /** The type of phone number available for provisioning. */
    public var phoneNumberType: PhoneNumberType?
    /** The address requirement needed for provisioning this number. If there is a requirement, the address must be the residence or place of business of the individual or entity using the phone number. */
    public var addressRequirement: AddressRequirement?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, phoneNumber: String?, countryCode: String?, region: String?, city: String?, capabilities: [Capabilities]?, phoneNumberType: PhoneNumberType?, addressRequirement: AddressRequirement?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.phoneNumber = phoneNumber
        self.countryCode = countryCode
        self.region = region
        self.city = city
        self.capabilities = capabilities
        self.phoneNumberType = phoneNumberType
        self.addressRequirement = addressRequirement
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case phoneNumber
        case countryCode
        case region
        case city
        case capabilities
        case phoneNumberType
        case addressRequirement
        case selfUri
    }


}




public class SmsPhoneNumberEntityListing: Codable {





















    public var entities: [SmsPhoneNumber]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var previousUri: String?
    public var nextUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [SmsPhoneNumber]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, previousUri: String?, nextUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.previousUri = previousUri
        self.nextUri = nextUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class SocialMediaAsyncAggregateQueryResponse: Codable {





    public var results: [SocialMediaAggregateDataContainer]?
    /** Cursor token to retrieve next page */
    public var cursor: String?

    public init(results: [SocialMediaAggregateDataContainer]?, cursor: String?) {
        self.results = results
        self.cursor = cursor
    }


}




public class SocialMediaAsyncDetailQuery: Codable {











    public enum Order: String, Codable { 
        case asc = "asc"
        case desc = "desc"
    }

    /** Behaves like one clause in a SQL WHERE. Specifies the date and time range of data being queried. Intervals are represented as an ISO-8601 string. For example: YYYY-MM-DDThh:mm:ss/YYYY-MM-DDThh:mm:ss */
    public var interval: String?
    /** Time zone context used to calculate response intervals (this allows resolving DST changes). The interval offset is used even when timeZone is specified. Default is UTC. Time zones are represented as a string of the zone name as found in the IANA time zone database. For example: UTC, Etc/UTC, or Europe/London */
    public var timeZone: String?
    /** Behaves like a SQL WHERE clause. This is ANDed with the interval parameter. Expresses boolean logical predicates as well as dimensional filters */
    public var filter: SocialMediaQueryFilter?
    /** List of topicIds to query in */
    public var topicIds: [String]?
    /** The number of results per page */
    public var pageSize: Int?
    /** Sorting of results based on time */
    public var order: Order?

    public init(interval: String?, timeZone: String?, filter: SocialMediaQueryFilter?, topicIds: [String]?, pageSize: Int?, order: Order?) {
        self.interval = interval
        self.timeZone = timeZone
        self.filter = filter
        self.topicIds = topicIds
        self.pageSize = pageSize
        self.order = order
    }


}




public class SocialMediaDetailDataContainer: Codable {





    public var interval: String?
    public var messages: [SocialMediaDetailMessageContainer]?

    public init(interval: String?, messages: [SocialMediaDetailMessageContainer]?) {
        self.interval = interval
        self.messages = messages
    }


}




public class SocialMediaQueryClause: Codable {

    public enum ModelType: String, Codable { 
        case and = "and"
        case or = "or"
    }



    /** Boolean operation to apply to the provided predicates */
    public var type: ModelType?
    /** Like a three-word sentence: (attribute-name) (operator) (target-value). */
    public var predicates: [SocialMediaQueryPredicate]?

    public init(type: ModelType?, predicates: [SocialMediaQueryPredicate]?) {
        self.type = type
        self.predicates = predicates
    }


}




public class SocialMediaStatisticalResponse: Codable {





    public var interval: String?
    public var metrics: [SocialMediaAggregateMetricData]?

    public init(interval: String?, metrics: [SocialMediaAggregateMetricData]?) {
        self.interval = interval
        self.metrics = metrics
    }


}




public class SourceEntity: Codable {



    public enum ModelType: String, Codable { 
        case thankYou = "ThankYou"
        case congratulations = "Congratulations"
        case highPerformance = "HighPerformance"
        case companyValues = "CompanyValues"
        case competition = "Competition"
        case race = "Race"
        case raffle = "Raffle"
        case teamGoal = "TeamGoal"
    }





    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The type of the source entity */
    public var type: ModelType?
    /** The contest data - Only supplied when celebration is of type ContestComplete */
    public var contestCompleteData: ContestCompleteData?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, type: ModelType?, contestCompleteData: ContestCompleteData?, selfUri: String?) {
        self._id = _id
        self.type = type
        self.contestCompleteData = contestCompleteData
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case type
        case contestCompleteData
        case selfUri
    }


}




public class SourceEntityListing: Codable {







    public var total: Int64?
    public var entities: [Source]?
    public var selfUri: String?

    public init(total: Int64?, entities: [Source]?, selfUri: String?) {
        self.total = total
        self.entities = entities
        self.selfUri = selfUri
    }


}




public class SourceLastSync: Codable {

    public enum State: String, Codable { 
        case success = "Success"
        case failed = "Failed"
        case inProgress = "InProgress"
        case unknown = "Unknown"
    }







    /** State of the last synchronization. */
    public var state: State?
    /** Last synchronization start-time. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateStarted: Date?
    /** Last synchronization end-time. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateEnded: Date?
    /** Optional error message of the last synchronization. */
    public var error: ErrorBody?

    public init(state: State?, dateStarted: Date?, dateEnded: Date?, error: ErrorBody?) {
        self.state = state
        self.dateStarted = dateStarted
        self.dateEnded = dateEnded
        self.error = error
    }


}




public class SpeechTextAnalyticsConversationSummary: Codable {

    public enum SummaryType: String, Codable { 
        case conversation = "Conversation"
        case agent = "Agent"
        case virtualAgent = "VirtualAgent"
    }

    public enum MediaType: String, Codable { 
        case unknown = "Unknown"
        case message = "Message"
        case call = "Call"
        case email = "Email"
    }











    /** The type of summary */
    public var summaryType: SummaryType?
    /** The media type of the associated interaction */
    public var mediaType: MediaType?
    /** Language of the summary */
    public var language: String?
    /** The id of the source (program, agent assistant, or flow) from which summarization is triggered */
    public var sourceId: String?
    /** A summarization of the conversation transcription */
    public var summary: String?
    /** Indicates whether or not the summary was generated by AI */
    public var generated: Bool?
    /** Timestamp of when the summary was created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?

    public init(summaryType: SummaryType?, mediaType: MediaType?, language: String?, sourceId: String?, summary: String?, generated: Bool?, dateCreated: Date?) {
        self.summaryType = summaryType
        self.mediaType = mediaType
        self.language = language
        self.sourceId = sourceId
        self.summary = summary
        self.generated = generated
        self.dateCreated = dateCreated
    }


}




public class SpeechTextAnalyticsConversationSummaryListing: Codable {



    public var entities: [SpeechTextAnalyticsConversationSummary]?

    public init(entities: [SpeechTextAnalyticsConversationSummary]?) {
        self.entities = entities
    }


}




public class StatEventFlowTopicStatsNotification: Codable {





    public var group: [String:String]?
    public var data: [StatEventFlowTopicIntervalMetrics]?

    public init(group: [String:String]?, data: [StatEventFlowTopicIntervalMetrics]?) {
        self.group = group
        self.data = data
    }


}




public class StatEventWrapUpCodeTopicIntervalMetrics: Codable {





    public var interval: String?
    public var metrics: [StatEventWrapUpCodeTopicMetricStats]?

    public init(interval: String?, metrics: [StatEventWrapUpCodeTopicMetricStats]?) {
        self.interval = interval
        self.metrics = metrics
    }


}




public class StatEventWrapUpCodeTopicMetricStats: Codable {







    public var metric: String?
    public var qualifier: String?
    public var stats: [String:Double]?

    public init(metric: String?, qualifier: String?, stats: [String:Double]?) {
        self.metric = metric
        self.qualifier = qualifier
        self.stats = stats
    }


}




public class StatisticalSummary: Codable {





























    public var max: Double?
    public var min: Double?
    public var count: Int64?
    public var countNegative: Int64?
    public var countPositive: Int64?
    public var sum: Double?
    public var current: Double?
    public var ratio: Double?
    public var numerator: Double?
    public var denominator: Double?
    public var target: Double?
    public var p95: Int64?
    public var p99: Int64?
    public var calculatedMetricValue: Int64?

    public init(max: Double?, min: Double?, count: Int64?, countNegative: Int64?, countPositive: Int64?, sum: Double?, current: Double?, ratio: Double?, numerator: Double?, denominator: Double?, target: Double?, p95: Int64?, p99: Int64?, calculatedMetricValue: Int64?) {
        self.max = max
        self.min = min
        self.count = count
        self.countNegative = countNegative
        self.countPositive = countPositive
        self.sum = sum
        self.current = current
        self.ratio = ratio
        self.numerator = numerator
        self.denominator = denominator
        self.target = target
        self.p95 = p95
        self.p99 = p99
        self.calculatedMetricValue = calculatedMetricValue
    }


}




public class SubjectDivisionGrantsEntityListing: Codable {





















    public var entities: [SubjectDivisionGrants]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var previousUri: String?
    public var nextUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [SubjectDivisionGrants]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, previousUri: String?, nextUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.previousUri = previousUri
        self.nextUri = nextUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class SubjectDivisions: Codable {





    /** A collection of subject IDs to associate with the given divisions */
    public var subjectIds: [String]?
    /** A collection of division IDs to associate with the given subjects */
    public var divisionIds: [String]?

    public init(subjectIds: [String]?, divisionIds: [String]?) {
        self.subjectIds = subjectIds
        self.divisionIds = divisionIds
    }


}




public class SuggestedSearchChunk: Codable {













    /** The document title. */
    public var title: String?
    /** The document uri. */
    public var uri: String?
    /** The chunk ID. */
    public var chunkId: String?
    /** The text of the knowledge chunk. */
    public var text: String?
    /** Value between 0 and 1. 1 corresponds to very confident, 0 to not confident at all. */
    public var confidence: Float?
    /** The article. */
    public var document: AddressableEntityRef?

    public init(title: String?, uri: String?, chunkId: String?, text: String?, confidence: Float?, document: AddressableEntityRef?) {
        self.title = title
        self.uri = uri
        self.chunkId = chunkId
        self.text = text
        self.confidence = confidence
        self.document = document
    }


}




public class SuggestionFeedback: Codable {

    public enum Rating: String, Codable { 
        case negative = "Negative"
        case positive = "Positive"
    }

    /** The rating value of the suggestion feedback. */
    public var rating: Rating?

    public init(rating: Rating?) {
        self.rating = rating
    }


}




public class SuggestionGeneratedKnowledgeAnswer: Codable {







    /** The search id. */
    public var searchId: String?
    /** The knowledge answer generated. */
    public var knowledgeAnswerGenerated: String?
    /** The suggested search chunks. */
    public var suggestedSearchChunks: [SuggestedSearchChunk]?

    public init(searchId: String?, knowledgeAnswerGenerated: String?, suggestedSearchChunks: [SuggestedSearchChunk]?) {
        self.searchId = searchId
        self.knowledgeAnswerGenerated = knowledgeAnswerGenerated
        self.suggestedSearchChunks = suggestedSearchChunks
    }


}




public class SummaryAggregateDataContainer: Codable {





    /** A mapping from dimension to value */
    public var group: [String:String]?
    public var data: [StatisticalResponse]?

    public init(group: [String:String]?, data: [StatisticalResponse]?) {
        self.group = group
        self.data = data
    }


}




public class SummaryAggregateQueryClause: Codable {

    public enum ModelType: String, Codable { 
        case and = "and"
        case or = "or"
    }



    /** Boolean operation to apply to the provided predicates */
    public var type: ModelType?
    /** Like a three-word sentence: (attribute-name) (operator) (target-value). */
    public var predicates: [SummaryAggregateQueryPredicate]?

    public init(type: ModelType?, predicates: [SummaryAggregateQueryPredicate]?) {
        self.type = type
        self.predicates = predicates
    }


}




public class SummaryAggregationQuery: Codable {







    public enum GroupBy: String, Codable { 
        case conversationid = "conversationId"
        case copied = "copied"
        case editedfield = "editedField"
        case errortype = "errorType"
        case language = "language"
        case mediatype = "mediaType"
        case messagetype = "messageType"
        case presented = "presented"
        case queueid = "queueId"
        case summarygenerated = "summaryGenerated"
        case summaryid = "summaryId"
        case summaryrating = "summaryRating"
        case triggersourceid = "triggerSourceId"
        case triggersourceoutcome = "triggerSourceOutcome"
        case triggersourcetype = "triggerSourceType"
        case userid = "userId"
        case wrapupcoderating = "wrapUpCodeRating"
        case wrapupcodesuggestionselected = "wrapUpCodeSuggestionSelected"
        case wrapupcodesgenerated = "wrapupCodesGenerated"
    }



    public enum Metrics: String, Codable { 
        case nconversationsummaries = "nConversationSummaries"
        case nconversationsummaryengagements = "nConversationSummaryEngagements"
        case tconversationsummary = "tConversationSummary"
    }





    public enum AlternateTimeDimension: String, Codable { 
        case eventtime = "eventTime"
    }

    public enum QueryType: String, Codable { 
        case bottomn = "bottomN"
        case groupby = "groupBy"
        case topn = "topN"
    }





    /** Behaves like one clause in a SQL WHERE. Specifies the date and time range of data being queried. Intervals are represented as an ISO-8601 string. For example: YYYY-MM-DDThh:mm:ss/YYYY-MM-DDThh:mm:ss */
    public var interval: String?
    /** Granularity aggregates metrics into subpartitions within the time interval specified. The default granularity is the same duration as the interval. Periods are represented as an ISO-8601 string. For example: P1D or P1DT12H */
    public var granularity: String?
    /** Time zone context used to calculate response intervals (this allows resolving DST changes). The interval offset is used even when timeZone is specified. Default is UTC. Time zones are represented as a string of the zone name as found in the IANA time zone database. For example: UTC, Etc/UTC, or Europe/London */
    public var timeZone: String?
    /** Behaves like a SQL GROUPBY. Allows for multiple levels of grouping as a list of dimensions. Partitions resulting aggregate computations into distinct named subgroups rather than across the entire result set as if it were one group. */
    public var groupBy: [GroupBy]?
    /** Behaves like a SQL WHERE clause. This is ANDed with the interval parameter. Expresses boolean logical predicates as well as dimensional filters */
    public var filter: SummaryAggregateQueryFilter?
    /** Behaves like a SQL SELECT clause. Only named metrics will be retrieved. */
    public var metrics: [Metrics]?
    /** Flattens any multivalued dimensions used in response groups (e.g. ['a','b','c']->'a,b,c') */
    public var flattenMultivaluedDimensions: Bool?
    /** Custom derived metric views */
    public var views: [SummaryAggregationView]?
    /** Dimension to use as the alternative timestamp for data in the aggregate.  Choosing \"eventTime\" uses the actual time of the data event. */
    public var alternateTimeDimension: AlternateTimeDimension?
    /** Query type to use. Use groupBy for all matching results, and topN/bottomN for N results ordered by the sortMetric. Default is groupBy. */
    public var queryType: QueryType?
    /** Required when requesting multiple metrics. Only applicable for topN/bottomN query type. */
    public var sortMetric: SummaryAggregationSort?
    /** How many results you want in an ordered list. Only applicable for topN/bottomN query type. */
    public var limit: Int?

    public init(interval: String?, granularity: String?, timeZone: String?, groupBy: [GroupBy]?, filter: SummaryAggregateQueryFilter?, metrics: [Metrics]?, flattenMultivaluedDimensions: Bool?, views: [SummaryAggregationView]?, alternateTimeDimension: AlternateTimeDimension?, queryType: QueryType?, sortMetric: SummaryAggregationSort?, limit: Int?) {
        self.interval = interval
        self.granularity = granularity
        self.timeZone = timeZone
        self.groupBy = groupBy
        self.filter = filter
        self.metrics = metrics
        self.flattenMultivaluedDimensions = flattenMultivaluedDimensions
        self.views = views
        self.alternateTimeDimension = alternateTimeDimension
        self.queryType = queryType
        self.sortMetric = sortMetric
        self.limit = limit
    }


}




public class SummaryAggregationSort: Codable {

    public enum Name: String, Codable { 
        case nconversationsummaries = "nConversationSummaries"
        case nconversationsummaryengagements = "nConversationSummaryEngagements"
        case tconversationsummary = "tConversationSummary"
    }

    public enum Function: String, Codable { 
        case average = "average"
        case count = "count"
        case max = "max"
        case min = "min"
        case sum = "sum"
    }

    /** Name of the metric used for sorting values. */
    public var name: Name?
    /** Aggregation function used for the sort metric. */
    public var function: Function?

    public init(name: Name?, function: Function?) {
        self.name = name
        self.function = function
    }


}




public class SummarySettingWithTranscript: Codable {







    /** Example transcript to preview with the setting. */
    public var transcript: String?
    /** Summary setting to preview on the transcript. */
    public var summarySetting: SummarySetting?
    /** Session identifier of the summary preview. */
    public var summaryPreviewSessionId: String?

    public init(transcript: String?, summarySetting: SummarySetting?, summaryPreviewSessionId: String?) {
        self.transcript = transcript
        self.summarySetting = summarySetting
        self.summaryPreviewSessionId = summaryPreviewSessionId
    }


}




public class SupportCenterCompactCategoryModuleTemplate: Codable {



    /** Whether this template is active or not */
    public var active: Bool?

    public init(active: Bool?) {
        self.active = active
    }


}




public class SupportCenterDetailedCategoryModuleSidebar: Codable {



    /** Whether sidebar is enabled or not */
    public var enabled: Bool?

    public init(enabled: Bool?) {
        self.enabled = enabled
    }


}




public class SupportCenterDetailedCategoryModuleTemplate: Codable {





    /** Whether this template is active or not */
    public var active: Bool?
    /** Sidebar settings for the template */
    public var sidebar: SupportCenterDetailedCategoryModuleSidebar?

    public init(active: Bool?, sidebar: SupportCenterDetailedCategoryModuleSidebar?) {
        self.active = active
        self.sidebar = sidebar
    }


}




public class SupportCenterImage: Codable {



    /** Source URLs for image */
    public var source: SupportCenterImageSource?

    public init(source: SupportCenterImageSource?) {
        self.source = source
    }


}




public class SupportCenterImageSource: Codable {



    /** Default URL for image */
    public var defaultUrl: String?

    public init(defaultUrl: String?) {
        self.defaultUrl = defaultUrl
    }


}




public class SupportCenterModuleSetting: Codable {

    public enum ModelType: String, Codable { 
        case search = "Search"
        case categories = "Categories"
        case faq = "FAQ"
        case contact = "Contact"
        case results = "Results"
        case article = "Article"
        case topViewedArticles = "TopViewedArticles"
    }







    /** Screen module type */
    public var type: ModelType?
    /** Whether or not knowledge portal (previously support center) screen module is enabled */
    public var enabled: Bool?
    /** Compact category module template */
    public var compactCategoryModuleTemplate: SupportCenterCompactCategoryModuleTemplate?
    /** Detailed category module template */
    public var detailedCategoryModuleTemplate: SupportCenterDetailedCategoryModuleTemplate?

    public init(type: ModelType?, enabled: Bool?, compactCategoryModuleTemplate: SupportCenterCompactCategoryModuleTemplate?, detailedCategoryModuleTemplate: SupportCenterDetailedCategoryModuleTemplate?) {
        self.type = type
        self.enabled = enabled
        self.compactCategoryModuleTemplate = compactCategoryModuleTemplate
        self.detailedCategoryModuleTemplate = detailedCategoryModuleTemplate
    }


}




public class SupportCenterScreen: Codable {

    public enum ModelType: String, Codable { 
        case home = "Home"
        case category = "Category"
        case searchResults = "SearchResults"
        case article = "Article"
    }



    /** The type of the screen */
    public var type: ModelType?
    /** Module settings for the screen, valid modules for each screenType: Home: Search, Categories, TopViewedArticles; Category: Search, Categories; SearchResults: Search, Results; Article: Search, Article; */
    public var moduleSettings: [SupportCenterModuleSetting]?

    public init(type: ModelType?, moduleSettings: [SupportCenterModuleSetting]?) {
        self.type = type
        self.moduleSettings = moduleSettings
    }


}




public class SupportCenterStyleSetting: Codable {





    /** Knowledge portal (previously support center) hero customizations */
    public var heroStyle: SupportCenterHeroStyle?
    /** Knowledge portal (previously support center) global customizations */
    public var globalStyle: SupportCenterGlobalStyle?

    public init(heroStyle: SupportCenterHeroStyle?, globalStyle: SupportCenterGlobalStyle?) {
        self.heroStyle = heroStyle
        self.globalStyle = globalStyle
    }


}



/** Supported content profile for inbound and outbound messages */

public class SupportedContent: Codable {



















    /** A unique supported content Id. */
    public var _id: String?
    /** The name of the supported content profile */
    public var name: String?
    /** Date this supported content profile was created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** Date this supported content profile was modified. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** User reference that created this supported content profile */
    public var createdBy: DomainEntityRef?
    /** User reference that modified this supported content profile */
    public var modifiedBy: DomainEntityRef?
    /** Version number */
    public var version: Int?
    /** Defines the allowable media that may be accepted for an inbound message or to be sent in an outbound message. The following is an example of allowing all inbound media, and for outbound all images and only mpeg video: {   \"mediaTypes\": {     \"allow\": {       \"inbound\": [{\"type\": \"*_/_*\"}],       \"outbound\": [{\"type\": \"image/_*\"}, {\"type\": \"video/mpeg\"}]     }   } } */
    public var mediaTypes: MediaTypes?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, dateCreated: Date?, dateModified: Date?, createdBy: DomainEntityRef?, modifiedBy: DomainEntityRef?, version: Int?, mediaTypes: MediaTypes?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.createdBy = createdBy
        self.modifiedBy = modifiedBy
        self.version = version
        self.mediaTypes = mediaTypes
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case dateCreated
        case dateModified
        case createdBy
        case modifiedBy
        case version
        case mediaTypes
        case selfUri
    }


}




public class SupportedContentListing: Codable {





















    public var entities: [SupportedContent]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var previousUri: String?
    public var nextUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [SupportedContent]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, previousUri: String?, nextUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.previousUri = previousUri
        self.nextUri = nextUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class SupportedDialectsEntityListing: Codable {



    public var entities: [SupportedDialectsTranscriptionEngine]?

    public init(entities: [SupportedDialectsTranscriptionEngine]?) {
        self.entities = entities
    }


}




public class SurveyDetailQueryFilter: Codable {

    public enum ModelType: String, Codable { 
        case and = "and"
        case or = "or"
    }





    /** Boolean operation to apply to the provided predicates and clauses */
    public var type: ModelType?
    /** Boolean 'and/or' logic with up to two-levels of nesting */
    public var clauses: [SurveyDetailQueryClause]?
    /** Like a three-word sentence: (attribute-name) (operator) (target-value). */
    public var predicates: [SurveyDetailQueryPredicate]?

    public init(type: ModelType?, clauses: [SurveyDetailQueryClause]?, predicates: [SurveyDetailQueryPredicate]?) {
        self.type = type
        self.clauses = clauses
        self.predicates = predicates
    }


}




public class SyncStatusRequest: Codable {

    public enum Status: String, Codable { 
        case created = "Created"
        case validationInProgress = "ValidationInProgress"
        case validationCompleted = "ValidationCompleted"
        case validationFailed = "ValidationFailed"
        case started = "Started"
        case inProgress = "InProgress"
        case completed = "Completed"
        case partialCompleted = "PartialCompleted"
        case failed = "Failed"
        case abortRequested = "AbortRequested"
        case aborted = "Aborted"
    }

    /** New status for an existing sync operation */
    public var status: Status?

    public init(status: Status?) {
        self.status = status
    }


}




public class SystemPrompt: Codable {











    /** The system prompt identifier */
    public var _id: String?
    public var name: String?
    public var _description: String?
    public var resources: [SystemPromptAsset]?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, _description: String?, resources: [SystemPromptAsset]?, selfUri: String?) {
        self._id = _id
        self.name = name
        self._description = _description
        self.resources = resources
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case _description = "description"
        case resources
        case selfUri
    }


}




public class TargetAttributeValue: Codable {





    public var _description: String?
    public var policyAttributes: [PolicyAttribute]?

    public init(_description: String?, policyAttributes: [PolicyAttribute]?) {
        self._description = _description
        self.policyAttributes = policyAttributes
    }

    public enum CodingKeys: String, CodingKey { 
        case _description = "description"
        case policyAttributes
    }


}




public class TeamActivityMetricValue: Codable {

    public enum Metric: String, Codable { 
        case oteamoffqueueusers = "oTeamOffQueueUsers"
        case oteamonqueueusers = "oTeamOnQueueUsers"
        case oteampresences = "oTeamPresences"
        case oteamroutingstatuses = "oTeamRoutingStatuses"
    }









    /** Metric */
    public var metric: Metric?
    /** Metric qualifier */
    public var qualifier: String?
    /** Secondary metric qualifier */
    public var secondaryQualifier: String?
    /** Entity ids for matching entities if details were requested */
    public var entityIds: [String]?
    /** Metric count */
    public var count: Int?

    public init(metric: Metric?, qualifier: String?, secondaryQualifier: String?, entityIds: [String]?, count: Int?) {
        self.metric = metric
        self.qualifier = qualifier
        self.secondaryQualifier = secondaryQualifier
        self.entityIds = entityIds
        self.count = count
    }


}




public class TeamActivityQueryMetric: Codable {

    public enum Metric: String, Codable { 
        case oteamoffqueueusers = "oTeamOffQueueUsers"
        case oteamonqueueusers = "oTeamOnQueueUsers"
        case oteampresences = "oTeamPresences"
        case oteamroutingstatuses = "oTeamRoutingStatuses"
    }



    /** The requested metric */
    public var metric: Metric?
    /** Flag for including observation details for this metric in the response */
    public var details: Bool?

    public init(metric: Metric?, details: Bool?) {
        self.metric = metric
        self.details = details
    }


}




public class TeamReference: Codable {





    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, selfUri: String?) {
        self._id = _id
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
    }


}




public class TemplateParameter: Codable {





    /** Response substitution identifier */
    public var _id: String?
    /** Response substitution value */
    public var value: String?

    public init(_id: String?, value: String?) {
        self._id = _id
        self.value = value
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case value
    }


}




public class TemporalUnit: Codable {









    public var durationEstimated: Bool?
    public var duration: Duration?
    public var timeBased: Bool?
    public var dateBased: Bool?

    public init(durationEstimated: Bool?, duration: Duration?, timeBased: Bool?, dateBased: Bool?) {
        self.durationEstimated = durationEstimated
        self.duration = duration
        self.timeBased = timeBased
        self.dateBased = dateBased
    }


}



/** Description of the Bot Flow. */

public class TextBotFlow: Codable {



    /** The Bot Flow ID. */
    public var _id: String?

    public init(_id: String?) {
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
    }


}



/** Information related to a successful launch of a bot flow. The ID will be used in subsequent turn requests of the bot flow. */

public class TextBotFlowLaunchResponse: Codable {



    /** The session ID of the bot flow, used to send to subsequent turn requests */
    public var _id: String?

    public init(_id: String?) {
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
    }


}



/** Describes a flow location. */

public class TextBotFlowLocation: Codable {







    /** The name of the action that was active when the event of interest happened. */
    public var actionName: String?
    /** The number of the action that was active when the event of interest happened. */
    public var actionNumber: Int?
    /** The name of the state or task which was active when the event of interest happened. */
    public var sequenceName: String?

    public init(actionName: String?, actionNumber: Int?, sequenceName: String?) {
        self.actionName = actionName
        self.actionNumber = actionNumber
        self.sequenceName = sequenceName
    }


}



/** Settings for a turn request to a bot flow. */

public class TextBotFlowTurnRequest: Codable {



    public enum InputEventType: String, Codable { 
        case noOp = "NoOp"
        case userInput = "UserInput"
        case richMediaInput = "RichMediaInput"
        case error = "Error"
        case noMatch = "NoMatch"
        case noInput = "NoInput"
        case userDisconnect = "UserDisconnect"
        case clientSessionExpired = "ClientSessionExpired"
    }





    /** The reference to a previous turn if appropriate, used to avoid race conditions. */
    public var previousTurn: TextBotTurnReference?
    /** Indicates the type of input event being requested. If appropriate, fill out the matching user input object details on this request. */
    public var inputEventType: InputEventType?
    /** The data for the input event of this turn if it is a user input event. Only one inputEvent may be set. */
    public var inputEventUserInput: TextBotUserInputEvent?
    /** The data for the input event of this turn if it is an error event. Only one inputEvent may be set. */
    public var inputEventError: TextBotErrorInputEvent?

    public init(previousTurn: TextBotTurnReference?, inputEventType: InputEventType?, inputEventUserInput: TextBotUserInputEvent?, inputEventError: TextBotErrorInputEvent?) {
        self.previousTurn = previousTurn
        self.inputEventType = inputEventType
        self.inputEventUserInput = inputEventUserInput
        self.inputEventError = inputEventError
    }


}



/** Input/Output data related to a bot flow which is exiting gracefully. */

public class TextBotInputOutputData: Codable {



    /** The input/output variables using the format as appropriate for the variable data type in the flow definition. */
    public var variables: [String:JSON]?

    public init(variables: [String:JSON]?) {
        self.variables = variables
    }


}



/** Prompt information related to a bot flow turn. */

public class TextBotModeOutputPrompts: Codable {



    /** The list of prompt segments. */
    public var segments: [TextBotPromptSegment]?

    public init(segments: [TextBotPromptSegment]?) {
        self.segments = segments
    }


}




public class TimeAndDateSubConditionRange: Codable {







    /** The minimum value of the range. Required for the operator BETWEEN. Format depends on type: timeOfDay: HH:mm, dayOfWeek: 1-7 (Monday-Sunday), dayOfMonth: 1-31, specificDate: yyyy-MM-dd (if includeYear=true) or MM-dd (if includeYear=false). */
    public var min: String?
    /** The maximum value of the range. Required for the operator BETWEEN. Format follows the same rules as 'min'. */
    public var max: String?
    /** A set of values that the date/ time data should be in. Required for the IN operator. Format depends on type: dayOfWeek: 1-7 (Monday-Sunday), dayOfMonth: 1-31, and/ or LAST_DAY, ODD_DAY, EVEN_DAY,specificDate: yyyy-MM-dd (if includeYear=true) or MM-dd (if includeYear=false). */
    public var inSet: [String]?

    public init(min: String?, max: String?, inSet: [String]?) {
        self.min = min
        self.max = max
        self.inSet = inSet
    }


}




public class TimeOffBalanceResponse: Codable {











    /** The ID for activity code associated with time off balance */
    public var activityCodeId: String?
    /** The ID of the time off type configured in HRIS integration */
    public var hrisTimeOffTypeId: String?
    /** The secondary ID of the time off type configured in HRIS integration */
    public var hrisTimeOffTypeSecondaryId: String?
    /** The Start date of the requested date range. The end date is determined by the size of interval list. Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd */
    public var startDate: Date?
    /** The list of available time off balance values in minutes for each day */
    public var balanceMinutesPerDay: [Int]?

    public init(activityCodeId: String?, hrisTimeOffTypeId: String?, hrisTimeOffTypeSecondaryId: String?, startDate: Date?, balanceMinutesPerDay: [Int]?) {
        self.activityCodeId = activityCodeId
        self.hrisTimeOffTypeId = hrisTimeOffTypeId
        self.hrisTimeOffTypeSecondaryId = hrisTimeOffTypeSecondaryId
        self.startDate = startDate
        self.balanceMinutesPerDay = balanceMinutesPerDay
    }


}




public class TimeOffBalancesResponse: Codable {





    /** The asynchronous job handling the query */
    public var job: TimeOffBalanceJobReference?
    /** The list of time off balances. May come via notification */
    public var entities: [TimeOffBalanceResponse]?

    public init(job: TimeOffBalanceJobReference?, entities: [TimeOffBalanceResponse]?) {
        self.job = job
        self.entities = entities
    }


}




public class TimeOffPlan: Codable {









    public enum AutoApprovalRule: String, Codable { 
        case never = "Never"
        case always = "Always"
        case checkLimits = "CheckLimits"
        case checkActivityCodes = "CheckActivityCodes"
        case checkLimitsAndActivityCodes = "CheckLimitsAndActivityCodes"
    }











    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The name of this time off plan. */
    public var name: String?
    /** The set of activity code IDs associated with this time off plan. */
    public var activityCodeIds: [String]?
    /** The set of time off limit IDs associated with this time off plan. */
    public var timeOffLimits: [TimeOffLimitReference]?
    /** Auto approval rule for this time off plan */
    public var autoApprovalRule: AutoApprovalRule?
    /** The number of days before the time off request start date for when the request will be expired from the waitlist. */
    public var daysBeforeStartToExpireFromWaitlist: Int?
    /** Time off type, if this time off plan is associated with the integration. */
    public var hrisTimeOffType: HrisTimeOffType?
    /** Whether this time off plan is currently being used by agents. */
    public var active: Bool?
    /** Version metadata for the time off plan. */
    public var metadata: WfmVersionedEntityMetadata?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, activityCodeIds: [String]?, timeOffLimits: [TimeOffLimitReference]?, autoApprovalRule: AutoApprovalRule?, daysBeforeStartToExpireFromWaitlist: Int?, hrisTimeOffType: HrisTimeOffType?, active: Bool?, metadata: WfmVersionedEntityMetadata?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.activityCodeIds = activityCodeIds
        self.timeOffLimits = timeOffLimits
        self.autoApprovalRule = autoApprovalRule
        self.daysBeforeStartToExpireFromWaitlist = daysBeforeStartToExpireFromWaitlist
        self.hrisTimeOffType = hrisTimeOffType
        self.active = active
        self.metadata = metadata
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case activityCodeIds
        case timeOffLimits
        case autoApprovalRule
        case daysBeforeStartToExpireFromWaitlist
        case hrisTimeOffType
        case active
        case metadata
        case selfUri
    }


}




public class TimeOffPlanListing: Codable {



    public var entities: [TimeOffPlan]?

    public init(entities: [TimeOffPlan]?) {
        self.entities = entities
    }


}




public class TimeOffRequest: Codable {













    public enum Status: String, Codable { 
        case pending = "PENDING"
        case approved = "APPROVED"
        case denied = "DENIED"
        case canceled = "CANCELED"
    }

    public enum Substatus: String, Codable { 
        case advanceTimeElapsed = "AdvanceTimeElapsed"
        case autoApproved = "AutoApproved"
        case blockedDate = "BlockedDate"
        case insufficientBalance = "InsufficientBalance"
        case invalidDailyDuration = "InvalidDailyDuration"
        case manualApproval = "ManualApproval"
        case outsideShift = "OutsideShift"
        case overlapsRestrictedActivityCode = "OverlapsRestrictedActivityCode"
        case removedFromWaitlist = "RemovedFromWaitlist"
        case reviewDate = "ReviewDate"
        case waitlisted = "Waitlisted"
    }



























    /** The id of the time off request */
    public var _id: String?
    /** The user that the time off request belongs to */
    public var user: UserReference?
    /** Whether this is a full day request (false means partial day) */
    public var isFullDayRequest: Bool?
    /** Whether this request has been marked as read by the agent */
    public var markedAsRead: Bool?
    /** The ID of the activity code associated with this time off request. Activity code must be of the TimeOff category */
    public var activityCodeId: String?
    /** Whether this is a paid time off request */
    public var paid: Bool?
    /** The status of this time off request */
    public var status: Status?
    /** The substatus of this time off request */
    public var substatus: Substatus?
    /** A set of start date-times in ISO-8601 format for partial day requests.  Will be not empty if isFullDayRequest == false */
    public var partialDayStartDateTimes: [Date]?
    /** A set of dates in yyyy-MM-dd format.  Should be interpreted in the management unit's configured time zone.  Will be not empty if isFullDayRequest == true */
    public var fullDayManagementUnitDates: [String]?
    /** The daily duration of this time off request in minutes */
    public var dailyDurationMinutes: Int?
    /** Daily durations for each day of this time off request in minutes */
    public var durationMinutes: [Int]?
    /** Payable minutes for each day of this time off request */
    public var payableMinutes: [Int]?
    /** Notes about the time off request */
    public var notes: String?
    /** The user who submitted this time off request. The id may be 'System' if it was an automated process */
    public var submittedBy: UserReference?
    /** The timestamp when this request was submitted. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var submittedDate: Date?
    /** The user who reviewed this time off request. The id may be 'System' if it was an automated process */
    public var reviewedBy: UserReference?
    /** The timestamp when this request was reviewed. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var reviewedDate: Date?
    /** The sync version of this time off request for which the scheduled activity is associated */
    public var syncVersion: Int?
    /** The version metadata of the time off request */
    public var metadata: WfmVersionedEntityMetadata?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, user: UserReference?, isFullDayRequest: Bool?, markedAsRead: Bool?, activityCodeId: String?, paid: Bool?, status: Status?, substatus: Substatus?, partialDayStartDateTimes: [Date]?, fullDayManagementUnitDates: [String]?, dailyDurationMinutes: Int?, durationMinutes: [Int]?, payableMinutes: [Int]?, notes: String?, submittedBy: UserReference?, submittedDate: Date?, reviewedBy: UserReference?, reviewedDate: Date?, syncVersion: Int?, metadata: WfmVersionedEntityMetadata?, selfUri: String?) {
        self._id = _id
        self.user = user
        self.isFullDayRequest = isFullDayRequest
        self.markedAsRead = markedAsRead
        self.activityCodeId = activityCodeId
        self.paid = paid
        self.status = status
        self.substatus = substatus
        self.partialDayStartDateTimes = partialDayStartDateTimes
        self.fullDayManagementUnitDates = fullDayManagementUnitDates
        self.dailyDurationMinutes = dailyDurationMinutes
        self.durationMinutes = durationMinutes
        self.payableMinutes = payableMinutes
        self.notes = notes
        self.submittedBy = submittedBy
        self.submittedDate = submittedDate
        self.reviewedBy = reviewedBy
        self.reviewedDate = reviewedDate
        self.syncVersion = syncVersion
        self.metadata = metadata
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case user
        case isFullDayRequest
        case markedAsRead
        case activityCodeId
        case paid
        case status
        case substatus
        case partialDayStartDateTimes
        case fullDayManagementUnitDates
        case dailyDurationMinutes
        case durationMinutes
        case payableMinutes
        case notes
        case submittedBy
        case submittedDate
        case reviewedBy
        case reviewedDate
        case syncVersion
        case metadata
        case selfUri
    }


}




public class TimeOffRequestListing: Codable {





    /** List of time off requests */
    public var entities: [TimeOffRequest]?
    /** URL from which to fetch results for requests with a large result set. If populated, the downloaded data will conform to the same schema as would normally be returned, excepting downloaded data will never itself contain a downloadUrl */
    public var downloadUrl: String?

    public init(entities: [TimeOffRequest]?, downloadUrl: String?) {
        self.entities = entities
        self.downloadUrl = downloadUrl
    }


}




public class TimeOffRequestNotification: Codable {







    public enum Status: String, Codable { 
        case pending = "PENDING"
        case approved = "APPROVED"
        case denied = "DENIED"
        case canceled = "CANCELED"
    }





    /** The ID of this time off request */
    public var timeOffRequestId: String?
    /** The user associated with this time off request */
    public var user: UserReference?
    /** Whether this is a full day request (false means partial day) */
    public var isFullDayRequest: Bool?
    /** The status of this time off request */
    public var status: Status?
    /** A set of start date-times in ISO-8601 format for partial day requests.  Will be not empty if isFullDayRequest == false */
    public var partialDayStartDateTimes: [Date]?
    /** A set of dates in yyyy-MM-dd format.  Should be interpreted in the management unit's configured time zone.  Will be not empty if isFullDayRequest == true */
    public var fullDayManagementUnitDates: [String]?

    public init(timeOffRequestId: String?, user: UserReference?, isFullDayRequest: Bool?, status: Status?, partialDayStartDateTimes: [Date]?, fullDayManagementUnitDates: [String]?) {
        self.timeOffRequestId = timeOffRequestId
        self.user = user
        self.isFullDayRequest = isFullDayRequest
        self.status = status
        self.partialDayStartDateTimes = partialDayStartDateTimes
        self.fullDayManagementUnitDates = fullDayManagementUnitDates
    }


}




public class TimeSlot: Codable {







    /** start time in xx:xx:xx.xxx format */
    public var startTime: String?
    /** stop time in xx:xx:xx.xxx format */
    public var stopTime: String?
    /** Day for this time slot, Monday = 1 ... Sunday = 7 */
    public var day: Int?

    public init(startTime: String?, stopTime: String?, day: Int?) {
        self.startTime = startTime
        self.stopTime = stopTime
        self.day = day
    }


}




public class TopicPhrase: Codable {







    public var _id: String?
    public var text: String?
    public var utteranceCount: Int?

    public init(_id: String?, text: String?, utteranceCount: Int?) {
        self._id = _id
        self.text = text
        self.utteranceCount = utteranceCount
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case text
        case utteranceCount
    }


}




public class TranscriptAggregateQueryFilter: Codable {

    public enum ModelType: String, Codable { 
        case and = "and"
        case or = "or"
    }





    /** Boolean operation to apply to the provided predicates and clauses */
    public var type: ModelType?
    /** Boolean 'and/or' logic with up to two-levels of nesting */
    public var clauses: [TranscriptAggregateQueryClause]?
    /** Like a three-word sentence: (attribute-name) (operator) (target-value). */
    public var predicates: [TranscriptAggregateQueryPredicate]?

    public init(type: ModelType?, clauses: [TranscriptAggregateQueryClause]?, predicates: [TranscriptAggregateQueryPredicate]?) {
        self.type = type
        self.clauses = clauses
        self.predicates = predicates
    }


}




public class TranscriptTopic: Codable {



















    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The name of the object. */
    public var name: String?
    /** The phrase which detected the topic.  */
    public var topicPhrase: String?
    /** The transcript phrase which detected the topic. */
    public var transcriptPhrase: String?
    /** The detection confidence of the topic. */
    public var confidence: Int?
    /** The start time of the topic phrase. */
    public var startTimeMilliseconds: Int64?
    public var duration: TopicDuration?
    /** Location of the phrase */
    public var offset: TopicOffset?
    /** Location of the phrase in the recording in milliseconds */
    public var recordingLocation: Int64?

    public init(_id: String?, name: String?, topicPhrase: String?, transcriptPhrase: String?, confidence: Int?, startTimeMilliseconds: Int64?, duration: TopicDuration?, offset: TopicOffset?, recordingLocation: Int64?) {
        self._id = _id
        self.name = name
        self.topicPhrase = topicPhrase
        self.transcriptPhrase = transcriptPhrase
        self.confidence = confidence
        self.startTimeMilliseconds = startTimeMilliseconds
        self.duration = duration
        self.offset = offset
        self.recordingLocation = recordingLocation
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case topicPhrase
        case transcriptPhrase
        case confidence
        case startTimeMilliseconds
        case duration
        case offset
        case recordingLocation
    }


}




public class TranscriptTopics: Codable {





    /** List of topics which need to be included in exact match criteria. This field is not mutually exclusive with excludes topic list. */
    public var includes: [String]?
    /** List of topics which need to be excluded in exact match criteria. This field is not mutually exclusive with includes topic list. */
    public var excludes: [String]?

    public init(includes: [String]?, excludes: [String]?) {
        self.includes = includes
        self.excludes = excludes
    }


}




public class TransferRequest: Codable {

    public enum TransferType: String, Codable { 
        case attended = "Attended"
        case unattended = "Unattended"
    }













    /** The type of transfer to perform. Attended, where the initiating agent maintains ownership of the conversation until the intended recipient accepts the transfer, or Unattended, where the initiating agent immediately disconnects. Default is Unattended. */
    public var transferType: TransferType?
    /** If true, the digital internal message will NOT be terminated. */
    public var keepInternalMessageAlive: Bool?
    /** The user ID of the transfer target. */
    public var userId: String?
    /** The user ID or queue ID of the transfer target. Address like a phone number can not be used for callbacks, but they can be used for other forms of communication. */
    public var address: String?
    /** The user name of the transfer target. */
    public var userName: String?
    /** The queue ID of the transfer target. */
    public var queueId: String?
    /** If true, transfer to the voicemail inbox of the participant that is being replaced. */
    public var voicemail: Bool?

    public init(transferType: TransferType?, keepInternalMessageAlive: Bool?, userId: String?, address: String?, userName: String?, queueId: String?, voicemail: Bool?) {
        self.transferType = transferType
        self.keepInternalMessageAlive = keepInternalMessageAlive
        self.userId = userId
        self.address = address
        self.userName = userName
        self.queueId = queueId
        self.voicemail = voicemail
    }


}




public class TransferResponseModifiedBy: Codable {





    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, selfUri: String?) {
        self._id = _id
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
    }


}




public class TransferToAddressRequest: Codable {

    public enum TransferType: String, Codable { 
        case attended = "Attended"
        case unattended = "Unattended"
    }





    /** The type of transfer to perform. Attended, where the initiating agent maintains ownership of the conversation until the intended recipient accepts the transfer, or Unattended, where the initiating agent immediately disconnects. Default is Unattended. */
    public var transferType: TransferType?
    /** If true, the digital internal message will NOT be terminated. */
    public var keepInternalMessageAlive: Bool?
    /** User's name, queue's name, destination's address or phone number. */
    public var address: String?

    public init(transferType: TransferType?, keepInternalMessageAlive: Bool?, address: String?) {
        self.transferType = transferType
        self.keepInternalMessageAlive = keepInternalMessageAlive
        self.address = address
    }


}




public class TransferToAgentRequest: Codable {

    public enum TransferType: String, Codable { 
        case attended = "Attended"
        case unattended = "Unattended"
    }











    /** The type of transfer to perform. Attended, where the initiating agent maintains ownership of the conversation until the intended recipient accepts the transfer, or Unattended, where the initiating agent immediately disconnects. Default is Unattended. */
    public var transferType: TransferType?
    /** If true, the digital internal message will NOT be terminated. */
    public var keepInternalMessageAlive: Bool?
    /** The id of the internal user. */
    public var userId: String?
    /** The userName (like users email) of the internal user. */
    public var userName: String?
    /** The name of the internal user. */
    public var userDisplayName: String?
    /** If true, transfer to the voicemail inbox of the participant that is being replaced. */
    public var voicemail: Bool?

    public init(transferType: TransferType?, keepInternalMessageAlive: Bool?, userId: String?, userName: String?, userDisplayName: String?, voicemail: Bool?) {
        self.transferType = transferType
        self.keepInternalMessageAlive = keepInternalMessageAlive
        self.userId = userId
        self.userName = userName
        self.userDisplayName = userDisplayName
        self.voicemail = voicemail
    }


}




public class TransferToExternalRequest: Codable {

    public enum TransferType: String, Codable { 
        case attended = "Attended"
        case unattended = "Unattended"
    }





    /** The type of transfer to perform. Attended, where the initiating agent maintains ownership of the conversation until the intended recipient accepts the transfer, or Unattended, where the initiating agent immediately disconnects. Default is Unattended. */
    public var transferType: TransferType?
    /** If true, the digital internal message will NOT be terminated. */
    public var keepInternalMessageAlive: Bool?
    /** The address (like phone number) of the external contact. */
    public var address: String?

    public init(transferType: TransferType?, keepInternalMessageAlive: Bool?, address: String?) {
        self.transferType = transferType
        self.keepInternalMessageAlive = keepInternalMessageAlive
        self.address = address
    }


}




public class TranslateSupportedLanguage: Codable {





    /** Supported translation language name, natively spelled (ex. Espaol) */
    public var languageName: String?
    /** Supported translation language code. See - https://docs.aws.amazon.com/translate/latest/dg/what-is-languages.html#what-is-languages-supported */
    public var languageCode: String?

    public init(languageName: String?, languageCode: String?) {
        self.languageName = languageName
        self.languageCode = languageCode
    }


}




public class TrendData: Codable {









    /** Start workday used as the date range. Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd */
    public var dateStartWorkday: Date?
    /** End workday used as the date range. Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd */
    public var dateEndWorkday: Date?
    /** Percent of goal */
    public var percentOfGoal: Double?
    /** Average metric value */
    public var averageValue: Double?

    public init(dateStartWorkday: Date?, dateEndWorkday: Date?, percentOfGoal: Double?, averageValue: Double?) {
        self.dateStartWorkday = dateStartWorkday
        self.dateEndWorkday = dateEndWorkday
        self.percentOfGoal = percentOfGoal
        self.averageValue = averageValue
    }


}




public class Trunk: Codable {



















    public enum State: String, Codable { 
        case active = "active"
        case inactive = "inactive"
        case deleted = "deleted"
    }





    public enum TrunkType: String, Codable { 
        case external = "EXTERNAL"
        case phone = "PHONE"
        case edge = "EDGE"
    }























    public enum OptionsEnabledStatus: String, Codable { 
        case enabled = "ENABLED"
        case disabled = "DISABLED"
        case notSupported = "NOT_SUPPORTED"
    }

    public enum RegistersEnabledStatus: String, Codable { 
        case enabled = "ENABLED"
        case disabled = "DISABLED"
        case notSupported = "NOT_SUPPORTED"
    }







    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The name of the entity. */
    public var name: String?
    /** The division to which this entity belongs. */
    public var division: Division?
    /** The resource's description. */
    public var _description: String?
    /** The current version of the resource. */
    public var version: Int?
    /** The date the resource was created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** The date of the last modification to the resource. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** The ID of the user that last modified the resource. */
    public var modifiedBy: String?
    /** The ID of the user that created the resource. */
    public var createdBy: String?
    /** Indicates if the resource is active, inactive, or deleted. */
    public var state: State?
    /** The application that last modified the resource. */
    public var modifiedByApp: String?
    /** The application that created the resource. */
    public var createdByApp: String?
    /** The type of this trunk. */
    public var trunkType: TrunkType?
    /** The Edge using this trunk. */
    public var edge: DomainEntityRef?
    /** The trunk base configuration used on this trunk. */
    public var trunkBase: DomainEntityRef?
    /** The metabase used to create this trunk. */
    public var trunkMetabase: DomainEntityRef?
    /** The edge group associated with this trunk. */
    public var edgeGroup: DomainEntityRef?
    /** True if this trunk is in-service.  This comes from the trunk_enabled property of the referenced trunk base. */
    public var inService: Bool?
    /** True if the Edge used by this trunk is in-service */
    public var enabled: Bool?
    /** The Logical Interface on the Edge to which the trunk is assigned. */
    public var logicalInterface: DomainEntityRef?
    /** The connected status of the trunk */
    public var connectedStatus: TrunkConnectedStatus?
    /** The trunk optionsStatus */
    public var optionsStatus: [TrunkMetricsOptions]?
    /** The trunk registersStatus */
    public var registersStatus: [TrunkMetricsRegisters]?
    /** The trunk ipStatus */
    public var ipStatus: TrunkMetricsNetworkTypeIp?
    /** Returns Enabled when the trunk base supports the availability interval and it has a value greater than 0. */
    public var optionsEnabledStatus: OptionsEnabledStatus?
    /** Returns Enabled when the trunk base supports the registration interval and it has a value greater than 0. */
    public var registersEnabledStatus: RegistersEnabledStatus?
    /** The IP Network Family of the trunk */
    public var family: Int?
    /** The list of proxy addresses (ports if provided) for the trunk */
    public var proxyAddressList: [String]?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, division: Division?, _description: String?, version: Int?, dateCreated: Date?, dateModified: Date?, modifiedBy: String?, createdBy: String?, state: State?, modifiedByApp: String?, createdByApp: String?, trunkType: TrunkType?, edge: DomainEntityRef?, trunkBase: DomainEntityRef?, trunkMetabase: DomainEntityRef?, edgeGroup: DomainEntityRef?, inService: Bool?, enabled: Bool?, logicalInterface: DomainEntityRef?, connectedStatus: TrunkConnectedStatus?, optionsStatus: [TrunkMetricsOptions]?, registersStatus: [TrunkMetricsRegisters]?, ipStatus: TrunkMetricsNetworkTypeIp?, optionsEnabledStatus: OptionsEnabledStatus?, registersEnabledStatus: RegistersEnabledStatus?, family: Int?, proxyAddressList: [String]?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.division = division
        self._description = _description
        self.version = version
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.modifiedBy = modifiedBy
        self.createdBy = createdBy
        self.state = state
        self.modifiedByApp = modifiedByApp
        self.createdByApp = createdByApp
        self.trunkType = trunkType
        self.edge = edge
        self.trunkBase = trunkBase
        self.trunkMetabase = trunkMetabase
        self.edgeGroup = edgeGroup
        self.inService = inService
        self.enabled = enabled
        self.logicalInterface = logicalInterface
        self.connectedStatus = connectedStatus
        self.optionsStatus = optionsStatus
        self.registersStatus = registersStatus
        self.ipStatus = ipStatus
        self.optionsEnabledStatus = optionsEnabledStatus
        self.registersEnabledStatus = registersEnabledStatus
        self.family = family
        self.proxyAddressList = proxyAddressList
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case division
        case _description = "description"
        case version
        case dateCreated
        case dateModified
        case modifiedBy
        case createdBy
        case state
        case modifiedByApp
        case createdByApp
        case trunkType
        case edge
        case trunkBase
        case trunkMetabase
        case edgeGroup
        case inService
        case enabled
        case logicalInterface
        case connectedStatus
        case optionsStatus
        case registersStatus
        case ipStatus
        case optionsEnabledStatus
        case registersEnabledStatus
        case family
        case proxyAddressList
        case selfUri
    }


}




public class TrunkInstanceTopicTrunkMetricsNetworkTypeIp: Codable {





    public var address: String?
    public var errorInfo: TrunkInstanceTopicTrunkErrorInfo?

    public init(address: String?, errorInfo: TrunkInstanceTopicTrunkErrorInfo?) {
        self.address = address
        self.errorInfo = errorInfo
    }


}




public class TrunkMetricsOptions: Codable {









    /** Server proxy address that this options array element represents. */
    public var proxyAddress: String?
    public var optionState: Bool?
    /** ISO 8601 format UTC absolute date & time of the last change of the option state. */
    public var optionStateTime: Date?
    public var errorInfo: TrunkErrorInfo?

    public init(proxyAddress: String?, optionState: Bool?, optionStateTime: Date?, errorInfo: TrunkErrorInfo?) {
        self.proxyAddress = proxyAddress
        self.optionState = optionState
        self.optionStateTime = optionStateTime
        self.errorInfo = errorInfo
    }


}




public class TrustCreate: Codable {











    /** The pairing Id created by the trustee. This is required to prove that the trustee agrees to the relationship.  Not required when creating a default pairing with Customer Care. */
    public var pairingId: String?
    /** If disabled no trustee user will have access, even if they were previously added. */
    public var enabled: Bool?
    /** The list of users and their roles to which access will be granted. The users are from the trustee and the roles are from the trustor. If no users are specified, at least one group is required. */
    public var users: [TrustMemberCreate]?
    /** The list of groups and their roles to which access will be granted. The groups are from the trustee and the roles are from the trustor. If no groups are specified, at least one user is required. */
    public var groups: [TrustMemberCreate]?
    /** The expiration date of the trust. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateExpired: Date?

    public init(pairingId: String?, enabled: Bool?, users: [TrustMemberCreate]?, groups: [TrustMemberCreate]?, dateExpired: Date?) {
        self.pairingId = pairingId
        self.enabled = enabled
        self.users = users
        self.groups = groups
        self.dateExpired = dateExpired
    }


}




public class TrustMemberCreate: Codable {







    /** Trustee User or Group Id */
    public var _id: String?
    /** The list of roles to be granted to this user or group. Roles will be granted in all divisions. */
    public var roleIds: [String]?
    /** The list of trustor organization roles granting this user or group access paired with the divisions for those roles. */
    public var roleDivisions: RoleDivisionGrants?

    public init(_id: String?, roleIds: [String]?, roleDivisions: RoleDivisionGrants?) {
        self._id = _id
        self.roleIds = roleIds
        self.roleDivisions = roleDivisions
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case roleIds
        case roleDivisions
    }


}




public class TrustRequestCreate: Codable {





    /** The list of trustee users that are requesting access. If no users are specified, at least one group is required. */
    public var userIds: [String]?
    /** The list of trustee groups that are requesting access. If no groups are specified, at least one user is required. */
    public var groupIds: [String]?

    public init(userIds: [String]?, groupIds: [String]?) {
        self.userIds = userIds
        self.groupIds = groupIds
    }


}




public class TrustUpdate: Codable {





    /** If disabled no trustee user will have access, even if they were previously added. */
    public var enabled: Bool?
    /** The expiration date of the trust. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateExpired: Date?

    public init(enabled: Bool?, dateExpired: Date?) {
        self.enabled = enabled
        self.dateExpired = dateExpired
    }


}




public class UCI10n: Codable {



    public var name: String?

    public init(name: String?) {
        self.name = name
    }


}




public class TweetUsage: Codable {







    /** Ingestion limit */
    public var ingestionLimit: Int64?
    /** The number of tweets consumed */
    public var tweetCount: Int64?
    /** The start of the usage period for the currently consumed tweets. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateStart: Date?

    public init(ingestionLimit: Int64?, tweetCount: Int64?, dateStart: Date?) {
        self.ingestionLimit = ingestionLimit
        self.tweetCount = tweetCount
        self.dateStart = dateStart
    }


}




public class TwitterDataIngestionRuleResponse: Codable {







    public enum Status: String, Codable { 
        case active = "Active"
        case deleted = "Deleted"
        case error = "Error"
        case paused = "Paused"
        case pending = "Pending"
        case systemPaused = "SystemPaused"
    }















    /** ID of the data ingestion rule. */
    public var _id: String?
    /** The name of the data ingestion rule. */
    public var name: String?
    /** A description of the data ingestion rule. */
    public var _description: String?
    /** The status of the data ingestion rule. */
    public var status: Status?
    /** The version number of the data ingestion rule. */
    public var version: Int?
    /** Timestamp indicating when the data ingestion rule was created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** Timestamp indicating when the data ingestion rule was last updated. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** The platform of the data ingestion rule. */
    public var platform: String?
    /** ISO 3166-1 alpha-2 country codes where Data Ingestion Rules should apply. Defaults to worldwide. */
    public var countries: [String]?
    /** Search terms for X (formally Twitter). */
    public var searchTerms: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, _description: String?, status: Status?, version: Int?, dateCreated: Date?, dateModified: Date?, platform: String?, countries: [String]?, searchTerms: String?, selfUri: String?) {
        self._id = _id
        self.name = name
        self._description = _description
        self.status = status
        self.version = version
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.platform = platform
        self.countries = countries
        self.searchTerms = searchTerms
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case _description = "description"
        case status
        case version
        case dateCreated
        case dateModified
        case platform
        case countries
        case searchTerms
        case selfUri
    }


}




public class TwitterIntegrationUpdateRequest: Codable {

















    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The name of the Twitter messaging integration. */
    public var name: String?
    /** Defines the SupportedContent profile configured for an integration */
    public var supportedContent: SupportedContentReference?
    /** Defines the message settings to be applied for this integration */
    public var messagingSetting: MessagingSettingRequestReference?
    /** The authorization code returned from the signup flow to request access tokens later on */
    public var signupCode: String?
    /** The codeChallenge used during the signup flow */
    public var codeChallenge: String?
    /** The redirectUri used during the signup flow */
    public var redirectUri: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, supportedContent: SupportedContentReference?, messagingSetting: MessagingSettingRequestReference?, signupCode: String?, codeChallenge: String?, redirectUri: String?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.supportedContent = supportedContent
        self.messagingSetting = messagingSetting
        self.signupCode = signupCode
        self.codeChallenge = codeChallenge
        self.redirectUri = redirectUri
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case supportedContent
        case messagingSetting
        case signupCode
        case codeChallenge
        case redirectUri
        case selfUri
    }


}




public class UnansweredGroup: Codable {













    /** The globally unique identifier for the object. */
    public var _id: String?
    /** Knowledge base unanswered group label */
    public var label: String?
    /** Represents a list of phrase groups inside an unanswered group */
    public var phraseGroups: [UnansweredPhraseGroup]?
    /** Represents a list of documents that may be linked to an unanswered group */
    public var suggestedDocuments: [UnansweredGroupSuggestedDocument]?
    /** Statistics object containing the various hit counts for an unanswered group */
    public var statistics: KnowledgeGroupStatistics?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, label: String?, phraseGroups: [UnansweredPhraseGroup]?, suggestedDocuments: [UnansweredGroupSuggestedDocument]?, statistics: KnowledgeGroupStatistics?, selfUri: String?) {
        self._id = _id
        self.label = label
        self.phraseGroups = phraseGroups
        self.suggestedDocuments = suggestedDocuments
        self.statistics = statistics
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case label
        case phraseGroups
        case suggestedDocuments
        case statistics
        case selfUri
    }


}




public class UnansweredGroupSuggestedDocument: Codable {





    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, selfUri: String?) {
        self._id = _id
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
    }


}




public class UnansweredGroups: Codable {



    public var entities: [UnansweredGroup]?

    public init(entities: [UnansweredGroup]?) {
        self.entities = entities
    }


}




public class UnansweredPhraseGroupPatchRequestBody: Codable {







    /** List of phrases and documents to be linked */
    public var phraseAssociations: [PhraseAssociations]?
    /** The start date to be used for filtering phrases. Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd */
    public var dateStart: Date?
    /** The end date to be used for filtering phrases. Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd */
    public var dateEnd: Date?

    public init(phraseAssociations: [PhraseAssociations]?, dateStart: Date?, dateEnd: Date?) {
        self.phraseAssociations = phraseAssociations
        self.dateStart = dateStart
        self.dateEnd = dateEnd
    }


}




public class UpdateAgentWorkPlanBiddingPreference: Codable {





    /** Whether the preference is submitted */
    public var submitted: Bool?
    /** The list of work plan bidding preferences */
    public var agentWorkPlanBidPreferences: [AgentWorkPlanBiddingPreferenceRequest]?

    public init(submitted: Bool?, agentWorkPlanBidPreferences: [AgentWorkPlanBiddingPreferenceRequest]?) {
        self.submitted = submitted
        self.agentWorkPlanBidPreferences = agentWorkPlanBidPreferences
    }


}




public class UpdateAnalyticsDataRetentionRequest: Codable {



    /** Analytics data retention period in days to set for the organization. */
    public var retentionDays: Int?

    public init(retentionDays: Int?) {
        self.retentionDays = retentionDays
    }


}




public class UpdateConferenceRequest: Codable {



    /** A list of conversations to merge into this conversation to create a conference. */
    public var conversationIds: [String]?

    public init(conversationIds: [String]?) {
        self.conversationIds = conversationIds
    }


}




public class UpdateRowIndexRequest: Codable {





    /** The row UUID. */
    public var rowId: String?
    /** The updated row index. Must be an integer value greater than or equal to 1. Must be less than or equal to x, where x is the number of rows in the decision table version. */
    public var rowIndex: Int?

    public init(rowId: String?, rowIndex: Int?) {
        self.rowId = rowId
        self.rowIndex = rowIndex
    }


}




public class UpdateServiceGoalTemplate: Codable {













    /** The name of the service goal template. */
    public var name: String?
    /** Service level targets for this service goal template */
    public var serviceLevel: BuServiceLevel?
    /** Average speed of answer targets for this service goal template */
    public var averageSpeedOfAnswer: BuAverageSpeedOfAnswer?
    /** Abandon rate targets for this service goal template */
    public var abandonRate: BuAbandonRate?
    /** Version metadata for the service goal template */
    public var metadata: WfmVersionedEntityMetadata?
    /** Settings controlling max percent increase and decrease of service goals for this service goal template */
    public var impactOverride: ServiceGoalTemplateImpactOverride?

    public init(name: String?, serviceLevel: BuServiceLevel?, averageSpeedOfAnswer: BuAverageSpeedOfAnswer?, abandonRate: BuAbandonRate?, metadata: WfmVersionedEntityMetadata?, impactOverride: ServiceGoalTemplateImpactOverride?) {
        self.name = name
        self.serviceLevel = serviceLevel
        self.averageSpeedOfAnswer = averageSpeedOfAnswer
        self.abandonRate = abandonRate
        self.metadata = metadata
        self.impactOverride = impactOverride
    }


}




public class UpdateTimeOffPlanBusinessUnitAssociation: Codable {





    /** The IDs of management units to which this time-off plan applies. This must not be set if staffingGroupIds is populated */
    public var managementUnitIds: SetWrapperString?
    /** The IDs of staffing groups to which this time-off plan applies. This must not be set if managementUnitIds is populated */
    public var staffingGroupIds: SetWrapperString?

    public init(managementUnitIds: SetWrapperString?, staffingGroupIds: SetWrapperString?) {
        self.managementUnitIds = managementUnitIds
        self.staffingGroupIds = staffingGroupIds
    }


}




public class UpdatedSettingsResponse: Codable {



    public var message: String?

    public init(message: String?) {
        self.message = message
    }


}




public class UploadUrlResponse: Codable {







    /** Presigned URL to PUT the file to */
    public var url: String?
    /** Key that identifies the file in the storage including the file name */
    public var uploadKey: String?
    /** Required headers when uploading a file through PUT request to the URL */
    public var headers: [String:String]?

    public init(url: String?, uploadKey: String?, headers: [String:String]?) {
        self.url = url
        self.uploadKey = uploadKey
        self.headers = headers
    }


}




public class UrlCondition: Codable {



    public enum Operator: String, Codable { 
        case containsall = "containsAll"
        case containsany = "containsAny"
        case notcontainsall = "notContainsAll"
        case notcontainsany = "notContainsAny"
        case equal = "equal"
        case notequal = "notEqual"
        case greaterthan = "greaterThan"
        case greaterthanorequal = "greaterThanOrEqual"
        case lessthan = "lessThan"
        case lessthanorequal = "lessThanOrEqual"
        case startswith = "startsWith"
        case endswith = "endsWith"
    }

    /** The URL condition value. */
    public var values: [String]?
    /** The comparison operator. */
    public var _operator: Operator?

    public init(values: [String]?, _operator: Operator?) {
        self.values = values
        self._operator = _operator
    }

    public enum CodingKeys: String, CodingKey { 
        case values
        case _operator = "operator"
    }


}




public class UserActivityQueryPredicate: Codable {

    public enum ModelType: String, Codable { 
        case dimension = "dimension"
        case property = "property"
        case metric = "metric"
    }

    public enum Dimension: String, Codable { 
        case organizationpresenceid = "organizationPresenceId"
        case presencedate = "presenceDate"
        case queueid = "queueId"
        case queuemembershipstatus = "queueMembershipStatus"
        case routingstatus = "routingStatus"
        case routingstatusdate = "routingStatusDate"
        case systempresence = "systemPresence"
        case teamid = "teamId"
        case userid = "userId"
    }

    public enum Operator: String, Codable { 
        case matches = "matches"
        case exists = "exists"
        case notexists = "notExists"
    }



    /** Optional type, can usually be inferred */
    public var type: ModelType?
    /** Left hand side for dimension predicates */
    public var dimension: Dimension?
    /** Optional operator, default is matches */
    public var _operator: Operator?
    /** Right hand side for dimension predicates */
    public var value: String?

    public init(type: ModelType?, dimension: Dimension?, _operator: Operator?, value: String?) {
        self.type = type
        self.dimension = dimension
        self._operator = _operator
        self.value = value
    }

    public enum CodingKeys: String, CodingKey { 
        case type
        case dimension
        case _operator = "operator"
        case value
    }


}




public class UserActivityResponse: Codable {



    public enum EntityIdDimension: String, Codable { 
        case organizationpresenceid = "organizationPresenceId"
        case presencedate = "presenceDate"
        case queueid = "queueId"
        case queuemembershipstatus = "queueMembershipStatus"
        case routingstatus = "routingStatus"
        case routingstatusdate = "routingStatusDate"
        case systempresence = "systemPresence"
        case teamid = "teamId"
        case userid = "userId"
    }

    /** Query results */
    public var results: [UserActivityData]?
    /** Dimension that is used as an entityId */
    public var entityIdDimension: EntityIdDimension?

    public init(results: [UserActivityData]?, entityIdDimension: EntityIdDimension?) {
        self.results = results
        self.entityIdDimension = entityIdDimension
    }


}




public class UserAggregateDataContainer: Codable {





    /** A mapping from dimension to value */
    public var group: [String:String]?
    public var data: [StatisticalResponse]?

    public init(group: [String:String]?, data: [StatisticalResponse]?) {
        self.group = group
        self.data = data
    }


}




public class UserAggregateQueryClause: Codable {

    public enum ModelType: String, Codable { 
        case and = "and"
        case or = "or"
    }



    /** Boolean operation to apply to the provided predicates */
    public var type: ModelType?
    /** Like a three-word sentence: (attribute-name) (operator) (target-value). */
    public var predicates: [UserAggregateQueryPredicate]?

    public init(type: ModelType?, predicates: [UserAggregateQueryPredicate]?) {
        self.type = type
        self.predicates = predicates
    }


}




public class UserAggregationQuery: Codable {







    public enum GroupBy: String, Codable { 
        case userid = "userId"
    }



    public enum Metrics: String, Codable { 
        case tagentroutingstatus = "tAgentRoutingStatus"
        case torganizationpresence = "tOrganizationPresence"
        case tsystempresence = "tSystemPresence"
    }





    public enum AlternateTimeDimension: String, Codable { 
        case eventtime = "eventTime"
    }

    /** Behaves like one clause in a SQL WHERE. Specifies the date and time range of data being queried. Intervals are represented as an ISO-8601 string. For example: YYYY-MM-DDThh:mm:ss/YYYY-MM-DDThh:mm:ss */
    public var interval: String?
    /** Granularity aggregates metrics into subpartitions within the time interval specified. The default granularity is the same duration as the interval. Periods are represented as an ISO-8601 string. For example: P1D or P1DT12H */
    public var granularity: String?
    /** Time zone context used to calculate response intervals (this allows resolving DST changes). The interval offset is used even when timeZone is specified. Default is UTC. Time zones are represented as a string of the zone name as found in the IANA time zone database. For example: UTC, Etc/UTC, or Europe/London */
    public var timeZone: String?
    /** Behaves like a SQL GROUPBY. Allows for multiple levels of grouping as a list of dimensions. Partitions resulting aggregate computations into distinct named subgroups rather than across the entire result set as if it were one group. */
    public var groupBy: [GroupBy]?
    /** Behaves like a SQL WHERE clause. This is ANDed with the interval parameter. Expresses boolean logical predicates as well as dimensional filters */
    public var filter: UserAggregateQueryFilter?
    /** Behaves like a SQL SELECT clause. Only named metrics will be retrieved. */
    public var metrics: [Metrics]?
    /** Flattens any multivalued dimensions used in response groups (e.g. ['a','b','c']->'a,b,c') */
    public var flattenMultivaluedDimensions: Bool?
    /** Custom derived metric views */
    public var views: [UserAggregationView]?
    /** Dimension to use as the alternative timestamp for data in the aggregate.  Choosing \"eventTime\" uses the actual time of the data event. */
    public var alternateTimeDimension: AlternateTimeDimension?

    public init(interval: String?, granularity: String?, timeZone: String?, groupBy: [GroupBy]?, filter: UserAggregateQueryFilter?, metrics: [Metrics]?, flattenMultivaluedDimensions: Bool?, views: [UserAggregationView]?, alternateTimeDimension: AlternateTimeDimension?) {
        self.interval = interval
        self.granularity = granularity
        self.timeZone = timeZone
        self.groupBy = groupBy
        self.filter = filter
        self.metrics = metrics
        self.flattenMultivaluedDimensions = flattenMultivaluedDimensions
        self.views = views
        self.alternateTimeDimension = alternateTimeDimension
    }


}




public class UserDetailQueryPredicate: Codable {

    public enum ModelType: String, Codable { 
        case dimension = "dimension"
        case property = "property"
        case metric = "metric"
    }

    public enum Dimension: String, Codable { 
        case userid = "userId"
    }

    public enum Operator: String, Codable { 
        case matches = "matches"
        case exists = "exists"
        case notexists = "notExists"
    }





    /** Optional type, can usually be inferred */
    public var type: ModelType?
    /** Left hand side for dimension predicates */
    public var dimension: Dimension?
    /** Optional operator, default is matches */
    public var _operator: Operator?
    /** Right hand side for dimension predicates */
    public var value: String?
    /** Right hand side for dimension predicates */
    public var range: NumericRange?

    public init(type: ModelType?, dimension: Dimension?, _operator: Operator?, value: String?, range: NumericRange?) {
        self.type = type
        self.dimension = dimension
        self._operator = _operator
        self.value = value
        self.range = range
    }

    public enum CodingKeys: String, CodingKey { 
        case type
        case dimension
        case _operator = "operator"
        case value
        case range
    }


}




public class UserDevice: Codable {















    public enum ModelType: String, Codable { 
        case android = "android"
        case ios = "ios"
    }





    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** device token sent by mobile clients. */
    public var deviceToken: String?
    /** notification id of the device. */
    public var notificationId: String?
    /** make of the device. */
    public var make: String?
    /** Device model */
    public var model: String?
    /** if the device accepts notifications */
    public var acceptNotifications: Bool?
    /** type of the device; ios or android */
    public var type: ModelType?
    public var sessionHash: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, deviceToken: String?, notificationId: String?, make: String?, model: String?, acceptNotifications: Bool?, type: ModelType?, sessionHash: String?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.deviceToken = deviceToken
        self.notificationId = notificationId
        self.make = make
        self.model = model
        self.acceptNotifications = acceptNotifications
        self.type = type
        self.sessionHash = sessionHash
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case deviceToken
        case notificationId
        case make
        case model
        case acceptNotifications
        case type
        case sessionHash
        case selfUri
    }


}




public class UserEndDetailEventTopicUserEndEvent: Codable {









    public enum DisconnectType: String, Codable { 
        case unknown = "UNKNOWN"
        case endpoint = "ENDPOINT"
        case client = "CLIENT"
        case system = "SYSTEM"
        case transfer = "TRANSFER"
        case error = "ERROR"
        case peer = "PEER"
        case other = "OTHER"
        case spam = "SPAM"
        case timeout = "TIMEOUT"
        case transportFailure = "TRANSPORT_FAILURE"
        case conferenceTransfer = "CONFERENCE_TRANSFER"
        case consultTransfer = "CONSULT_TRANSFER"
        case forwardTransfer = "FORWARD_TRANSFER"
        case noAnswerTransfer = "NO_ANSWER_TRANSFER"
        case notAvailableTransfer = "NOT_AVAILABLE_TRANSFER"
        case uncallable = "UNCALLABLE"
        case dndEndpoint = "DND_ENDPOINT"
        case dndTransfer = "DND_TRANSFER"
        case inactivity = "INACTIVITY"
        case sessionExpired = "SESSION_EXPIRED"
    }

    public enum MediaType: String, Codable { 
        case unknown = "UNKNOWN"
        case voice = "VOICE"
        case chat = "CHAT"
        case email = "EMAIL"
        case callback = "CALLBACK"
        case cobrowse = "COBROWSE"
        case video = "VIDEO"
        case screenshare = "SCREENSHARE"
        case message = "MESSAGE"
        case internalmessage = "INTERNALMESSAGE"
        case screenmonitoring = "SCREENMONITORING"
    }



    public enum Direction: String, Codable { 
        case unknown = "UNKNOWN"
        case inbound = "INBOUND"
        case outbound = "OUTBOUND"
    }

















    public enum MessageType: String, Codable { 
        case unknown = "UNKNOWN"
        case sms = "SMS"
        case twitter = "TWITTER"
        case facebook = "FACEBOOK"
        case line = "LINE"
        case whatsapp = "WHATSAPP"
        case webmessaging = "WEBMESSAGING"
        case _open = "OPEN"
        case instagram = "INSTAGRAM"
        case apple = "APPLE"
    }























    public var eventTime: Int64?
    public var conversationId: String?
    public var participantId: String?
    public var sessionId: String?
    public var disconnectType: DisconnectType?
    public var mediaType: MediaType?
    public var provider: String?
    public var direction: Direction?
    public var ani: String?
    public var dnis: String?
    public var addressTo: String?
    public var addressFrom: String?
    public var callbackUserName: String?
    public var callbackNumbers: [String]?
    public var callbackScheduledTime: Int64?
    public var subject: String?
    public var messageType: MessageType?
    public var userId: String?
    public var divisionId: String?
    public var queueId: String?
    public var interactingDurationMs: Int64?
    public var heldDurationMs: Int64?
    public var alertingDurationMs: Int64?
    public var contactingDurationMs: Int64?
    public var dialingDurationMs: Int64?
    public var callbackDurationMs: Int64?
    public var conversationExternalContactIds: [String]?
    public var conversationExternalOrganizationIds: [String]?

    public init(eventTime: Int64?, conversationId: String?, participantId: String?, sessionId: String?, disconnectType: DisconnectType?, mediaType: MediaType?, provider: String?, direction: Direction?, ani: String?, dnis: String?, addressTo: String?, addressFrom: String?, callbackUserName: String?, callbackNumbers: [String]?, callbackScheduledTime: Int64?, subject: String?, messageType: MessageType?, userId: String?, divisionId: String?, queueId: String?, interactingDurationMs: Int64?, heldDurationMs: Int64?, alertingDurationMs: Int64?, contactingDurationMs: Int64?, dialingDurationMs: Int64?, callbackDurationMs: Int64?, conversationExternalContactIds: [String]?, conversationExternalOrganizationIds: [String]?) {
        self.eventTime = eventTime
        self.conversationId = conversationId
        self.participantId = participantId
        self.sessionId = sessionId
        self.disconnectType = disconnectType
        self.mediaType = mediaType
        self.provider = provider
        self.direction = direction
        self.ani = ani
        self.dnis = dnis
        self.addressTo = addressTo
        self.addressFrom = addressFrom
        self.callbackUserName = callbackUserName
        self.callbackNumbers = callbackNumbers
        self.callbackScheduledTime = callbackScheduledTime
        self.subject = subject
        self.messageType = messageType
        self.userId = userId
        self.divisionId = divisionId
        self.queueId = queueId
        self.interactingDurationMs = interactingDurationMs
        self.heldDurationMs = heldDurationMs
        self.alertingDurationMs = alertingDurationMs
        self.contactingDurationMs = contactingDurationMs
        self.dialingDurationMs = dialingDurationMs
        self.callbackDurationMs = callbackDurationMs
        self.conversationExternalContactIds = conversationExternalContactIds
        self.conversationExternalOrganizationIds = conversationExternalOrganizationIds
    }


}




public class UserEntityListing: Codable {





















    public var entities: [User]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var previousUri: String?
    public var nextUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [User]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, previousUri: String?, nextUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.previousUri = previousUri
        self.nextUri = nextUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class UserEstablishedEvent: Codable {



























    /** A unique (V4 UUID) eventId for this event */
    public var eventId: String?
    /** A Date Time representing the time this event occurred. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var eventDateTime: Date?
    /** A unique Id (V4 UUID) identifying this conversation */
    public var conversationId: String?
    /** A unique Id (V4 UUID) identifying this communication */
    public var communicationId: String?
    /** Identifies the phone number used to reach this user if it is different from the information that would be accessed by userId. */
    public var phoneNumber: String?
    /** The userId (V4 UUID) for the user this communication belongs to. */
    public var userId: String?
    /** A Station ID (V4 UUID) that identifies the station being used if the user is using a station and the stationId is known. */
    public var stationId: String?
    /** The automatic number identification if it is available for this conversation. */
    public var ani: String?
    /** The dialed number identification if it is available for this conversation. */
    public var dnis: String?
    /** Indicates whether or not this user will be required to complete after call work. */
    public var afterCallWorkRequired: Bool?
    /** The id (V4 UUID) of the queue that the user is calling on behalf of. Applies to outbound calls only. */
    public var queueId: String?
    /** Metadata about this communication. */
    public var initialConfiguration: InitialConfiguration?
    /** Metadata about the source of this communication's interaction. */
    public var sourceConfiguration: SourceConfiguration?

    public init(eventId: String?, eventDateTime: Date?, conversationId: String?, communicationId: String?, phoneNumber: String?, userId: String?, stationId: String?, ani: String?, dnis: String?, afterCallWorkRequired: Bool?, queueId: String?, initialConfiguration: InitialConfiguration?, sourceConfiguration: SourceConfiguration?) {
        self.eventId = eventId
        self.eventDateTime = eventDateTime
        self.conversationId = conversationId
        self.communicationId = communicationId
        self.phoneNumber = phoneNumber
        self.userId = userId
        self.stationId = stationId
        self.ani = ani
        self.dnis = dnis
        self.afterCallWorkRequired = afterCallWorkRequired
        self.queueId = queueId
        self.initialConfiguration = initialConfiguration
        self.sourceConfiguration = sourceConfiguration
    }


}



/** Defines a link between an External Identifier and Authority pair to a Entity Type and Entity Identifier pair. Represents the two way, one to one mapping of an External Authority or System of Record's identifier to a PureCloud entity. e.g. (ExternalId='05001',Authority='XyzCRM') to (entityType=user,entityId='8eb03b33-3acb-4bc1-a244-50b9b9f19495') */

public class UserExternalIdentifier: Codable {







    /** Authority or System of Record which owns the External Identifier */
    public var authorityName: String?
    /** External Key */
    public var externalKey: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(authorityName: String?, externalKey: String?, selfUri: String?) {
        self.authorityName = authorityName
        self.externalKey = externalKey
        self.selfUri = selfUri
    }


}




public class UserLicenses: Codable {







    /** The globally unique identifier for the object. */
    public var _id: String?
    public var licenses: [String]?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, licenses: [String]?, selfUri: String?) {
        self._id = _id
        self.licenses = licenses
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case licenses
        case selfUri
    }


}




public class UserNextActivityReminder: Codable {

    public enum ActivityCategory: String, Codable { 
        case onQueueWork = "OnQueueWork"
        case _break = "Break"
        case meal = "Meal"
        case meeting = "Meeting"
        case offQueueWork = "OffQueueWork"
        case timeOff = "TimeOff"
        case training = "Training"
        case unavailable = "Unavailable"
        case unscheduled = "Unscheduled"
    }



    /** Upcoming activity for which the user is scheduled */
    public var activityCategory: ActivityCategory?
    /** The start timestamp of the scheduled activity in ISO-8601 format */
    public var startDate: Date?

    public init(activityCategory: ActivityCategory?, startDate: Date?) {
        self.activityCategory = activityCategory
        self.startDate = startDate
    }


}




public class UserObservationQueryFilter: Codable {

    public enum ModelType: String, Codable { 
        case and = "and"
        case or = "or"
    }





    /** Boolean operation to apply to the provided predicates and clauses */
    public var type: ModelType?
    /** Boolean 'and/or' logic with up to two-levels of nesting */
    public var clauses: [UserObservationQueryClause]?
    /** Like a three-word sentence: (attribute-name) (operator) (target-value). */
    public var predicates: [UserObservationQueryPredicate]?

    public init(type: ModelType?, clauses: [UserObservationQueryClause]?, predicates: [UserObservationQueryPredicate]?) {
        self.type = type
        self.clauses = clauses
        self.predicates = predicates
    }


}




public class UserParam: Codable {





    public var key: String?
    public var value: String?

    public init(key: String?, value: String?) {
        self.key = key
        self.value = value
    }


}




public class UserQueue: Codable {

































    public enum ScoringMethod: String, Codable { 
        case timestampAndPriority = "TimestampAndPriority"
        case priorityOnly = "PriorityOnly"
    }

    public enum LastAgentRoutingMode: String, Codable { 
        case disabled = "Disabled"
        case queueMembersOnly = "QueueMembersOnly"
        case anyAgent = "AnyAgent"
    }



    public enum SkillEvaluationMethod: String, Codable { 
        case _none = "NONE"
        case best = "BEST"
        case all = "ALL"
    }











































    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** The division to which this entity belongs. */
    public var division: Division?
    /** The queue description. */
    public var _description: String?
    /** The date the queue was created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** The date of the last modification to the queue. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** The ID of the user that last modified the queue. */
    public var modifiedBy: String?
    /** The ID of the user that created the queue. */
    public var createdBy: String?
    /** The total number of members in the queue. */
    public var memberCount: Int?
    /** The number of user members (i.e., non-group members) in the queue. */
    public var userMemberCount: Int?
    /** The number of joined members in the queue. */
    public var joinedMemberCount: Int?
    /** The media settings for the queue. */
    public var mediaSettings: QueueMediaSettings?
    /** The routing rules for the queue, used for Preferred Agent Routing. */
    public var routingRules: [RoutingRule]?
    /** The Conditional Group Routing settings for the queue. */
    public var conditionalGroupRouting: ConditionalGroupRouting?
    /** The Conditional Group Activation settings for the queue. */
    public var conditionalGroupActivation: ConditionalGroupActivation?
    /** The bullseye settings for the queue. */
    public var bullseye: Bullseye?
    /** The Scoring Method for the queue. */
    public var scoringMethod: ScoringMethod?
    /** The Last Agent Routing Mode for the queue. */
    public var lastAgentRoutingMode: LastAgentRoutingMode?
    /** The ACW settings for the queue. */
    public var acwSettings: AcwSettings?
    /** The skill evaluation method to use when routing conversations. */
    public var skillEvaluationMethod: SkillEvaluationMethod?
    /** The groups of agents associated with the queue, if any.  Queue membership will update to match group membership changes. */
    public var memberGroups: [MemberGroup]?
    /** The in-queue flow to use for call conversations waiting in queue. */
    public var queueFlow: DomainEntityRef?
    /** The in-queue flow to use for email conversations waiting in queue. */
    public var emailInQueueFlow: DomainEntityRef?
    /** The in-queue flow to use for message conversations waiting in queue. */
    public var messageInQueueFlow: DomainEntityRef?
    /** The prompt used for whisper on the queue, if configured. */
    public var whisperPrompt: DomainEntityRef?
    /** The audio to be played when calls on this queue are on hold. If not configured, the default on-hold music will play. */
    public var onHoldPrompt: DomainEntityRef?
    /** Canned response library IDs and mode with which they are associated with the queue */
    public var cannedResponseLibraries: CannedResponseLibraries?
    /** Indicates whether voice transcription is enabled for this queue. */
    public var enableTranscription: Bool?
    /** Indicates whether audio monitoring is enabled for this queue. */
    public var enableAudioMonitoring: Bool?
    /** Indicates whether manual assignment is enabled for this queue. */
    public var enableManualAssignment: Bool?
    /** The Agent Owned Routing settings for the queue */
    public var agentOwnedRouting: AgentOwnedRouting?
    /** The Direct Routing settings for the queue */
    public var directRouting: DirectRouting?
    /** The name to use for caller identification for outbound calls from this queue. */
    public var callingPartyName: String?
    /** The phone number to use for caller identification for outbound calls from this queue. */
    public var callingPartyNumber: String?
    /** The default script Ids for the communication types. */
    public var defaultScripts: [String:Script]?
    /** The messaging addresses for the queue. */
    public var outboundMessagingAddresses: QueueMessagingAddresses?
    /** The default email address to use for outbound email from this queue. */
    public var outboundEmailAddress: QueueEmailAddress?
    /** The ID of an associated external queue. */
    public var peerId: String?
    /** Indicates whether recording in-queue calls is suppressed for this queue. */
    public var suppressInQueueCallRecording: Bool?
    public var joined: Bool?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, division: Division?, _description: String?, dateCreated: Date?, dateModified: Date?, modifiedBy: String?, createdBy: String?, memberCount: Int?, userMemberCount: Int?, joinedMemberCount: Int?, mediaSettings: QueueMediaSettings?, routingRules: [RoutingRule]?, conditionalGroupRouting: ConditionalGroupRouting?, conditionalGroupActivation: ConditionalGroupActivation?, bullseye: Bullseye?, scoringMethod: ScoringMethod?, lastAgentRoutingMode: LastAgentRoutingMode?, acwSettings: AcwSettings?, skillEvaluationMethod: SkillEvaluationMethod?, memberGroups: [MemberGroup]?, queueFlow: DomainEntityRef?, emailInQueueFlow: DomainEntityRef?, messageInQueueFlow: DomainEntityRef?, whisperPrompt: DomainEntityRef?, onHoldPrompt: DomainEntityRef?, cannedResponseLibraries: CannedResponseLibraries?, enableTranscription: Bool?, enableAudioMonitoring: Bool?, enableManualAssignment: Bool?, agentOwnedRouting: AgentOwnedRouting?, directRouting: DirectRouting?, callingPartyName: String?, callingPartyNumber: String?, defaultScripts: [String:Script]?, outboundMessagingAddresses: QueueMessagingAddresses?, outboundEmailAddress: QueueEmailAddress?, peerId: String?, suppressInQueueCallRecording: Bool?, joined: Bool?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.division = division
        self._description = _description
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.modifiedBy = modifiedBy
        self.createdBy = createdBy
        self.memberCount = memberCount
        self.userMemberCount = userMemberCount
        self.joinedMemberCount = joinedMemberCount
        self.mediaSettings = mediaSettings
        self.routingRules = routingRules
        self.conditionalGroupRouting = conditionalGroupRouting
        self.conditionalGroupActivation = conditionalGroupActivation
        self.bullseye = bullseye
        self.scoringMethod = scoringMethod
        self.lastAgentRoutingMode = lastAgentRoutingMode
        self.acwSettings = acwSettings
        self.skillEvaluationMethod = skillEvaluationMethod
        self.memberGroups = memberGroups
        self.queueFlow = queueFlow
        self.emailInQueueFlow = emailInQueueFlow
        self.messageInQueueFlow = messageInQueueFlow
        self.whisperPrompt = whisperPrompt
        self.onHoldPrompt = onHoldPrompt
        self.cannedResponseLibraries = cannedResponseLibraries
        self.enableTranscription = enableTranscription
        self.enableAudioMonitoring = enableAudioMonitoring
        self.enableManualAssignment = enableManualAssignment
        self.agentOwnedRouting = agentOwnedRouting
        self.directRouting = directRouting
        self.callingPartyName = callingPartyName
        self.callingPartyNumber = callingPartyNumber
        self.defaultScripts = defaultScripts
        self.outboundMessagingAddresses = outboundMessagingAddresses
        self.outboundEmailAddress = outboundEmailAddress
        self.peerId = peerId
        self.suppressInQueueCallRecording = suppressInQueueCallRecording
        self.joined = joined
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case division
        case _description = "description"
        case dateCreated
        case dateModified
        case modifiedBy
        case createdBy
        case memberCount
        case userMemberCount
        case joinedMemberCount
        case mediaSettings
        case routingRules
        case conditionalGroupRouting
        case conditionalGroupActivation
        case bullseye
        case scoringMethod
        case lastAgentRoutingMode
        case acwSettings
        case skillEvaluationMethod
        case memberGroups
        case queueFlow
        case emailInQueueFlow
        case messageInQueueFlow
        case whisperPrompt
        case onHoldPrompt
        case cannedResponseLibraries
        case enableTranscription
        case enableAudioMonitoring
        case enableManualAssignment
        case agentOwnedRouting
        case directRouting
        case callingPartyName
        case callingPartyNumber
        case defaultScripts
        case outboundMessagingAddresses
        case outboundEmailAddress
        case peerId
        case suppressInQueueCallRecording
        case joined
        case selfUri
    }


}




public class UserRecordingEntityListing: Codable {





















    public var entities: [UserRecording]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var previousUri: String?
    public var nextUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [UserRecording]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, previousUri: String?, nextUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.previousUri = previousUri
        self.nextUri = nextUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}



/** Represents an organization skill assigned to a user. When assigning to a user specify the organization skill id as the id. */

public class UserRoutingSkillPost: Codable {









    /** The id of the existing routing skill to add to the user */
    public var _id: String?
    /** Proficiency is a rating from 0.0 to 5.0 on how competent an agent is for a particular skill. It is used when a queue is set to \"Best available skills\" mode to allow acd interactions to target agents with higher proficiency ratings. */
    public var proficiency: Double?
    /** URI to the organization skill used by this user skill. */
    public var skillUri: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, proficiency: Double?, skillUri: String?, selfUri: String?) {
        self._id = _id
        self.proficiency = proficiency
        self.skillUri = skillUri
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case proficiency
        case skillUri
        case selfUri
    }


}




public class UserRoutingStatusEvent: Codable {







    public enum Status: String, Codable { 
        case offQueue = "OffQueue"
        case idle = "Idle"
        case interacting = "Interacting"
        case communicating = "Communicating"
        case notResponding = "NotResponding"
    }



    /** A unique (UUID) eventId for this event */
    public var eventId: String?
    /** A timestamp as epoch representing the time this event occurred. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var eventDateTime: Date?
    /** Unique identifier of the agent. */
    public var agentId: String?
    /** The agent's current routing status. */
    public var status: Status?
    /** The agent's source platform Id. */
    public var sourceId: String?

    public init(eventId: String?, eventDateTime: Date?, agentId: String?, status: Status?, sourceId: String?) {
        self.eventId = eventId
        self.eventDateTime = eventDateTime
        self.agentId = agentId
        self.status = status
        self.sourceId = sourceId
    }


}




public class UserSearchCriteria: Codable {









    public enum Operator: String, Codable { 
        case and = "AND"
        case or = "OR"
        case not = "NOT"
    }







    public enum ModelType: String, Codable { 
        case exact = "EXACT"
        case startsWith = "STARTS_WITH"
        case contains = "CONTAINS"
        case regex = "REGEX"
        case term = "TERM"
        case terms = "TERMS"
        case requiredFields = "REQUIRED_FIELDS"
        case matchAll = "MATCH_ALL"
        case queryString = "QUERY_STRING"
    }

    /** The end value of the range. This field is used for range search types. */
    public var endValue: String?
    /** A list of values for the search to match against */
    public var values: [String]?
    /** The start value of the range. This field is used for range search types. */
    public var startValue: String?
    /** A value for the search to match against */
    public var value: String?
    /** How to apply this search criteria against other criteria */
    public var _operator: Operator?
    /** Groups multiple conditions */
    public var group: [UserSearchCriteria]?
    /** Set date format for criteria values when using date range search type.  Supports Java date format syntax, example yyyy-MM-dd'T'HH:mm:ss.SSSX. */
    public var dateFormat: String?
    /** Field names to search against */
    public var fields: [String]?
    /** Search Type */
    public var type: ModelType?

    public init(endValue: String?, values: [String]?, startValue: String?, value: String?, _operator: Operator?, group: [UserSearchCriteria]?, dateFormat: String?, fields: [String]?, type: ModelType?) {
        self.endValue = endValue
        self.values = values
        self.startValue = startValue
        self.value = value
        self._operator = _operator
        self.group = group
        self.dateFormat = dateFormat
        self.fields = fields
        self.type = type
    }

    public enum CodingKeys: String, CodingKey { 
        case endValue
        case values
        case startValue
        case value
        case _operator = "operator"
        case group
        case dateFormat
        case fields
        case type
    }


}




public class UserTokensTopicTokenNotification: Codable {















    public var user: UserTokensTopicUriReference?
    public var ipAddress: String?
    public var dateCreated: String?
    public var tokenExpirationDate: String?
    public var sessionId: String?
    public var clientId: String?
    public var tokenHash: String?

    public init(user: UserTokensTopicUriReference?, ipAddress: String?, dateCreated: String?, tokenExpirationDate: String?, sessionId: String?, clientId: String?, tokenHash: String?) {
        self.user = user
        self.ipAddress = ipAddress
        self.dateCreated = dateCreated
        self.tokenExpirationDate = tokenExpirationDate
        self.sessionId = sessionId
        self.clientId = clientId
        self.tokenHash = tokenHash
    }


}




public class UserTrendData: Codable {













    /** Start workday used as the date range. Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd */
    public var dateStartWorkday: Date?
    /** End workday used as the date range. Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd */
    public var dateEndWorkday: Date?
    /** Percent of goal */
    public var percentOfGoal: Double?
    /** Average metric value */
    public var averageValue: Double?
    /** Rank, ordered by total points */
    public var rankTotalPoints: Int?
    /** Rank, ordered by percentage of points */
    public var rankPercentagePoints: Int?

    public init(dateStartWorkday: Date?, dateEndWorkday: Date?, percentOfGoal: Double?, averageValue: Double?, rankTotalPoints: Int?, rankPercentagePoints: Int?) {
        self.dateStartWorkday = dateStartWorkday
        self.dateEndWorkday = dateEndWorkday
        self.percentOfGoal = percentOfGoal
        self.averageValue = averageValue
        self.rankTotalPoints = rankTotalPoints
        self.rankPercentagePoints = rankPercentagePoints
    }


}



/** The settings for User Video */

public class UserVideoSettings: Codable {







    /** whether or not user camera is allowed */
    public var allowCamera: Bool?
    /** whether or not user screen share is allowed */
    public var allowScreenShare: Bool?
    /** whether or not user microphone is allowed */
    public var allowMicrophone: Bool?

    public init(allowCamera: Bool?, allowScreenShare: Bool?, allowMicrophone: Bool?) {
        self.allowCamera = allowCamera
        self.allowScreenShare = allowScreenShare
        self.allowMicrophone = allowMicrophone
    }


}




public class UsersRulesRuleReference: Codable {





    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, selfUri: String?) {
        self._id = _id
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
    }


}




public class UtilizationLabelEntityListing: Codable {





















    public var entities: [UtilizationLabel]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var previousUri: String?
    public var nextUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [UtilizationLabel]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, previousUri: String?, nextUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.previousUri = previousUri
        self.nextUri = nextUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class UtilizationResponse: Codable {





    /** Map of media type to utilization settings. */
    public var utilization: [String:MediaUtilization]?
    /** Map of label ids to utilization settings. */
    public var labelUtilizations: [String:LabelUtilizationResponse]?

    public init(utilization: [String:MediaUtilization]?, labelUtilizations: [String:LabelUtilizationResponse]?) {
        self.utilization = utilization
        self.labelUtilizations = labelUtilizations
    }


}




public class V2ConversationMessageTypingEventForUserTopicConversationMessagingToRecipient: Codable {





    public enum IdType: String, Codable { 
        case email = "Email"
        case phone = "Phone"
        case opaque = "Opaque"
    }











    public var nickname: String?
    public var _id: String?
    public var idType: IdType?
    public var image: String?
    public var firstName: String?
    public var lastName: String?
    public var email: String?
    public var additionalIds: [V2ConversationMessageTypingEventForUserTopicConversationRecipientAdditionalIdentifier]?

    public init(nickname: String?, _id: String?, idType: IdType?, image: String?, firstName: String?, lastName: String?, email: String?, additionalIds: [V2ConversationMessageTypingEventForUserTopicConversationRecipientAdditionalIdentifier]?) {
        self.nickname = nickname
        self._id = _id
        self.idType = idType
        self.image = image
        self.firstName = firstName
        self.lastName = lastName
        self.email = email
        self.additionalIds = additionalIds
    }

    public enum CodingKeys: String, CodingKey { 
        case nickname
        case _id = "id"
        case idType
        case image
        case firstName
        case lastName
        case email
        case additionalIds
    }


}




public class V2ConversationMessageTypingEventForUserTopicMessageData: Codable {





    public var conversationId: String?
    public var normalizedMessage: V2ConversationMessageTypingEventForUserTopicConversationNormalizedMessage?

    public init(conversationId: String?, normalizedMessage: V2ConversationMessageTypingEventForUserTopicConversationNormalizedMessage?) {
        self.conversationId = conversationId
        self.normalizedMessage = normalizedMessage
    }


}




public class V2ConversationMessageTypingEventForWorkflowTopicConversationMessageEvent: Codable {

    public enum EventType: String, Codable { 
        case coBrowse = "CoBrowse"
        case typing = "Typing"
    }



    public var eventType: EventType?
    public var typing: V2ConversationMessageTypingEventForWorkflowTopicConversationEventTyping?

    public init(eventType: EventType?, typing: V2ConversationMessageTypingEventForWorkflowTopicConversationEventTyping?) {
        self.eventType = eventType
        self.typing = typing
    }


}




public class V2ConversationMessageTypingEventForWorkflowTopicConversationMessagingChannel: Codable {



    public enum Platform: String, Codable { 
        case twitter = "Twitter"
        case facebook = "Facebook"
        case instagram = "Instagram"
        case line = "Line"
        case whatsapp = "Whatsapp"
        case webMessaging = "WebMessaging"
        case _open = "Open"
        case sms = "Sms"
        case apple = "Apple"
    }







    public var _id: String?
    public var platform: Platform?
    public var to: V2ConversationMessageTypingEventForWorkflowTopicConversationMessagingToRecipient?
    public var from: V2ConversationMessageTypingEventForWorkflowTopicConversationMessagingFromRecipient?
    public var time: Date?

    public init(_id: String?, platform: Platform?, to: V2ConversationMessageTypingEventForWorkflowTopicConversationMessagingToRecipient?, from: V2ConversationMessageTypingEventForWorkflowTopicConversationMessagingFromRecipient?, time: Date?) {
        self._id = _id
        self.platform = platform
        self.to = to
        self.from = from
        self.time = time
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case platform
        case to
        case from
        case time
    }


}



/** This contains contextual information about an invoking entity. */

public class V2FlowExecutionDataFlowidTopicInvokingJourneyActionMapContext: Codable {





    /** The identifier of the journey action map that invoked this flow. */
    public var actionMapId: String?
    /** The identifier of the specific action map instance that invoked this flow. */
    public var actionId: String?

    public init(actionMapId: String?, actionId: String?) {
        self.actionMapId = actionMapId
        self.actionId = actionId
    }


}



/** The quality context that invoked this. */

public class V2FlowExecutionDataFlowidTopicInvokingQualityContext: Codable {





    /** The identifier of the quality policy that invoked this flow. */
    public var policyId: String?
    /** The name of the quality policy that invoked this flow. */
    public var policyName: String?

    public init(policyId: String?, policyName: String?) {
        self.policyId = policyId
        self.policyName = policyName
    }


}



/** This contains information about the workitem that invoked this flow execution. */

public class V2FlowExecutionDataFlowidTopicInvokingWorkitemContext: Codable {





    /** The identifier of the workitem that invoked this flow. */
    public var workitemId: String?
    /** The name of the process workitem that invoked this flow. */
    public var workitemName: String?

    public init(workitemId: String?, workitemName: String?) {
        self.workitemId = workitemId
        self.workitemName = workitemName
    }


}




public class V2IntegrationPresenceEventOrganizationPresence: Codable {





    public var _id: UUID?
    public var systemPresence: String?

    public init(_id: UUID?, systemPresence: String?) {
        self._id = _id
        self.systemPresence = systemPresence
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case systemPresence
    }


}




public class V2IntegrationPresenceEventPresenceActivityEvent: Codable {



    public enum EventType: String, Codable { 
        case userPresenceStatusChanged = "UserPresenceStatusChanged"
        case userPrimaryPresenceSourceChanged = "UserPrimaryPresenceSourceChanged"
    }













    public var userId: UUID?
    public var eventType: EventType?
    public var source: String?
    public var modifiedDate: Date?
    public var presenceDefinition: V2IntegrationPresenceEventOrganizationPresence?
    public var message: String?
    public var currentDisplaySourceId: UUID?
    public var previousDisplaySourceId: UUID?

    public init(userId: UUID?, eventType: EventType?, source: String?, modifiedDate: Date?, presenceDefinition: V2IntegrationPresenceEventOrganizationPresence?, message: String?, currentDisplaySourceId: UUID?, previousDisplaySourceId: UUID?) {
        self.userId = userId
        self.eventType = eventType
        self.source = source
        self.modifiedDate = modifiedDate
        self.presenceDefinition = presenceDefinition
        self.message = message
        self.currentDisplaySourceId = currentDisplaySourceId
        self.previousDisplaySourceId = previousDisplaySourceId
    }


}




public class V2MobiusAlertsTopicAlertingAddressableEntityRef: Codable {





    /** The ID of the resource */
    public var _id: String?
    public var displayName: String?

    public init(_id: String?, displayName: String?) {
        self._id = _id
        self.displayName = displayName
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case displayName
    }


}




public class V2MobiusRulesTopicAlertNotification: Codable {



    public enum NotificationTypes: String, Codable { 
        case device = "Device"
        case email = "Email"
        case sms = "Sms"
        case push = "Push"
        case unknown = "Unknown"
    }



    public var recipient: V2MobiusRulesTopicAlertNotificationRecipient?
    public var notificationTypes: [NotificationTypes]?
    public var locale: String?

    public init(recipient: V2MobiusRulesTopicAlertNotificationRecipient?, notificationTypes: [NotificationTypes]?, locale: String?) {
        self.recipient = recipient
        self.notificationTypes = notificationTypes
        self.locale = locale
    }


}




public class V2QueueObservationObservationCountNotification: Codable {



    /** List of observations by grouping. */
    public var results: [V2QueueObservationMetricCountGroup]?

    public init(results: [V2QueueObservationMetricCountGroup]?) {
        self.results = results
    }


}




public class V2SessionConversationsSummarySettingsPreviewEventConversationReasonMessage: Codable {







    public var text: String?
    public var _description: String?
    public var score: Double?

    public init(text: String?, _description: String?, score: Double?) {
        self.text = text
        self._description = _description
        self.score = score
    }

    public enum CodingKeys: String, CodingKey { 
        case text
        case _description = "description"
        case score
    }


}




public class V2SessionConversationsSummarySettingsPreviewEventConversationResolutionMessage: Codable {







    public var text: String?
    public var _description: String?
    public var score: Double?

    public init(text: String?, _description: String?, score: Double?) {
        self.text = text
        self._description = _description
        self.score = score
    }

    public enum CodingKeys: String, CodingKey { 
        case text
        case _description = "description"
        case score
    }


}




public class V2StaConversationCategoriesStaConversationCategoriesMessage: Codable {





    public enum MediaType: String, Codable { 
        case unknown = "unknown"
        case call = "call"
        case chat = "chat"
        case email = "email"
        case message = "message"
    }





    public var organizationId: String?
    public var conversationId: UUID?
    public var mediaType: MediaType?
    public var transcriptIds: [String]?
    public var categoryIds: [UUID]?

    public init(organizationId: String?, conversationId: UUID?, mediaType: MediaType?, transcriptIds: [String]?, categoryIds: [UUID]?) {
        self.organizationId = organizationId
        self.conversationId = conversationId
        self.mediaType = mediaType
        self.transcriptIds = transcriptIds
        self.categoryIds = categoryIds
    }


}




public class V2StaEmpathyOverallTopicAgentEmpathyScore: Codable {





    public var agentId: String?
    public var overallEmpathyScore: Double?

    public init(agentId: String?, overallEmpathyScore: Double?) {
        self.agentId = agentId
        self.overallEmpathyScore = overallEmpathyScore
    }


}




public class V2StaTopicsDetectedTopicParticipant: Codable {











    public var userId: String?
    public var queueId: String?
    public var divisionId: String?
    public var purpose: String?
    public var flowId: String?

    public init(userId: String?, queueId: String?, divisionId: String?, purpose: String?, flowId: String?) {
        self.userId = userId
        self.queueId = queueId
        self.divisionId = divisionId
        self.purpose = purpose
        self.flowId = flowId
    }


}




public class V2WebMessagingUndeliveredMessageTopicWebMessagingUndeliveredMessageEventBody: Codable {

















    public var conversationId: String?
    public var deploymentId: String?
    public var participantId: String?
    public var externalContactId: String?
    public var communicationId: String?
    public var sessionExpiry: Int64?
    public var messages: [V2WebMessagingUndeliveredMessageTopicMessage]?
    public var eventTimeMs: Int64?

    public init(conversationId: String?, deploymentId: String?, participantId: String?, externalContactId: String?, communicationId: String?, sessionExpiry: Int64?, messages: [V2WebMessagingUndeliveredMessageTopicMessage]?, eventTimeMs: Int64?) {
        self.conversationId = conversationId
        self.deploymentId = deploymentId
        self.participantId = participantId
        self.externalContactId = externalContactId
        self.communicationId = communicationId
        self.sessionExpiry = sessionExpiry
        self.messages = messages
        self.eventTimeMs = eventTimeMs
    }


}




public class ValidateAddressResponse: Codable {





    /** Was the passed in address valid */
    public var valid: Bool?
    /** Subscriber schema */
    public var response: SubscriberResponse?

    public init(valid: Bool?, response: SubscriberResponse?) {
        self.valid = valid
        self.response = response
    }


}




public class ValidationError: Codable {





    /** Line number for the error in CSV */
    public var lineNumber: Int64?
    /** Detail of the error in CSV */
    public var message: String?

    public init(lineNumber: Int64?, message: String?) {
        self.lineNumber = lineNumber
        self.message = message
    }


}




public class ValidationErrorListing: Codable {



    public var entities: [ValidationErrorResponse]?

    public init(entities: [ValidationErrorResponse]?) {
        self.entities = entities
    }


}




public class ValueWrapperActivityPlanServiceGoalImpactOverrides: Codable {



    /** The value for the associated field */
    public var value: ActivityPlanServiceGoalImpactOverrides?

    public init(value: ActivityPlanServiceGoalImpactOverrides?) {
        self.value = value
    }


}




public class ValueWrapperHrisTimeOffType: Codable {



    /** The value for the associated field */
    public var value: HrisTimeOffType?

    public init(value: HrisTimeOffType?) {
        self.value = value
    }


}




public class ValueWrapperString: Codable {



    /** The value for the associated field */
    public var value: String?

    public init(value: String?) {
        self.value = value
    }


}




public class ValueWrapperUserSearchRule: Codable {



    /** The value for the associated field */
    public var value: UserSearchRule?

    public init(value: UserSearchRule?) {
        self.value = value
    }


}



/** The settings to enable video chat */

public class VideoSettings: Codable {







    /** whether or not video is enabled */
    public var enabled: Bool?
    /** Video Settings for agent */
    public var agent: AgentVideoSettings?
    /** Video Settings for user */
    public var user: UserVideoSettings?

    public init(enabled: Bool?, agent: AgentVideoSettings?, user: UserVideoSettings?) {
        self.enabled = enabled
        self.agent = agent
        self.user = user
    }


}




public class VoicemailMediaInfo: Codable {









    /** The globally unique identifier for the object. */
    public var _id: String?
    public var mediaFileUri: String?
    public var mediaImageUri: String?
    public var waveformData: [Float]?

    public init(_id: String?, mediaFileUri: String?, mediaImageUri: String?, waveformData: [Float]?) {
        self._id = _id
        self.mediaFileUri = mediaFileUri
        self.mediaImageUri = mediaImageUri
        self.waveformData = waveformData
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case mediaFileUri
        case mediaImageUri
        case waveformData
    }


}




public class VoicemailMessageEntityListing: Codable {





















    public var entities: [VoicemailMessage]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var previousUri: String?
    public var nextUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [VoicemailMessage]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, previousUri: String?, nextUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.previousUri = previousUri
        self.nextUri = nextUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}



/** Governs how the voicemail is retained */

public class VoicemailRetentionPolicy: Codable {

    public enum VoicemailRetentionPolicyType: String, Codable { 
        case retainIndefinitely = "RETAIN_INDEFINITELY"
        case retainWithTtl = "RETAIN_WITH_TTL"
        case immediateDelete = "IMMEDIATE_DELETE"
    }



    /** The retention policy type */
    public var voicemailRetentionPolicyType: VoicemailRetentionPolicyType?
    /** If retentionPolicyType == RETAIN_WITH_TTL, then this value represents the number of days for the TTL */
    public var numberOfDays: Int?

    public init(voicemailRetentionPolicyType: VoicemailRetentionPolicyType?, numberOfDays: Int?) {
        self.voicemailRetentionPolicyType = voicemailRetentionPolicyType
        self.numberOfDays = numberOfDays
    }


}




public class WaitlistPosition: Codable {









    /** The time off request for this wait list position */
    public var timeOffRequest: TimeOffRequestReference?
    /** The time off limit for which time off request is waitlisted */
    public var timeOffLimit: TimeOffLimitReference?
    /** The date to which this wait list position applies, as defined by the time zone of the business unit. Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd */
    public var date: Date?
    /** The time off request's position in the waitlist on the date. 1 means time off is the first in the waitlist */
    public var waitlistPosition: Int?

    public init(timeOffRequest: TimeOffRequestReference?, timeOffLimit: TimeOffLimitReference?, date: Date?, waitlistPosition: Int?) {
        self.timeOffRequest = timeOffRequest
        self.timeOffLimit = timeOffLimit
        self.date = date
        self.waitlistPosition = waitlistPosition
    }


}




public class WaitlistPositionListing: Codable {



    public var entities: [WaitlistPosition]?

    public init(entities: [WaitlistPosition]?) {
        self.entities = entities
    }


}




public class WebChatDeployment: Codable {





















    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    public var _description: String?
    public var authenticationRequired: Bool?
    /** URL for third party service authenticating web chat clients. See https://github.com/MyPureCloud/authenticated-web-chat-server-examples */
    public var authenticationUrl: String?
    public var disabled: Bool?
    public var webChatConfig: WebChatConfig?
    public var allowedDomains: [String]?
    /** The URI of the Inbound Chat Flow to run when new chats are initiated under this Deployment. */
    public var flow: DomainEntityRef?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, _description: String?, authenticationRequired: Bool?, authenticationUrl: String?, disabled: Bool?, webChatConfig: WebChatConfig?, allowedDomains: [String]?, flow: DomainEntityRef?, selfUri: String?) {
        self._id = _id
        self.name = name
        self._description = _description
        self.authenticationRequired = authenticationRequired
        self.authenticationUrl = authenticationUrl
        self.disabled = disabled
        self.webChatConfig = webChatConfig
        self.allowedDomains = allowedDomains
        self.flow = flow
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case _description = "description"
        case authenticationRequired
        case authenticationUrl
        case disabled
        case webChatConfig
        case allowedDomains
        case flow
        case selfUri
    }


}




public class WebDeploymentsJourneyContext: Codable {







    /** A subset of the Journey System's action data relevant to a part of a conversation (for external linkage and internal usage/context) */
    public var journeyAction: JourneyAction?
    /** Journey customer information. Used for linking the authenticated customer with the journey.  */
    public var customer: JourneyCustomer?
    /** Contains the Journey System's customer session details. */
    public var customerSession: JourneyCustomerSession?

    public init(journeyAction: JourneyAction?, customer: JourneyCustomer?, customerSession: JourneyCustomerSession?) {
        self.journeyAction = journeyAction
        self.customer = customer
        self.customerSession = customerSession
    }


}




public class WebDeploymentsOAuthExchangeRequest: Codable {







    /** The WebDeployment ID */
    public var deploymentId: String?
    /** A Customer journey context. */
    public var journeyContext: WebDeploymentsJourneyContext?
    public var oauth: WebDeploymentsOAuthRequestParameters?

    public init(deploymentId: String?, journeyContext: WebDeploymentsJourneyContext?, oauth: WebDeploymentsOAuthRequestParameters?) {
        self.deploymentId = deploymentId
        self.journeyContext = journeyContext
        self.oauth = oauth
    }


}




public class WebDeploymentsRefreshJWTRequest: Codable {





    /** Refresh token used to issue a new JWT. */
    public var refreshToken: String?
    /** The WebDeployment ID */
    public var deploymentId: String?

    public init(refreshToken: String?, deploymentId: String?) {
        self.refreshToken = refreshToken
        self.deploymentId = deploymentId
    }


}




public class WebEventDevice: Codable {

    public enum Category: String, Codable { 
        case desktop = "desktop"
        case mobile = "mobile"
        case tablet = "tablet"
        case other = "other"
    }

















    /** Device category. */
    public var category: Category?
    /** Device type (e.g. iPad, iPhone, Other). */
    public var type: String?
    /** Flag that is true for mobile devices. */
    public var isMobile: Bool?
    /** Device's screen height. */
    public var screenHeight: Int?
    /** Device's screen width. */
    public var screenWidth: Int?
    /** Device's screen density, measured as a scale factor where a value of 1 represents a baseline 1:1 ratio of pixels to logical (device-independent) pixels. */
    public var screenDensity: Int?
    /** Operating system family. */
    public var osFamily: String?
    /** Operating system version. */
    public var osVersion: String?
    /** Manufacturer of the device. */
    public var manufacturer: String?

    public init(category: Category?, type: String?, isMobile: Bool?, screenHeight: Int?, screenWidth: Int?, screenDensity: Int?, osFamily: String?, osVersion: String?, manufacturer: String?) {
        self.category = category
        self.type = type
        self.isMobile = isMobile
        self.screenHeight = screenHeight
        self.screenWidth = screenWidth
        self.screenDensity = screenDensity
        self.osFamily = osFamily
        self.osVersion = osVersion
        self.manufacturer = manufacturer
    }


}




public class WebEventResponse: Codable {



































    /** Identifier of the customer in the source of the event. */
    public var customerId: String?
    /** Represents the action the customer performed. Event types are created for each unique event name and can be faceted on in segment and outcome conditions. A valid event name must only contain alphanumeric characters and underscores. A good event name is typically an object followed by the action performed in past tense, e.g. page_viewed, order_completed, user_registered. */
    public var eventName: String?
    /** Type of identifier for the customer ID (e.g., cookie). */
    public var customerIdType: String?
    /** The webpage where the user interaction occurred. */
    public var page: ResponsePage?
    /** HTTP User-Agent string (see https://tools.ietf.org/html/rfc1945#section-10.15). */
    public var userAgentString: String?
    /** Customer's browser. */
    public var browser: WebEventBrowser?
    /** Customer's device. */
    public var device: WebEventDevice?
    /** Represents the keywords in a customer search query. */
    public var searchQuery: String?
    /** Customer's IP-based organization or ISP name. */
    public var ipOrganization: String?
    /** Customer's geolocation. */
    public var geolocation: JourneyGeolocation?
    /** Urchin Tracking Module (UTM) parameters used to track the effectiveness of online marketing campaigns. */
    public var mktCampaign: JourneyCampaign?
    /** The session that the event belongs to. */
    public var session: WebEventResponseSession?
    /** Identifies the web page that originally generated the request for the current page being viewed. */
    public var referrer: Referrer?
    /** User-defined attributes associated with a particular event. These attributes provide additional context about the event. For example, items_in_cart or subscription_level. */
    public var attributes: [String:CustomEventAttribute]?
    /** Traits are attributes intrinsic to the customer that may be sent in selected events, (e.g. email, givenName, cellPhone). Traits are used to collect information for identity resolution. For example, the same person might be using an application on different devices which might create two sessions with different customerIds. Additional information can be provided as traits to help link those two sessions and customers to a single external contact through common identifiers that were submitted via a form fill, message, or other input in both sessions. */
    public var traits: [String:CustomEventAttribute]?
    /** Indicates whether the event was produced during an authenticated session. */
    public var authenticated: Bool?
    /** UTC timestamp indicating when the event actually took place, events older than an hour will be rejected. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var createdDate: Date?

    public init(customerId: String?, eventName: String?, customerIdType: String?, page: ResponsePage?, userAgentString: String?, browser: WebEventBrowser?, device: WebEventDevice?, searchQuery: String?, ipOrganization: String?, geolocation: JourneyGeolocation?, mktCampaign: JourneyCampaign?, session: WebEventResponseSession?, referrer: Referrer?, attributes: [String:CustomEventAttribute]?, traits: [String:CustomEventAttribute]?, authenticated: Bool?, createdDate: Date?) {
        self.customerId = customerId
        self.eventName = eventName
        self.customerIdType = customerIdType
        self.page = page
        self.userAgentString = userAgentString
        self.browser = browser
        self.device = device
        self.searchQuery = searchQuery
        self.ipOrganization = ipOrganization
        self.geolocation = geolocation
        self.mktCampaign = mktCampaign
        self.session = session
        self.referrer = referrer
        self.attributes = attributes
        self.traits = traits
        self.authenticated = authenticated
        self.createdDate = createdDate
    }


}




public class WebEventResponseSession: Codable {















    /** The globally unique identifier for the object. */
    public var _id: String?
    /** Indicates how long the customer has been on the site within this session. */
    public var durationInSeconds: Int?
    /** The count of all events recorded during this session. */
    public var eventCount: Int?
    /** The count of all pageviews performed during this session. */
    public var pageviewCount: Int?
    /** The referrer of the first event in the web session. */
    public var referrer: Referrer?
    /** The URI for this object */
    public var selfUri: String?
    /** Date of the session's first event, that is when the session starts. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var createdDate: Date?

    public init(_id: String?, durationInSeconds: Int?, eventCount: Int?, pageviewCount: Int?, referrer: Referrer?, selfUri: String?, createdDate: Date?) {
        self._id = _id
        self.durationInSeconds = durationInSeconds
        self.eventCount = eventCount
        self.pageviewCount = pageviewCount
        self.referrer = referrer
        self.selfUri = selfUri
        self.createdDate = createdDate
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case durationInSeconds
        case eventCount
        case pageviewCount
        case referrer
        case selfUri
        case createdDate
    }


}



/** A Presence event. */

public class WebMessagingEventPresence: Codable {

    public enum ModelType: String, Codable { 
        case join = "Join"
        case disconnect = "Disconnect"
        case clear = "Clear"
        case signIn = "SignIn"
        case sessionExpired = "SessionExpired"
    }

    /** Describes the type of Presence event. */
    public var type: ModelType?

    public init(type: ModelType?) {
        self.type = type
    }


}




public class WeekScheduleListItemResponse: Codable {

















    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The URI for this object */
    public var selfUri: String?
    /** First day of this week schedule in yyyy-MM-dd format */
    public var weekDate: String?
    /** Description of the week schedule */
    public var _description: String?
    /** Whether the week schedule is published */
    public var published: Bool?
    /** Summary of the results from the schedule run */
    public var generationResults: WeekScheduleGenerationResult?
    /** Short term forecast associated with this schedule */
    public var shortTermForecast: ShortTermForecastReference?
    /** Version metadata for this work plan */
    public var metadata: WfmVersionedEntityMetadata?

    public init(_id: String?, selfUri: String?, weekDate: String?, _description: String?, published: Bool?, generationResults: WeekScheduleGenerationResult?, shortTermForecast: ShortTermForecastReference?, metadata: WfmVersionedEntityMetadata?) {
        self._id = _id
        self.selfUri = selfUri
        self.weekDate = weekDate
        self._description = _description
        self.published = published
        self.generationResults = generationResults
        self.shortTermForecast = shortTermForecast
        self.metadata = metadata
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
        case weekDate
        case _description = "description"
        case published
        case generationResults
        case shortTermForecast
        case metadata
    }


}




public class WfmActivityPlanJobCompleteTopicErrorBody: Codable {









    public var status: Int64?
    public var code: String?
    public var message: String?
    public var messageParams: [String:String]?

    public init(status: Int64?, code: String?, message: String?, messageParams: [String:String]?) {
        self.status = status
        self.code = code
        self.message = message
        self.messageParams = messageParams
    }


}




public class WfmActivityPlanRunJobCompleteTopicActivityPlanJobException: Codable {

    public enum ExceptionType: String, Codable { 
        case unscheduledAttendees = "UnscheduledAttendees"
        case sessionsNotDeleted = "SessionsNotDeleted"
    }



    public var exceptionType: ExceptionType?
    public var occurrences: [WfmActivityPlanRunJobCompleteTopicActivityPlanOccurrenceReference]?

    public init(exceptionType: ExceptionType?, occurrences: [WfmActivityPlanRunJobCompleteTopicActivityPlanOccurrenceReference]?) {
        self.exceptionType = exceptionType
        self.occurrences = occurrences
    }


}




public class WfmActivityPlanRunJobCompleteTopicActivityPlanReference: Codable {



    public var _id: String?

    public init(_id: String?) {
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
    }


}




public class WfmAdherenceExplanationJobCompleteTopicBusinessUnit: Codable {



    public var _id: String?

    public init(_id: String?) {
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
    }


}




public class WfmAdherenceExplanationJobCompleteTopicErrorBody: Codable {









    public var status: Int64?
    public var code: String?
    public var message: String?
    public var messageParams: [String:String]?

    public init(status: Int64?, code: String?, message: String?, messageParams: [String:String]?) {
        self.status = status
        self.code = code
        self.message = message
        self.messageParams = messageParams
    }


}




public class WfmAgentAdherenceExplanationChangedAgentTopicUserReference: Codable {



    public var _id: String?

    public init(_id: String?) {
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
    }


}




public class WfmAgentAdherenceExplanationChangedBusinessUnitTopicUserReference: Codable {



    public var _id: String?

    public init(_id: String?) {
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
    }


}




public class WfmAgentHistoricalAdherenceResponse: Codable {







    /** A reference to the job that was started by the request */
    public var job: WfmAgentHistoricalAdherenceJobReference?
    /** The url list to GET the results of the agent adherence query. This field is populated only if query state is Complete */
    public var downloadUrls: [String]?
    /** Results will come via downloadUrls, however it may come inline if small enough */
    public var result: WfmAgentHistoricalAdherenceResult?

    public init(job: WfmAgentHistoricalAdherenceJobReference?, downloadUrls: [String]?, result: WfmAgentHistoricalAdherenceResult?) {
        self.job = job
        self.downloadUrls = downloadUrls
        self.result = result
    }


}




public class WfmAgentScheduleUpdateTopicAgentScheduleShiftUpdate: Codable {

    public enum ModelType: String, Codable { 
        case added = "Added"
        case edited = "Edited"
        case deleted = "Deleted"
    }



    public var type: ModelType?
    public var shiftStartDates: [Date]?

    public init(type: ModelType?, shiftStartDates: [Date]?) {
        self.type = type
        self.shiftStartDates = shiftStartDates
    }


}




public class WfmAgentScheduleUpdateTopicAgentScheduleUpdateNotification: Codable {









    public var user: WfmAgentScheduleUpdateTopicUserReference?
    public var startDate: Date?
    public var endDate: Date?
    public var updates: [WfmAgentScheduleUpdateTopicAgentScheduleShiftUpdate]?

    public init(user: WfmAgentScheduleUpdateTopicUserReference?, startDate: Date?, endDate: Date?, updates: [WfmAgentScheduleUpdateTopicAgentScheduleShiftUpdate]?) {
        self.user = user
        self.startDate = startDate
        self.endDate = endDate
        self.updates = updates
    }


}




public class WfmAlternativeShiftJobCompleteEventV3AlternativeShiftJobCompleteNotification: Codable {



    public enum ModelType: String, Codable { 
        case listOffers = "ListOffers"
        case searchOffers = "SearchOffers"
        case listUserTrades = "ListUserTrades"
        case searchTrades = "SearchTrades"
        case bulkUpdateTrades = "BulkUpdateTrades"
    }

    public enum Status: String, Codable { 
        case processing = "Processing"
        case complete = "Complete"
        case error = "Error"
    }





    public var _id: String?
    public var type: ModelType?
    public var status: Status?
    public var downloadUrl: String?
    public var error: WfmAlternativeShiftJobCompleteEventV3ErrorBody?

    public init(_id: String?, type: ModelType?, status: Status?, downloadUrl: String?, error: WfmAlternativeShiftJobCompleteEventV3ErrorBody?) {
        self._id = _id
        self.type = type
        self.status = status
        self.downloadUrl = downloadUrl
        self.error = error
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case type
        case status
        case downloadUrl
        case error
    }


}




public class Widget: Codable {







    public enum ModelType: String, Codable { 
        case metric = "METRIC"
        case chart = "CHART"
        case pie = "PIE"
        case heatMap = "HEAT_MAP"
        case freeText = "FREE_TEXT"
        case agentStatus = "AGENT_STATUS"
        case realtimeAdherence = "REALTIME_ADHERENCE"
        case webContentUrl = "WEB_CONTENT_URL"
        case agentActivity = "AGENT_ACTIVITY"
    }

    public enum Metrics: String, Codable { 
        case avgTalkTime = "AVG_TALK_TIME"
        case avgHoldTime = "AVG_HOLD_TIME"
        case avgAcwTime = "AVG_ACW_TIME"
        case avgWaitTime = "AVG_WAIT_TIME"
        case avgHandleTime = "AVG_HANDLE_TIME"
        case avgAlertTime = "AVG_ALERT_TIME"
        case avgAnswerTime = "AVG_ANSWER_TIME"
        case avgAbandonTime = "AVG_ABANDON_TIME"
        case totalTalkTime = "TOTAL_TALK_TIME"
        case totalHandleTime = "TOTAL_HANDLE_TIME"
        case totalHoldTime = "TOTAL_HOLD_TIME"
        case totalAcwTime = "TOTAL_ACW_TIME"
        case totalAlertTime = "TOTAL_ALERT_TIME"
        case maxAbandonTime = "MAX_ABANDON_TIME"
        case maxWaitTime = "MAX_WAIT_TIME"
        case maxTalkTime = "MAX_TALK_TIME"
        case maxHoldTime = "MAX_HOLD_TIME"
        case maxAcwTime = "MAX_ACW_TIME"
        case minAbandonTime = "MIN_ABANDON_TIME"
        case minWaitTime = "MIN_WAIT_TIME"
        case minTalkTime = "MIN_TALK_TIME"
        case minHoldTime = "MIN_HOLD_TIME"
        case minAcwTime = "MIN_ACW_TIME"
        case alertCount = "ALERT_COUNT"
        case offeredCount = "OFFERED_COUNT"
        case abandonedCount = "ABANDONED_COUNT"
        case abandonedPercent = "ABANDONED_PERCENT"
        case shortAbandonedCount = "SHORT_ABANDONED_COUNT"
        case shortAbandonedPercent = "SHORT_ABANDONED_PERCENT"
        case abandonedNoShortCount = "ABANDONED_NO_SHORT_COUNT"
        case abandonedNoShortPercent = "ABANDONED_NO_SHORT_PERCENT"
        case answeredCount = "ANSWERED_COUNT"
        case answeredPercent = "ANSWERED_PERCENT"
        case flowoutCount = "FLOWOUT_COUNT"
        case flowoutPercent = "FLOWOUT_PERCENT"
        case outboundCount = "OUTBOUND_COUNT"
        case outboundAttemptedCount = "OUTBOUND_ATTEMPTED_COUNT"
        case voicemailCount = "VOICEMAIL_COUNT"
        case handledCount = "HANDLED_COUNT"
        case heldCount = "HELD_COUNT"
        case transferredCount = "TRANSFERRED_COUNT"
        case transferredPercent = "TRANSFERRED_PERCENT"
        case waitingCurrent = "WAITING_CURRENT"
        case interactingCurrent = "INTERACTING_CURRENT"
        case heldCurrent = "HELD_CURRENT"
        case alertingCurrent = "ALERTING_CURRENT"
        case serviceLevel = "SERVICE_LEVEL"
        case overServiceLevel = "OVER_SERVICE_LEVEL"
        case onlineAgents = "ONLINE_AGENTS"
        case availableAgents = "AVAILABLE_AGENTS"
        case awayAgents = "AWAY_AGENTS"
        case breakAgents = "BREAK_AGENTS"
        case mealAgents = "MEAL_AGENTS"
        case trainingAgents = "TRAINING_AGENTS"
        case busyAgents = "BUSY_AGENTS"
        case meetingAgents = "MEETING_AGENTS"
        case systemAwayAgents = "SYSTEM_AWAY_AGENTS"
        case offlineAgents = "OFFLINE_AGENTS"
        case onQueueAgents = "ON_QUEUE_AGENTS"
        case offQueueAgents = "OFF_QUEUE_AGENTS"
        case interactingAgents = "INTERACTING_AGENTS"
        case acwAgents = "ACW_AGENTS"
        case communicatingAgents = "COMMUNICATING_AGENTS"
        case idleAgents = "IDLE_AGENTS"
        case notRespondingAgents = "NOT_RESPONDING_AGENTS"
        case longestWaiting = "LONGEST_WAITING"
        case longestInteracting = "LONGEST_INTERACTING"
        case flowActiveLongest = "FLOW_ACTIVE_LONGEST"
        case flowActiveCurrent = "FLOW_ACTIVE_CURRENT"
        case flowEntriesCount = "FLOW_ENTRIES_COUNT"
        case flowTotalDuration = "FLOW_TOTAL_DURATION"
        case flowMaxDuration = "FLOW_MAX_DURATION"
        case flowAvgDuration = "FLOW_AVG_DURATION"
        case flowDisconnectCount = "FLOW_DISCONNECT_COUNT"
        case flowDisconnectPercent = "FLOW_DISCONNECT_PERCENT"
        case flowTotalDisconnectDuration = "FLOW_TOTAL_DISCONNECT_DURATION"
        case flowAvgDisconnectDuration = "FLOW_AVG_DISCONNECT_DURATION"
        case flowMaxDisconnectDuration = "FLOW_MAX_DISCONNECT_DURATION"
        case flowFlowDisconnect = "FLOW_FLOW_DISCONNECT"
        case flowFlowDisconnectPercent = "FLOW_FLOW_DISCONNECT_PERCENT"
        case flowSystemErrorDisconnect = "FLOW_SYSTEM_ERROR_DISCONNECT"
        case flowSystemErrorDisconnectPercent = "FLOW_SYSTEM_ERROR_DISCONNECT_PERCENT"
        case flowCustomerDisconnect = "FLOW_CUSTOMER_DISCONNECT"
        case flowCustomerDisconnectPercent = "FLOW_CUSTOMER_DISCONNECT_PERCENT"
        case flowShortDisconnect = "FLOW_SHORT_DISCONNECT"
        case flowShortDisconnectPercent = "FLOW_SHORT_DISCONNECT_PERCENT"
        case flowExitCount = "FLOW_EXIT_COUNT"
        case flowExitPercent = "FLOW_EXIT_PERCENT"
        case flowTotalExitDuration = "FLOW_TOTAL_EXIT_DURATION"
        case flowMaxExitDuration = "FLOW_MAX_EXIT_DURATION"
        case flowAvgExitDuration = "FLOW_AVG_EXIT_DURATION"
        case flowAcdExitCount = "FLOW_ACD_EXIT_COUNT"
        case flowAcdExitPercent = "FLOW_ACD_EXIT_PERCENT"
        case flowGroupExitCount = "FLOW_GROUP_EXIT_COUNT"
        case flowGroupExitPercent = "FLOW_GROUP_EXIT_PERCENT"
        case flowNumberExitCount = "FLOW_NUMBER_EXIT_COUNT"
        case flowNumberExitPercent = "FLOW_NUMBER_EXIT_PERCENT"
        case flowUserExitCount = "FLOW_USER_EXIT_COUNT"
        case flowUserExitPercent = "FLOW_USER_EXIT_PERCENT"
        case flowFlowExitCount = "FLOW_FLOW_EXIT_COUNT"
        case flowFlowExitPercent = "FLOW_FLOW_EXIT_PERCENT"
        case flowSecureFlowExitCount = "FLOW_SECURE_FLOW_EXIT_COUNT"
        case flowSecureFlowExitPercent = "FLOW_SECURE_FLOW_EXIT_PERCENT"
        case flowAcdVoicemailExitCount = "FLOW_ACD_VOICEMAIL_EXIT_COUNT"
        case flowAcdVoicemailExitPercent = "FLOW_ACD_VOICEMAIL_EXIT_PERCENT"
        case flowUserVoicemailExitCount = "FLOW_USER_VOICEMAIL_EXIT_COUNT"
        case flowUserVoicemailExitPercent = "FLOW_USER_VOICEMAIL_EXIT_PERCENT"
        case flowOutcomeCount = "FLOW_OUTCOME_COUNT"
        case flowAvgOutcomeDecimal = "FLOW_AVG_OUTCOME_DECIMAL"
        case flowOutcomeFailureCount = "FLOW_OUTCOME_FAILURE_COUNT"
        case flowOutcomeFailurePercent = "FLOW_OUTCOME_FAILURE_PERCENT"
        case flowOutcomeSuccessCount = "FLOW_OUTCOME_SUCCESS_COUNT"
        case flowOutcomeSuccessPercent = "FLOW_OUTCOME_SUCCESS_PERCENT"
        case flowOutcomeTotalDuration = "FLOW_OUTCOME_TOTAL_DURATION"
        case flowOutcomeMaxDuration = "FLOW_OUTCOME_MAX_DURATION"
        case flowOutcomeAvgDuration = "FLOW_OUTCOME_AVG_DURATION"
        case flowOutcomeMinDuration = "FLOW_OUTCOME_MIN_DURATION"
        case offQueueTime = "OFF_QUEUE_TIME"
        case offQueuePercent = "OFF_QUEUE_PERCENT"
        case availableTime = "AVAILABLE_TIME"
        case availablePercent = "AVAILABLE_PERCENT"
        case busyTime = "BUSY_TIME"
        case busyPercent = "BUSY_PERCENT"
        case awayTime = "AWAY_TIME"
        case awayPercent = "AWAY_PERCENT"
        case breakTime = "BREAK_TIME"
        case breakPercent = "BREAK_PERCENT"
        case mealTime = "MEAL_TIME"
        case mealPercent = "MEAL_PERCENT"
        case meetingTime = "MEETING_TIME"
        case meetingPercent = "MEETING_PERCENT"
        case trainingTime = "TRAINING_TIME"
        case trainingPercent = "TRAINING_PERCENT"
        case interactingTime = "INTERACTING_TIME"
        case interactingPercent = "INTERACTING_PERCENT"
        case communicatingTime = "COMMUNICATING_TIME"
        case communicatingPercent = "COMMUNICATING_PERCENT"
        case systemAwayTime = "SYSTEM_AWAY_TIME"
        case systemAwayPercent = "SYSTEM_AWAY_PERCENT"
        case onQueueTime = "ON_QUEUE_TIME"
        case onQueuePercent = "ON_QUEUE_PERCENT"
        case idleTime = "IDLE_TIME"
        case idlePercent = "IDLE_PERCENT"
        case notRespondingTime = "NOT_RESPONDING_TIME"
        case notRespondingPercent = "NOT_RESPONDING_PERCENT"
        case loggedInTime = "LOGGED_IN_TIME"
        case occupancyPercent = "OCCUPANCY_PERCENT"
        case minAlertTime = "MIN_ALERT_TIME"
        case maxAlertTime = "MAX_ALERT_TIME"
        case minHandleTime = "MIN_HANDLE_TIME"
        case maxHandleTime = "MAX_HANDLE_TIME"
        case minAnsweredTime = "MIN_ANSWERED_TIME"
        case maxAnsweredTime = "MAX_ANSWERED_TIME"
        case minNotRespondingTime = "MIN_NOT_RESPONDING_TIME"
        case maxNotRespondingTime = "MAX_NOT_RESPONDING_TIME"
        case metServiceLevel = "MET_SERVICE_LEVEL"
        case wfmAdherenceStatus = "WFM_ADHERENCE_STATUS"
        case wfmScheduledActivity = "WFM_SCHEDULED_ACTIVITY"
        case wfmAdherenceDuration = "WFM_ADHERENCE_DURATION"
        case agentTitle = "AGENT_TITLE"
        case agentDepartment = "AGENT_DEPARTMENT"
        case agentExtension = "AGENT_EXTENSION"
        case agentSkills = "AGENT_SKILLS"
        case agentLocation = "AGENT_LOCATION"
        case agentReportsTo = "AGENT_REPORTS_TO"
        case agentEmail = "AGENT_EMAIL"
        case agentRole = "AGENT_ROLE"
        case agentGroup = "AGENT_GROUP"
        case agentTimeInStatus = "AGENT_TIME_IN_STATUS"
        case agentTimeInRoutingStatus = "AGENT_TIME_IN_ROUTING_STATUS"
        case agentStatus = "AGENT_STATUS"
        case agentSecondaryStatus = "AGENT_SECONDARY_STATUS"
        case agentRoutingStatus = "AGENT_ROUTING_STATUS"
        case agentMediaTypes = "AGENT_MEDIA_TYPES"
        case acwCount = "ACW_COUNT"
        case answerTransferredPercent = "ANSWER_TRANSFERRED_PERCENT"
        case flowAvgMilestoneDecimal = "FLOW_AVG_MILESTONE_DECIMAL"
        case notRespondingCount = "NOT_RESPONDING_COUNT"
        case avgAcwHandled = "AVG_ACW_HANDLED"
        case avgContactingTime = "AVG_CONTACTING_TIME"
        case avgDialingTime = "AVG_DIALING_TIME"
        case avgFlowoutTime = "AVG_FLOWOUT_TIME"
        case avgHoldHandled = "AVG_HOLD_HANDLED"
        case avgMonitor = "AVG_MONITOR"
        case blindTransferCount = "BLIND_TRANSFER_COUNT"
        case blindTransferPercent = "BLIND_TRANSFER_PERCENT"
        case connectedCount = "CONNECTED_COUNT"
        case consultCount = "CONSULT_COUNT"
        case consultTransferCount = "CONSULT_TRANSFER_COUNT"
        case consultTransferPercent = "CONSULT_TRANSFER_PERCENT"
        case contactingCount = "CONTACTING_COUNT"
        case dialingCount = "DIALING_COUNT"
        case errorCount = "ERROR_COUNT"
        case externalMediaCount = "EXTERNAL_MEDIA_COUNT"
        case maxContactingTime = "MAX_CONTACTING_TIME"
        case maxDialingTime = "MAX_DIALING_TIME"
        case maxFlowoutTime = "MAX_FLOWOUT_TIME"
        case flowMilestoneCount = "FLOW_MILESTONE_COUNT"
        case minFlowoutTime = "MIN_FLOWOUT_TIME"
        case maxMonitor = "MAX_MONITOR"
        case minContactingTime = "MIN_CONTACTING_TIME"
        case minDialingTime = "MIN_DIALING_TIME"
        case minMonitor = "MIN_MONITOR"
        case monitorCount = "MONITOR_COUNT"
        case mediaCount = "MEDIA_COUNT"
        case serviceLevelTarget = "SERVICE_LEVEL_TARGET"
        case serviceLevelTargetCurrent = "SERVICE_LEVEL_TARGET_CURRENT"
        case talkCount = "TALK_COUNT"
        case totalAbandonTime = "TOTAL_ABANDON_TIME"
        case totalNotRespondingTime = "TOTAL_NOT_RESPONDING_TIME"
        case totalContacting = "TOTAL_CONTACTING"
        case totalDialing = "TOTAL_DIALING"
        case totalMonitor = "TOTAL_MONITOR"
        case totalWaitTime = "TOTAL_WAIT_TIME"
        case waitCount = "WAIT_COUNT"
        case parkCount = "PARK_COUNT"
        case avgParkTime = "AVG_PARK_TIME"
        case totalParkTime = "TOTAL_PARK_TIME"
        case minParkTime = "MIN_PARK_TIME"
        case maxParkTime = "MAX_PARK_TIME"
        case inboundAudioCount = "INBOUND_AUDIO_COUNT"
        case outboundAudioCount = "OUTBOUND_AUDIO_COUNT"
    }

















    public enum SortOrder: String, Codable { 
        case ascending = "ascending"
        case descending = "descending"
    }

    public enum SortKey: String, Codable { 
        case name = "Name"
        case duration = "Duration"
    }













    public enum Periods: String, Codable { 
        case _none = "NONE"
        case currentHalfHour = "CURRENT_HALF_HOUR"
        case today = "TODAY"
        case yesterday = "YESTERDAY"
        case thisWeek = "THIS_WEEK"
        case lastWeek = "LAST_WEEK"
        case thisMonth = "THIS_MONTH"
        case lastMonth = "LAST_MONTH"
        case prior7Days = "PRIOR_7_DAYS"
        case past7DaysToDate = "PAST_7_DAYS_TO_DATE"
        case prior30Days = "PRIOR_30_DAYS"
        case past30DaysToDate = "PAST_30_DAYS_TO_DATE"
        case prior3Months = "PRIOR_3_MONTHS"
    }

    public enum MediaTypes: String, Codable { 
        case callback = "callback"
        case chat = "chat"
        case cobrowse = "cobrowse"
        case email = "email"
        case internalmessage = "internalmessage"
        case message = "message"
        case screenmonitoring = "screenmonitoring"
        case screenshare = "screenshare"
        case unknown = "unknown"
        case video = "video"
        case voice = "voice"
    }







    public enum SelectedStatuses: String, Codable { 
        case available = "Available"
        case away = "Away"
        case busy = "Busy"
        case _break = "Break"
        case meeting = "Meeting"
        case training = "Training"
        case meal = "Meal"
        case systemAway = "SystemAway"
        case onQueue = "OnQueue"
        case interacting = "Interacting"
        case notResponding = "NotResponding"
        case idle = "Idle"
        case communicating = "Communicating"
        case offQueue = "OffQueue"
        case online = "Online"
        case offline = "Offline"
    }

    public enum SelectedSegmentTypes: String, Codable { 
        case alert = "alert"
        case barging = "barging"
        case callback = "callback"
        case coaching = "coaching"
        case contacting = "contacting"
        case converting = "converting"
        case delay = "delay"
        case dialing = "dialing"
        case hold = "hold"
        case interact = "interact"
        case ivr = "ivr"
        case monitoring = "monitoring"
        case parked = "parked"
        case scheduled = "scheduled"
        case screenmonitoring = "screenmonitoring"
        case sharing = "sharing"
        case system = "system"
        case transmitting = "transmitting"
        case unknown = "unknown"
        case uploading = "uploading"
        case voicemail = "voicemail"
        case wrapup = "wrapup"
    }

    public enum AgentInteractionSortOrder: String, Codable { 
        case ascending = "ascending"
        case descending = "descending"
    }

    /** The row number for the specific dashboard widget configuration. */
    public var row: Int?
    /** The column number for the specific dashboard widget configuration. */
    public var column: Int?
    /** The title for the dashboard widget configuration. */
    public var title: String?
    /** The type of dashboard widget configuration. */
    public var type: ModelType?
    /** The list of metrics for the dashboard widget configuration. */
    public var metrics: [Metrics]?
    /** The display text for the dashboard widget configuration. */
    public var displayText: String?
    /** The color of the display text for the dashboard widget configuration in RGB hexadecimal format (for example \"#FF0000\" represents red). */
    public var displayTextColor: String?
    /** The external web URL for the dashboard widget configuration. */
    public var webContentUrl: String?
    /** Indicates each filter to be displayed individually. */
    public var splitFilters: Bool?
    /** Indicates that data for each media type should be shown individually. */
    public var splitByMediaType: Bool?
    /** Indicates the display be the longest time. */
    public var showLongest: Bool?
    /** Indicates the widget to be displayed as table. */
    public var displayAsTable: Bool?
    /** Indicates the display to include duration. */
    public var showDuration: Bool?
    /** The sort order of the table. */
    public var sortOrder: SortOrder?
    /** The sort key of the table. */
    public var sortKey: SortKey?
    /** Indicates the limit of displayed entities. */
    public var entityLimit: Int?
    /** Indicates whether to display aggregate across all entity and media type combination. */
    public var displayAggregates: Bool?
    /** Indicates whether a widget should take the full width of a dashboard or be shown only in a single slot. */
    public var isFullWidth: Bool?
    /** Indicates whether a widget should show the percentage diff between two values. */
    public var showPercentageChange: Bool?
    /** Indicates whether a widget should show the profile picture of an agent. */
    public var showProfilePicture: Bool?
    /** The filters to be applied for dashboard widget configuration */
    public var filter: ViewFilter?
    /** The list of periods for the dashboard widget configuration */
    public var periods: [Periods]?
    /** The list of media types for the dashboard widget configuration */
    public var mediaTypes: [MediaTypes]?
    /** List of warnings for dashboard widget configuration */
    public var warnings: [Warning]?
    /** Indicates the show time in status of a widget configuration. */
    public var showTimeInStatus: Bool?
    /** Indicates to show offline agent widget. */
    public var showOfflineAgents: Bool?
    /** Indicates the selected statuses used to filter the agent widget in the dashboard. */
    public var selectedStatuses: [SelectedStatuses]?
    /** Indicates the selected segment types used to filter the agent activity in the dashboard. */
    public var selectedSegmentTypes: [SelectedSegmentTypes]?
    /** The sort order of the interactions in the agent status widget. */
    public var agentInteractionSortOrder: AgentInteractionSortOrder?

    public init(row: Int?, column: Int?, title: String?, type: ModelType?, metrics: [Metrics]?, displayText: String?, displayTextColor: String?, webContentUrl: String?, splitFilters: Bool?, splitByMediaType: Bool?, showLongest: Bool?, displayAsTable: Bool?, showDuration: Bool?, sortOrder: SortOrder?, sortKey: SortKey?, entityLimit: Int?, displayAggregates: Bool?, isFullWidth: Bool?, showPercentageChange: Bool?, showProfilePicture: Bool?, filter: ViewFilter?, periods: [Periods]?, mediaTypes: [MediaTypes]?, warnings: [Warning]?, showTimeInStatus: Bool?, showOfflineAgents: Bool?, selectedStatuses: [SelectedStatuses]?, selectedSegmentTypes: [SelectedSegmentTypes]?, agentInteractionSortOrder: AgentInteractionSortOrder?) {
        self.row = row
        self.column = column
        self.title = title
        self.type = type
        self.metrics = metrics
        self.displayText = displayText
        self.displayTextColor = displayTextColor
        self.webContentUrl = webContentUrl
        self.splitFilters = splitFilters
        self.splitByMediaType = splitByMediaType
        self.showLongest = showLongest
        self.displayAsTable = displayAsTable
        self.showDuration = showDuration
        self.sortOrder = sortOrder
        self.sortKey = sortKey
        self.entityLimit = entityLimit
        self.displayAggregates = displayAggregates
        self.isFullWidth = isFullWidth
        self.showPercentageChange = showPercentageChange
        self.showProfilePicture = showProfilePicture
        self.filter = filter
        self.periods = periods
        self.mediaTypes = mediaTypes
        self.warnings = warnings
        self.showTimeInStatus = showTimeInStatus
        self.showOfflineAgents = showOfflineAgents
        self.selectedStatuses = selectedStatuses
        self.selectedSegmentTypes = selectedSegmentTypes
        self.agentInteractionSortOrder = agentInteractionSortOrder
    }


}




public class WfmBuIntradayDataUpdateTopicBuShortTermForecastReference: Codable {







    public var _id: String?
    public var weekDate: String?
    public var _description: String?

    public init(_id: String?, weekDate: String?, _description: String?) {
        self._id = _id
        self.weekDate = weekDate
        self._description = _description
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case weekDate
        case _description = "description"
    }


}




public class WfmBuScheduleTopicBuScheduleMetadata: Codable {



















    public var _id: String?
    public var weekDate: Date?
    public var weekCount: Int64?
    public var _description: String?
    public var published: Bool?
    public var shortTermForecast: WfmBuScheduleTopicBuShortTermForecastReference?
    public var managementUnits: [WfmBuScheduleTopicBuManagementUnitScheduleSummary]?
    public var generationResults: WfmBuScheduleTopicBuScheduleGenerationResultSummary?
    public var metadata: WfmBuScheduleTopicWfmVersionedEntityMetadata?

    public init(_id: String?, weekDate: Date?, weekCount: Int64?, _description: String?, published: Bool?, shortTermForecast: WfmBuScheduleTopicBuShortTermForecastReference?, managementUnits: [WfmBuScheduleTopicBuManagementUnitScheduleSummary]?, generationResults: WfmBuScheduleTopicBuScheduleGenerationResultSummary?, metadata: WfmBuScheduleTopicWfmVersionedEntityMetadata?) {
        self._id = _id
        self.weekDate = weekDate
        self.weekCount = weekCount
        self._description = _description
        self.published = published
        self.shortTermForecast = shortTermForecast
        self.managementUnits = managementUnits
        self.generationResults = generationResults
        self.metadata = metadata
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case weekDate
        case weekCount
        case _description = "description"
        case published
        case shortTermForecast
        case managementUnits
        case generationResults
        case metadata
    }


}




public class WfmBuScheduleTopicManagementUnit: Codable {



    public var _id: String?

    public init(_id: String?) {
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
    }


}




public class WfmBuShortTermForecastGenerateProgressTopicBuShortTermForecast: Codable {





    public enum CreationMethod: String, Codable { 
        case _import = "Import"
        case importedHistoricalWeightedAverage = "ImportedHistoricalWeightedAverage"
        case historicalWeightedAverage = "HistoricalWeightedAverage"
        case advanced = "Advanced"
    }





















    public var _id: String?
    public var weekDate: String?
    public var creationMethod: CreationMethod?
    public var _description: String?
    public var legacy: Bool?
    public var referenceStartDate: Date?
    public var sourceDays: [WfmBuShortTermForecastGenerateProgressTopicForecastSourceDayPointer]?
    public var modifications: [WfmBuShortTermForecastGenerateProgressTopicBuForecastModification]?
    public var timeZone: String?
    public var planningGroupsVersion: Int64?
    public var weekCount: Int64?
    public var metadata: WfmBuShortTermForecastGenerateProgressTopicWfmVersionedEntityMetadata?
    public var canUseForScheduling: Bool?

    public init(_id: String?, weekDate: String?, creationMethod: CreationMethod?, _description: String?, legacy: Bool?, referenceStartDate: Date?, sourceDays: [WfmBuShortTermForecastGenerateProgressTopicForecastSourceDayPointer]?, modifications: [WfmBuShortTermForecastGenerateProgressTopicBuForecastModification]?, timeZone: String?, planningGroupsVersion: Int64?, weekCount: Int64?, metadata: WfmBuShortTermForecastGenerateProgressTopicWfmVersionedEntityMetadata?, canUseForScheduling: Bool?) {
        self._id = _id
        self.weekDate = weekDate
        self.creationMethod = creationMethod
        self._description = _description
        self.legacy = legacy
        self.referenceStartDate = referenceStartDate
        self.sourceDays = sourceDays
        self.modifications = modifications
        self.timeZone = timeZone
        self.planningGroupsVersion = planningGroupsVersion
        self.weekCount = weekCount
        self.metadata = metadata
        self.canUseForScheduling = canUseForScheduling
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case weekDate
        case creationMethod
        case _description = "description"
        case legacy
        case referenceStartDate
        case sourceDays
        case modifications
        case timeZone
        case planningGroupsVersion
        case weekCount
        case metadata
        case canUseForScheduling
    }


}




public class WfmBuShortTermForecastImportCompleteTopicForecastSourceDayPointer: Codable {

    public enum DayOfWeek: String, Codable { 
        case sunday = "Sunday"
        case monday = "Monday"
        case tuesday = "Tuesday"
        case wednesday = "Wednesday"
        case thursday = "Thursday"
        case friday = "Friday"
        case saturday = "Saturday"
        case eighthDay = "EighthDay"
    }









    public var dayOfWeek: DayOfWeek?
    public var weight: Int64?
    public var date: String?
    public var fileName: String?
    public var dataKey: String?

    public init(dayOfWeek: DayOfWeek?, weight: Int64?, date: String?, fileName: String?, dataKey: String?) {
        self.dayOfWeek = dayOfWeek
        self.weight = weight
        self.date = date
        self.fileName = fileName
        self.dataKey = dataKey
    }


}




public class WfmBuShortTermForecastImportCompleteTopicUserReference: Codable {



    public var _id: String?

    public init(_id: String?) {
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
    }


}




public class WfmBuShortTermForecastStaffingRequirementsGenerateCompleteTopicBuForecastShortTermStaffingRequirementsResults: Codable {







    public var weekNumber: Int64?
    public var downloadUrl: String?
    public var downloadUrlExpirationDate: Date?

    public init(weekNumber: Int64?, downloadUrl: String?, downloadUrlExpirationDate: Date?) {
        self.weekNumber = weekNumber
        self.downloadUrl = downloadUrl
        self.downloadUrlExpirationDate = downloadUrlExpirationDate
    }


}




public class WfmBuShortTermForecastStaffingRequirementsGenerateCompleteTopicBuShortTermForecastReference: Codable {







    public var _id: String?
    public var weekDate: String?
    public var _description: String?

    public init(_id: String?, weekDate: String?, _description: String?) {
        self._id = _id
        self.weekDate = weekDate
        self._description = _description
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case weekDate
        case _description = "description"
    }


}




public class WfmHistoricalAdherenceAgentCalculationsCompleteTopicUserReference: Codable {



    public var _id: String?

    public init(_id: String?) {
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
    }


}




public class WfmHistoricalAdherenceBulkCalculationsCompleteTopicWfmHistoricalAdherenceBulkCalculationsCompleteNotification: Codable {





    public enum QueryState: String, Codable { 
        case unknown = "Unknown"
        case complete = "Complete"
        case error = "Error"
        case processing = "Processing"
    }

    public var _id: String?
    public var downloadUrls: [String]?
    public var queryState: QueryState?

    public init(_id: String?, downloadUrls: [String]?, queryState: QueryState?) {
        self._id = _id
        self.downloadUrls = downloadUrls
        self.queryState = queryState
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case downloadUrls
        case queryState
    }


}




public class WfmHistoricalAdherenceBulkItem: Codable {













    /** The ID of the management unit to query */
    public var managementUnitId: String?
    /** Beginning of the date range to query in ISO-8601 format */
    public var startDate: Date?
    /** End of the date range to query in ISO-8601 format */
    public var endDate: Date?
    /** The IDs of the users to query. If not included, will query every user in the management unit */
    public var userIds: [String]?
    /** Whether user exceptions should be returned as part of the results. Defaults to false if not specified. */
    public var includeExceptions: Bool?
    /** Whether user actual activities should be returned as part of the results. Defaults to false if not specified. */
    public var includeActuals: Bool?

    public init(managementUnitId: String?, startDate: Date?, endDate: Date?, userIds: [String]?, includeExceptions: Bool?, includeActuals: Bool?) {
        self.managementUnitId = managementUnitId
        self.startDate = startDate
        self.endDate = endDate
        self.userIds = userIds
        self.includeExceptions = includeExceptions
        self.includeActuals = includeActuals
    }


}




public class WfmHistoricalAdherenceBulkJobReference: Codable {



    public enum Status: String, Codable { 
        case processing = "Processing"
        case complete = "Complete"
        case error = "Error"
    }



    /** The ID of the historical adherence job to listen for via notification or query using the jobs route */
    public var _id: String?
    /** The status of the historical adherence job */
    public var status: Status?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, status: Status?, selfUri: String?) {
        self._id = _id
        self.status = status
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case status
        case selfUri
    }


}




public class WfmHistoricalAdherenceBulkQuery: Codable {





    /** The historical adherence items to query */
    public var items: [WfmHistoricalAdherenceBulkItem]?
    /** The time zone, in olson format, to use in defining days when computing adherence. The results will be returned as UTC timestamps regardless of the time zone input. */
    public var timeZone: String?

    public init(items: [WfmHistoricalAdherenceBulkItem]?, timeZone: String?) {
        self.items = items
        self.timeZone = timeZone
    }


}




public class WfmHistoricalAdherenceBulkResult: Codable {











    /** Beginning of the date range for this result in ISO-8601 format */
    public var startDate: Date?
    /** End of the date range for this result in ISO-8601 format */
    public var endDate: Date?
    /** The ID of the management unit for this result */
    public var managementUnitId: String?
    /** The individual results for each user */
    public var userResults: [WfmHistoricalAdherenceBulkUserResult]?
    /** Map of secondary presence lookup ID to corresponding secondary presence ID */
    public var lookupIdToSecondaryPresenceId: [String:String]?

    public init(startDate: Date?, endDate: Date?, managementUnitId: String?, userResults: [WfmHistoricalAdherenceBulkUserResult]?, lookupIdToSecondaryPresenceId: [String:String]?) {
        self.startDate = startDate
        self.endDate = endDate
        self.managementUnitId = managementUnitId
        self.userResults = userResults
        self.lookupIdToSecondaryPresenceId = lookupIdToSecondaryPresenceId
    }


}




public class WfmHistoricalAdherenceBulkUserResult: Codable {







    public enum Impact: String, Codable { 
        case positive = "Positive"
        case negative = "Negative"
        case neutral = "Neutral"
        case unknown = "Unknown"
    }







    /** The ID of the user for whom the adherence is queried */
    public var userId: String?
    /** Adherence percentage for this user, in the scale of 0 - 100 */
    public var adherencePercentage: Double?
    /** Conformance percentage for this user, in the scale of 0 - 100. Conformance percentage can be greater than 100 when the actual on-queue time is greater than the scheduled on-queue time for the same period. */
    public var conformancePercentage: Double?
    /** The impact of the current adherence state for this user */
    public var impact: Impact?
    /** List of adherence exceptions for this user */
    public var exceptionInfo: [HistoricalAdherenceExceptionInfo]?
    /** List of adherence actuals for this user */
    public var actuals: [HistoricalAdherenceActuals]?
    /** Adherence and conformance metrics for days in query range */
    public var dayMetrics: [WfmHistoricalAdherenceBulkUserDayMetrics]?

    public init(userId: String?, adherencePercentage: Double?, conformancePercentage: Double?, impact: Impact?, exceptionInfo: [HistoricalAdherenceExceptionInfo]?, actuals: [HistoricalAdherenceActuals]?, dayMetrics: [WfmHistoricalAdherenceBulkUserDayMetrics]?) {
        self.userId = userId
        self.adherencePercentage = adherencePercentage
        self.conformancePercentage = conformancePercentage
        self.impact = impact
        self.exceptionInfo = exceptionInfo
        self.actuals = actuals
        self.dayMetrics = dayMetrics
    }


}




public class WfmHistoricalAdherenceResponse: Codable {









    public enum QueryState: String, Codable { 
        case processing = "Processing"
        case complete = "Complete"
        case error = "Error"
    }

    /** The query ID to listen for */
    public var _id: String?
    /** Deprecated. Use downloadUrls instead. */
    public var downloadUrl: String?
    /** Result will always come via downloadUrls; however the schema is included for documentation */
    public var downloadResult: WfmHistoricalAdherenceResultWrapper?
    /** The uri list to GET the results of the Historical Adherence query. For notification purposes only */
    public var downloadUrls: [String]?
    /** The state of the adherence query */
    public var queryState: QueryState?

    public init(_id: String?, downloadUrl: String?, downloadResult: WfmHistoricalAdherenceResultWrapper?, downloadUrls: [String]?, queryState: QueryState?) {
        self._id = _id
        self.downloadUrl = downloadUrl
        self.downloadResult = downloadResult
        self.downloadUrls = downloadUrls
        self.queryState = queryState
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case downloadUrl
        case downloadResult
        case downloadUrls
        case queryState
    }


}




public class WfmIntradayDataUpdateTopicIntradayDataGroup: Codable {

    public enum MediaType: String, Codable { 
        case voice = "Voice"
        case chat = "Chat"
        case email = "Email"
        case callback = "Callback"
        case message = "Message"
        case workitem = "Workitem"
    }













    public var mediaType: MediaType?
    public var forecastDataPerInterval: [WfmIntradayDataUpdateTopicIntradayForecastData]?
    public var scheduleDataPerInterval: [WfmIntradayDataUpdateTopicIntradayScheduleData]?
    public var historicalAgentDataPerInterval: [WfmIntradayDataUpdateTopicIntradayHistoricalAgentData]?
    public var historicalQueueDataPerInterval: [WfmIntradayDataUpdateTopicIntradayHistoricalQueueData]?
    public var performancePredictionAgentDataPerInterval: [WfmIntradayDataUpdateTopicIntradayPerformancePredictionAgentData]?
    public var performancePredictionQueueDataPerInterval: [WfmIntradayDataUpdateTopicIntradayPerformancePredictionQueueData]?

    public init(mediaType: MediaType?, forecastDataPerInterval: [WfmIntradayDataUpdateTopicIntradayForecastData]?, scheduleDataPerInterval: [WfmIntradayDataUpdateTopicIntradayScheduleData]?, historicalAgentDataPerInterval: [WfmIntradayDataUpdateTopicIntradayHistoricalAgentData]?, historicalQueueDataPerInterval: [WfmIntradayDataUpdateTopicIntradayHistoricalQueueData]?, performancePredictionAgentDataPerInterval: [WfmIntradayDataUpdateTopicIntradayPerformancePredictionAgentData]?, performancePredictionQueueDataPerInterval: [WfmIntradayDataUpdateTopicIntradayPerformancePredictionQueueData]?) {
        self.mediaType = mediaType
        self.forecastDataPerInterval = forecastDataPerInterval
        self.scheduleDataPerInterval = scheduleDataPerInterval
        self.historicalAgentDataPerInterval = historicalAgentDataPerInterval
        self.historicalQueueDataPerInterval = historicalQueueDataPerInterval
        self.performancePredictionAgentDataPerInterval = performancePredictionAgentDataPerInterval
        self.performancePredictionQueueDataPerInterval = performancePredictionQueueDataPerInterval
    }


}




public class WfmMoveAgentsCompleteTopicUserReference: Codable {



    public var _id: String?

    public init(_id: String?) {
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
    }


}




public class WfmMoveManagementUnitTopicMoveManagementUnitNotification: Codable {



    public enum Status: String, Codable { 
        case processing = "Processing"
        case complete = "Complete"
        case canceled = "Canceled"
        case error = "Error"
    }

    public var businessUnit: WfmMoveManagementUnitTopicBusinessUnit?
    public var status: Status?

    public init(businessUnit: WfmMoveManagementUnitTopicBusinessUnit?, status: Status?) {
        self.businessUnit = businessUnit
        self.status = status
    }


}




public class WfmScheduleReference: Codable {









    /** The ID of the WFM schedule */
    public var _id: String?
    /** A reference to a Workforce Management Business Unit */
    public var businessUnit: WfmBusinessUnitReference?
    /** The start week date for this schedule. Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd */
    public var weekDate: Date?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, businessUnit: WfmBusinessUnitReference?, weekDate: Date?, selfUri: String?) {
        self._id = _id
        self.businessUnit = businessUnit
        self.weekDate = weekDate
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case businessUnit
        case weekDate
        case selfUri
    }


}




public class WfmServiceGoalImpact: Codable {





    /** The maximum allowed percent increase from the configured goal */
    public var increaseByPercent: Double?
    /** The maximum allowed percent decrease from the configured goal */
    public var decreaseByPercent: Double?

    public init(increaseByPercent: Double?, decreaseByPercent: Double?) {
        self.increaseByPercent = increaseByPercent
        self.decreaseByPercent = decreaseByPercent
    }


}




public class WfmTimeOffBalanceJobTopicErrorBody: Codable {









    public var status: Int64?
    public var code: String?
    public var message: String?
    public var messageParams: [String:String]?

    public init(status: Int64?, code: String?, message: String?, messageParams: [String:String]?) {
        self.status = status
        self.code = code
        self.message = message
        self.messageParams = messageParams
    }


}




public class WfmTimeOffBalanceJobTopicTimeOffBalance: Codable {











    public var activityCodeId: String?
    public var hrisTimeOffTypeId: String?
    public var hrisTimeOffTypeSecondaryId: String?
    public var startDate: Date?
    public var balanceMinutesPerDay: [Int64]?

    public init(activityCodeId: String?, hrisTimeOffTypeId: String?, hrisTimeOffTypeSecondaryId: String?, startDate: Date?, balanceMinutesPerDay: [Int64]?) {
        self.activityCodeId = activityCodeId
        self.hrisTimeOffTypeId = hrisTimeOffTypeId
        self.hrisTimeOffTypeSecondaryId = hrisTimeOffTypeSecondaryId
        self.startDate = startDate
        self.balanceMinutesPerDay = balanceMinutesPerDay
    }


}




public class WfmUserNotificationTopicWfmUserNotification: Codable {







    public enum ModelType: String, Codable { 
        case shiftTrade = "ShiftTrade"
        case timeOffRequest = "TimeOffRequest"
        case adherenceExplanation = "AdherenceExplanation"
        case alternativeShift = "AlternativeShift"
    }















    public var _id: String?
    public var mutableGroupId: String?
    public var timestamp: Date?
    public var type: ModelType?
    public var shiftTrade: WfmUserNotificationTopicShiftTradeNotification?
    public var timeOffRequest: WfmUserNotificationTopicTimeOffRequestNotification?
    public var adherenceExplanation: WfmUserNotificationTopicAdherenceExplanationNotification?
    public var alternativeShift: WfmUserNotificationTopicAlternativeShiftNotification?
    public var agentNotification: Bool?
    public var otherNotificationIdsInGroup: [String]?
    public var markedAsRead: Bool?

    public init(_id: String?, mutableGroupId: String?, timestamp: Date?, type: ModelType?, shiftTrade: WfmUserNotificationTopicShiftTradeNotification?, timeOffRequest: WfmUserNotificationTopicTimeOffRequestNotification?, adherenceExplanation: WfmUserNotificationTopicAdherenceExplanationNotification?, alternativeShift: WfmUserNotificationTopicAlternativeShiftNotification?, agentNotification: Bool?, otherNotificationIdsInGroup: [String]?, markedAsRead: Bool?) {
        self._id = _id
        self.mutableGroupId = mutableGroupId
        self.timestamp = timestamp
        self.type = type
        self.shiftTrade = shiftTrade
        self.timeOffRequest = timeOffRequest
        self.adherenceExplanation = adherenceExplanation
        self.alternativeShift = alternativeShift
        self.agentNotification = agentNotification
        self.otherNotificationIdsInGroup = otherNotificationIdsInGroup
        self.markedAsRead = markedAsRead
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case mutableGroupId
        case timestamp
        case type
        case shiftTrade
        case timeOffRequest
        case adherenceExplanation
        case alternativeShift
        case agentNotification
        case otherNotificationIdsInGroup
        case markedAsRead
    }


}




public class WfmUserScheduleAdherenceUpdatedMuTopicActivityCodeReference: Codable {





    public var _id: String?
    public var secondaryPresences: [WfmUserScheduleAdherenceUpdatedMuTopicSecondaryPresenceReference]?

    public init(_id: String?, secondaryPresences: [WfmUserScheduleAdherenceUpdatedMuTopicSecondaryPresenceReference]?) {
        self._id = _id
        self.secondaryPresences = secondaryPresences
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case secondaryPresences
    }


}




public class WfmUserScheduleAdherenceUpdatedMuTopicUriReference: Codable {





    /** The ID of the resource */
    public var _id: String?
    /** The name of the resource */
    public var name: String?

    public init(_id: String?, name: String?) {
        self._id = _id
        self.name = name
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
    }


}




public class WfmUserScheduleAdherenceUpdatedTeamTopicQueueReference: Codable {



    public var _id: String?

    public init(_id: String?) {
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
    }


}




public class WfmUserScheduleAdherenceUpdatedTeamTopicSecondaryPresenceReference: Codable {



    public var _id: String?

    public init(_id: String?) {
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
    }


}




public class WfmUserScheduleAdherenceUpdatedTopicUserScheduleAdherenceUpdate: Codable {















    public enum RoutingStatus: String, Codable { 
        case empty = "__EMPTY__"
        case offQueue = "OFF_QUEUE"
        case idle = "IDLE"
        case interacting = "INTERACTING"
        case notResponding = "NOT_RESPONDING"
        case communicating = "COMMUNICATING"
        case offline = "OFFLINE"
    }





    public enum AdherenceState: String, Codable { 
        case inAdherence = "InAdherence"
        case outOfAdherence = "OutOfAdherence"
        case unscheduled = "Unscheduled"
        case unknown = "Unknown"
        case ignored = "Ignored"
        case explained = "Explained"
    }



















    public var user: WfmUserScheduleAdherenceUpdatedTopicUserReference?
    public var managementUnitId: String?
    public var team: WfmUserScheduleAdherenceUpdatedTopicUriReference?
    public var scheduledActivityCategory: String?
    public var scheduledActivityCode: WfmUserScheduleAdherenceUpdatedTopicActivityCodeReference?
    public var systemPresence: String?
    public var organizationSecondaryPresenceId: String?
    public var routingStatus: RoutingStatus?
    public var actualActivityCategory: String?
    public var isOutOfOffice: Bool?
    public var adherenceState: AdherenceState?
    public var impact: String?
    public var adherenceExplanation: WfmUserScheduleAdherenceUpdatedTopicRealTimeAdherenceExplanation?
    public var adherenceChangeTime: Date?
    public var presenceUpdateTime: Date?
    public var activeQueues: [WfmUserScheduleAdherenceUpdatedTopicQueueReference]?
    public var activeQueuesModifiedTime: Date?
    public var removedFromManagementUnit: Bool?
    public var suppressOnTimeReminder: Bool?
    public var nextActivityReminders: [WfmUserScheduleAdherenceUpdatedTopicUserNextActivityReminder]?

    public init(user: WfmUserScheduleAdherenceUpdatedTopicUserReference?, managementUnitId: String?, team: WfmUserScheduleAdherenceUpdatedTopicUriReference?, scheduledActivityCategory: String?, scheduledActivityCode: WfmUserScheduleAdherenceUpdatedTopicActivityCodeReference?, systemPresence: String?, organizationSecondaryPresenceId: String?, routingStatus: RoutingStatus?, actualActivityCategory: String?, isOutOfOffice: Bool?, adherenceState: AdherenceState?, impact: String?, adherenceExplanation: WfmUserScheduleAdherenceUpdatedTopicRealTimeAdherenceExplanation?, adherenceChangeTime: Date?, presenceUpdateTime: Date?, activeQueues: [WfmUserScheduleAdherenceUpdatedTopicQueueReference]?, activeQueuesModifiedTime: Date?, removedFromManagementUnit: Bool?, suppressOnTimeReminder: Bool?, nextActivityReminders: [WfmUserScheduleAdherenceUpdatedTopicUserNextActivityReminder]?) {
        self.user = user
        self.managementUnitId = managementUnitId
        self.team = team
        self.scheduledActivityCategory = scheduledActivityCategory
        self.scheduledActivityCode = scheduledActivityCode
        self.systemPresence = systemPresence
        self.organizationSecondaryPresenceId = organizationSecondaryPresenceId
        self.routingStatus = routingStatus
        self.actualActivityCategory = actualActivityCategory
        self.isOutOfOffice = isOutOfOffice
        self.adherenceState = adherenceState
        self.impact = impact
        self.adherenceExplanation = adherenceExplanation
        self.adherenceChangeTime = adherenceChangeTime
        self.presenceUpdateTime = presenceUpdateTime
        self.activeQueues = activeQueues
        self.activeQueuesModifiedTime = activeQueuesModifiedTime
        self.removedFromManagementUnit = removedFromManagementUnit
        self.suppressOnTimeReminder = suppressOnTimeReminder
        self.nextActivityReminders = nextActivityReminders
    }


}




public class WhatsAppEmbeddedSignupIntegrationRequest: Codable {













    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The name of the WhatsApp Integration */
    public var name: String?
    /** Defines the SupportedContent profile configured for an integration */
    public var supportedContent: SupportedContentReference?
    /** Defines the message settings to be applied for this integration */
    public var messagingSetting: MessagingSettingRequestReference?
    /** The access token returned from the embedded signup flow */
    public var embeddedSignupAccessToken: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, supportedContent: SupportedContentReference?, messagingSetting: MessagingSettingRequestReference?, embeddedSignupAccessToken: String?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.supportedContent = supportedContent
        self.messagingSetting = messagingSetting
        self.embeddedSignupAccessToken = embeddedSignupAccessToken
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case supportedContent
        case messagingSetting
        case embeddedSignupAccessToken
        case selfUri
    }


}



/** Wheel picker component with selectable items */

public class WheelPicker: Codable {





    /** Unique identifier for the wheel picker (generated by backend) */
    public var _id: String?
    /** Items in the wheel picker */
    public var items: [WheelPickerItem]?

    public init(_id: String?, items: [WheelPickerItem]?) {
        self._id = _id
        self.items = items
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case items
    }


}




public class WidgetClientConfig: Codable {









    public var v1: WidgetClientConfigV1?
    public var v2: JSON?
    public var v1Http: WidgetClientConfigV1Http?
    public var thirdParty: JSON?

    public init(v1: WidgetClientConfigV1?, v2: JSON?, v1Http: WidgetClientConfigV1Http?, thirdParty: JSON?) {
        self.v1 = v1
        self.v2 = v2
        self.v1Http = v1Http
        self.thirdParty = thirdParty
    }

    public enum CodingKeys: String, CodingKey { 
        case v1
        case v2
        case v1Http = "v1-http"
        case thirdParty = "third-party"
    }


}




public class WidgetClientConfigV1: Codable {

    public enum WebChatSkin: String, Codable { 
        case basic = "basic"
        case modernCaretSkin = "modern-caret-skin"
    }



    public var webChatSkin: WebChatSkin?
    public var authenticationUrl: String?

    public init(webChatSkin: WebChatSkin?, authenticationUrl: String?) {
        self.webChatSkin = webChatSkin
        self.authenticationUrl = authenticationUrl
    }


}




public class WorkPlanBidGroupResponse: Codable {









    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The work plan bid group */
    public var workPlanBidGroup: WorkPlanBidGroup?
    /** The meta data of the bid group */
    public var metadata: WorkPlanBidMetadata?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, workPlanBidGroup: WorkPlanBidGroup?, metadata: WorkPlanBidMetadata?, selfUri: String?) {
        self._id = _id
        self.workPlanBidGroup = workPlanBidGroup
        self.metadata = metadata
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case workPlanBidGroup
        case metadata
        case selfUri
    }


}




public class WorkPlanBidGroupSummaryList: Codable {



    /** List of work plan bid group summary */
    public var workPlanBidGroupSummaryList: [WorkPlanBidGroupSummary]?

    public init(workPlanBidGroupSummaryList: [WorkPlanBidGroupSummary]?) {
        self.workPlanBidGroupSummaryList = workPlanBidGroupSummaryList
    }


}




public class WorkPlanConstraintConflictMessage: Codable {

    public enum ModelType: String, Codable { 
        case unknownFix = "UnknownFix"
        case withPotentialFixes = "WithPotentialFixes"
    }



    /** Type of constraint conflict that can be resolved by clients in order to generate agent schedules */
    public var type: ModelType?
    /** The arguments to the type of the message that can help clients resolve validation issues */
    public var arguments: [WorkPlanValidationMessageArgument]?

    public init(type: ModelType?, arguments: [WorkPlanValidationMessageArgument]?) {
        self.type = type
        self.arguments = arguments
    }


}




public class WorkPlanListItemResponse: Codable {

























































    public enum ShiftStartVarianceType: String, Codable { 
        case shiftStart = "ShiftStart"
        case shiftStartAndPaidDuration = "ShiftStartAndPaidDuration"
    }













    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** Whether the work plan is enabled for scheduling */
    public var enabled: Bool?
    /** Whether the work plan is valid or not */
    public var valid: Bool?
    /** Whether the weekly paid time constraint is enabled for this work plan */
    public var constrainWeeklyPaidTime: Bool?
    /** Whether the weekly paid time constraint is flexible for this work plan */
    public var flexibleWeeklyPaidTime: Bool?
    /** Exact weekly paid time in minutes for this work plan. Used if flexibleWeeklyPaidTime == false */
    public var weeklyExactPaidMinutes: Int?
    /** Minimum weekly paid time in minutes for this work plan. Used if flexibleWeeklyPaidTime == true */
    public var weeklyMinimumPaidMinutes: Int?
    /** Maximum weekly paid time in minutes for this work plan. Used if flexibleWeeklyPaidTime == true */
    public var weeklyMaximumPaidMinutes: Int?
    /** Whether paid time granularity is constrained for this work plan */
    public var constrainPaidTimeGranularity: Bool?
    /** Granularity in minutes allowed for shift paid time in this work plan. Used if constrainPaidTimeGranularity == true */
    public var paidTimeGranularityMinutes: Int?
    /** Whether the minimum time between shifts constraint is enabled for this work plan */
    public var constrainMinimumTimeBetweenShifts: Bool?
    /** Minimum time between shifts in minutes defined in this work plan. Used if constrainMinimumTimeBetweenShifts == true */
    public var minimumTimeBetweenShiftsMinutes: Int?
    /** Maximum number days in a week allowed to be scheduled for this work plan */
    public var maximumDays: Int?
    /** Minimum amount of consecutive non working minutes per week that agents who are assigned this work plan are allowed to have off */
    public var minimumConsecutiveNonWorkingMinutesPerWeek: Int?
    /** Whether to constrain the maximum consecutive working weekends */
    public var constrainMaximumConsecutiveWorkingWeekends: Bool?
    /** The maximum number of consecutive weekends that agents who are assigned to this work plan are allowed to work */
    public var maximumConsecutiveWorkingWeekends: Int?
    /** The minimum number of days that agents assigned to a work plan must work per week */
    public var minimumWorkingDaysPerWeek: Int?
    /** Whether to constrain the maximum consecutive working days */
    public var constrainMaximumConsecutiveWorkingDays: Bool?
    /** The maximum number of consecutive days that agents assigned to this work plan are allowed to work. Used if constrainMaximumConsecutiveWorkingDays == true */
    public var maximumConsecutiveWorkingDays: Int?
    /** The time period in minutes for the duration between the start times of two consecutive working days */
    public var minimumShiftStartDistanceMinutes: Int?
    /** Minimum days off in the planning period */
    public var minimumDaysOffPerPlanningPeriod: Int?
    /** Maximum days off in the planning period */
    public var maximumDaysOffPerPlanningPeriod: Int?
    /** Minimum paid minutes in the planning period */
    public var minimumPaidMinutesPerPlanningPeriod: Int?
    /** Maximum paid minutes in the planning period */
    public var maximumPaidMinutesPerPlanningPeriod: Int?
    /** Whether to constrain the maximum working weekends in the planning period */
    public var constrainMaximumWorkingWeekendsPerPlanningPeriod: Bool?
    /** Maximum working weekends in the planning period */
    public var maximumWorkingWeekendsPerPlanningPeriod: Int?
    /** Optional days to schedule for this work plan. Populate with expand=details */
    public var optionalDays: SetWrapperDayOfWeek?
    /** This constraint ensures that an agent starts each workday within a user-defined time threshold */
    public var shiftStartVarianceType: ShiftStartVarianceType?
    /** Variance in minutes among start times of shifts in this work plan. Populate with expand=details */
    public var shiftStartVariances: ListWrapperShiftStartVariance?
    /** Shifts in this work plan. Populate with expand=details (defaults to empty list) */
    public var shifts: [WorkPlanShift]?
    /** Agents in this work plan. Populate with expand=details (defaults to empty list) */
    public var agents: [DeletableUserReference]?
    /** Number of agents in this work plan.  Populate with expand=agentCount */
    public var agentCount: Int?
    /** Version metadata for this work plan */
    public var metadata: WfmVersionedEntityMetadata?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, enabled: Bool?, valid: Bool?, constrainWeeklyPaidTime: Bool?, flexibleWeeklyPaidTime: Bool?, weeklyExactPaidMinutes: Int?, weeklyMinimumPaidMinutes: Int?, weeklyMaximumPaidMinutes: Int?, constrainPaidTimeGranularity: Bool?, paidTimeGranularityMinutes: Int?, constrainMinimumTimeBetweenShifts: Bool?, minimumTimeBetweenShiftsMinutes: Int?, maximumDays: Int?, minimumConsecutiveNonWorkingMinutesPerWeek: Int?, constrainMaximumConsecutiveWorkingWeekends: Bool?, maximumConsecutiveWorkingWeekends: Int?, minimumWorkingDaysPerWeek: Int?, constrainMaximumConsecutiveWorkingDays: Bool?, maximumConsecutiveWorkingDays: Int?, minimumShiftStartDistanceMinutes: Int?, minimumDaysOffPerPlanningPeriod: Int?, maximumDaysOffPerPlanningPeriod: Int?, minimumPaidMinutesPerPlanningPeriod: Int?, maximumPaidMinutesPerPlanningPeriod: Int?, constrainMaximumWorkingWeekendsPerPlanningPeriod: Bool?, maximumWorkingWeekendsPerPlanningPeriod: Int?, optionalDays: SetWrapperDayOfWeek?, shiftStartVarianceType: ShiftStartVarianceType?, shiftStartVariances: ListWrapperShiftStartVariance?, shifts: [WorkPlanShift]?, agents: [DeletableUserReference]?, agentCount: Int?, metadata: WfmVersionedEntityMetadata?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.enabled = enabled
        self.valid = valid
        self.constrainWeeklyPaidTime = constrainWeeklyPaidTime
        self.flexibleWeeklyPaidTime = flexibleWeeklyPaidTime
        self.weeklyExactPaidMinutes = weeklyExactPaidMinutes
        self.weeklyMinimumPaidMinutes = weeklyMinimumPaidMinutes
        self.weeklyMaximumPaidMinutes = weeklyMaximumPaidMinutes
        self.constrainPaidTimeGranularity = constrainPaidTimeGranularity
        self.paidTimeGranularityMinutes = paidTimeGranularityMinutes
        self.constrainMinimumTimeBetweenShifts = constrainMinimumTimeBetweenShifts
        self.minimumTimeBetweenShiftsMinutes = minimumTimeBetweenShiftsMinutes
        self.maximumDays = maximumDays
        self.minimumConsecutiveNonWorkingMinutesPerWeek = minimumConsecutiveNonWorkingMinutesPerWeek
        self.constrainMaximumConsecutiveWorkingWeekends = constrainMaximumConsecutiveWorkingWeekends
        self.maximumConsecutiveWorkingWeekends = maximumConsecutiveWorkingWeekends
        self.minimumWorkingDaysPerWeek = minimumWorkingDaysPerWeek
        self.constrainMaximumConsecutiveWorkingDays = constrainMaximumConsecutiveWorkingDays
        self.maximumConsecutiveWorkingDays = maximumConsecutiveWorkingDays
        self.minimumShiftStartDistanceMinutes = minimumShiftStartDistanceMinutes
        self.minimumDaysOffPerPlanningPeriod = minimumDaysOffPerPlanningPeriod
        self.maximumDaysOffPerPlanningPeriod = maximumDaysOffPerPlanningPeriod
        self.minimumPaidMinutesPerPlanningPeriod = minimumPaidMinutesPerPlanningPeriod
        self.maximumPaidMinutesPerPlanningPeriod = maximumPaidMinutesPerPlanningPeriod
        self.constrainMaximumWorkingWeekendsPerPlanningPeriod = constrainMaximumWorkingWeekendsPerPlanningPeriod
        self.maximumWorkingWeekendsPerPlanningPeriod = maximumWorkingWeekendsPerPlanningPeriod
        self.optionalDays = optionalDays
        self.shiftStartVarianceType = shiftStartVarianceType
        self.shiftStartVariances = shiftStartVariances
        self.shifts = shifts
        self.agents = agents
        self.agentCount = agentCount
        self.metadata = metadata
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case enabled
        case valid
        case constrainWeeklyPaidTime
        case flexibleWeeklyPaidTime
        case weeklyExactPaidMinutes
        case weeklyMinimumPaidMinutes
        case weeklyMaximumPaidMinutes
        case constrainPaidTimeGranularity
        case paidTimeGranularityMinutes
        case constrainMinimumTimeBetweenShifts
        case minimumTimeBetweenShiftsMinutes
        case maximumDays
        case minimumConsecutiveNonWorkingMinutesPerWeek
        case constrainMaximumConsecutiveWorkingWeekends
        case maximumConsecutiveWorkingWeekends
        case minimumWorkingDaysPerWeek
        case constrainMaximumConsecutiveWorkingDays
        case maximumConsecutiveWorkingDays
        case minimumShiftStartDistanceMinutes
        case minimumDaysOffPerPlanningPeriod
        case maximumDaysOffPerPlanningPeriod
        case minimumPaidMinutesPerPlanningPeriod
        case maximumPaidMinutesPerPlanningPeriod
        case constrainMaximumWorkingWeekendsPerPlanningPeriod
        case maximumWorkingWeekendsPerPlanningPeriod
        case optionalDays
        case shiftStartVarianceType
        case shiftStartVariances
        case shifts
        case agents
        case agentCount
        case metadata
        case selfUri
    }


}




public class Workbin: Codable {

















    /** The globally unique identifier for the object. */
    public var _id: String?
    /** Workbin name */
    public var name: String?
    /** The division to which this entity belongs. */
    public var division: Division?
    /** Workbin description */
    public var _description: String?
    /** The creation date of the Workbin. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** The modified date of the Workbin. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** The id of the User who modified the Workbin. */
    public var modifiedBy: UserReference?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, division: Division?, _description: String?, dateCreated: Date?, dateModified: Date?, modifiedBy: UserReference?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.division = division
        self._description = _description
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.modifiedBy = modifiedBy
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case division
        case _description = "description"
        case dateCreated
        case dateModified
        case modifiedBy
        case selfUri
    }


}




public class WorkbinDelta: Codable {









    public var name: WorkitemsAttributeChangeString?
    public var _description: WorkitemsAttributeChangeString?
    public var dateModified: WorkitemsAttributeChangeInstant?
    public var modifiedBy: WorkitemsAttributeChangeString?

    public init(name: WorkitemsAttributeChangeString?, _description: WorkitemsAttributeChangeString?, dateModified: WorkitemsAttributeChangeInstant?, modifiedBy: WorkitemsAttributeChangeString?) {
        self.name = name
        self._description = _description
        self.dateModified = dateModified
        self.modifiedBy = modifiedBy
    }

    public enum CodingKeys: String, CodingKey { 
        case name
        case _description = "description"
        case dateModified
        case modifiedBy
    }


}




public class WorkdayPointsTrendItem: Codable {





    /** workday date for the points trend. Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd */
    public var dateWorkday: Date?
    /** workday points for the date */
    public var points: Double?

    public init(dateWorkday: Date?, points: Double?) {
        self.dateWorkday = dateWorkday
        self.points = points
    }


}




public class WorkdayValuesMetricItem: Codable {







    public enum UnitType: String, Codable { 
        case _none = "None"
        case percent = "Percent"
        case currency = "Currency"
        case seconds = "Seconds"
        case number = "Number"
        case attendanceStatus = "AttendanceStatus"
        case unit = "Unit"
    }



    /** Gamification metric for the average and the trend */
    public var metric: AddressableEntityRef?
    /** Gamification metric definition for the average and the trend */
    public var metricDefinition: DomainEntityRef?
    /** The average value of the metric */
    public var average: Double?
    /** The unit type of the metric value */
    public var unitType: UnitType?
    /** The metric value trend */
    public var trend: [WorkdayValuesTrendItem]?

    public init(metric: AddressableEntityRef?, metricDefinition: DomainEntityRef?, average: Double?, unitType: UnitType?, trend: [WorkdayValuesTrendItem]?) {
        self.metric = metric
        self.metricDefinition = metricDefinition
        self.average = average
        self.unitType = unitType
        self.trend = trend
    }


}




public class WorkitemChangeListing: Codable {











    public var entities: [WorkitemsChangeWorkitemDelta]?
    public var nextUri: String?
    public var selfUri: String?
    public var previousUri: String?
    public var after: String?

    public init(entities: [WorkitemsChangeWorkitemDelta]?, nextUri: String?, selfUri: String?, previousUri: String?, after: String?) {
        self.entities = entities
        self.nextUri = nextUri
        self.selfUri = selfUri
        self.previousUri = previousUri
        self.after = after
    }


}




public class WorkitemDateBasedConditionUpdate: Codable {

    public enum Attribute: String, Codable { 
        case datedue = "dateDue"
        case dateexpires = "dateExpires"
        case ttl = "ttl"
        case datecreated = "dateCreated"
    }



    /** The name of the workitem date attribute. */
    public var attribute: Attribute?
    /** The time in minutes before or after the date attribute. */
    public var relativeMinutesToInvocation: Int?

    public init(attribute: Attribute?, relativeMinutesToInvocation: Int?) {
        self.attribute = attribute
        self.relativeMinutesToInvocation = relativeMinutesToInvocation
    }


}




public class WorkitemOnAttributeChangeRule: Codable {





    public enum ModelType: String, Codable { 
        case onCreate = "OnCreate"
        case onAttributeChange = "OnAttributeChange"
        case date = "Date"
    }









    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** The type of the rule. */
    public var type: ModelType?
    /** The rules action. If the condition criteria is met this action will be executed. */
    public var action: WorkitemRuleAction?
    /** The Worktype containing the rule. */
    public var worktype: WorktypeReference?
    /** The rules condition. If the condition criteria is met the rules action will be executed. */
    public var condition: WorkitemOnAttributeChangeCondition?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, type: ModelType?, action: WorkitemRuleAction?, worktype: WorktypeReference?, condition: WorkitemOnAttributeChangeCondition?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.type = type
        self.action = action
        self.worktype = worktype
        self.condition = condition
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case type
        case action
        case worktype
        case condition
        case selfUri
    }


}




public class WorkitemOnAttributeChangeRuleListing: Codable {











    public var entities: [WorkitemOnAttributeChangeRule]?
    public var nextUri: String?
    public var selfUri: String?
    public var previousUri: String?
    public var after: String?

    public init(entities: [WorkitemOnAttributeChangeRule]?, nextUri: String?, selfUri: String?, previousUri: String?, after: String?) {
        self.entities = entities
        self.nextUri = nextUri
        self.selfUri = selfUri
        self.previousUri = previousUri
        self.after = after
    }


}




public class WorkitemRuleSettings: Codable {



    /** When set to true, the worktypes flow rules will be processed. Default value is false. */
    public var flowRulesEnabled: Bool?

    public init(flowRulesEnabled: Bool?) {
        self.flowRulesEnabled = flowRulesEnabled
    }


}




public class WorkitemTerminate: Codable {



    /** The ID of the status the workitem should be updated to when terminating. The status must be a 'Closed' category status. */
    public var statusId: String?

    public init(statusId: String?) {
        self.statusId = statusId
    }


}




public class WorkitemVersion: Codable {































    public enum StatusCategory: String, Codable { 
        case _open = "Open"
        case inProgress = "InProgress"
        case waiting = "Waiting"
        case closed = "Closed"
        case unknown = "Unknown"
    }



















    public enum AssignmentState: String, Codable { 
        case unknown = "Unknown"
        case acdStarted = "AcdStarted"
        case alerting = "Alerting"
        case alertTimeout = "AlertTimeout"
        case acdCancelled = "AcdCancelled"
        case terminated = "Terminated"
        case idle = "Idle"
        case declined = "Declined"
        case connected = "Connected"
        case disconnected = "Disconnected"
        case parked = "Parked"
        case held = "Held"
        case acdExpired = "AcdExpired"
    }

























    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The name of the Workitem. */
    public var name: String?
    /** The division to which this entity belongs. */
    public var division: Division?
    /** The Worktype of the Workitem. */
    public var type: WorktypeReference?
    /** The description of the Workitem. */
    public var _description: String?
    /** The language of the Workitem. */
    public var language: LanguageReference?
    /** The utilization label of the Workitem. */
    public var utilizationLabel: WorkitemUtilizationLabelReference?
    /** The priority of the Workitem. The valid range is between -25,000,000 and 25,000,000. */
    public var priority: Int?
    /** The creation date of the Workitem. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** The modified date of the Workitem. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** The due date of the Workitem. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateDue: Date?
    /** The expiry date of the Workitem. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateExpires: Date?
    /** The estimated duration in seconds to complete the workitem. */
    public var durationSeconds: Int?
    /** The time to live of the Workitem in seconds. */
    public var ttl: Int?
    /** The current Status of the Workitem. */
    public var status: WorkitemStatusReference?
    /** The Category of the current Status of the Workitem. */
    public var statusCategory: StatusCategory?
    /** The State change date. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateStatusChanged: Date?
    /** The date the Workitem was closed. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateClosed: Date?
    /** The Workbin that contains the Workitem. */
    public var workbin: WorkbinReference?
    /** The reporter of the Workitem. */
    public var reporter: UserReferenceWithName?
    /** The assignee of the Workitem. */
    public var assignee: UserReferenceWithName?
    /** The external contact of the Workitem. */
    public var externalContact: ExternalContactReference?
    /** The external tag of the Workitem. */
    public var externalTag: String?
    /** The User who modified the Workitem. */
    public var modifiedBy: UserReference?
    /** The Workitems queue. */
    public var queue: WorkitemQueueReference?
    /** The assignment state of the workitem. */
    public var assignmentState: AssignmentState?
    /** The assignment state change date. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateAssignmentStateChanged: Date?
    /** The duration in seconds before an alert will timeout. */
    public var alertTimeoutSeconds: Int?
    /** The skills of the Workitem. */
    public var skills: [RoutingSkillReference]?
    /** The preferred agents of the Workitem. */
    public var preferredAgents: [UserReference]?
    /** Set it to false to disable auto status transition. By default, it is enabled. */
    public var autoStatusTransition: Bool?
    /** The schema defining the custom fields of the Workitem. The schema is inherited from the Workitems Worktype at creation time. */
    public var schema: WorkitemSchema?
    /** Custom fields defined in the schema referenced by the Workitem. */
    public var customFields: [String:JSON]?
    /** Auto status transition details of Workitem. */
    public var autoStatusTransitionDetail: AutoStatusTransitionDetail?
    /** A list of scored agents for the Workitem. */
    public var scoredAgents: [WorkitemScoredAgent]?
    /** The script that will be executed for the Workitem. */
    public var script: WorkitemScriptReference?
    /** Version */
    public var version: Int?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, division: Division?, type: WorktypeReference?, _description: String?, language: LanguageReference?, utilizationLabel: WorkitemUtilizationLabelReference?, priority: Int?, dateCreated: Date?, dateModified: Date?, dateDue: Date?, dateExpires: Date?, durationSeconds: Int?, ttl: Int?, status: WorkitemStatusReference?, statusCategory: StatusCategory?, dateStatusChanged: Date?, dateClosed: Date?, workbin: WorkbinReference?, reporter: UserReferenceWithName?, assignee: UserReferenceWithName?, externalContact: ExternalContactReference?, externalTag: String?, modifiedBy: UserReference?, queue: WorkitemQueueReference?, assignmentState: AssignmentState?, dateAssignmentStateChanged: Date?, alertTimeoutSeconds: Int?, skills: [RoutingSkillReference]?, preferredAgents: [UserReference]?, autoStatusTransition: Bool?, schema: WorkitemSchema?, customFields: [String:JSON]?, autoStatusTransitionDetail: AutoStatusTransitionDetail?, scoredAgents: [WorkitemScoredAgent]?, script: WorkitemScriptReference?, version: Int?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.division = division
        self.type = type
        self._description = _description
        self.language = language
        self.utilizationLabel = utilizationLabel
        self.priority = priority
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.dateDue = dateDue
        self.dateExpires = dateExpires
        self.durationSeconds = durationSeconds
        self.ttl = ttl
        self.status = status
        self.statusCategory = statusCategory
        self.dateStatusChanged = dateStatusChanged
        self.dateClosed = dateClosed
        self.workbin = workbin
        self.reporter = reporter
        self.assignee = assignee
        self.externalContact = externalContact
        self.externalTag = externalTag
        self.modifiedBy = modifiedBy
        self.queue = queue
        self.assignmentState = assignmentState
        self.dateAssignmentStateChanged = dateAssignmentStateChanged
        self.alertTimeoutSeconds = alertTimeoutSeconds
        self.skills = skills
        self.preferredAgents = preferredAgents
        self.autoStatusTransition = autoStatusTransition
        self.schema = schema
        self.customFields = customFields
        self.autoStatusTransitionDetail = autoStatusTransitionDetail
        self.scoredAgents = scoredAgents
        self.script = script
        self.version = version
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case division
        case type
        case _description = "description"
        case language
        case utilizationLabel
        case priority
        case dateCreated
        case dateModified
        case dateDue
        case dateExpires
        case durationSeconds
        case ttl
        case status
        case statusCategory
        case dateStatusChanged
        case dateClosed
        case workbin
        case reporter
        case assignee
        case externalContact
        case externalTag
        case modifiedBy
        case queue
        case assignmentState
        case dateAssignmentStateChanged
        case alertTimeoutSeconds
        case skills
        case preferredAgents
        case autoStatusTransition
        case schema
        case customFields
        case autoStatusTransitionDetail
        case scoredAgents
        case script
        case version
        case selfUri
    }


}




public class WorkitemVersionListing: Codable {











    public var entities: [WorkitemVersion]?
    public var nextUri: String?
    public var selfUri: String?
    public var previousUri: String?
    public var after: String?

    public init(entities: [WorkitemVersion]?, nextUri: String?, selfUri: String?, previousUri: String?, after: String?) {
        self.entities = entities
        self.nextUri = nextUri
        self.selfUri = selfUri
        self.previousUri = previousUri
        self.after = after
    }


}




public class WorkitemsAttributeChangeInstant: Codable {





    /** New property value. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var newValue: Date?
    /** Old property value. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var oldValue: Date?

    public init(newValue: Date?, oldValue: Date?) {
        self.newValue = newValue
        self.oldValue = oldValue
    }


}




public class WorkitemsAttributeChangeList: Codable {





    /** New property value */
    public var newValue: [JSON]?
    /** Old property value */
    public var oldValue: [JSON]?

    public init(newValue: [JSON]?, oldValue: [JSON]?) {
        self.newValue = newValue
        self.oldValue = oldValue
    }


}




public class WorkitemsAttributeChangeWorkitemRuleSettings: Codable {





    /** New property value */
    public var newValue: WorkitemRuleSettings?
    /** Old property value */
    public var oldValue: WorkitemRuleSettings?

    public init(newValue: WorkitemRuleSettings?, oldValue: WorkitemRuleSettings?) {
        self.newValue = newValue
        self.oldValue = oldValue
    }


}




public class WorkitemsChangeWorkitemDelta: Codable {







    /** Version */
    public var version: Int?
    /** modifiedBy */
    public var modifiedBy: UserReference?
    /** The changes that originated this version */
    public var delta: WorkitemDelta?

    public init(version: Int?, modifiedBy: UserReference?, delta: WorkitemDelta?) {
        self.version = version
        self.modifiedBy = modifiedBy
        self.delta = delta
    }


}




public class WorkitemsEventsNotificationCustomAttribute: Codable {

    public enum DataType: String, Codable { 
        case unknown = "unknown"
        case string = "string"
        case number = "number"
        case boolean_ = "boolean$"
        case integer = "integer"
    }



    public var dataType: DataType?
    public var value: String?

    public init(dataType: DataType?, value: String?) {
        self.dataType = dataType
        self.value = value
    }


}




public class WorkitemsEventsNotificationScoredAgent: Codable {





    public var _id: UUID?
    public var score: Int64?

    public init(_id: UUID?, score: Int64?) {
        self._id = _id
        self.score = score
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case score
    }


}




public class WorkitemsQueueEventsNotificationPropertyChange: Codable {







    public var property: String?
    public var oldValues: [String]?
    public var newValues: [String]?

    public init(property: String?, oldValues: [String]?, newValues: [String]?) {
        self.property = property
        self.oldValues = oldValues
        self.newValues = newValues
    }


}




public class WorkitemsUserEventsNotificationCustomAttribute: Codable {

    public enum DataType: String, Codable { 
        case unknown = "unknown"
        case string = "string"
        case number = "number"
        case boolean_ = "boolean$"
        case integer = "integer"
    }



    public var dataType: DataType?
    public var value: String?

    public init(dataType: DataType?, value: String?) {
        self.dataType = dataType
        self.value = value
    }


}




public class WorkitemsUserEventsNotificationScoredAgent: Codable {





    public var _id: UUID?
    public var score: Int64?

    public init(_id: UUID?, score: Int64?) {
        self._id = _id
        self.score = score
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case score
    }


}




public class WorktypeQuerySort: Codable {

    public enum Name: String, Codable { 
        case datemodified = "dateModified"
        case name = "name"
    }



    /** Specify an attribute for sorting. It's possible to use an attribute both for sorting and in the query at the same time, but these restrictions apply: Only the operators EQ, LT, LTE, GT, GTE, BETWEEN and BEGINS_WITH are supported and the attribute can't be present in more than one filter. */
    public var name: Name?
    /** Sort Ascending */
    public var ascending: Bool?

    public init(name: Name?, ascending: Bool?) {
        self.name = name
        self.ascending = ascending
    }


}




public class WrapUpCodeMapping: Codable {












    public enum DefaultSet: String, Codable { 
        case contactUncallable = "CONTACT_UNCALLABLE"
        case numberUncallable = "NUMBER_UNCALLABLE"
        case rightPartyContact = "RIGHT_PARTY_CONTACT"
        case businessSuccess = "BUSINESS_SUCCESS"
        case businessFailure = "BUSINESS_FAILURE"
        case businessNeutral = "BUSINESS_NEUTRAL"
    }




    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** Creation time of the entity. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** Last modified time of the entity. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** Required for updates, must match the version number of the most recent update */
    public var version: Int?
    /** The default set of wrap-up flags. These will be used if there is no entry for a given wrap-up code in the mapping. */
    public var defaultSet: [DefaultSet]?
    /** A map from wrap-up code identifiers to a set of wrap-up flags. */
    public var mapping: [String:[String]]?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, dateCreated: Date?, dateModified: Date?, version: Int?, defaultSet: [DefaultSet]?, mapping: [String:[String]]?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.version = version
        self.defaultSet = defaultSet
        self.mapping = mapping
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case dateCreated
        case dateModified
        case version
        case defaultSet
        case mapping
        case selfUri
    }


}




public class WrapUpCodeReference: Codable {



    /** The globally unique identifier for the object. */
    public var _id: String?

    public init(_id: String?) {
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
    }


}




public class WrapupCodePredictionConfig: Codable {



    /** Copilot generated wrapup code prediction is enabled. */
    public var enabled: Bool?

    public init(enabled: Bool?) {
        self.enabled = enabled
    }


}




public class WrapupDetailEventTopicWrapupEvent: Codable {









    public enum MediaType: String, Codable { 
        case unknown = "UNKNOWN"
        case voice = "VOICE"
        case chat = "CHAT"
        case email = "EMAIL"
        case callback = "CALLBACK"
        case cobrowse = "COBROWSE"
        case video = "VIDEO"
        case screenshare = "SCREENSHARE"
        case message = "MESSAGE"
        case internalmessage = "INTERNALMESSAGE"
        case screenmonitoring = "SCREENMONITORING"
    }



    public enum Direction: String, Codable { 
        case unknown = "UNKNOWN"
        case inbound = "INBOUND"
        case outbound = "OUTBOUND"
    }

















    public enum MessageType: String, Codable { 
        case unknown = "UNKNOWN"
        case sms = "SMS"
        case twitter = "TWITTER"
        case facebook = "FACEBOOK"
        case line = "LINE"
        case whatsapp = "WHATSAPP"
        case webmessaging = "WEBMESSAGING"
        case _open = "OPEN"
        case instagram = "INSTAGRAM"
        case apple = "APPLE"
    }













    public var eventTime: Int64?
    public var conversationId: String?
    public var participantId: String?
    public var sessionId: String?
    public var mediaType: MediaType?
    public var provider: String?
    public var direction: Direction?
    public var ani: String?
    public var dnis: String?
    public var addressTo: String?
    public var addressFrom: String?
    public var callbackUserName: String?
    public var callbackNumbers: [String]?
    public var callbackScheduledTime: Int64?
    public var subject: String?
    public var messageType: MessageType?
    public var queueId: String?
    public var wrapupCode: String?
    public var wrapupNotes: String?
    public var wrapupDurationMs: Int64?
    public var conversationExternalContactIds: [String]?
    public var conversationExternalOrganizationIds: [String]?

    public init(eventTime: Int64?, conversationId: String?, participantId: String?, sessionId: String?, mediaType: MediaType?, provider: String?, direction: Direction?, ani: String?, dnis: String?, addressTo: String?, addressFrom: String?, callbackUserName: String?, callbackNumbers: [String]?, callbackScheduledTime: Int64?, subject: String?, messageType: MessageType?, queueId: String?, wrapupCode: String?, wrapupNotes: String?, wrapupDurationMs: Int64?, conversationExternalContactIds: [String]?, conversationExternalOrganizationIds: [String]?) {
        self.eventTime = eventTime
        self.conversationId = conversationId
        self.participantId = participantId
        self.sessionId = sessionId
        self.mediaType = mediaType
        self.provider = provider
        self.direction = direction
        self.ani = ani
        self.dnis = dnis
        self.addressTo = addressTo
        self.addressFrom = addressFrom
        self.callbackUserName = callbackUserName
        self.callbackNumbers = callbackNumbers
        self.callbackScheduledTime = callbackScheduledTime
        self.subject = subject
        self.messageType = messageType
        self.queueId = queueId
        self.wrapupCode = wrapupCode
        self.wrapupNotes = wrapupNotes
        self.wrapupDurationMs = wrapupDurationMs
        self.conversationExternalContactIds = conversationExternalContactIds
        self.conversationExternalOrganizationIds = conversationExternalOrganizationIds
    }


}




public class WrapupInput: Codable {

















    /** The user configured wrap up code id. */
    public var code: String?
    /** The user configured wrap up code name. */
    public var name: String?
    /** Text entered by the agent to describe the call or disposition. */
    public var notes: String?
    /** List of tags selected by the agent to describe the call or disposition. */
    public var tags: [String]?
    /** The length of time in seconds that the agent spent doing after call work. */
    public var durationSeconds: Int?
    /** The timestamp when the wrapup was finished. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var endTime: Date?
    /** Indicates if this is a pending save and should not require a code to be specified.  This allows someone to save some temporary wrapup that will be used later. */
    public var provisional: Bool?
    /** Prevent updates to wrapup end time when set to true. */
    public var disableEndTimeUpdates: Bool?

    public init(code: String?, name: String?, notes: String?, tags: [String]?, durationSeconds: Int?, endTime: Date?, provisional: Bool?, disableEndTimeUpdates: Bool?) {
        self.code = code
        self.name = name
        self.notes = notes
        self.tags = tags
        self.durationSeconds = durationSeconds
        self.endTime = endTime
        self.provisional = provisional
        self.disableEndTimeUpdates = disableEndTimeUpdates
    }


}

