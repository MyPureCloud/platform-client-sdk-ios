//
// Generated by swagger-codegen
// https://github.com/swagger-api/swagger-codegen
//

import Foundation


/** Input parameter for a CX infrastructure as code accelerator */

public class AcceleratorParameter: Codable {





    /** Parameter Name */
    public var name: String?
    /** Parameter Value */
    public var value: String?

    public init(name: String?, value: String?) {
        self.name = name
        self.value = value
    }


}




public class AcdStartDetailEventTopicAcdStartEvent: Codable {









    public enum MediaType: String, Codable { 
        case unknown = "UNKNOWN"
        case voice = "VOICE"
        case chat = "CHAT"
        case email = "EMAIL"
        case callback = "CALLBACK"
        case cobrowse = "COBROWSE"
        case video = "VIDEO"
        case screenshare = "SCREENSHARE"
        case message = "MESSAGE"
        case internalmessage = "INTERNALMESSAGE"
    }



    public enum Direction: String, Codable { 
        case unknown = "UNKNOWN"
        case inbound = "INBOUND"
        case outbound = "OUTBOUND"
    }

















    public enum MessageType: String, Codable { 
        case unknown = "UNKNOWN"
        case sms = "SMS"
        case twitter = "TWITTER"
        case facebook = "FACEBOOK"
        case line = "LINE"
        case whatsapp = "WHATSAPP"
        case webmessaging = "WEBMESSAGING"
        case _open = "OPEN"
        case instagram = "INSTAGRAM"
        case apple = "APPLE"
    }















    public var eventTime: Int64?
    public var conversationId: String?
    public var participantId: String?
    public var sessionId: String?
    public var mediaType: MediaType?
    public var provider: String?
    public var direction: Direction?
    public var ani: String?
    public var dnis: String?
    public var addressTo: String?
    public var addressFrom: String?
    public var callbackUserName: String?
    public var callbackNumbers: [String]?
    public var callbackScheduledTime: Int64?
    public var subject: String?
    public var messageType: MessageType?
    public var queueId: String?
    public var divisionId: String?
    public var conversationExternalContactIds: [String]?
    public var conversationExternalOrganizationIds: [String]?
    public var utilizationLabel: String?
    public var routingPriority: Int64?
    public var requestedRoutingSkillIds: [UUID]?

    public init(eventTime: Int64?, conversationId: String?, participantId: String?, sessionId: String?, mediaType: MediaType?, provider: String?, direction: Direction?, ani: String?, dnis: String?, addressTo: String?, addressFrom: String?, callbackUserName: String?, callbackNumbers: [String]?, callbackScheduledTime: Int64?, subject: String?, messageType: MessageType?, queueId: String?, divisionId: String?, conversationExternalContactIds: [String]?, conversationExternalOrganizationIds: [String]?, utilizationLabel: String?, routingPriority: Int64?, requestedRoutingSkillIds: [UUID]?) {
        self.eventTime = eventTime
        self.conversationId = conversationId
        self.participantId = participantId
        self.sessionId = sessionId
        self.mediaType = mediaType
        self.provider = provider
        self.direction = direction
        self.ani = ani
        self.dnis = dnis
        self.addressTo = addressTo
        self.addressFrom = addressFrom
        self.callbackUserName = callbackUserName
        self.callbackNumbers = callbackNumbers
        self.callbackScheduledTime = callbackScheduledTime
        self.subject = subject
        self.messageType = messageType
        self.queueId = queueId
        self.divisionId = divisionId
        self.conversationExternalContactIds = conversationExternalContactIds
        self.conversationExternalOrganizationIds = conversationExternalOrganizationIds
        self.utilizationLabel = utilizationLabel
        self.routingPriority = routingPriority
        self.requestedRoutingSkillIds = requestedRoutingSkillIds
    }


}



/** Details for an mTLS certificate */

public class ActionCertificate: Codable {

    public enum SigningAuthority: String, Codable { 
        case digiCert = "DigiCert"
        case genesys = "Genesys"
    }



    public enum Status: String, Codable { 
        case current = "Current"
        case upcoming = "Upcoming"
    }

    public enum ModelType: String, Codable { 
        case client = "Client"
    }

    /** The Signing Authority for the certificate */
    public var signingAuthority: SigningAuthority?
    /** The certificate string */
    public var certificate: String?
    /** The certificate status */
    public var status: Status?
    /** The certificate type */
    public var type: ModelType?

    public init(signingAuthority: SigningAuthority?, certificate: String?, status: Status?, type: ModelType?) {
        self.signingAuthority = signingAuthority
        self.certificate = certificate
        self.status = status
        self.type = type
    }


}




public class ActionCertificateListing: Codable {





















    public var entities: [ActionCertificate]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var previousUri: String?
    public var nextUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [ActionCertificate]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, previousUri: String?, nextUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.previousUri = previousUri
        self.nextUri = nextUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}



/** Defines components of the Action Config. */

public class ActionConfig: Codable {







    /** Optional 1-60 second timeout enforced on the execution or test of this action. This setting is invalid for Custom Authentication Actions. */
    public var timeoutSeconds: Int?
    /** Configuration of outbound request. */
    public var request: RequestConfig?
    /** Configuration of response processing. */
    public var response: ResponseConfig?

    public init(timeoutSeconds: Int?, request: RequestConfig?, response: ResponseConfig?) {
        self.timeoutSeconds = timeoutSeconds
        self.request = request
        self.response = response
    }


}



/** Contract definition. */

public class ActionContractInput: Codable {





    /** Execution input contract */
    public var input: PostInputContract?
    /** Execution output contract */
    public var output: PostOutputContract?

    public init(input: PostInputContract?, output: PostOutputContract?) {
        self.input = input
        self.output = output
    }


}



/** Input requirements of Action. */

public class ActionInput: Codable {







    /** JSON Schema that defines the body of the request that the client (edge/architect/postman) is sending to the service, on the /execute path. If the 'flatten' query parameter is omitted or false, this field will be returned. Either inputSchema or inputSchemaFlattened will be returned, not both. */
    public var inputSchema: JsonSchemaDocument?
    /** JSON Schema that defines the body of the request that the client (edge/architect/postman) is sending to the service, on the /execute path. The schema is transformed based on Architect's flattened format. If the 'flatten' query parameter is supplied as true, this field will be returned. Either inputSchema or inputSchemaFlattened will be returned, not both. */
    public var inputSchemaFlattened: JsonSchemaDocument?
    /** The URI of the input schema */
    public var inputSchemaUri: String?

    public init(inputSchema: JsonSchemaDocument?, inputSchemaFlattened: JsonSchemaDocument?, inputSchemaUri: String?) {
        self.inputSchema = inputSchema
        self.inputSchemaFlattened = inputSchemaFlattened
        self.inputSchemaUri = inputSchemaUri
    }


}




public class ActionMapEstimateResult: Codable {









    /** Number of sessions qualified for Action map. */
    public var qualifiedSessionCount: Int?
    /** Total number of sessions. */
    public var totalSessionCount: Int?
    /** Number of sessions qualified for Action map per segment. */
    public var perSegmentCounts: [SegmentEstimateCount]?
    /** Difference made by outcome criteria to number of sessions qualified for Action map. */
    public var outcomesScoresCount: Int?

    public init(qualifiedSessionCount: Int?, totalSessionCount: Int?, perSegmentCounts: [SegmentEstimateCount]?, outcomesScoresCount: Int?) {
        self.qualifiedSessionCount = qualifiedSessionCount
        self.totalSessionCount = totalSessionCount
        self.perSegmentCounts = perSegmentCounts
        self.outcomesScoresCount = outcomesScoresCount
    }


}




public class ActionTemplate: Codable {









    public enum MediaType: String, Codable { 
        case webchat = "webchat"
        case webmessagingoffer = "webMessagingOffer"
        case contentoffer = "contentOffer"
        case integrationaction = "integrationAction"
        case architectflow = "architectFlow"
        case openaction = "openAction"
    }

    public enum State: String, Codable { 
        case active = "Active"
        case inactive = "Inactive"
        case deleted = "Deleted"
    }









    /** The globally unique identifier for the object. */
    public var _id: String?
    /** Name of the action template. */
    public var name: String?
    /** Description of the action template's functionality. */
    public var _description: String?
    /** The version of the action template. */
    public var version: Int?
    /** Media type of action described by the action template. */
    public var mediaType: MediaType?
    /** Whether the action template is currently active, inactive or deleted. */
    public var state: State?
    /** Properties used to configure an action of type content offer */
    public var contentOffer: ContentOffer?
    /** The URI for this object */
    public var selfUri: String?
    /** Date when action template was created in ISO-8601 format. */
    public var createdDate: Date?
    /** Date when action template was last modified in ISO-8601 format. */
    public var modifiedDate: Date?

    public init(_id: String?, name: String?, _description: String?, version: Int?, mediaType: MediaType?, state: State?, contentOffer: ContentOffer?, selfUri: String?, createdDate: Date?, modifiedDate: Date?) {
        self._id = _id
        self.name = name
        self._description = _description
        self.version = version
        self.mediaType = mediaType
        self.state = state
        self.contentOffer = contentOffer
        self.selfUri = selfUri
        self.createdDate = createdDate
        self.modifiedDate = modifiedDate
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case _description = "description"
        case version
        case mediaType
        case state
        case contentOffer
        case selfUri
        case createdDate
        case modifiedDate
    }


}




public class ActionTemplateListing: Codable {





















    public var entities: [ActionTemplate]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var previousUri: String?
    public var nextUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [ActionTemplate]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, previousUri: String?, nextUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.previousUri = previousUri
        self.nextUri = nextUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class ActivityCode: Codable {











    public enum Category: String, Codable { 
        case onQueueWork = "OnQueueWork"
        case _break = "Break"
        case meal = "Meal"
        case meeting = "Meeting"
        case offQueueWork = "OffQueueWork"
        case timeOff = "TimeOff"
        case training = "Training"
        case unavailable = "Unavailable"
    }











    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The URI for this object */
    public var selfUri: String?
    /** The name of the activity code. Default activity codes will be created with an empty name */
    public var name: String?
    /** Whether this activity code is active or has been deleted */
    public var isActive: Bool?
    /** Whether this is a default activity code */
    public var isDefault: Bool?
    /** The activity code's category. */
    public var category: Category?
    /** The default length of the activity in minutes */
    public var lengthInMinutes: Int?
    /** Whether an agent is paid while performing this activity */
    public var countsAsPaidTime: Bool?
    /** Indicates whether or not the activity should be counted as contiguous work time for calculating daily constraints */
    public var countsAsWorkTime: Bool?
    /** Whether an agent can select this activity code when creating or editing a time off request. Null if the activity's category is not time off. */
    public var agentTimeOffSelectable: Bool?
    /** Version metadata for the associated management unit's list of activity codes */
    public var metadata: WfmVersionedEntityMetadata?

    public init(_id: String?, selfUri: String?, name: String?, isActive: Bool?, isDefault: Bool?, category: Category?, lengthInMinutes: Int?, countsAsPaidTime: Bool?, countsAsWorkTime: Bool?, agentTimeOffSelectable: Bool?, metadata: WfmVersionedEntityMetadata?) {
        self._id = _id
        self.selfUri = selfUri
        self.name = name
        self.isActive = isActive
        self.isDefault = isDefault
        self.category = category
        self.lengthInMinutes = lengthInMinutes
        self.countsAsPaidTime = countsAsPaidTime
        self.countsAsWorkTime = countsAsWorkTime
        self.agentTimeOffSelectable = agentTimeOffSelectable
        self.metadata = metadata
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
        case name
        case isActive
        case isDefault
        case category
        case lengthInMinutes
        case countsAsPaidTime
        case countsAsWorkTime
        case agentTimeOffSelectable
        case metadata
    }


}




public class ActivityCodeSummary: Codable {









    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** The secondary presences of this activity code. */
    public var secondaryPresences: [SecondaryPresence]?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, secondaryPresences: [SecondaryPresence]?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.secondaryPresences = secondaryPresences
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case secondaryPresences
        case selfUri
    }


}




public class ActivityPlanOccurrenceReference: Codable {





    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, selfUri: String?) {
        self._id = _id
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
    }


}




public class ActivityPlanRunJobResponse: Codable {





    public enum Status: String, Codable { 
        case processing = "Processing"
        case complete = "Complete"
        case error = "Error"
    }







    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The activity plan associated with this job */
    public var activityPlan: ActivityPlanReference?
    /** The status of the job */
    public var status: Status?
    /** The list of exceptions that occurred while running this activity plan job. These are exceptions that affect individual occurrences but didn't prevent the job from completing */
    public var exceptions: [ActivityPlanJobException]?
    /** Error details if status == 'Error'. These are errors that caused the job to fail to complete */
    public var error: ErrorBody?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, activityPlan: ActivityPlanReference?, status: Status?, exceptions: [ActivityPlanJobException]?, error: ErrorBody?, selfUri: String?) {
        self._id = _id
        self.activityPlan = activityPlan
        self.status = status
        self.exceptions = exceptions
        self.error = error
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case activityPlan
        case status
        case exceptions
        case error
        case selfUri
    }


}




public class AcwDetailEventTopicAfterCallWorkEvent: Codable {









    public enum MediaType: String, Codable { 
        case unknown = "UNKNOWN"
        case voice = "VOICE"
        case chat = "CHAT"
        case email = "EMAIL"
        case callback = "CALLBACK"
        case cobrowse = "COBROWSE"
        case video = "VIDEO"
        case screenshare = "SCREENSHARE"
        case message = "MESSAGE"
        case internalmessage = "INTERNALMESSAGE"
    }



    public enum Direction: String, Codable { 
        case unknown = "UNKNOWN"
        case inbound = "INBOUND"
        case outbound = "OUTBOUND"
    }

















    public enum MessageType: String, Codable { 
        case unknown = "UNKNOWN"
        case sms = "SMS"
        case twitter = "TWITTER"
        case facebook = "FACEBOOK"
        case line = "LINE"
        case whatsapp = "WHATSAPP"
        case webmessaging = "WEBMESSAGING"
        case _open = "OPEN"
        case instagram = "INSTAGRAM"
        case apple = "APPLE"
    }















    public var eventTime: Int64?
    public var conversationId: String?
    public var participantId: String?
    public var sessionId: String?
    public var mediaType: MediaType?
    public var provider: String?
    public var direction: Direction?
    public var ani: String?
    public var dnis: String?
    public var addressTo: String?
    public var addressFrom: String?
    public var callbackUserName: String?
    public var callbackNumbers: [String]?
    public var callbackScheduledTime: Int64?
    public var subject: String?
    public var messageType: MessageType?
    public var userId: String?
    public var queueId: String?
    public var wrapupCode: String?
    public var wrapupNotes: String?
    public var wrapupDurationMs: Int64?
    public var conversationExternalContactIds: [String]?
    public var conversationExternalOrganizationIds: [String]?

    public init(eventTime: Int64?, conversationId: String?, participantId: String?, sessionId: String?, mediaType: MediaType?, provider: String?, direction: Direction?, ani: String?, dnis: String?, addressTo: String?, addressFrom: String?, callbackUserName: String?, callbackNumbers: [String]?, callbackScheduledTime: Int64?, subject: String?, messageType: MessageType?, userId: String?, queueId: String?, wrapupCode: String?, wrapupNotes: String?, wrapupDurationMs: Int64?, conversationExternalContactIds: [String]?, conversationExternalOrganizationIds: [String]?) {
        self.eventTime = eventTime
        self.conversationId = conversationId
        self.participantId = participantId
        self.sessionId = sessionId
        self.mediaType = mediaType
        self.provider = provider
        self.direction = direction
        self.ani = ani
        self.dnis = dnis
        self.addressTo = addressTo
        self.addressFrom = addressFrom
        self.callbackUserName = callbackUserName
        self.callbackNumbers = callbackNumbers
        self.callbackScheduledTime = callbackScheduledTime
        self.subject = subject
        self.messageType = messageType
        self.userId = userId
        self.queueId = queueId
        self.wrapupCode = wrapupCode
        self.wrapupNotes = wrapupNotes
        self.wrapupDurationMs = wrapupDurationMs
        self.conversationExternalContactIds = conversationExternalContactIds
        self.conversationExternalOrganizationIds = conversationExternalOrganizationIds
    }


}




public class AddAdherenceExplanationAdminRequest: Codable {

    public enum ModelType: String, Codable { 
        case late = "Late"
    }







    public enum Status: String, Codable { 
        case pending = "Pending"
        case approved = "Approved"
        case denied = "Denied"
    }

    /** The type of the adherence explanation */
    public var type: ModelType?
    /** The start timestamp of the adherence explanation in ISO-8601 format */
    public var startDate: Date?
    /** The length of the adherence explanation in minutes */
    public var lengthMinutes: Int?
    /** Notes about the adherence explanation */
    public var notes: String?
    /** The status of the adherence explanation */
    public var status: Status?

    public init(type: ModelType?, startDate: Date?, lengthMinutes: Int?, notes: String?, status: Status?) {
        self.type = type
        self.startDate = startDate
        self.lengthMinutes = lengthMinutes
        self.notes = notes
        self.status = status
    }


}




public class AdditionalMatchCriteria: Codable {



    public enum MediaFilter: String, Codable { 
        case withMedia = "WithMedia"
        case withoutMedia = "WithoutMedia"
    }

    /** List of topics with specific data ingestion rules to filter messages for escalation. */
    public var topics: [TopicCriteria]?
    /** Escalate message based on media presence. Not setting any value will escalate all types of msg. */
    public var mediaFilter: MediaFilter?

    public init(topics: [TopicCriteria]?, mediaFilter: MediaFilter?) {
        self.topics = topics
        self.mediaFilter = mediaFilter
    }


}




public class AdditionalSocialMediaMessage: Codable {







    /** The body of the text message.  Maximum character count is 2000 characters. */
    public var textBody: String?
    /** The media ids associated with the text message. See https://developer.genesys.cloud/api/rest/v2/conversations/messaging-media-upload for example usage. */
    public var mediaIds: [String]?
    /** The ID of the message to which this request is replying. */
    public var inReplyToMessageId: String?

    public init(textBody: String?, mediaIds: [String]?, inReplyToMessageId: String?) {
        self.textBody = textBody
        self.mediaIds = mediaIds
        self.inReplyToMessageId = inReplyToMessageId
    }


}




public class AddressableLicenseDefinition: Codable {





    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, selfUri: String?) {
        self._id = _id
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
    }


}




public class AdherenceExplanationJobReference: Codable {



    public enum ModelType: String, Codable { 
        case addExplanation = "AddExplanation"
        case updateExplanation = "UpdateExplanation"
        case queryAgentExplanations = "QueryAgentExplanations"
        case queryBuExplanations = "QueryBuExplanations"
    }

    public enum Status: String, Codable { 
        case processing = "Processing"
        case complete = "Complete"
        case error = "Error"
    }



    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The type of the adherence explanation job */
    public var type: ModelType?
    /** The status of the adherence explanation job */
    public var status: Status?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, type: ModelType?, status: Status?, selfUri: String?) {
        self._id = _id
        self.type = type
        self.status = status
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case type
        case status
        case selfUri
    }


}




public class AdherenceExplanationListingBuQueryResponse: Codable {



    public var entities: [AdherenceExplanationResponse]?

    public init(entities: [AdherenceExplanationResponse]?) {
        self.entities = entities
    }


}




public class AdherenceSettings: Codable {













    /** The threshold in minutes where an alert will be triggered when an agent is considered severely out of adherence */
    public var severeAlertThresholdMinutes: Int?
    /** Target adherence percentage */
    public var adherenceTargetPercent: Int?
    /** The threshold in seconds for which agents should not be penalized for being momentarily out of adherence */
    public var adherenceExceptionThresholdSeconds: Int?
    /** Whether to treat all non-on-queue activities as equivalent for adherence purposes */
    public var nonOnQueueActivitiesEquivalent: Bool?
    /** Whether to track on-queue activities */
    public var trackOnQueueActivity: Bool?
    /** Activity categories that should be ignored for adherence purposes */
    public var ignoredActivityCategories: IgnoredActivityCategories?

    public init(severeAlertThresholdMinutes: Int?, adherenceTargetPercent: Int?, adherenceExceptionThresholdSeconds: Int?, nonOnQueueActivitiesEquivalent: Bool?, trackOnQueueActivity: Bool?, ignoredActivityCategories: IgnoredActivityCategories?) {
        self.severeAlertThresholdMinutes = severeAlertThresholdMinutes
        self.adherenceTargetPercent = adherenceTargetPercent
        self.adherenceExceptionThresholdSeconds = adherenceExceptionThresholdSeconds
        self.nonOnQueueActivitiesEquivalent = nonOnQueueActivitiesEquivalent
        self.trackOnQueueActivity = trackOnQueueActivity
        self.ignoredActivityCategories = ignoredActivityCategories
    }


}




public class AdhocRecordingTopicRecordingDataV2: Codable {



































    public var _id: String?
    public var name: String?
    public var dateCreated: Date?
    public var dateModified: Date?
    public var workspace: AdhocRecordingTopicWorkspaceData?
    public var createdBy: AdhocRecordingTopicUserData?
    public var contentType: String?
    public var contentLength: Int64?
    public var filename: String?
    public var changeNumber: Int64?
    public var dateUploaded: Date?
    public var uploadedBy: AdhocRecordingTopicUserData?
    public var lockInfo: AdhocRecordingTopicLockData?
    public var selfUri: String?
    public var durationMillieconds: Int64?
    public var conversation: AdhocRecordingTopicConversationData?
    public var read: Bool?

    public init(_id: String?, name: String?, dateCreated: Date?, dateModified: Date?, workspace: AdhocRecordingTopicWorkspaceData?, createdBy: AdhocRecordingTopicUserData?, contentType: String?, contentLength: Int64?, filename: String?, changeNumber: Int64?, dateUploaded: Date?, uploadedBy: AdhocRecordingTopicUserData?, lockInfo: AdhocRecordingTopicLockData?, selfUri: String?, durationMillieconds: Int64?, conversation: AdhocRecordingTopicConversationData?, read: Bool?) {
        self._id = _id
        self.name = name
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.workspace = workspace
        self.createdBy = createdBy
        self.contentType = contentType
        self.contentLength = contentLength
        self.filename = filename
        self.changeNumber = changeNumber
        self.dateUploaded = dateUploaded
        self.uploadedBy = uploadedBy
        self.lockInfo = lockInfo
        self.selfUri = selfUri
        self.durationMillieconds = durationMillieconds
        self.conversation = conversation
        self.read = read
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case dateCreated
        case dateModified
        case workspace
        case createdBy
        case contentType
        case contentLength
        case filename
        case changeNumber
        case dateUploaded
        case uploadedBy
        case lockInfo
        case selfUri
        case durationMillieconds
        case conversation
        case read
    }


}




public class Adjacents: Codable {







    public var superiors: [User]?
    public var siblings: [User]?
    public var directReports: [User]?

    public init(superiors: [User]?, siblings: [User]?, directReports: [User]?) {
        self.superiors = superiors
        self.siblings = siblings
        self.directReports = directReports
    }


}




public class AgentActivityChangedTopicOutOfOffice: Codable {





    public var active: Bool?
    public var modifiedDate: Date?

    public init(active: Bool?, modifiedDate: Date?) {
        self.active = active
        self.modifiedDate = modifiedDate
    }


}




public class AgentActivityChangedTopicPresence: Codable {







    public var presenceDefinition: AgentActivityChangedTopicOrganizationPresence?
    public var presenceMessage: String?
    public var modifiedDate: Date?

    public init(presenceDefinition: AgentActivityChangedTopicOrganizationPresence?, presenceMessage: String?, modifiedDate: Date?) {
        self.presenceDefinition = presenceDefinition
        self.presenceMessage = presenceMessage
        self.modifiedDate = modifiedDate
    }


}




public class AgentCopilotAggregateQueryResponse: Codable {



    public var results: [AgentCopilotAggregateDataContainer]?

    public init(results: [AgentCopilotAggregateDataContainer]?) {
        self.results = results
    }


}




public class AgentCopilotAggregationView: Codable {

    public enum Target: String, Codable { 
        case ncannedresponsesuggestions = "nCannedResponseSuggestions"
        case ndistinctsuggestions = "nDistinctSuggestions"
        case nknowledgearticlesuggestions = "nKnowledgeArticleSuggestions"
        case nknowledgesearchsuggestions = "nKnowledgeSearchSuggestions"
        case nscriptsuggestions = "nScriptSuggestions"
    }



    public enum Function: String, Codable { 
        case rangebound = "rangeBound"
    }



    /** Target metric name */
    public var target: Target?
    /** A unique name for this view. Must be distinct from other views and built-in metric names. */
    public var name: String?
    /** Type of view you wish to create */
    public var function: Function?
    /** Range of numbers for slicing up data */
    public var range: AggregationRange?

    public init(target: Target?, name: String?, function: Function?, range: AggregationRange?) {
        self.target = target
        self.name = name
        self.function = function
        self.range = range
    }


}




public class AgentCountRange: Codable {





    /** The minimum value of agent count per work plan */
    public var minimum: Int?
    /** The maximum value of agent count per work plan */
    public var maximum: Int?

    public init(minimum: Int?, maximum: Int?) {
        self.minimum = minimum
        self.maximum = maximum
    }


}




public class AgentDirectRoutingBackupSettings: Codable {











    /** ID of queue to be used as backup. If queueId and userId are both specified, queue behaves as secondary backup. */
    public var queueId: String?
    /** ID of user to be used as backup. If queueId and userId are both specified, user behaves as primary backup. */
    public var userId: String?
    /** Flag indicating if Direct Routing interactions should wait for Direct Routing agent or go immediately to selected backup. */
    public var waitForAgent: Bool?
    /** Time (in seconds) that a Direct Routing interaction will wait for Direct Routing agent before going to selected backup. Valid range [60, 864000]. */
    public var agentWaitSeconds: Int?
    /** Set of users that this user is a backup for. */
    public var backedUpUsers: [String]?

    public init(queueId: String?, userId: String?, waitForAgent: Bool?, agentWaitSeconds: Int?, backedUpUsers: [String]?) {
        self.queueId = queueId
        self.userId = userId
        self.waitForAgent = waitForAgent
        self.agentWaitSeconds = agentWaitSeconds
        self.backedUpUsers = backedUpUsers
    }


}




public class AgentPossibleWorkShiftsResponse: Codable {











    /** Start date of requested effective work plan. Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd */
    public var weekStartDate: Date?
    /** Each element is the ID of an effective work plan for a specific week */
    public var pattern: [Int]?
    /** Each element is a weekly effective work plan that can be used for multiple weeks */
    public var weeklyPossibleWorkShifts: [PossibleWorkShiftsForWeek]?
    /** Number of minutes in each interval in the intervalScheduleProbabilities */
    public var schedulerIntervalLengthMinutes: Int?
    /** The time zone of the business unit */
    public var timeZone: String?

    public init(weekStartDate: Date?, pattern: [Int]?, weeklyPossibleWorkShifts: [PossibleWorkShiftsForWeek]?, schedulerIntervalLengthMinutes: Int?, timeZone: String?) {
        self.weekStartDate = weekStartDate
        self.pattern = pattern
        self.weeklyPossibleWorkShifts = weeklyPossibleWorkShifts
        self.schedulerIntervalLengthMinutes = schedulerIntervalLengthMinutes
        self.timeZone = timeZone
    }


}




public class AgentQueryAdherenceExplanationsRequest: Codable {





    /** The start date of the range to query. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var startDate: Date?
    /** The end date of the range to query. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var endDate: Date?

    public init(startDate: Date?, endDate: Date?) {
        self.startDate = startDate
        self.endDate = endDate
    }


}




public class AgentStateCountsRequest: Codable {





    /** Filters that target user-level data */
    public var userFilter: AgentStateUserFilter?
    /** Filters that target session-level data */
    public var sessionFilter: AgentStateSessionFilter?

    public init(userFilter: AgentStateUserFilter?, sessionFilter: AgentStateSessionFilter?) {
        self.userFilter = userFilter
        self.sessionFilter = sessionFilter
    }


}




public class AgentWorkPlan: Codable {





















    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** Whether the weekly paid time constraint is enabled for this work plan */
    public var constrainWeeklyPaidTime: Bool?
    /** Whether the weekly paid time constraint is flexible for this work plan */
    public var flexibleWeeklyPaidTime: Bool?
    /** Exact weekly paid time in minutes for this work plan. Used if flexibleWeeklyPaidTime == false */
    public var weeklyExactPaidMinutes: Int?
    /** Minimum weekly paid time in minutes for this work plan. Used if flexibleWeeklyPaidTime == true */
    public var weeklyMinimumPaidMinutes: Int?
    /** Maximum weekly paid time in minutes for this work plan. Used if flexibleWeeklyPaidTime == true */
    public var weeklyMaximumPaidMinutes: Int?
    /** Optional days to schedule for this work plan */
    public var optionalDays: SetWrapperDayOfWeek?
    /** Shifts in this work plan */
    public var shifts: [AgentWorkPlanShift]?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, constrainWeeklyPaidTime: Bool?, flexibleWeeklyPaidTime: Bool?, weeklyExactPaidMinutes: Int?, weeklyMinimumPaidMinutes: Int?, weeklyMaximumPaidMinutes: Int?, optionalDays: SetWrapperDayOfWeek?, shifts: [AgentWorkPlanShift]?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.constrainWeeklyPaidTime = constrainWeeklyPaidTime
        self.flexibleWeeklyPaidTime = flexibleWeeklyPaidTime
        self.weeklyExactPaidMinutes = weeklyExactPaidMinutes
        self.weeklyMinimumPaidMinutes = weeklyMinimumPaidMinutes
        self.weeklyMaximumPaidMinutes = weeklyMaximumPaidMinutes
        self.optionalDays = optionalDays
        self.shifts = shifts
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case constrainWeeklyPaidTime
        case flexibleWeeklyPaidTime
        case weeklyExactPaidMinutes
        case weeklyMinimumPaidMinutes
        case weeklyMaximumPaidMinutes
        case optionalDays
        case shifts
        case selfUri
    }


}




public class AgentWorkPlanActivity: Codable {





    /** Length of the activity in minutes */
    public var lengthMinutes: Int?
    /** Whether the activity is paid */
    public var countsAsPaidTime: Bool?

    public init(lengthMinutes: Int?, countsAsPaidTime: Bool?) {
        self.lengthMinutes = lengthMinutes
        self.countsAsPaidTime = countsAsPaidTime
    }


}




public class AgentWorkPlanShift: Codable {



























    /** Days of the week applicable for this shift */
    public var days: SetWrapperDayOfWeek?
    /** Whether the start time of the shift is flexible */
    public var flexibleStartTime: Bool?
    /** Exact start time of the shift defined as offset minutes from midnight. Used if flexibleStartTime == false */
    public var exactStartTimeMinutesFromMidnight: Int?
    /** Earliest start time of the shift defined as offset minutes from midnight. Used if flexibleStartTime == true */
    public var earliestStartTimeMinutesFromMidnight: Int?
    /** Latest start time of the shift defined as offset minutes from midnight. Used if flexibleStartTime == true */
    public var latestStartTimeMinutesFromMidnight: Int?
    /** This is the earliest time a shift can end */
    public var earliestStopTimeMinutesFromMidnight: Int?
    /** Whether the latest stop time constraint for the shift is enabled */
    public var constrainLatestStopTime: Bool?
    /** Latest stop time of the shift defined as offset minutes from midnight. Used if constrainStopTime == true */
    public var latestStopTimeMinutesFromMidnight: Int?
    /** Whether the paid time setting for the shift is flexible */
    public var flexiblePaidTime: Bool?
    /** Exact paid time in minutes configured for the shift. Used if flexiblePaidTime == false */
    public var exactPaidTimeMinutes: Int?
    /** Minimum paid time in minutes configured for the shift. Used if flexiblePaidTime == true */
    public var minimumPaidTimeMinutes: Int?
    /** Maximum paid time in minutes configured for the shift. Used if flexiblePaidTime == true */
    public var maximumPaidTimeMinutes: Int?
    /** Activities configured for this shift */
    public var activities: [AgentWorkPlanActivity]?

    public init(days: SetWrapperDayOfWeek?, flexibleStartTime: Bool?, exactStartTimeMinutesFromMidnight: Int?, earliestStartTimeMinutesFromMidnight: Int?, latestStartTimeMinutesFromMidnight: Int?, earliestStopTimeMinutesFromMidnight: Int?, constrainLatestStopTime: Bool?, latestStopTimeMinutesFromMidnight: Int?, flexiblePaidTime: Bool?, exactPaidTimeMinutes: Int?, minimumPaidTimeMinutes: Int?, maximumPaidTimeMinutes: Int?, activities: [AgentWorkPlanActivity]?) {
        self.days = days
        self.flexibleStartTime = flexibleStartTime
        self.exactStartTimeMinutesFromMidnight = exactStartTimeMinutesFromMidnight
        self.earliestStartTimeMinutesFromMidnight = earliestStartTimeMinutesFromMidnight
        self.latestStartTimeMinutesFromMidnight = latestStartTimeMinutesFromMidnight
        self.earliestStopTimeMinutesFromMidnight = earliestStopTimeMinutesFromMidnight
        self.constrainLatestStopTime = constrainLatestStopTime
        self.latestStopTimeMinutesFromMidnight = latestStopTimeMinutesFromMidnight
        self.flexiblePaidTime = flexiblePaidTime
        self.exactPaidTimeMinutes = exactPaidTimeMinutes
        self.minimumPaidTimeMinutes = minimumPaidTimeMinutes
        self.maximumPaidTimeMinutes = maximumPaidTimeMinutes
        self.activities = activities
    }


}




public class AgentWorkPlans: Codable {





    /** The user (agent) for whom the work plans were requested */
    public var user: UserReference?
    /** The list of weekly work plan lookup keys. Keys to be searched under workPlanLookup property at top level of result */
    public var workPlanLookupKeysPerWeek: [Int]?

    public init(user: UserReference?, workPlanLookupKeysPerWeek: [Int]?) {
        self.user = user
        self.workPlanLookupKeysPerWeek = workPlanLookupKeysPerWeek
    }


}




public class AiAnswer: Codable {





    public enum FailureType: String, Codable { 
        case lowConfidenceError = "LowConfidenceError"
        case parsingError = "ParsingError"
        case serviceError = "ServiceError"
        case lowHistoricalAccuracyError = "LowHistoricalAccuracyError"
    }

    /** The unique identifier of the suggested AI answer. */
    public var answerId: String?
    /** An explanation providing the reasoning behind the suggested answer. */
    public var explanation: String?
    /** Describes the type of error associated with the AI answer. */
    public var failureType: FailureType?

    public init(answerId: String?, explanation: String?, failureType: FailureType?) {
        self.answerId = answerId
        self.explanation = explanation
        self.failureType = failureType
    }


}




public class AiScoringSetting: Codable {



    /** True if AI Scoring feature is configured. */
    public var enabled: Bool?

    public init(enabled: Bool?) {
        self.enabled = enabled
    }


}




public class AiScoringSettings: Codable {







    /** The globally unique identifier for the object. */
    public var _id: String?
    public var questionGroupSettings: [QuestionGroupSettings]?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, questionGroupSettings: [QuestionGroupSettings]?, selfUri: String?) {
        self._id = _id
        self.questionGroupSettings = questionGroupSettings
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case questionGroupSettings
        case selfUri
    }


}




public class AlertListing: Codable {





















    public var entities: [CommonAlert]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var previousUri: String?
    public var nextUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [CommonAlert]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, previousUri: String?, nextUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.previousUri = previousUri
        self.nextUri = nextUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class AlertNotification: Codable {




    public enum NotificationTypes: String, Codable { 
        case sms = "Sms"
        case device = "Device"
        case email = "Email"
        case push = "Push"
    }


    /** The entity to receive the notification. */
    public var recipient: String?
    /** The notification types the user will receive. */
    public var notificationTypes: [NotificationTypes]?
    /** The locale whose language will be used when sending alerts.  Locale should be in theformat language_COUNTRY where language is always lower case and country is always upper case. */
    public var locale: String?

    public init(recipient: String?, notificationTypes: [NotificationTypes]?, locale: String?) {
        self.recipient = recipient
        self.notificationTypes = notificationTypes
        self.locale = locale
    }


}




public class AlertRequest: Codable {

    public enum ModelType: String, Codable { 
        case mute = "Mute"
        case snooze = "Snooze"
        case unread = "Unread"
    }









    /** The action being taken on the alert. */
    public var type: ModelType?
    /** The start date of the mute/snooze period. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateStart: Date?
    /** The end date of the mute/snooze period. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateEnd: Date?
    /** The fields need for an unread update requests */
    public var unread: UnreadFields?
    public var validRequest: Bool?

    public init(type: ModelType?, dateStart: Date?, dateEnd: Date?, unread: UnreadFields?, validRequest: Bool?) {
        self.type = type
        self.dateStart = dateStart
        self.dateEnd = dateEnd
        self.unread = unread
        self.validRequest = validRequest
    }


}




public class AlertSummary: Codable {





    public enum MetricType: String, Codable { 
        case interval = "Interval"
        case instance = "Instance"
    }



    /** The entities who violated the rule condition over the duration of the alert. */
    public var entities: [AlertSummaryEntity]?
    /** The id of the conversation that triggered the alert.  Only used for alerts based on instance-based conversation metrics. */
    public var conversation: AddressableEntityRef?
    /** The metric type that is monitored. */
    public var metricType: MetricType?
    /** Flag that indicated whether or not the alert is for a rule with a condition for all members of a team. */
    public var entitiesAreTeamMembers: Bool?

    public init(entities: [AlertSummaryEntity]?, conversation: AddressableEntityRef?, metricType: MetricType?, entitiesAreTeamMembers: Bool?) {
        self.entities = entities
        self.conversation = conversation
        self.metricType = metricType
        self.entitiesAreTeamMembers = entitiesAreTeamMembers
    }


}




public class AlertablePresences: Codable {

    public enum AlertablePresences: String, Codable { 
        case available = "Available"
        case away = "Away"
        case busy = "Busy"
        case offline = "Offline"
        case idle = "Idle"
        case onQueue = "OnQueue"
        case meal = "Meal"
        case training = "Training"
        case meeting = "Meeting"
        case _break = "Break"
    }

    /** The list of alertable system presences. */
    public var alertablePresences: [AlertablePresences]?

    public init(alertablePresences: [AlertablePresences]?) {
        self.alertablePresences = alertablePresences
    }


}




public class AlternativeShiftAgentScheduledShift: Codable {











    /** The number of days since start of schedule */
    public var dayIndex: Int?
    /** A key generated for an offer to help facilitate alternative shift trading */
    public var referenceKey: String?
    /** The start date of this shift in ISO-8601 format */
    public var startDate: Date?
    /** The length of this shift in minutes */
    public var lengthMinutes: Int?
    /** A list of activities in this shift */
    public var activities: [BuAgentScheduleActivity]?

    public init(dayIndex: Int?, referenceKey: String?, startDate: Date?, lengthMinutes: Int?, activities: [BuAgentScheduleActivity]?) {
        self.dayIndex = dayIndex
        self.referenceKey = referenceKey
        self.startDate = startDate
        self.lengthMinutes = lengthMinutes
        self.activities = activities
    }


}




public class AlternativeShiftOffersRequest: Codable {





    /** The existing schedule being used to find alternative shift offers */
    public var schedule: AlternativeShiftScheduleLookup?
    /** The start date for the week in this schedule in yyyy-MM-dd format. Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd */
    public var queryWeekDate: Date?

    public init(schedule: AlternativeShiftScheduleLookup?, queryWeekDate: Date?) {
        self.schedule = schedule
        self.queryWeekDate = queryWeekDate
    }


}




public class AlternativeShiftTradeResponse: Codable {



















    public enum State: String, Codable { 
        case canceled = "Canceled"
        case denied = "Denied"
        case expired = "Expired"
        case submitted = "Submitted"
        case approved = "Approved"
    }

    public enum ProcessingStatus: String, Codable { 
        case error = "Error"
        case waitingForScheduleUpdate = "WaitingForScheduleUpdate"
        case scheduleUpdating = "ScheduleUpdating"
        case scheduleUpdated = "ScheduleUpdated"
        case waitingForReview = "WaitingForReview"
        case reviewing = "Reviewing"
    }







    public enum Violations: String, Codable { 
        case serviceGoalsNotMet = "ServiceGoalsNotMet"
    }





    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The job ID of the alternative shift offer listing, from which the trade was chosen */
    public var shiftOfferJobId: String?
    /** The existing shifts from the offer, may be empty */
    public var existingShifts: [AlternativeShiftAgentScheduledShift]?
    /** The offered shifts from the offer, may be empty */
    public var offeredShifts: [AlternativeShiftAgentScheduledShift]?
    /** The existing schedule information associated with the trade */
    public var schedule: AlternativeShiftScheduleLookup?
    /** The management unit of this alternative shift trade request */
    public var managementUnit: ManagementUnitReference?
    /** The user who submitted the trade request */
    public var user: UserReference?
    /** The start week date of the associated schedule in yyyy-MM-dd format. Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd */
    public var weekDate: Date?
    /** The date when the trade will expire in ISO-8601 format. The trade cannot be approved after expiration */
    public var expirationDate: Date?
    /** The state of this alternative shift trade */
    public var state: State?
    /** The processing status of this alternative shift trade */
    public var processingStatus: ProcessingStatus?
    /** The timestamp of when the trade request was reviewed by the system in ISO-8601 format */
    public var systemDateReviewed: Date?
    /** The timestamp of when the trade request was reviewed by an admin in ISO-8601 format */
    public var adminDateReviewed: Date?
    /** The admin who reviewed this alternative shift trade after system denial */
    public var adminReviewedBy: UserReference?
    /** A list of trade match violations */
    public var violations: [Violations]?
    /** Version metadata for this alternative shift trade */
    public var metadata: WfmVersionedEntityMetadata?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, shiftOfferJobId: String?, existingShifts: [AlternativeShiftAgentScheduledShift]?, offeredShifts: [AlternativeShiftAgentScheduledShift]?, schedule: AlternativeShiftScheduleLookup?, managementUnit: ManagementUnitReference?, user: UserReference?, weekDate: Date?, expirationDate: Date?, state: State?, processingStatus: ProcessingStatus?, systemDateReviewed: Date?, adminDateReviewed: Date?, adminReviewedBy: UserReference?, violations: [Violations]?, metadata: WfmVersionedEntityMetadata?, selfUri: String?) {
        self._id = _id
        self.shiftOfferJobId = shiftOfferJobId
        self.existingShifts = existingShifts
        self.offeredShifts = offeredShifts
        self.schedule = schedule
        self.managementUnit = managementUnit
        self.user = user
        self.weekDate = weekDate
        self.expirationDate = expirationDate
        self.state = state
        self.processingStatus = processingStatus
        self.systemDateReviewed = systemDateReviewed
        self.adminDateReviewed = adminDateReviewed
        self.adminReviewedBy = adminReviewedBy
        self.violations = violations
        self.metadata = metadata
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case shiftOfferJobId
        case existingShifts
        case offeredShifts
        case schedule
        case managementUnit
        case user
        case weekDate
        case expirationDate
        case state
        case processingStatus
        case systemDateReviewed
        case adminDateReviewed
        case adminReviewedBy
        case violations
        case metadata
        case selfUri
    }


}




public class AnalyticsConversationSegment: Codable {









    public enum DisconnectType: String, Codable { 
        case client = "client"
        case conferencetransfer = "conferenceTransfer"
        case consulttransfer = "consultTransfer"
        case dndendpoint = "dndEndpoint"
        case dndtransfer = "dndTransfer"
        case endpoint = "endpoint"
        case error = "error"
        case forwardtransfer = "forwardTransfer"
        case inactivity = "inactivity"
        case noanswertransfer = "noAnswerTransfer"
        case notavailabletransfer = "notAvailableTransfer"
        case other = "other"
        case peer = "peer"
        case sessionexpired = "sessionExpired"
        case spam = "spam"
        case system = "system"
        case timeout = "timeout"
        case transfer = "transfer"
        case transportfailure = "transportFailure"
        case uncallable = "uncallable"
    }



















    public enum SegmentType: String, Codable { 
        case alert = "alert"
        case barging = "barging"
        case callback = "callback"
        case coaching = "coaching"
        case contacting = "contacting"
        case converting = "converting"
        case delay = "delay"
        case dialing = "dialing"
        case hold = "hold"
        case interact = "interact"
        case ivr = "ivr"
        case monitoring = "monitoring"
        case parked = "parked"
        case scheduled = "scheduled"
        case sharing = "sharing"
        case system = "system"
        case transmitting = "transmitting"
        case unknown = "unknown"
        case uploading = "uploading"
        case voicemail = "voicemail"
        case wrapup = "wrapup"
    }





















    /** Flag indicating if audio is muted or not (true/false) */
    public var audioMuted: Bool?
    /** Indicates whether the segment was a conference */
    public var conference: Bool?
    /** The unique identifier of a new conversation when a conversation is ended for a conference */
    public var destinationConversationId: String?
    /** The unique identifier of a new session when a session is ended for a conference */
    public var destinationSessionId: String?
    /** The session disconnect type */
    public var disconnectType: DisconnectType?
    /** A code corresponding to the error that occurred */
    public var errorCode: String?
    /** Unique identifier for a Genesys Cloud group */
    public var groupId: String?
    /** Q.850 response code(s) */
    public var q850ResponseCodes: [Int64]?
    /** Queue identifier */
    public var queueId: String?
    /** Unique identifier for the language requested for an interaction */
    public var requestedLanguageId: String?
    /** Unique identifier(s) for skill(s) requested for an interaction */
    public var requestedRoutingSkillIds: [String]?
    /** Unique identifier(s) for agent(s) requested for an interaction */
    public var requestedRoutingUserIds: [String]?
    /** The end time of a segment. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var segmentEnd: Date?
    /** The start time of a segment. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var segmentStart: Date?
    /** The activity that takes place in the segment, such as hold or interact */
    public var segmentType: SegmentType?
    /** SIP response code(s) */
    public var sipResponseCodes: [Int64]?
    /** The unique identifier of the previous conversation when a new conversation is created for a conference */
    public var sourceConversationId: String?
    /** The unique identifier of the previous session when a new session is created for a conference */
    public var sourceSessionId: String?
    /** The subject for the initial email that started this conversation */
    public var subject: String?
    /** Flag indicating if video is muted/paused or not (true/false) */
    public var videoMuted: Bool?
    /** Wrap up code */
    public var wrapUpCode: String?
    /** Note entered by an agent during after-call work */
    public var wrapUpNote: String?
    /** Tag(s) assigned during after-call work */
    public var wrapUpTags: [String]?
    /** Scored agents */
    public var scoredAgents: [AnalyticsScoredAgent]?
    /** Additional segment properties */
    public var properties: [AnalyticsProperty]?

    public init(audioMuted: Bool?, conference: Bool?, destinationConversationId: String?, destinationSessionId: String?, disconnectType: DisconnectType?, errorCode: String?, groupId: String?, q850ResponseCodes: [Int64]?, queueId: String?, requestedLanguageId: String?, requestedRoutingSkillIds: [String]?, requestedRoutingUserIds: [String]?, segmentEnd: Date?, segmentStart: Date?, segmentType: SegmentType?, sipResponseCodes: [Int64]?, sourceConversationId: String?, sourceSessionId: String?, subject: String?, videoMuted: Bool?, wrapUpCode: String?, wrapUpNote: String?, wrapUpTags: [String]?, scoredAgents: [AnalyticsScoredAgent]?, properties: [AnalyticsProperty]?) {
        self.audioMuted = audioMuted
        self.conference = conference
        self.destinationConversationId = destinationConversationId
        self.destinationSessionId = destinationSessionId
        self.disconnectType = disconnectType
        self.errorCode = errorCode
        self.groupId = groupId
        self.q850ResponseCodes = q850ResponseCodes
        self.queueId = queueId
        self.requestedLanguageId = requestedLanguageId
        self.requestedRoutingSkillIds = requestedRoutingSkillIds
        self.requestedRoutingUserIds = requestedRoutingUserIds
        self.segmentEnd = segmentEnd
        self.segmentStart = segmentStart
        self.segmentType = segmentType
        self.sipResponseCodes = sipResponseCodes
        self.sourceConversationId = sourceConversationId
        self.sourceSessionId = sourceSessionId
        self.subject = subject
        self.videoMuted = videoMuted
        self.wrapUpCode = wrapUpCode
        self.wrapUpNote = wrapUpNote
        self.wrapUpTags = wrapUpTags
        self.scoredAgents = scoredAgents
        self.properties = properties
    }


}




public class AnalyticsEvaluation: Codable {













    public enum EvaluationStatus: String, Codable { 
        case finished = "Finished"
        case inProgress = "InProgress"
        case inReview = "InReview"
        case pending = "Pending"
        case retracted = "Retracted"
    }























    /** Indicates whether an assignee is applicable for the evaluation. Set to false when assignee is not applicable */
    public var assigneeApplicable: Bool?
    /** UserId of the assignee */
    public var assigneeId: String?
    /** The calibration ID used for the purpose of training evaluators */
    public var calibrationId: String?
    /** A unique identifier for an evaluation form, regardless of version */
    public var contextId: String?
    /** Whether the evaluation has been deleted */
    public var deleted: Bool?
    /** Unique identifier for the evaluation */
    public var evaluationId: String?
    /** Status of evaluation */
    public var evaluationStatus: EvaluationStatus?
    /** A unique identifier of the user who evaluated the interaction */
    public var evaluatorId: String?
    /** Specifies when an evaluation occurred. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var eventTime: Date?
    /** ID of the evaluation form used */
    public var formId: String?
    /** Name of the evaluation form used */
    public var formName: String?
    /** The ID of the associated queue */
    public var queueId: String?
    /** Whether the evaluation has been released */
    public var released: Bool?
    /** Whether the evaluation has been rescored at least once */
    public var rescored: Bool?
    /** Whether the evaluation was auto submitted by the system */
    public var systemSubmitted: Bool?
    /** ID of the agent the evaluation was performed against */
    public var userId: String?
    public var oTotalCriticalScore: Int64?
    public var oTotalScore: Int64?

    public init(assigneeApplicable: Bool?, assigneeId: String?, calibrationId: String?, contextId: String?, deleted: Bool?, evaluationId: String?, evaluationStatus: EvaluationStatus?, evaluatorId: String?, eventTime: Date?, formId: String?, formName: String?, queueId: String?, released: Bool?, rescored: Bool?, systemSubmitted: Bool?, userId: String?, oTotalCriticalScore: Int64?, oTotalScore: Int64?) {
        self.assigneeApplicable = assigneeApplicable
        self.assigneeId = assigneeId
        self.calibrationId = calibrationId
        self.contextId = contextId
        self.deleted = deleted
        self.evaluationId = evaluationId
        self.evaluationStatus = evaluationStatus
        self.evaluatorId = evaluatorId
        self.eventTime = eventTime
        self.formId = formId
        self.formName = formName
        self.queueId = queueId
        self.released = released
        self.rescored = rescored
        self.systemSubmitted = systemSubmitted
        self.userId = userId
        self.oTotalCriticalScore = oTotalCriticalScore
        self.oTotalScore = oTotalScore
    }


}




public class AnalyticsFlow: Codable {





    public enum EntryType: String, Codable { 
        case agent = "agent"
        case direct = "direct"
        case dnis = "dnis"
        case flow = "flow"
        case outbound = "outbound"
    }







    public enum FlowType: String, Codable { 
        case bot = "BOT"
        case commonmodule = "COMMONMODULE"
        case digitalbot = "DIGITALBOT"
        case inboundcall = "INBOUNDCALL"
        case inboundchat = "INBOUNDCHAT"
        case inboundemail = "INBOUNDEMAIL"
        case inboundshortmessage = "INBOUNDSHORTMESSAGE"
        case inqueuecall = "INQUEUECALL"
        case inqueueemail = "INQUEUEEMAIL"
        case inqueueshortmessage = "INQUEUESHORTMESSAGE"
        case outboundcall = "OUTBOUNDCALL"
        case securecall = "SECURECALL"
        case speech = "SPEECH"
        case surveyinvite = "SURVEYINVITE"
        case voice = "VOICE"
        case voicemail = "VOICEMAIL"
        case voicesurvey = "VOICESURVEY"
        case workflow = "WORKFLOW"
        case workitem = "WORKITEM"
    }

















    /** Flow ending language, e.g. en-us */
    public var endingLanguage: String?
    /** The particular entry reason for this flow, e.g. an address, userId, or flowId */
    public var entryReason: String?
    /** The entry type for this flow, e.g. dnis, dialer, agent, flow, or direct */
    public var entryType: EntryType?
    /** The exit reason for this flow, e.g. DISCONNECT */
    public var exitReason: String?
    /** The unique identifier of this flow */
    public var flowId: String?
    /** The name of this flow at the time of flow execution */
    public var flowName: String?
    /** The type of this flow */
    public var flowType: FlowType?
    /** The version of this flow */
    public var flowVersion: String?
    /** Flag indicating whether the flow issued a callback */
    public var issuedCallback: Bool?
    /** The recognition failure reason causing to exit/disconnect */
    public var recognitionFailureReason: String?
    /** Flow starting language, e.g. en-us */
    public var startingLanguage: String?
    /** The address of a flow transfer target, e.g. a phone number, an email address, or a queueId */
    public var transferTargetAddress: String?
    /** The name of a flow transfer target */
    public var transferTargetName: String?
    /** The type of transfer for flows that ended with a transfer */
    public var transferType: String?
    /** Flow outcomes */
    public var outcomes: [AnalyticsFlowOutcome]?

    public init(endingLanguage: String?, entryReason: String?, entryType: EntryType?, exitReason: String?, flowId: String?, flowName: String?, flowType: FlowType?, flowVersion: String?, issuedCallback: Bool?, recognitionFailureReason: String?, startingLanguage: String?, transferTargetAddress: String?, transferTargetName: String?, transferType: String?, outcomes: [AnalyticsFlowOutcome]?) {
        self.endingLanguage = endingLanguage
        self.entryReason = entryReason
        self.entryType = entryType
        self.exitReason = exitReason
        self.flowId = flowId
        self.flowName = flowName
        self.flowType = flowType
        self.flowVersion = flowVersion
        self.issuedCallback = issuedCallback
        self.recognitionFailureReason = recognitionFailureReason
        self.startingLanguage = startingLanguage
        self.transferTargetAddress = transferTargetAddress
        self.transferTargetName = transferTargetName
        self.transferType = transferType
        self.outcomes = outcomes
    }


}




public class AnalyticsReportingSettings: Codable {







    /** Indication of whether or not personal data is masked in data export and the Analytics/Reporting UI */
    public var piiMaskingEnabled: Bool?
    /** Indication of whether or not to obfuscate export data from the Queue Agent Details view based on User ACL */
    public var queueAgentAccessObfuscation: Bool?
    /** Indicates whether PII data is masked in My Interaction export and the Analytics/Reporting UI */
    public var myInteractionsPiiMaskingEnabled: Bool?

    public init(piiMaskingEnabled: Bool?, queueAgentAccessObfuscation: Bool?, myInteractionsPiiMaskingEnabled: Bool?) {
        self.piiMaskingEnabled = piiMaskingEnabled
        self.queueAgentAccessObfuscation = queueAgentAccessObfuscation
        self.myInteractionsPiiMaskingEnabled = myInteractionsPiiMaskingEnabled
    }


}




public class AnalyticsScoredAgent: Codable {





    /** Assigned agent score for this conversation (0 - 100, higher being better) */
    public var agentScore: Int?
    /** Unique identifier for the agent that was scored for this conversation */
    public var scoredAgentId: String?

    public init(agentScore: Int?, scoredAgentId: String?) {
        self.agentScore = agentScore
        self.scoredAgentId = scoredAgentId
    }


}




public class AnalyticsUserPresenceRecord: Codable {





    public enum SystemPresence: String, Codable { 
        case available = "AVAILABLE"
        case away = "AWAY"
        case busy = "BUSY"
        case offline = "OFFLINE"
        case idle = "IDLE"
        case onQueue = "ON_QUEUE"
        case meal = "MEAL"
        case training = "TRAINING"
        case meeting = "MEETING"
        case _break = "BREAK"
    }



    /** The start time of the record. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var startTime: Date?
    /** The end time of the record. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var endTime: Date?
    /** The user's system presence */
    public var systemPresence: SystemPresence?
    /** The identifier for the user's organization presence */
    public var organizationPresenceId: String?

    public init(startTime: Date?, endTime: Date?, systemPresence: SystemPresence?, organizationPresenceId: String?) {
        self.startTime = startTime
        self.endTime = endTime
        self.systemPresence = systemPresence
        self.organizationPresenceId = organizationPresenceId
    }


}




public class ApiUsageClientQuery: Codable {



    public enum Granularity: String, Codable { 
        case day = "Day"
        case week = "Week"
        case month = "Month"
    }

    public enum Metrics: String, Codable { 
        case status200 = "Status200"
        case status300 = "Status300"
        case status400 = "Status400"
        case status500 = "Status500"
        case status429 = "Status429"
        case requests = "Requests"
    }

    public enum GroupBy: String, Codable { 
        case oauthclientid = "OAuthClientId"
        case organizationId = "OrganizationId"
        case templateUri = "TemplateUri"
        case httpMethod = "HttpMethod"
    }

    /** Behaves like one clause in a SQL WHERE. Specifies the date and time range of data being queried. Intervals are represented as an ISO-8601 string. For example: YYYY-MM-DDThh:mm:ss/YYYY-MM-DDThh:mm:ss */
    public var interval: String?
    /** Date granularity of the results */
    public var granularity: Granularity?
    /** Behaves like a SQL SELECT clause. Enables retrieving only named metrics. If omitted, all metrics that are available will be returned (like SELECT *). */
    public var metrics: [Metrics]?
    /** Behaves like a SQL GROUPBY. Allows for multiple levels of grouping as a list of dimensions. Partitions resulting aggregate computations into distinct named subgroups rather than across the entire result set as if it were one group. */
    public var groupBy: [GroupBy]?

    public init(interval: String?, granularity: Granularity?, metrics: [Metrics]?, groupBy: [GroupBy]?) {
        self.interval = interval
        self.granularity = granularity
        self.metrics = metrics
        self.groupBy = groupBy
    }


}




public class ApiUsageSimpleSearch: Codable {



    public enum Metrics: String, Codable { 
        case date = "Date"
        case clientName = "ClientName"
        case httpMethod = "HttpMethod"
        case templateUri = "TemplateUri"
        case status200 = "Status200"
        case status300 = "Status300"
        case status400 = "Status400"
        case status500 = "Status500"
        case status429 = "Status429"
    }



    public enum HttpMethods: String, Codable { 
        case _get = "GET"
        case post = "POST"
        case delete = "DELETE"
        case patch = "PATCH"
        case put = "PUT"
        case head = "HEAD"
        case connect = "CONNECT"
        case options = "OPTIONS"
        case trace = "TRACE"
    }



    /** Behaves like one clause in a SQL WHERE. Specifies the date and time range of data being queried. Intervals are represented as an ISO-8601 string. For example: YYYY-MM-DDThh:mm:ss/YYYY-MM-DDThh:mm:ss */
    public var interval: String?
    /** Behaves like a SQL SELECT clause. Enables retrieving only named metrics. If omitted, all metrics that are available will be returned (like SELECT *). */
    public var metrics: [Metrics]?
    /** Behaves like a SQL WHERE with multiple IN operators. Specifies a list of OAuth client names to be queried. */
    public var oauthClientNames: [String]?
    /** Behaves like a SQL WHERE with multiple IN operators. Specifies a list of HTTP methods to be queried. */
    public var httpMethods: [HttpMethods]?
    /** Behaves like a SQL WHERE with multiple IN operators. Specifies a list of Template Uris to be queried. */
    public var templateUris: [String]?

    public init(interval: String?, metrics: [Metrics]?, oauthClientNames: [String]?, httpMethods: [HttpMethods]?, templateUris: [String]?) {
        self.interval = interval
        self.metrics = metrics
        self.oauthClientNames = oauthClientNames
        self.httpMethods = httpMethods
        self.templateUris = templateUris
    }


}




public class AppleIMessageApp: Codable {







    /** Application Name. */
    public var applicationName: String?
    /** Application ID. */
    public var applicationId: String?
    /** Bundle ID. */
    public var bundleId: String?

    public init(applicationName: String?, applicationId: String?, bundleId: String?) {
        self.applicationName = applicationName
        self.applicationId = applicationId
        self.bundleId = bundleId
    }


}




public class AppleIdentityResolutionConfig: Codable {









    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The division to use when performing identity resolution. */
    public var division: WritableStarrableDivision?
    /** Whether the channel should resolve identities */
    public var resolveIdentities: Bool?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, division: WritableStarrableDivision?, resolveIdentities: Bool?, selfUri: String?) {
        self._id = _id
        self.division = division
        self.resolveIdentities = resolveIdentities
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case division
        case resolveIdentities
        case selfUri
    }


}




public class AppleIntegration: Codable {



























    public enum CreateStatus: String, Codable { 
        case initiated = "Initiated"
        case completed = "Completed"
        case error = "Error"
    }













    /** A unique integration Id. */
    public var _id: String?
    /** The name of the Apple messaging integration. */
    public var name: String?
    /** Defines the SupportedContent profile configured for an integration */
    public var supportedContent: SupportedContentReference?
    public var messagingSetting: MessagingSettingReference?
    /** The Apple Messages for Business Id for the Apple messaging integration. */
    public var messagesForBusinessId: String?
    /** The name of the business. */
    public var businessName: String?
    /** The url of the businesses logo. */
    public var logoUrl: String?
    /** The status of the Apple Integration */
    public var status: String?
    /** The recipient associated to the Apple messaging Integration. This recipient is used to associate a flow to an integration */
    public var recipient: DomainEntityRef?
    /** Date this Integration was created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** Date this Integration was last modified. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** User reference that created this Integration */
    public var createdBy: DomainEntityRef?
    /** User reference that last modified this Integration */
    public var modifiedBy: DomainEntityRef?
    /** Status of asynchronous create operation */
    public var createStatus: CreateStatus?
    /** Error information returned, if createStatus is set to Error */
    public var createError: ErrorBody?
    /** Interactive Application (iMessage App) Settings. */
    public var appleIMessageApp: AppleIMessageApp?
    /** The Apple Messages for Business authentication setting. */
    public var appleAuthentication: AppleAuthentication?
    /** Apple Pay settings. */
    public var applePay: ApplePay?
    /** The configuration to control identity resolution. */
    public var identityResolution: AppleIdentityResolutionConfig?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, supportedContent: SupportedContentReference?, messagingSetting: MessagingSettingReference?, messagesForBusinessId: String?, businessName: String?, logoUrl: String?, status: String?, recipient: DomainEntityRef?, dateCreated: Date?, dateModified: Date?, createdBy: DomainEntityRef?, modifiedBy: DomainEntityRef?, createStatus: CreateStatus?, createError: ErrorBody?, appleIMessageApp: AppleIMessageApp?, appleAuthentication: AppleAuthentication?, applePay: ApplePay?, identityResolution: AppleIdentityResolutionConfig?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.supportedContent = supportedContent
        self.messagingSetting = messagingSetting
        self.messagesForBusinessId = messagesForBusinessId
        self.businessName = businessName
        self.logoUrl = logoUrl
        self.status = status
        self.recipient = recipient
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.createdBy = createdBy
        self.modifiedBy = modifiedBy
        self.createStatus = createStatus
        self.createError = createError
        self.appleIMessageApp = appleIMessageApp
        self.appleAuthentication = appleAuthentication
        self.applePay = applePay
        self.identityResolution = identityResolution
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case supportedContent
        case messagingSetting
        case messagesForBusinessId
        case businessName
        case logoUrl
        case status
        case recipient
        case dateCreated
        case dateModified
        case createdBy
        case modifiedBy
        case createStatus
        case createError
        case appleIMessageApp
        case appleAuthentication
        case applePay
        case identityResolution
        case selfUri
    }


}




public class AppleIntegrationRequest: Codable {























    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The name of the Apple messaging integration. */
    public var name: String?
    /** Defines the SupportedContent profile configured for an integration */
    public var supportedContent: SupportedContentReference?
    /** Defines the message settings to be applied for this integration */
    public var messagingSetting: MessagingSettingRequestReference?
    /** The Apple Messages for Business Id for the Apple messaging integration. */
    public var messagesForBusinessId: String?
    /** The name of the business. */
    public var businessName: String?
    /** The url of the businesses logo. */
    public var logoUrl: String?
    /** Interactive Application (iMessage App) Settings. */
    public var appleIMessageApp: AppleIMessageApp?
    /** The Apple Messages for Business authentication setting. */
    public var appleAuthentication: AppleAuthentication?
    /** Apple Pay settings. */
    public var applePay: ApplePay?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, supportedContent: SupportedContentReference?, messagingSetting: MessagingSettingRequestReference?, messagesForBusinessId: String?, businessName: String?, logoUrl: String?, appleIMessageApp: AppleIMessageApp?, appleAuthentication: AppleAuthentication?, applePay: ApplePay?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.supportedContent = supportedContent
        self.messagingSetting = messagingSetting
        self.messagesForBusinessId = messagesForBusinessId
        self.businessName = businessName
        self.logoUrl = logoUrl
        self.appleIMessageApp = appleIMessageApp
        self.appleAuthentication = appleAuthentication
        self.applePay = applePay
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case supportedContent
        case messagingSetting
        case messagesForBusinessId
        case businessName
        case logoUrl
        case appleIMessageApp
        case appleAuthentication
        case applePay
        case selfUri
    }


}



/** The client who initiated the change. */

public class ArchitectDependencyTrackingBuildNotificationClient: Codable {





    /** The ID of the client. */
    public var _id: String?
    /** The name of the client, if available. */
    public var name: String?

    public init(_id: String?, name: String?) {
        self._id = _id
        self.name = name
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
    }


}




public class ArchitectDependencyTrackingBuildNotificationHomeOrganization: Codable {







    public var _id: String?
    public var name: String?
    public var thirdPartyOrgName: String?

    public init(_id: String?, name: String?, thirdPartyOrgName: String?) {
        self._id = _id
        self.name = name
        self.thirdPartyOrgName = thirdPartyOrgName
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case thirdPartyOrgName
    }


}




public class ArchitectExportJobStateResponse: Codable {



    public enum Status: String, Codable { 
        case registered = "Registered"
        case started = "Started"
        case success = "Success"
        case failure = "Failure"
    }

    public enum Command: String, Codable { 
        case publish = "Publish"
        case create = "Create"
        case update = "Update"
        case export = "Export"
    }







    /** The globally unique identifier for the object. */
    public var _id: String?
    /** Status of the Architect Export Job */
    public var status: Status?
    /** The command executed by the Architect Job */
    public var command: Command?
    /** The signed URL for downloading exported Architect data. If more than one flow was exported as part of the job, the URL provides a zipped folder containing all flows. */
    public var downloadUrl: String?
    /** Warnings and Errors messages of the Architect Job */
    public var messages: [ArchitectJobMessage]?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, status: Status?, command: Command?, downloadUrl: String?, messages: [ArchitectJobMessage]?, selfUri: String?) {
        self._id = _id
        self.status = status
        self.command = command
        self.downloadUrl = downloadUrl
        self.messages = messages
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case status
        case command
        case downloadUrl
        case messages
        case selfUri
    }


}



/** The client who initiated the change. */

public class ArchitectFlowNotificationClient: Codable {





    /** The ID of the client. */
    public var _id: String?
    /** The name of the client, if available. */
    public var name: String?

    public init(_id: String?, name: String?) {
        self._id = _id
        self.name = name
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
    }


}




public class ArchitectFlowNotificationErrorDetail: Codable {









    public var errorCode: String?
    public var entityId: String?
    public var entityName: String?
    public var fieldName: String?

    public init(errorCode: String?, entityId: String?, entityName: String?, fieldName: String?) {
        self.errorCode = errorCode
        self.entityId = entityId
        self.entityName = entityName
        self.fieldName = fieldName
    }


}




public class ArchitectFlowNotificationHomeOrganization: Codable {







    public var _id: String?
    public var name: String?
    public var thirdPartyOrgName: String?

    public init(_id: String?, name: String?, thirdPartyOrgName: String?) {
        self._id = _id
        self.name = name
        self.thirdPartyOrgName = thirdPartyOrgName
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case thirdPartyOrgName
    }


}




public class ArchitectFlowOutcomeNotificationFlowOutcomeNotification: Codable {









    /** The flow outcome ID */
    public var _id: String?
    /** The flow outcome name */
    public var name: String?
    /** The flow outcome description */
    public var _description: String?
    public var currentOperation: ArchitectFlowOutcomeNotificationArchitectOperation?

    public init(_id: String?, name: String?, _description: String?, currentOperation: ArchitectFlowOutcomeNotificationArchitectOperation?) {
        self._id = _id
        self.name = name
        self._description = _description
        self.currentOperation = currentOperation
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case _description = "description"
        case currentOperation
    }


}



/** The user who initiated the change. */

public class ArchitectFlowOutcomeNotificationUser: Codable {







    /** The ID of the user. */
    public var _id: String?
    /** The name of the user, if available. */
    public var name: String?
    public var homeOrg: ArchitectFlowOutcomeNotificationHomeOrganization?

    public init(_id: String?, name: String?, homeOrg: ArchitectFlowOutcomeNotificationHomeOrganization?) {
        self._id = _id
        self.name = name
        self.homeOrg = homeOrg
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case homeOrg
    }


}



/** The error message params, if the action failed */

public class ArchitectPromptNotificationErrorMessageParams: Codable {





    public var additionalProperties: [String:String]?
    public var getAdditionalProperties: [String:String]?

    public init(additionalProperties: [String:String]?, getAdditionalProperties: [String:String]?) {
        self.additionalProperties = additionalProperties
        self.getAdditionalProperties = getAdditionalProperties
    }


}



/** Learning module response */

public class AssignedLearningModule: Codable {



















    public enum Source: String, Codable { 
        case userCreated = "UserCreated"
        case genesysBeyond = "GenesysBeyond"
    }



















    public enum ModelType: String, Codable { 
        case informational = "Informational"
        case assessedContent = "AssessedContent"
        case assessment = "Assessment"
        case external = "External"
        case native = "Native"
    }













    public enum ArchivalMode: String, Codable { 
        case graceful = "Graceful"
        case immediate = "Immediate"
    }

    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The name of learning module */
    public var name: String?
    /** If true, learning module is excluded when retrieving modules for manual assignment */
    public var excludedFromCatalog: Bool?
    /** The user who created learning module */
    public var createdBy: UserReference?
    /** The date/time learning module was created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** The user who modified learning module */
    public var modifiedBy: UserReference?
    /** The date/time learning module was modified. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** The version of published learning module */
    public var version: Int?
    /** The external ID of the learning module */
    public var externalId: String?
    /** The source of the learning module */
    public var source: Source?
    /** The rule for learning module; read-only, and only populated when requested via expand param. */
    public var rule: LearningModuleRule?
    /** If true, learning module content should be viewed one by one in order */
    public var enforceContentOrder: Bool?
    /** Allows to view Assessment results in detail */
    public var reviewAssessmentResults: ReviewAssessmentResults?
    /** The current assignments for the requested users */
    public var currentAssignments: [LearningAssignment]?
    /** The URI for this object */
    public var selfUri: String?
    /** If true, learning module is archived */
    public var isArchived: Bool?
    /** If true, learning module is published */
    public var isPublished: Bool?
    /** The description of learning module */
    public var _description: String?
    /** The completion time of learning module in days */
    public var completionTimeInDays: Int?
    /** The type for the learning module */
    public var type: ModelType?
    /** The list of inform steps in a learning module */
    public var informSteps: [LearningModuleInformStep]?
    /** The assessment form for learning module */
    public var assessmentForm: AssessmentForm?
    /** The learning module summary data */
    public var summaryData: LearningModuleSummary?
    /** The learning module reassign summary data */
    public var reassignSummaryData: LearningModuleReassignSummary?
    /** The cover art for the learning module */
    public var coverArt: LearningModuleCoverArtResponse?
    /** The recommended time in minutes to complete the module */
    public var lengthInMinutes: Int?
    /** The mode of archival for learning module */
    public var archivalMode: ArchivalMode?

    public init(_id: String?, name: String?, excludedFromCatalog: Bool?, createdBy: UserReference?, dateCreated: Date?, modifiedBy: UserReference?, dateModified: Date?, version: Int?, externalId: String?, source: Source?, rule: LearningModuleRule?, enforceContentOrder: Bool?, reviewAssessmentResults: ReviewAssessmentResults?, currentAssignments: [LearningAssignment]?, selfUri: String?, isArchived: Bool?, isPublished: Bool?, _description: String?, completionTimeInDays: Int?, type: ModelType?, informSteps: [LearningModuleInformStep]?, assessmentForm: AssessmentForm?, summaryData: LearningModuleSummary?, reassignSummaryData: LearningModuleReassignSummary?, coverArt: LearningModuleCoverArtResponse?, lengthInMinutes: Int?, archivalMode: ArchivalMode?) {
        self._id = _id
        self.name = name
        self.excludedFromCatalog = excludedFromCatalog
        self.createdBy = createdBy
        self.dateCreated = dateCreated
        self.modifiedBy = modifiedBy
        self.dateModified = dateModified
        self.version = version
        self.externalId = externalId
        self.source = source
        self.rule = rule
        self.enforceContentOrder = enforceContentOrder
        self.reviewAssessmentResults = reviewAssessmentResults
        self.currentAssignments = currentAssignments
        self.selfUri = selfUri
        self.isArchived = isArchived
        self.isPublished = isPublished
        self._description = _description
        self.completionTimeInDays = completionTimeInDays
        self.type = type
        self.informSteps = informSteps
        self.assessmentForm = assessmentForm
        self.summaryData = summaryData
        self.reassignSummaryData = reassignSummaryData
        self.coverArt = coverArt
        self.lengthInMinutes = lengthInMinutes
        self.archivalMode = archivalMode
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case excludedFromCatalog
        case createdBy
        case dateCreated
        case modifiedBy
        case dateModified
        case version
        case externalId
        case source
        case rule
        case enforceContentOrder
        case reviewAssessmentResults
        case currentAssignments
        case selfUri
        case isArchived
        case isPublished
        case _description = "description"
        case completionTimeInDays
        case type
        case informSteps
        case assessmentForm
        case summaryData
        case reassignSummaryData
        case coverArt
        case lengthInMinutes
        case archivalMode
    }


}




public class Assignment: Codable {







    /** The list of users successfully assigned to the custom performance profile */
    public var assignedMembers: [UserReference]?
    /** The list of users successfully removed from the custom performance profile */
    public var removedMembers: [UserReference]?
    /** The list of users failed assignment or removal for the custom performance profile */
    public var assignmentErrors: [AssignmentError]?

    public init(assignedMembers: [UserReference]?, removedMembers: [UserReference]?, assignmentErrors: [AssignmentError]?) {
        self.assignedMembers = assignedMembers
        self.removedMembers = removedMembers
        self.assignmentErrors = assignmentErrors
    }


}




public class AssignmentValidation: Codable {









    /** The list of users that are not assigned to any custom performance profile */
    public var membersNotAssigned: [UserReference]?
    /** The list of users that are already assigned to the requesting custom performance profile */
    public var membersAlreadyAssigned: [UserReference]?
    /** The list of users that are already assigned to other custom performance profiles */
    public var membersAlreadyAssignedToOther: [OtherProfileAssignment]?
    /** The list of user id that are invalid for the gamfication service to handle */
    public var invalidMemberAssignments: [InvalidAssignment]?

    public init(membersNotAssigned: [UserReference]?, membersAlreadyAssigned: [UserReference]?, membersAlreadyAssignedToOther: [OtherProfileAssignment]?, invalidMemberAssignments: [InvalidAssignment]?) {
        self.membersNotAssigned = membersNotAssigned
        self.membersAlreadyAssigned = membersAlreadyAssigned
        self.membersAlreadyAssignedToOther = membersAlreadyAssignedToOther
        self.invalidMemberAssignments = invalidMemberAssignments
    }


}




public class Assistant: Codable {



















    public enum State: String, Codable { 
        case active = "Active"
        case inactive = "Inactive"
    }





    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The name of the assistant that will assist the agent. */
    public var name: String?
    /** Date when the assistant was created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** Date when the assistant was last modified. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** The user who created the assistant. */
    public var createdBy: UserReference?
    /** The user who last modified the assistant. */
    public var modifiedBy: UserReference?
    /** (Deprecated: use the 'knowledgeSuggestionConfig' for genesys knowledge suggestions) Configuration of Dialogflow used to assist the agent with transcriptions and knowledge suggestions. */
    public var googleDialogflowConfig: GoogleDialogflowConfig?
    /** Configuration for speech transcription used to assist the agent. */
    public var transcriptionConfig: TranscriptionConfig?
    /** Configuration that defines how to produce knowledge suggestions. */
    public var knowledgeSuggestionConfig: KnowledgeSuggestionConfig?
    /** State of the assistant. */
    public var state: State?
    /** Agent copilot configuration. */
    public var copilot: Copilot?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, dateCreated: Date?, dateModified: Date?, createdBy: UserReference?, modifiedBy: UserReference?, googleDialogflowConfig: GoogleDialogflowConfig?, transcriptionConfig: TranscriptionConfig?, knowledgeSuggestionConfig: KnowledgeSuggestionConfig?, state: State?, copilot: Copilot?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.createdBy = createdBy
        self.modifiedBy = modifiedBy
        self.googleDialogflowConfig = googleDialogflowConfig
        self.transcriptionConfig = transcriptionConfig
        self.knowledgeSuggestionConfig = knowledgeSuggestionConfig
        self.state = state
        self.copilot = copilot
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case dateCreated
        case dateModified
        case createdBy
        case modifiedBy
        case googleDialogflowConfig
        case transcriptionConfig
        case knowledgeSuggestionConfig
        case state
        case copilot
        case selfUri
    }


}




public class AssistantListing: Codable {









    public var entities: [Assistant]?
    public var nextUri: String?
    public var selfUri: String?
    public var previousUri: String?

    public init(entities: [Assistant]?, nextUri: String?, selfUri: String?, previousUri: String?) {
        self.entities = entities
        self.nextUri = nextUri
        self.selfUri = selfUri
        self.previousUri = previousUri
    }


}




public class AssistantQueueUsersBulkAddRequest: Codable {



    /** List of users to assign assistant for. Maximum users to add is 100 per request. */
    public var entities: [AssistantQueueUser]?

    public init(entities: [AssistantQueueUser]?) {
        self.entities = entities
    }


}




public class AsyncConversationQuery: Codable {











    public enum Order: String, Codable { 
        case asc = "asc"
        case desc = "desc"
        case unordered = "unordered"
    }

    public enum OrderBy: String, Codable { 
        case conversationstart = "conversationStart"
        case conversationend = "conversationEnd"
        case segmentstart = "segmentStart"
        case segmentend = "segmentEnd"
    }







    /** Filters that target conversation-level data */
    public var conversationFilters: [ConversationDetailQueryFilter]?
    /** Filters that target individual segments within a conversation */
    public var segmentFilters: [SegmentDetailQueryFilter]?
    /** Filters that target evaluations */
    public var evaluationFilters: [EvaluationDetailQueryFilter]?
    /** Filters that target surveys */
    public var surveyFilters: [SurveyDetailQueryFilter]?
    /** Filters that target resolutions */
    public var resolutionFilters: [ResolutionDetailQueryFilter]?
    /** Sort the result set in ascending/descending order. Default is ascending */
    public var order: Order?
    /** Specify which data element within the result set to use for sorting. The options  to use as a basis for sorting the results: conversationStart, segmentStart, and segmentEnd. If not specified, the default is conversationStart */
    public var orderBy: OrderBy?
    /** Specifies the date and time range of data being queried. Results will include all conversations that had activity during the interval. Intervals are represented as an ISO-8601 string. For example: YYYY-MM-DDThh:mm:ss/YYYY-MM-DDThh:mm:ss */
    public var interval: String?
    /** Specify number of results to be returned */
    public var limit: Int?
    /** Add a filter to only include conversations that started after the beginning of the interval start date (UTC) */
    public var startOfDayIntervalMatching: Bool?

    public init(conversationFilters: [ConversationDetailQueryFilter]?, segmentFilters: [SegmentDetailQueryFilter]?, evaluationFilters: [EvaluationDetailQueryFilter]?, surveyFilters: [SurveyDetailQueryFilter]?, resolutionFilters: [ResolutionDetailQueryFilter]?, order: Order?, orderBy: OrderBy?, interval: String?, limit: Int?, startOfDayIntervalMatching: Bool?) {
        self.conversationFilters = conversationFilters
        self.segmentFilters = segmentFilters
        self.evaluationFilters = evaluationFilters
        self.surveyFilters = surveyFilters
        self.resolutionFilters = resolutionFilters
        self.order = order
        self.orderBy = orderBy
        self.interval = interval
        self.limit = limit
        self.startOfDayIntervalMatching = startOfDayIntervalMatching
    }


}




public class AsyncUserDetailsQuery: Codable {









    public enum Order: String, Codable { 
        case asc = "asc"
        case desc = "desc"
        case unordered = "unordered"
    }



    /** Specifies the date and time range of data being queried. Conversations MUST have started within this time range to potentially be included within the result set. Intervals are represented as an ISO-8601 string. For example: YYYY-MM-DDThh:mm:ss/YYYY-MM-DDThh:mm:ss */
    public var interval: String?
    /** Filters that target the users to retrieve data for */
    public var userFilters: [UserDetailQueryFilter]?
    /** Filters that target system and organization presence-level data */
    public var presenceFilters: [PresenceDetailQueryFilter]?
    /** Filters that target agent routing status-level data */
    public var routingStatusFilters: [RoutingStatusDetailQueryFilter]?
    /** Sort the result set in ascending/descending order. Default is ascending */
    public var order: Order?
    /** Specify number of results to be returned */
    public var limit: Int?

    public init(interval: String?, userFilters: [UserDetailQueryFilter]?, presenceFilters: [PresenceDetailQueryFilter]?, routingStatusFilters: [RoutingStatusDetailQueryFilter]?, order: Order?, limit: Int?) {
        self.interval = interval
        self.userFilters = userFilters
        self.presenceFilters = presenceFilters
        self.routingStatusFilters = routingStatusFilters
        self.order = order
        self.limit = limit
    }


}




public class AttendanceStatus: Codable {



    public enum AttendanceStatusType: String, Codable { 
        case hasData = "HasData"
        case scheduled = "Scheduled"
        case absent = "Absent"
        case present = "Present"
        case noSchedule = "NoSchedule"
    }

    public enum HasEvaluation: String, Codable { 
        case hasQualityEvaluation = "HasQualityEvaluation"
        case noQualityEvaluation = "NoQualityEvaluation"
    }

    /** the workday date of this attendance status. Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd */
    public var dateWorkday: Date?
    /** the attendance status */
    public var attendanceStatusType: AttendanceStatusType?
    /** the quality evaluation score status */
    public var hasEvaluation: HasEvaluation?

    public init(dateWorkday: Date?, attendanceStatusType: AttendanceStatusType?, hasEvaluation: HasEvaluation?) {
        self.dateWorkday = dateWorkday
        self.attendanceStatusType = attendanceStatusType
        self.hasEvaluation = hasEvaluation
    }


}




public class AttendanceStatusListing: Codable {



    public var entities: [AttendanceStatus]?

    public init(entities: [AttendanceStatus]?) {
        self.entities = entities
    }


}




public class AtzmTimeSlot: Codable {





    /** The earliest time to dial a contact. Valid format is HH:mm */
    public var earliestCallableTime: String?
    /** The latest time to dial a contact. Valid format is HH:mm */
    public var latestCallableTime: String?

    public init(earliestCallableTime: String?, latestCallableTime: String?) {
        self.earliestCallableTime = earliestCallableTime
        self.latestCallableTime = latestCallableTime
    }


}




public class AttributeDetailEventTopicCommunication: Codable {



    public enum MediaType: String, Codable { 
        case unknown = "UNKNOWN"
        case voice = "VOICE"
        case chat = "CHAT"
        case email = "EMAIL"
        case callback = "CALLBACK"
        case cobrowse = "COBROWSE"
        case video = "VIDEO"
        case screenshare = "SCREENSHARE"
        case message = "MESSAGE"
        case internalmessage = "INTERNALMESSAGE"
    }

    public var _id: String?
    public var mediaType: MediaType?

    public init(_id: String?, mediaType: MediaType?) {
        self._id = _id
        self.mediaType = mediaType
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case mediaType
    }


}




public class AuditQueryEntity: Codable {





    /** Name of the Entity */
    public var name: String?
    /** List of Actions */
    public var actions: [String]?

    public init(name: String?, actions: [String]?) {
        self.name = name
        self.actions = actions
    }


}




public class AuditQueryServiceMapping: Codable {



    /** List of Services */
    public var services: [AuditQueryService]?

    public init(services: [AuditQueryService]?) {
        self.services = services
    }


}




public class AuditTopicMessageInfo: Codable {









    public var localizableMessageCode: String?
    public var message: String?
    public var messageWithParams: String?
    public var messageParams: [String:String]?

    public init(localizableMessageCode: String?, message: String?, messageWithParams: String?, messageParams: [String:String]?) {
        self.localizableMessageCode = localizableMessageCode
        self.message = message
        self.messageWithParams = messageWithParams
        self.messageParams = messageParams
    }


}




public class AuthzDivisionCursorListing: Codable {









    public var entities: [AuthzDivision]?
    public var nextUri: String?
    public var selfUri: String?
    public var previousUri: String?

    public init(entities: [AuthzDivision]?, nextUri: String?, selfUri: String?, previousUri: String?) {
        self.entities = entities
        self.nextUri = nextUri
        self.selfUri = selfUri
        self.previousUri = previousUri
    }


}




public class AuthzGrantRole: Codable {













    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    public var _description: String?
    public var policies: [AuthzGrantPolicy]?
    public var _default: Bool?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, _description: String?, policies: [AuthzGrantPolicy]?, _default: Bool?, selfUri: String?) {
        self._id = _id
        self.name = name
        self._description = _description
        self.policies = policies
        self._default = _default
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case _description = "description"
        case policies
        case _default = "default"
        case selfUri
    }


}




public class AuthzSubject: Codable {











    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    public var grants: [AuthzGrant]?
    public var version: Int?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, grants: [AuthzGrant]?, version: Int?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.grants = grants
        self.version = version
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case grants
        case version
        case selfUri
    }


}




public class AvailableTimeOffRequest: Codable {





    /** The ID for activity code to query available time off minutes */
    public var activityCodeId: String?
    /** A list of date ranges of available time off minutes. A maximum number of date ranges is 30. The maximum total number of days in all ranges is 366. If no ranges are specified, then only the presence of the associated time off limit object will be checked. In such case, if the association exists, then the response will contain a list with of a single element filled with timeOffLimitId only. */
    public var dateRanges: [LocalDateRange]?

    public init(activityCodeId: String?, dateRanges: [LocalDateRange]?) {
        self.activityCodeId = activityCodeId
        self.dateRanges = dateRanges
    }


}




public class AvailableTranslations: Codable {





    public var orgSpecific: [String]?
    public var builtin: [String]?

    public init(orgSpecific: [String]?, builtin: [String]?) {
        self.orgSpecific = orgSpecific
        self.builtin = builtin
    }


}




public class BaseProgramEntity: Codable {







    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case selfUri
    }


}



/** A maximum of 100 events are allowed per request */

public class BatchUserRoutingStatusEventRequest: Codable {



    /** UserRoutingStatus events for this batch */
    public var userRoutingStatusEvents: [UserRoutingStatusEvent]?

    public init(userRoutingStatusEvents: [UserRoutingStatusEvent]?) {
        self.userRoutingStatusEvents = userRoutingStatusEvents
    }


}




public class BotAggregateQueryFilter: Codable {

    public enum ModelType: String, Codable { 
        case and = "and"
        case or = "or"
    }





    /** Boolean operation to apply to the provided predicates and clauses */
    public var type: ModelType?
    /** Boolean 'and/or' logic with up to two-levels of nesting */
    public var clauses: [BotAggregateQueryClause]?
    /** Like a three-word sentence: (attribute-name) (operator) (target-value). */
    public var predicates: [BotAggregateQueryPredicate]?

    public init(type: ModelType?, clauses: [BotAggregateQueryClause]?, predicates: [BotAggregateQueryPredicate]?) {
        self.type = type
        self.clauses = clauses
        self.predicates = predicates
    }


}




public class BotConnectorBotVersionSummaryEntityListing: Codable {





















    public var entities: [BotVersionSummary]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var previousUri: String?
    public var nextUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [BotVersionSummary]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, previousUri: String?, nextUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.previousUri = previousUri
        self.nextUri = nextUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}



/** Model for setting the launch configuration for a Nuance bot available to Genesys Cloud */

public class BotExecutionConfiguration: Codable {







    /** The Nuance bot ID */
    public var botId: String?
    /** The hostname to use when contacting Nuance to execute this bot */
    public var executionHost: String?
    /** The bot's launch credentials */
    public var botCredentials: NuanceBotCredentials?

    public init(botId: String?, executionHost: String?, botCredentials: NuanceBotCredentials?) {
        self.botId = botId
        self.executionHost = executionHost
        self.botCredentials = botCredentials
    }


}



/** A botConnector's bot intention */

public class BotIntent: Codable {





    /** The name of this intent.  This can be up to 100 characters long and must be comprised of displayable characters without leading or trailing whitespace */
    public var name: String?
    /** Optional returned data values associated with this intent, limit of 50. */
    public var slots: [String:BotSlot]?

    public init(name: String?, slots: [String:BotSlot]?) {
        self.name = name
        self.slots = slots
    }


}




public class BuActivitySettingsResponse: Codable {



    /** Default Activity Code settings */
    public var defaultActivityCode: ActivityCodeReference?

    public init(defaultActivityCode: ActivityCodeReference?) {
        self.defaultActivityCode = defaultActivityCode
    }


}




public class BuAlternativeShiftJobResponse: Codable {



    public enum Status: String, Codable { 
        case processing = "Processing"
        case complete = "Complete"
        case error = "Error"
    }

    public enum ModelType: String, Codable { 
        case listOffers = "ListOffers"
        case searchOffers = "SearchOffers"
        case listUserTrades = "ListUserTrades"
        case searchTrades = "SearchTrades"
        case bulkUpdateTrades = "BulkUpdateTrades"
    }













    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The status of the alternative shift job */
    public var status: Status?
    /** The type of job */
    public var type: ModelType?
    /** The URL where completed results are available, only set if status == 'Complete' */
    public var downloadUrl: String?
    /** Any error information, only set if the status == 'Error' */
    public var error: ErrorBody?
    /** Schema template for deserializing data returned from the downloadUrl. Use if type == 'ListOffers' or 'SearchOffers' */
    public var viewOffersResults: AlternativeShiftOffersViewResponseTemplate?
    /** Schema template for deserializing data returned from the downloadUrl. Use if type == 'ListUserTrades' or 'SearchTrades' */
    public var viewTradesResults: AlternativeShiftTradesViewResponseTemplate?
    /** Schema template for deserializing data returned from the downloadUrl. Use if type == 'BulkUpdateTrades' */
    public var bulkUpdateTradesResults: AlternativeShiftBulkUpdateTradesResponseTemplate?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, status: Status?, type: ModelType?, downloadUrl: String?, error: ErrorBody?, viewOffersResults: AlternativeShiftOffersViewResponseTemplate?, viewTradesResults: AlternativeShiftTradesViewResponseTemplate?, bulkUpdateTradesResults: AlternativeShiftBulkUpdateTradesResponseTemplate?, selfUri: String?) {
        self._id = _id
        self.status = status
        self.type = type
        self.downloadUrl = downloadUrl
        self.error = error
        self.viewOffersResults = viewOffersResults
        self.viewTradesResults = viewTradesResults
        self.bulkUpdateTradesResults = bulkUpdateTradesResults
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case status
        case type
        case downloadUrl
        case error
        case viewOffersResults
        case viewTradesResults
        case bulkUpdateTradesResults
        case selfUri
    }


}




public class BuAverageSpeedOfAnswer: Codable {





    /** Whether to include average speed of answer (ASA) in the associated configuration */
    public var include: Bool?
    /** The target average speed of answer (ASA) in seconds. Required if include == true */
    public var seconds: Int?

    public init(include: Bool?, seconds: Int?) {
        self.include = include
        self.seconds = seconds
    }


}




public class BuForecastGenerationPlanningGroupResult: Codable {





    /** The ID of the planning group */
    public var planningGroupId: String?
    /** The generation results for the associated planning group */
    public var metricResults: [BuForecastTimeSeriesResult]?

    public init(planningGroupId: String?, metricResults: [BuForecastTimeSeriesResult]?) {
        self.planningGroupId = planningGroupId
        self.metricResults = metricResults
    }


}




public class BuForecastStaffingRequirementsResultResponse: Codable {











    public enum State: String, Codable { 
        case processing = "Processing"
        case complete = "Complete"
        case error = "Error"
    }



    /** The ID of the business unit to which the forecast staffing requirements belongs */
    public var businessUnitId: String?
    /** The forecast reference */
    public var forecast: BuShortTermForecastReference?
    /** The reference start date for interval-based data for this forecast as an ISO-8601 string */
    public var referenceStartDate: Date?
    /** The number of weeks in this forecast */
    public var weekCount: Int?
    /** The period/interval in minutes for which to aggregate the data */
    public var intervalLengthMinutes: Int?
    /** The state of the staffing requirements generation */
    public var state: State?
    /** The forecast staffing requirement results, Will be populated when state == 'Complete' */
    public var results: [BuForecastStaffingRequirementsResult]?

    public init(businessUnitId: String?, forecast: BuShortTermForecastReference?, referenceStartDate: Date?, weekCount: Int?, intervalLengthMinutes: Int?, state: State?, results: [BuForecastStaffingRequirementsResult]?) {
        self.businessUnitId = businessUnitId
        self.forecast = forecast
        self.referenceStartDate = referenceStartDate
        self.weekCount = weekCount
        self.intervalLengthMinutes = intervalLengthMinutes
        self.state = state
        self.results = results
    }


}




public class BuFullDayTimeOffMarker: Codable {



















    /** The date of the time off marker, interpreted in the business unit's time zone. Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd */
    public var businessUnitDate: Date?
    /** The length of the time off marker in minutes */
    public var lengthMinutes: Int?
    /** The description of the time off marker */
    public var _description: String?
    /** The ID of the activity code associated with the time off marker */
    public var activityCodeId: String?
    /** Whether the time off marker is paid */
    public var paid: Bool?
    /** Payable minutes for the time off marker */
    public var payableMinutes: Int?
    /** The ID of the time off request */
    public var timeOffRequestId: String?
    /** The sync version of the full day time off request for which the scheduled activity is associated */
    public var timeOffRequestSyncVersion: Int?
    /** Set to 'true' to delete this time off marker. Will always be null on responses, only has an effect on schedule update */
    public var delete: Bool?

    public init(businessUnitDate: Date?, lengthMinutes: Int?, _description: String?, activityCodeId: String?, paid: Bool?, payableMinutes: Int?, timeOffRequestId: String?, timeOffRequestSyncVersion: Int?, delete: Bool?) {
        self.businessUnitDate = businessUnitDate
        self.lengthMinutes = lengthMinutes
        self._description = _description
        self.activityCodeId = activityCodeId
        self.paid = paid
        self.payableMinutes = payableMinutes
        self.timeOffRequestId = timeOffRequestId
        self.timeOffRequestSyncVersion = timeOffRequestSyncVersion
        self.delete = delete
    }

    public enum CodingKeys: String, CodingKey { 
        case businessUnitDate
        case lengthMinutes
        case _description = "description"
        case activityCodeId
        case paid
        case payableMinutes
        case timeOffRequestId
        case timeOffRequestSyncVersion
        case delete
    }


}




public class BuIntradayDataGroup: Codable {

    public enum MediaType: String, Codable { 
        case voice = "Voice"
        case chat = "Chat"
        case email = "Email"
        case callback = "Callback"
        case message = "Message"
        case workitem = "Workitem"
    }













    /** The media type associated with this intraday group */
    public var mediaType: MediaType?
    /** Forecast data summary for this date range */
    public var forecastDataSummary: BuIntradayForecastData?
    /** Forecast data per interval for this date range */
    public var forecastDataPerInterval: [BuIntradayForecastData]?
    /** Schedule data summary for this date range */
    public var scheduleDataSummary: BuIntradayScheduleData?
    /** Schedule data per interval for this date range */
    public var scheduleDataPerInterval: [BuIntradayScheduleData]?
    /** Performance prediction data summary for this date range */
    public var performancePredictionDataSummary: IntradayPerformancePredictionData?
    /** Performance prediction data per interval for this date range */
    public var performancePredictionDataPerInterval: [IntradayPerformancePredictionData]?

    public init(mediaType: MediaType?, forecastDataSummary: BuIntradayForecastData?, forecastDataPerInterval: [BuIntradayForecastData]?, scheduleDataSummary: BuIntradayScheduleData?, scheduleDataPerInterval: [BuIntradayScheduleData]?, performancePredictionDataSummary: IntradayPerformancePredictionData?, performancePredictionDataPerInterval: [IntradayPerformancePredictionData]?) {
        self.mediaType = mediaType
        self.forecastDataSummary = forecastDataSummary
        self.forecastDataPerInterval = forecastDataPerInterval
        self.scheduleDataSummary = scheduleDataSummary
        self.scheduleDataPerInterval = scheduleDataPerInterval
        self.performancePredictionDataSummary = performancePredictionDataSummary
        self.performancePredictionDataPerInterval = performancePredictionDataPerInterval
    }


}




public class BuListAlternativeShiftTradesResponse: Codable {





    /** The asynchronous job handling the request. Null if result returns synchronously */
    public var job: BuAlternativeShiftJobResponse?
    /** The result of the request. May come via notification. Null if job is populated */
    public var result: AlternativeShiftTradeListing?

    public init(job: BuAlternativeShiftJobResponse?, result: AlternativeShiftTradeListing?) {
        self.job = job
        self.result = result
    }


}




public class BuNotificationSettingsResponse: Codable {



    /** Schedule notification settings */
    public var scheduling: BuScheduleNotificationsSettingsResponse?

    public init(scheduling: BuScheduleNotificationsSettingsResponse?) {
        self.scheduling = scheduling
    }


}




public class BuQueryAdherenceExplanationsResponse: Codable {







    /** The asynchronous job handling the query */
    public var job: AdherenceExplanationJobReference?
    /** The result of the query. May come via notification */
    public var result: AdherenceExplanationListingBuQueryResponse?
    /** The URL from which to download the result. May come via notification */
    public var downloadUrl: String?

    public init(job: AdherenceExplanationJobReference?, result: AdherenceExplanationListingBuQueryResponse?, downloadUrl: String?) {
        self.job = job
        self.result = result
        self.downloadUrl = downloadUrl
    }


}




public class BuSchedulingSettingsResponse: Codable {




    public enum SyncTimeOffProperties: String, Codable { 
        case payableMinutes = "PayableMinutes"
    }




    public enum ActivitySmoothingType: String, Codable { 
        case reduceConcurrentActivitiesAcrossBu = "ReduceConcurrentActivitiesAcrossBu"
        case reduceConcurrentActivitiesAcrossMu = "ReduceConcurrentActivitiesAcrossMu"
        case consistentServiceLevel = "ConsistentServiceLevel"
    }



    /** Schedule generation message severity configuration */
    public var messageSeverities: [SchedulerMessageTypeSeverity]?
    /** Synchronize set of time off properties from scheduled activities to time off requests when the schedule is published. */
    public var syncTimeOffProperties: [SyncTimeOffProperties]?
    /** Configures the max percent increase and decrease of service goals for this business unit */
    public var serviceGoalImpact: WfmServiceGoalImpactSettings?
    /** Indicates whether or not per minute granularity for scheduling will be enabled for this business unit. Defaults to false. */
    public var allowWorkPlanPerMinuteGranularity: Bool?
    /** The activity smoothing type for schedule generation in this business unit */
    public var activitySmoothingType: ActivitySmoothingType?
    /** Indicates whether to provide variability in schedule generation */
    public var induceScheduleVariability: Bool?

    public init(messageSeverities: [SchedulerMessageTypeSeverity]?, syncTimeOffProperties: [SyncTimeOffProperties]?, serviceGoalImpact: WfmServiceGoalImpactSettings?, allowWorkPlanPerMinuteGranularity: Bool?, activitySmoothingType: ActivitySmoothingType?, induceScheduleVariability: Bool?) {
        self.messageSeverities = messageSeverities
        self.syncTimeOffProperties = syncTimeOffProperties
        self.serviceGoalImpact = serviceGoalImpact
        self.allowWorkPlanPerMinuteGranularity = allowWorkPlanPerMinuteGranularity
        self.activitySmoothingType = activitySmoothingType
        self.induceScheduleVariability = induceScheduleVariability
    }


}




public class BuSearchAgentSchedulesRequest: Codable {







    /** Start date of the range to search. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var startDate: Date?
    /** End date of the range to search. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var endDate: Date?
    /** IDs of the users for whose schedules to search */
    public var userIds: [String]?

    public init(startDate: Date?, endDate: Date?, userIds: [String]?) {
        self.startDate = startDate
        self.endDate = endDate
        self.userIds = userIds
    }


}




public class BuShortTermForecastWeekReference: Codable {











    /** Forecast id used in this work plan bid */
    public var _id: String?
    /** The weekDate of the short term forecast in yyyy-MM-dd format. Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd */
    public var weekDate: Date?
    /** The description of the short term forecast */
    public var _description: String?
    /** The week number used for this bid. First week starts with number 1 */
    public var weekNumber: Int?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, weekDate: Date?, _description: String?, weekNumber: Int?, selfUri: String?) {
        self._id = _id
        self.weekDate = weekDate
        self._description = _description
        self.weekNumber = weekNumber
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case weekDate
        case _description = "description"
        case weekNumber
        case selfUri
    }


}




public class BuShortTermForecastingSettings: Codable {



    /** The number of historical weeks to consider when creating a forecast. This setting is only used for legacy weighted average forecasts */
    public var defaultHistoryWeeks: Int?

    public init(defaultHistoryWeeks: Int?) {
        self.defaultHistoryWeeks = defaultHistoryWeeks
    }


}




public class BuTimeOffLimitRange: Codable {





    /** Start date of the range. The end date is determined by the size of 'limitMinutesPerDay'. Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd */
    public var startDate: Date?
    /** The list of time-off limit values in minutes per day. If 'null' is specified, then the day-specific value is cleared. Such a day will have a value of 0 */
    public var limitMinutesPerDay: [Int]?

    public init(startDate: Date?, limitMinutesPerDay: [Int]?) {
        self.startDate = startDate
        self.limitMinutesPerDay = limitMinutesPerDay
    }


}




public class BulkContactsRequest: Codable {



    public var entities: [ExternalContact]?

    public init(entities: [ExternalContact]?) {
        self.entities = entities
    }


}




public class BulkEntityErrorContactEnrichRequest: Codable {













    /** An error code for the specific error condition. */
    public var code: String?
    /** A short error message. */
    public var message: String?
    /** The HTTP Status Code for the error. */
    public var status: Int?
    /** Whether this particular error should be retried. */
    public var retryable: Bool?
    /** Additional error details for specific fields. */
    public var details: [BulkErrorDetail]?
    /** The entity body specified in the Bulk request operation that caused this error. */
    public var entity: ContactEnrichRequest?

    public init(code: String?, message: String?, status: Int?, retryable: Bool?, details: [BulkErrorDetail]?, entity: ContactEnrichRequest?) {
        self.code = code
        self.message = message
        self.status = status
        self.retryable = retryable
        self.details = details
        self.entity = entity
    }


}




public class BulkEntityErrorEntity: Codable {













    /** An error code for the specific error condition. */
    public var code: String?
    /** A short error message. */
    public var message: String?
    /** The HTTP Status Code for the error. */
    public var status: Int?
    /** Whether this particular error should be retried. */
    public var retryable: Bool?
    /** Additional error details for specific fields. */
    public var details: [BulkErrorDetail]?
    /** The entity body specified in the Bulk request operation that caused this error. */
    public var entity: Entity?

    public init(code: String?, message: String?, status: Int?, retryable: Bool?, details: [BulkErrorDetail]?, entity: Entity?) {
        self.code = code
        self.message = message
        self.status = status
        self.retryable = retryable
        self.details = details
        self.entity = entity
    }


}




public class BulkFetchOrganizationsResponse: Codable {







    /** A list of results for all of the Bulk operations specified in the request. Includes both successes and failures. Ordering is NOT guaranteed - may be in a different order from the request. */
    public var results: [BulkResponseResultExternalOrganizationEntityBulkEntityErrorEntity]?
    /** The number of failed operations in the results. */
    public var errorCount: Int?
    /** The indexes of all failed operations in the results field. */
    public var errorIndexes: [Int]?

    public init(results: [BulkResponseResultExternalOrganizationEntityBulkEntityErrorEntity]?, errorCount: Int?, errorIndexes: [Int]?) {
        self.results = results
        self.errorCount = errorCount
        self.errorIndexes = errorIndexes
    }


}




public class BulkJobTerminateResultEntity: Codable {





    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, selfUri: String?) {
        self._id = _id
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
    }


}




public class BulkJobTerminateResultsResponse: Codable {







    /** A list of the results from the bulk operation. */
    public var results: [BulkJobTerminateResult]?
    /** The number of errors from the bulk operation. */
    public var errorCount: Int?
    /** An index of where the errors are in the listing. */
    public var errorIndexes: [Int]?

    public init(results: [BulkJobTerminateResult]?, errorCount: Int?, errorIndexes: [Int]?) {
        self.results = results
        self.errorCount = errorCount
        self.errorIndexes = errorIndexes
    }


}




public class BulkNotesRequest: Codable {



    public var entities: [Note]?

    public init(entities: [Note]?) {
        self.entities = entities
    }


}




public class BulkOrganizationsResponse: Codable {







    /** A list of results for all of the Bulk operations specified in the request. Includes both successes and failures. Ordering is NOT guaranteed - may be in a different order from the request. */
    public var results: [BulkResponseResultExternalOrganizationExternalOrganizationBulkEntityErrorExternalOrganization]?
    /** The number of failed operations in the results. */
    public var errorCount: Int?
    /** The indexes of all failed operations in the results field. */
    public var errorIndexes: [Int]?

    public init(results: [BulkResponseResultExternalOrganizationExternalOrganizationBulkEntityErrorExternalOrganization]?, errorCount: Int?, errorIndexes: [Int]?) {
        self.results = results
        self.errorCount = errorCount
        self.errorIndexes = errorIndexes
    }


}




public class BulkRelationshipsRequest: Codable {



    public var entities: [Relationship]?

    public init(entities: [Relationship]?) {
        self.entities = entities
    }


}




public class BulkResponseResultExternalContactExternalContactBulkEntityErrorExternalContact: Codable {









    /** The id associated with this operation. For Bulk Enrich, this id is specified in the request; for all other Bulk endpoints, this id is the id of the affected entity. */
    public var _id: String?
    /** Whether the requested operation completed successfully. */
    public var success: Bool?
    /** The entity which was affected by this Bulk operation. Only returned on success. */
    public var entity: ExternalContact?
    /** An error describing why this Bulk operation failed. Only returned on failure. */
    public var error: BulkEntityErrorExternalContact?

    public init(_id: String?, success: Bool?, entity: ExternalContact?, error: BulkEntityErrorExternalContact?) {
        self._id = _id
        self.success = success
        self.entity = entity
        self.error = error
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case success
        case entity
        case error
    }


}




public class BulkResponseResultExternalOrganizationEntityBulkEntityErrorEntity: Codable {









    /** The id associated with this operation. For Bulk Enrich, this id is specified in the request; for all other Bulk endpoints, this id is the id of the affected entity. */
    public var _id: String?
    /** Whether the requested operation completed successfully. */
    public var success: Bool?
    /** The entity which was affected by this Bulk operation. Only returned on success. */
    public var entity: ExternalOrganization?
    /** An error describing why this Bulk operation failed. Only returned on failure. */
    public var error: BulkEntityErrorEntity?

    public init(_id: String?, success: Bool?, entity: ExternalOrganization?, error: BulkEntityErrorEntity?) {
        self._id = _id
        self.success = success
        self.entity = entity
        self.error = error
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case success
        case entity
        case error
    }


}




public class BulkResponseResultNoteNoteBulkEntityErrorNote: Codable {









    /** The id associated with this operation. For Bulk Enrich, this id is specified in the request; for all other Bulk endpoints, this id is the id of the affected entity. */
    public var _id: String?
    /** Whether the requested operation completed successfully. */
    public var success: Bool?
    /** The entity which was affected by this Bulk operation. Only returned on success. */
    public var entity: Note?
    /** An error describing why this Bulk operation failed. Only returned on failure. */
    public var error: BulkEntityErrorNote?

    public init(_id: String?, success: Bool?, entity: Note?, error: BulkEntityErrorNote?) {
        self._id = _id
        self.success = success
        self.entity = entity
        self.error = error
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case success
        case entity
        case error
    }


}




public class BulkResponseResultRelationshipRelationshipBulkEntityErrorRelationship: Codable {









    /** The id associated with this operation. For Bulk Enrich, this id is specified in the request; for all other Bulk endpoints, this id is the id of the affected entity. */
    public var _id: String?
    /** Whether the requested operation completed successfully. */
    public var success: Bool?
    /** The entity which was affected by this Bulk operation. Only returned on success. */
    public var entity: Relationship?
    /** An error describing why this Bulk operation failed. Only returned on failure. */
    public var error: BulkEntityErrorRelationship?

    public init(_id: String?, success: Bool?, entity: Relationship?, error: BulkEntityErrorRelationship?) {
        self._id = _id
        self.success = success
        self.entity = entity
        self.error = error
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case success
        case entity
        case error
    }


}




public class BusinessUnitActivityCode: Codable {









    public enum Category: String, Codable { 
        case onQueueWork = "OnQueueWork"
        case _break = "Break"
        case meal = "Meal"
        case meeting = "Meeting"
        case offQueueWork = "OffQueueWork"
        case timeOff = "TimeOff"
        case training = "Training"
        case unavailable = "Unavailable"
    }























    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** Whether this activity code is active or has been deleted */
    public var active: Bool?
    /** Whether this is a default activity code */
    public var defaultCode: Bool?
    /** The category of the activity code */
    public var category: Category?
    /** The default length of the activity in minutes */
    public var lengthInMinutes: Int?
    /** Whether an agent is paid while performing this activity */
    public var countsAsPaidTime: Bool?
    /** Indicates whether or not the activity should be counted as contiguous work time for calculating daily constraints */
    public var countsAsWorkTime: Bool?
    /** Whether an agent can select this activity code when creating or editing a time off request. Null if the activity's category is not time off. */
    public var agentTimeOffSelectable: Bool?
    /** Whether or not this activity code counts toward shrinkage calculations */
    public var countsTowardShrinkage: Bool?
    /** Whether this activity code is considered planned or unplanned shrinkage */
    public var plannedShrinkage: Bool?
    /** Whether this activity code is considered interruptible */
    public var interruptible: Bool?
    /** The secondary presences of this activity code */
    public var secondaryPresences: [SecondaryPresence]?
    /** Planning groups associated with this activity code */
    public var planningGroups: [PlanningGroupReference]?
    /** Version metadata of this activity code */
    public var metadata: WfmVersionedEntityMetadata?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, active: Bool?, defaultCode: Bool?, category: Category?, lengthInMinutes: Int?, countsAsPaidTime: Bool?, countsAsWorkTime: Bool?, agentTimeOffSelectable: Bool?, countsTowardShrinkage: Bool?, plannedShrinkage: Bool?, interruptible: Bool?, secondaryPresences: [SecondaryPresence]?, planningGroups: [PlanningGroupReference]?, metadata: WfmVersionedEntityMetadata?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.active = active
        self.defaultCode = defaultCode
        self.category = category
        self.lengthInMinutes = lengthInMinutes
        self.countsAsPaidTime = countsAsPaidTime
        self.countsAsWorkTime = countsAsWorkTime
        self.agentTimeOffSelectable = agentTimeOffSelectable
        self.countsTowardShrinkage = countsTowardShrinkage
        self.plannedShrinkage = plannedShrinkage
        self.interruptible = interruptible
        self.secondaryPresences = secondaryPresences
        self.planningGroups = planningGroups
        self.metadata = metadata
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case active
        case defaultCode
        case category
        case lengthInMinutes
        case countsAsPaidTime
        case countsAsWorkTime
        case agentTimeOffSelectable
        case countsTowardShrinkage
        case plannedShrinkage
        case interruptible
        case secondaryPresences
        case planningGroups
        case metadata
        case selfUri
    }


}




public class BusinessUnitActivityCodeListing: Codable {





    public var entities: [BusinessUnitActivityCode]?
    /** URL from which to fetch results for requests with a large result set. If populated, the downloaded data will conform to the same schema as would normally be returned, excepting downloaded data will never itself contain a downloadUrl */
    public var downloadUrl: String?

    public init(entities: [BusinessUnitActivityCode]?, downloadUrl: String?) {
        self.entities = entities
        self.downloadUrl = downloadUrl
    }


}




public class CachedMediaItemEntityListing: Codable {





















    public var entities: [CachedMediaItem]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var previousUri: String?
    public var nextUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [CachedMediaItem]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, previousUri: String?, nextUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.previousUri = previousUri
        self.nextUri = nextUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class CalibrationCreate: Codable {

































    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    public var calibrator: User?
    public var agent: User?
    /** The conversation to use for the calibration. */
    public var conversation: ConversationReference?
    public var evaluationForm: EvaluationForm?
    public var contextId: String?
    public var averageScore: Int?
    public var highScore: Int?
    public var lowScore: Int?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var createdDate: Date?
    public var evaluations: [Evaluation]?
    public var evaluators: [User]?
    public var scoringIndex: Evaluation?
    public var expertEvaluator: User?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, calibrator: User?, agent: User?, conversation: ConversationReference?, evaluationForm: EvaluationForm?, contextId: String?, averageScore: Int?, highScore: Int?, lowScore: Int?, createdDate: Date?, evaluations: [Evaluation]?, evaluators: [User]?, scoringIndex: Evaluation?, expertEvaluator: User?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.calibrator = calibrator
        self.agent = agent
        self.conversation = conversation
        self.evaluationForm = evaluationForm
        self.contextId = contextId
        self.averageScore = averageScore
        self.highScore = highScore
        self.lowScore = lowScore
        self.createdDate = createdDate
        self.evaluations = evaluations
        self.evaluators = evaluators
        self.scoringIndex = scoringIndex
        self.expertEvaluator = expertEvaluator
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case calibrator
        case agent
        case conversation
        case evaluationForm
        case contextId
        case averageScore
        case highScore
        case lowScore
        case createdDate
        case evaluations
        case evaluators
        case scoringIndex
        case expertEvaluator
        case selfUri
    }


}




public class CallHistoryConversation: Codable {







    public enum Direction: String, Codable { 
        case inbound = "inbound"
        case outbound = "outbound"
    }



















    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** The list of participants involved in the conversation. */
    public var participants: [CallHistoryParticipant]?
    /** The direction of the call relating to the current user */
    public var direction: Direction?
    /** Did the call end in the current user's voicemail */
    public var wentToVoicemail: Bool?
    /** Did the user not answer this conversation */
    public var missedCall: Bool?
    /** The time the user joined the conversation. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var startTime: Date?
    /** Was this conversation a conference */
    public var wasConference: Bool?
    /** Was this conversation a callback */
    public var wasCallback: Bool?
    /** Did this conversation have a screen share session */
    public var hadScreenShare: Bool?
    /** Did this conversation have a cobrowse session */
    public var hadCobrowse: Bool?
    /** Was this conversation associated with an outbound campaign */
    public var wasOutboundCampaign: Bool?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, participants: [CallHistoryParticipant]?, direction: Direction?, wentToVoicemail: Bool?, missedCall: Bool?, startTime: Date?, wasConference: Bool?, wasCallback: Bool?, hadScreenShare: Bool?, hadCobrowse: Bool?, wasOutboundCampaign: Bool?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.participants = participants
        self.direction = direction
        self.wentToVoicemail = wentToVoicemail
        self.missedCall = missedCall
        self.startTime = startTime
        self.wasConference = wasConference
        self.wasCallback = wasCallback
        self.hadScreenShare = hadScreenShare
        self.hadCobrowse = hadCobrowse
        self.wasOutboundCampaign = wasOutboundCampaign
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case participants
        case direction
        case wentToVoicemail
        case missedCall
        case startTime
        case wasConference
        case wasCallback
        case hadScreenShare
        case hadCobrowse
        case wasOutboundCampaign
        case selfUri
    }


}




public class CallMediaPolicy: Codable {





    /** Actions applied when specified conditions are met */
    public var actions: PolicyActions?
    /** Conditions for when actions should be applied */
    public var conditions: CallMediaPolicyConditions?

    public init(actions: PolicyActions?, conditions: CallMediaPolicyConditions?) {
        self.actions = actions
        self.conditions = conditions
    }


}




public class CallMediaPolicyConditions: Codable {















    public enum Directions: String, Codable { 
        case inbound = "INBOUND"
        case outbound = "OUTBOUND"
    }



    /** List of users to apply this policy to. Each user object can include the 'id' field containing the user's unique identifier. Example: [{\"id\":\"<userId>\"}]. */
    public var forUsers: [PolicyUser]?
    public var dateRanges: [String]?
    public var forQueues: [Queue]?
    public var wrapupCodes: [WrapupCode]?
    public var languages: [Language]?
    public var timeAllowed: TimeAllowed?
    /** Teams to match conversations against */
    public var teams: [Team]?
    public var directions: [Directions]?
    public var duration: DurationCondition?

    public init(forUsers: [PolicyUser]?, dateRanges: [String]?, forQueues: [Queue]?, wrapupCodes: [WrapupCode]?, languages: [Language]?, timeAllowed: TimeAllowed?, teams: [Team]?, directions: [Directions]?, duration: DurationCondition?) {
        self.forUsers = forUsers
        self.dateRanges = dateRanges
        self.forQueues = forQueues
        self.wrapupCodes = wrapupCodes
        self.languages = languages
        self.timeAllowed = timeAllowed
        self.teams = teams
        self.directions = directions
        self.duration = duration
    }


}




public class CallableContactsDiagnostic: Codable {









    /** Attempt limits for the campaign's contact list */
    public var attemptLimits: DomainEntityRef?
    /** Do not call lists for the campaign */
    public var dncLists: [DomainEntityRef]?
    /** Callable time sets for the campaign */
    public var callableTimeSet: DomainEntityRef?
    /** Rule sets for the campaign */
    public var ruleSets: [DomainEntityRef]?

    public init(attemptLimits: DomainEntityRef?, dncLists: [DomainEntityRef]?, callableTimeSet: DomainEntityRef?, ruleSets: [DomainEntityRef]?) {
        self.attemptLimits = attemptLimits
        self.dncLists = dncLists
        self.callableTimeSet = callableTimeSet
        self.ruleSets = ruleSets
    }


}




public class CampaignDiagnostics: Codable {





























    /** Campaign properties that can impact which contacts are callable */
    public var callableContacts: CallableContactsDiagnostic?
    /** Information regarding the campaign's queue */
    public var queueUtilizationDiagnostic: QueueUtilizationDiagnostic?
    /** Information regarding the campaign's rule sets */
    public var ruleSetDiagnostics: [RuleSetDiagnostic]?
    /** Current number of outstanding interactions on the campaign */
    public var outstandingInteractionsCount: Int?
    /** Current number of scheduled interactions on the campaign */
    public var scheduledInteractionsCount: Int?
    /** Current number of time zone rescheduled calls on the campaign */
    public var timeZoneRescheduledCallsCount: Int?
    /** Number of contacts that don't match filter. This is currently supported only for Campaigns with dynamic filter on. */
    public var filteredOutContactsCount: Int?
    /** Information regarding the campaign's available agents. */
    public var idleAgents: Int?
    /** Information regarding the campaign's effective available agents. */
    public var effectiveIdleAgents: Double?
    /** Information on the campaign's lines utilization. */
    public var linesUtilization: CampaignLinesUtilization?
    /** Number of contacts called during the campaign. */
    public var numberOfContactsCalled: Int64?
    /** Total number of contacts in the campaign. */
    public var totalNumberOfContacts: Int64?
    /** A list of current error conditions associated with the campaign. */
    public var campaignErrors: [RestErrorDetail]?
    /** Information regarding the campaign's skills */
    public var campaignSkillStatistics: CampaignSkillStatistics?

    public init(callableContacts: CallableContactsDiagnostic?, queueUtilizationDiagnostic: QueueUtilizationDiagnostic?, ruleSetDiagnostics: [RuleSetDiagnostic]?, outstandingInteractionsCount: Int?, scheduledInteractionsCount: Int?, timeZoneRescheduledCallsCount: Int?, filteredOutContactsCount: Int?, idleAgents: Int?, effectiveIdleAgents: Double?, linesUtilization: CampaignLinesUtilization?, numberOfContactsCalled: Int64?, totalNumberOfContacts: Int64?, campaignErrors: [RestErrorDetail]?, campaignSkillStatistics: CampaignSkillStatistics?) {
        self.callableContacts = callableContacts
        self.queueUtilizationDiagnostic = queueUtilizationDiagnostic
        self.ruleSetDiagnostics = ruleSetDiagnostics
        self.outstandingInteractionsCount = outstandingInteractionsCount
        self.scheduledInteractionsCount = scheduledInteractionsCount
        self.timeZoneRescheduledCallsCount = timeZoneRescheduledCallsCount
        self.filteredOutContactsCount = filteredOutContactsCount
        self.idleAgents = idleAgents
        self.effectiveIdleAgents = effectiveIdleAgents
        self.linesUtilization = linesUtilization
        self.numberOfContactsCalled = numberOfContactsCalled
        self.totalNumberOfContacts = totalNumberOfContacts
        self.campaignErrors = campaignErrors
        self.campaignSkillStatistics = campaignSkillStatistics
    }


}




public class CampaignPerformanceDataProgress: Codable {



    /** Percentage of contacts processed during the campaign */
    public var percentage: Double?

    public init(percentage: Double?) {
        self.percentage = percentage
    }


}




public class CampaignRuleAction: Codable {





    public enum ActionType: String, Codable { 
        case turnoncampaign = "turnOnCampaign"
        case turnoffcampaign = "turnOffCampaign"
        case turnonsequence = "turnOnSequence"
        case turnoffsequence = "turnOffSequence"
        case setcampaignpriority = "setCampaignPriority"
        case recyclecampaign = "recycleCampaign"
        case setcampaigndialingmode = "setCampaignDialingMode"
        case setcampaignabandonrate = "setCampaignAbandonRate"
        case setcampaignnumberoflines = "setCampaignNumberOfLines"
        case setcampaignweight = "setCampaignWeight"
        case setcampaignmaxcallsperagent = "setCampaignMaxCallsPerAgent"
        case setcampaignmessagesperminute = "setCampaignMessagesPerMinute"
        case changecampaignqueue = "changeCampaignQueue"
        case changecampaigntemplate = "changeCampaignTemplate"
    }



    public var _id: String?
    /** The parameters for the CampaignRuleAction. Required for certain actionTypes. */
    public var parameters: CampaignRuleParameters?
    /** The action to take on the campaignRuleActionEntities. */
    public var actionType: ActionType?
    /** The list of entities that this action will apply to. */
    public var campaignRuleActionEntities: CampaignRuleActionEntities?

    public init(_id: String?, parameters: CampaignRuleParameters?, actionType: ActionType?, campaignRuleActionEntities: CampaignRuleActionEntities?) {
        self._id = _id
        self.parameters = parameters
        self.actionType = actionType
        self.campaignRuleActionEntities = campaignRuleActionEntities
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case parameters
        case actionType
        case campaignRuleActionEntities
    }


}




public class CampaignRuleWarning: Codable {

    public enum Code: String, Codable { 
        case conditionsNoEntities = "ConditionsNoEntities"
        case conditionsNoSequences = "ConditionsNoSequences"
        case conditionsNoCampaigns = "ConditionsNoCampaigns"
        case conditionsNoMessagingCampaigns = "ConditionsNoMessagingCampaigns"
        case actionNoEntities = "ActionNoEntities"
        case actionNoSequences = "ActionNoSequences"
        case actionNoCampaigns = "ActionNoCampaigns"
        case actionNoMessagingCampaigns = "ActionNoMessagingCampaigns"
        case noQueue = "NoQueue"
        case noContentTemplates = "NoContentTemplates"
        case noSmsContentTemplate = "NoSmsContentTemplate"
        case noEmailContentTemplate = "NoEmailContentTemplate"
        case conditionsWaitingForLinesOnlyPreviewOrExternal = "ConditionsWaitingForLinesOnlyPreviewOrExternal"
        case conditionsWaitingForAgentsOnlyAgentless = "ConditionsWaitingForAgentsOnlyAgentless"
    }





    /** Warning code for this warning. */
    public var code: Code?
    /** Warning message for this warning. */
    public var message: String?
    /** Additional warning information */
    public var params: CampaignRuleWarningParameters?

    public init(code: Code?, message: String?, params: CampaignRuleWarningParameters?) {
        self.code = code
        self.message = message
        self.params = params
    }


}




public class CapacityPlanDeleteRequest: Codable {



    /** The IDs of the capacity plans to be deleted */
    public var capacityPlanIds: [String]?

    public init(capacityPlanIds: [String]?) {
        self.capacityPlanIds = capacityPlanIds
    }


}




public class CapacityPlanRequest: Codable {















    /** The name of the capacity plan */
    public var name: String?
    /** Description of the capacity plan */
    public var _description: String?
    /** The start date for the capacity plan relative to the business unit time zone in yyyy-MM-dd format. Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd */
    public var startBusinessUnitDate: Date?
    /** The end date for the capacity plan relative to the business unit time zone in yyyy-MM-dd format. Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd */
    public var endBusinessUnitDate: Date?
    /** The selected forecast for this capacity plan. Null when main forecast is used in the future */
    public var forecast: BuShortTermForecastReference?
    /** The weekly hours used to calculate full time equivalent agents */
    public var fullTimeEquivalentWeeklyHours: Double?
    /** List of staffing group allocations to be used for the capacity plan */
    public var staffingGroupAllocations: [CreateStaffingGroupAllocation]?

    public init(name: String?, _description: String?, startBusinessUnitDate: Date?, endBusinessUnitDate: Date?, forecast: BuShortTermForecastReference?, fullTimeEquivalentWeeklyHours: Double?, staffingGroupAllocations: [CreateStaffingGroupAllocation]?) {
        self.name = name
        self._description = _description
        self.startBusinessUnitDate = startBusinessUnitDate
        self.endBusinessUnitDate = endBusinessUnitDate
        self.forecast = forecast
        self.fullTimeEquivalentWeeklyHours = fullTimeEquivalentWeeklyHours
        self.staffingGroupAllocations = staffingGroupAllocations
    }

    public enum CodingKeys: String, CodingKey { 
        case name
        case _description = "description"
        case startBusinessUnitDate
        case endBusinessUnitDate
        case forecast
        case fullTimeEquivalentWeeklyHours
        case staffingGroupAllocations
    }


}




public class CapacityPlanStaffingGroupAllocationsResponse: Codable {









    /** The capacity plan to which the staffing groups belong */
    public var capacityPlan: CapacityPlanReference?
    /** The weekly hours used to calculate full time equivalent agents */
    public var fullTimeEquivalentWeeklyHours: Double?
    /** The URL to download the staffing group allocations */
    public var downloadUrl: String?
    /** Staffing groups allocation results always come through downloadUrl, the schema included here is just for documentation */
    public var downloadTemplate: StaffingGroupAllocationsResponseTemplate?

    public init(capacityPlan: CapacityPlanReference?, fullTimeEquivalentWeeklyHours: Double?, downloadUrl: String?, downloadTemplate: StaffingGroupAllocationsResponseTemplate?) {
        self.capacityPlan = capacityPlan
        self.fullTimeEquivalentWeeklyHours = fullTimeEquivalentWeeklyHours
        self.downloadUrl = downloadUrl
        self.downloadTemplate = downloadTemplate
    }


}




public class CapacityPlanStaffingGroupMetricChangeHistoryListResponse: Codable {



    public var entities: [StaffingGroupMetricChangeResponse]?

    public init(entities: [StaffingGroupMetricChangeResponse]?) {
        self.entities = entities
    }


}



/** A card action that a user can take. */

public class CardAction: Codable {

    public enum ModelType: String, Codable { 
        case link = "Link"
        case postback = "Postback"
    }









    /** Describes the type of action. */
    public var type: ModelType?
    /** The response text from the button click. */
    public var text: String?
    /** Content of the textback payload after clicking a button. */
    public var payload: String?
    /** The location of the image file associated with action. */
    public var url: String?
    /** Indicates if the card option is selected by end customer. */
    public var isSelected: Bool?

    public init(type: ModelType?, text: String?, payload: String?, url: String?, isSelected: Bool?) {
        self.type = type
        self.text = text
        self.payload = payload
        self.url = url
        self.isSelected = isSelected
    }


}




public class CategoriesFilter: Codable {



    /** A list of categories to filter by. Articles matching any of the specified categories can be accessed. */
    public var entities: [CategoryEntity]?

    public init(entities: [CategoryEntity]?) {
        self.entities = entities
    }


}




public class CertificateAuthorityEntityListing: Codable {





















    public var entities: [DomainCertificateAuthority]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var previousUri: String?
    public var nextUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [DomainCertificateAuthority]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, previousUri: String?, nextUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.previousUri = previousUri
        self.nextUri = nextUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class ChannelEntityListing: Codable {



    public var entities: [Channel]?

    public init(entities: [Channel]?) {
        self.entities = entities
    }


}




public class Chat: Codable {



    public var jabberId: String?

    public init(jabberId: String?) {
        self.jabberId = jabberId
    }


}




public class ChatConversation: Codable {



















    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** The list of participants involved in the conversation. */
    public var participants: [ChatMediaParticipant]?
    /** The list of other media channels involved in the conversation. */
    public var otherMediaUris: [String]?
    /** The list of the most recent 20 transfer commands applied to this conversation. */
    public var recentTransfers: [TransferResponse]?
    /** An optional label that categorizes the conversation.  Max-utilization settings can be configured at a per-label level */
    public var utilizationLabelId: String?
    /** The time in the future, after which this conversation would be considered inactive. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var inactivityTimeout: Date?
    /** Identifiers of divisions associated with this conversation. */
    public var divisions: [ConversationDivisionMembership]?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, participants: [ChatMediaParticipant]?, otherMediaUris: [String]?, recentTransfers: [TransferResponse]?, utilizationLabelId: String?, inactivityTimeout: Date?, divisions: [ConversationDivisionMembership]?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.participants = participants
        self.otherMediaUris = otherMediaUris
        self.recentTransfers = recentTransfers
        self.utilizationLabelId = utilizationLabelId
        self.inactivityTimeout = inactivityTimeout
        self.divisions = divisions
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case participants
        case otherMediaUris
        case recentTransfers
        case utilizationLabelId
        case inactivityTimeout
        case divisions
        case selfUri
    }


}




public class ChatSendMessageResponse: Codable {



    /** The id of the created message */
    public var _id: String?

    public init(_id: String?) {
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
    }


}




public class ChatUserRef: Codable {















    public var _id: String?
    public var name: String?
    public var selfUri: String?
    public var jid: String?
    public var inactive: Bool?
    public var integrations: [Contact]?
    public var presence: ChatPresence?

    public init(_id: String?, name: String?, selfUri: String?, jid: String?, inactive: Bool?, integrations: [Contact]?, presence: ChatPresence?) {
        self._id = _id
        self.name = name
        self.selfUri = selfUri
        self.jid = jid
        self.inactive = inactive
        self.integrations = integrations
        self.presence = presence
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case selfUri
        case jid
        case inactive
        case integrations
        case presence
    }


}




public class ClientUsageQueryResponse: Codable {









    /** The jobId of the query. */
    public var _id: String?
    public var name: String?
    /** The uri to get the results. */
    public var resultsUri: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, resultsUri: String?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.resultsUri = resultsUri
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case resultsUri
        case selfUri
    }


}




public class ClonedUserEntityListing: Codable {







    public var total: Int64?
    public var entities: [ClonedUser]?
    public var selfUri: String?

    public init(total: Int64?, entities: [ClonedUser]?, selfUri: String?) {
        self.total = total
        self.entities = entities
        self.selfUri = selfUri
    }


}




public class CoachingAnnotationList: Codable {





















    public var entities: [CoachingAnnotation]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var previousUri: String?
    public var nextUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [CoachingAnnotation]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, previousUri: String?, nextUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.previousUri = previousUri
        self.nextUri = nextUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class CoachingSlot: Codable {







    public enum DifferenceRating: String, Codable { 
        case poor = "Poor"
        case neutral = "Neutral"
        case good = "Good"
    }



    /** Start date and time of scheduled coaching appointment slot. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateStart: Date?
    /** Length of coaching appointment slot in minutes */
    public var lengthInMinutes: Int?
    /** Difference between scheduled and forecast headcount for this slot after scheduling the coaching appointment */
    public var staffingDifference: Double?
    /** Rating based on the staffing difference for scheduled slot */
    public var differenceRating: DifferenceRating?
    /** Workforce Management schedule information associated with the slot */
    public var wfmSchedule: WfmScheduleReference?

    public init(dateStart: Date?, lengthInMinutes: Int?, staffingDifference: Double?, differenceRating: DifferenceRating?, wfmSchedule: WfmScheduleReference?) {
        self.dateStart = dateStart
        self.lengthInMinutes = lengthInMinutes
        self.staffingDifference = staffingDifference
        self.differenceRating = differenceRating
        self.wfmSchedule = wfmSchedule
    }


}




public class CoachingAppointmentReference: Codable {





    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, selfUri: String?) {
        self._id = _id
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
    }


}




public class CoachingAppointmentStatusResponse: Codable {







    public enum Status: String, Codable { 
        case scheduled = "Scheduled"
        case inProgress = "InProgress"
        case completed = "Completed"
        case invalidSchedule = "InvalidSchedule"
    }

    /** The coaching appointment this status belongs to */
    public var appointment: CoachingAppointmentReference?
    /** User who updated the status */
    public var createdBy: UserReference?
    /** Creation time of the status. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** The status of the coaching appointment */
    public var status: Status?

    public init(appointment: CoachingAppointmentReference?, createdBy: UserReference?, dateCreated: Date?, status: Status?) {
        self.appointment = appointment
        self.createdBy = createdBy
        self.dateCreated = dateCreated
        self.status = status
    }


}




public class CoachingSlotsRequest: Codable {











    /** Range of time to get slots for scheduling coaching appointments. Intervals are represented as an ISO-8601 string. For example: YYYY-MM-DDThh:mm:ss/YYYY-MM-DDThh:mm:ss */
    public var interval: String?
    /** The duration of coaching appointment to schedule in 15 minutes granularity up to maximum of 60 minutes */
    public var lengthInMinutes: Int?
    /** List of attendees to determine coaching appointment slots */
    public var attendeeIds: [String]?
    /** List of facilitators to determine coaching appointment slots */
    public var facilitatorIds: [String]?
    /** List of appointment ids to exclude from consideration when determining blocked slots */
    public var interruptibleAppointmentIds: [String]?

    public init(interval: String?, lengthInMinutes: Int?, attendeeIds: [String]?, facilitatorIds: [String]?, interruptibleAppointmentIds: [String]?) {
        self.interval = interval
        self.lengthInMinutes = lengthInMinutes
        self.attendeeIds = attendeeIds
        self.facilitatorIds = facilitatorIds
        self.interruptibleAppointmentIds = interruptibleAppointmentIds
    }


}




public class CollaborateChatAdhocMessageEventTopicCollaborateChatEntity: Codable {





    public enum EntityType: String, Codable { 
        case group = "Group"
        case user = "User"
        case adhoc = "Adhoc"
    }

    public var entityJid: String?
    public var entityId: String?
    public var entityType: EntityType?

    public init(entityJid: String?, entityId: String?, entityType: EntityType?) {
        self.entityJid = entityJid
        self.entityId = entityId
        self.entityType = entityType
    }


}




public class CommandStatusEntityListing: Codable {





















    public var entities: [CommandStatus]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var previousUri: String?
    public var nextUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [CommandStatus]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, previousUri: String?, nextUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.previousUri = previousUri
        self.nextUri = nextUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class CommonCampaignEntityListing: Codable {





















    public var entities: [CommonCampaign]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var previousUri: String?
    public var nextUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [CommonCampaign]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, previousUri: String?, nextUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.previousUri = previousUri
        self.nextUri = nextUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class CommonRuleBulkUpdateNotificationsRequest: Codable {






    public enum TypesToAdd: String, Codable { 
        case sms = "Sms"
        case device = "Device"
        case email = "Email"
        case push = "Push"
    }

    public enum TypesToRemove: String, Codable { 
        case sms = "Sms"
        case device = "Device"
        case email = "Email"
        case push = "Push"
    }
    /** The user supplied rules ids to be updated */
    public var ruleIds: [String]?
    /** The rule properties to be updated */
    public var properties: ModifiableRuleProperties?
    /** Collection of alerting notification types to add for all entities in the rules */
    public var typesToAdd: [TypesToAdd]?
    /** Collection of alerting notification types to remove for all entities in the rules */
    public var typesToRemove: [TypesToRemove]?

    public init(ruleIds: [String]?, properties: ModifiableRuleProperties?, typesToAdd: [TypesToAdd]?, typesToRemove: [TypesToRemove]?) {
        self.ruleIds = ruleIds
        self.properties = properties
        self.typesToAdd = typesToAdd
        self.typesToRemove = typesToRemove
    }


}




public class Compliance: Codable {







    /** List of configurations for 'StopSettings' compliance */
    public var stopSettings: [StopSettings]?
    /** List of configurations for 'OptInSettings' compliance */
    public var optInSettings: [OptInSettings]?
    /** List of configurations for 'HelpSettings' compliance */
    public var helpSettings: [HelpSettings]?

    public init(stopSettings: [StopSettings]?, optInSettings: [OptInSettings]?, helpSettings: [HelpSettings]?) {
        self.stopSettings = stopSettings
        self.optInSettings = optInSettings
        self.helpSettings = helpSettings
    }


}




public class ConditionalGroupRouting: Codable {



    /** The set of rules to be executed for each conversation */
    public var rules: [ConditionalGroupRoutingRule]?

    public init(rules: [ConditionalGroupRoutingRule]?) {
        self.rules = rules
    }


}




public class ConfusionInfo: Codable {



    /** Confusion details between this utterance and other intents. */
    public var intents: [ConfusionIntentInfo]?

    public init(intents: [ConfusionIntentInfo]?) {
        self.intents = intents
    }


}




public class ConfusionIntentDetails: Codable {











    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** Number of utterances in this intent which are similar to parent utterance. */
    public var utteranceCount: Int?
    /** List of utterance which are similar to parent utterance. */
    public var utterances: [ConfusionUtterance]?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, utteranceCount: Int?, utterances: [ConfusionUtterance]?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.utteranceCount = utteranceCount
        self.utterances = utterances
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case utteranceCount
        case utterances
        case selfUri
    }


}




public class ConsumingResourcesEntityListing: Codable {





















    public var entities: [Dependency]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var previousUri: String?
    public var nextUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [Dependency]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, previousUri: String?, nextUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.previousUri = previousUri
        self.nextUri = nextUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class ContactBulkEditRequest: Codable {











    /** Contact List Filter ID. */
    public var contactListFilterId: String?
    /** Criteria to filter the contacts by. */
    public var criteria: ContactBulkSearchCriteria?
    /** Contact IDs to be bulk edited. */
    public var contactIds: [String]?
    /** Contact object with details of fields used for patching. */
    public var contact: DialerContact?
    /** Whether to do backup export as part of Bulk Operation or not. Default: true. */
    public var generateDownloadURI: Bool?

    public init(contactListFilterId: String?, criteria: ContactBulkSearchCriteria?, contactIds: [String]?, contact: DialerContact?, generateDownloadURI: Bool?) {
        self.contactListFilterId = contactListFilterId
        self.criteria = criteria
        self.contactIds = contactIds
        self.contact = contact
        self.generateDownloadURI = generateDownloadURI
    }


}




public class ContactCenterSettings: Codable {



    /** Strip skills from transfer */
    public var removeSkillsFromBlindTransfer: Bool?

    public init(removeSkillsFromBlindTransfer: Bool?) {
        self.removeSkillsFromBlindTransfer = removeSkillsFromBlindTransfer
    }


}




public class ContactColumnTimeZone: Codable {



    public enum ColumnType: String, Codable { 
        case phone = "PHONE"
        case zip = "ZIP"
    }

    /** Time zone that the column matched to. Time zones are represented as a string of the zone name as found in the IANA time zone database. For example: UTC, Etc/UTC, or Europe/London */
    public var timeZone: String?
    /** Column Type will be either PHONE or ZIP */
    public var columnType: ColumnType?

    public init(timeZone: String?, columnType: ColumnType?) {
        self.timeZone = timeZone
        self.columnType = columnType
    }


}




public class ContactImportJobRequest: Codable {





    /** Settings id */
    public var settingsId: String?
    /** The division to import into */
    public var division: WritableStarrableDivision?

    public init(settingsId: String?, division: WritableStarrableDivision?) {
        self.settingsId = settingsId
        self.division = division
    }


}




public class ContactImportJobStatusUpdateRequest: Codable {



    public enum Status: String, Codable { 
        case _continue = "Continue"
        case cancel = "Cancel"
        case retry = "Retry"
    }

    /** Job Id */
    public var jobId: String?
    /** Workflow status */
    public var status: Status?

    public init(jobId: String?, status: Status?) {
        self.jobId = jobId
        self.status = status
    }


}




public class ContactListFilterEntityListing: Codable {





















    public var entities: [ContactListFilter]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var previousUri: String?
    public var nextUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [ContactListFilter]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, previousUri: String?, nextUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.previousUri = previousUri
        self.nextUri = nextUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class ContactableStatus: Codable {





    /** Indicates whether or not the entire contact is contactable for the associated media type. */
    public var contactable: Bool?
    /** A map of individual contact method columns to whether the individual column is contactable for the associated media type. */
    public var columnStatus: [String:ColumnStatus]?

    public init(contactable: Bool?, columnStatus: [String:ColumnStatus]?) {
        self.contactable = contactable
        self.columnStatus = columnStatus
    }


}



/** Button response object representing the click of a structured message button, such as a quick reply. */

public class ContentButtonResponse: Codable {



    public enum ModelType: String, Codable { 
        case button = "Button"
        case quickReply = "QuickReply"
        case datePicker = "DatePicker"
    }





    /** An ID assigned to the button response (Deprecated). */
    public var _id: String?
    /** Describes the button that resulted in the Button Response. */
    public var type: ModelType?
    /** The response text from the button click. */
    public var text: String?
    /** The response payload associated with the clicked button. */
    public var payload: String?

    public init(_id: String?, type: ModelType?, text: String?, payload: String?) {
        self._id = _id
        self.type = type
        self.text = text
        self.payload = payload
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case type
        case text
        case payload
    }


}



/** Card content object. */

public class ContentCard: Codable {













    /** Text to show in the title. */
    public var title: String?
    /** Text to show in the description. */
    public var _description: String?
    /** URL of an image. */
    public var image: String?
    /** URL of a video. */
    public var video: String?
    /** The default button action. */
    public var defaultAction: ContentCardAction?
    /** An array of action objects. */
    public var actions: [ContentCardAction]?

    public init(title: String?, _description: String?, image: String?, video: String?, defaultAction: ContentCardAction?, actions: [ContentCardAction]?) {
        self.title = title
        self._description = _description
        self.image = image
        self.video = video
        self.defaultAction = defaultAction
        self.actions = actions
    }

    public enum CodingKeys: String, CodingKey { 
        case title
        case _description = "description"
        case image
        case video
        case defaultAction
        case actions
    }


}



/** DatePicker content object. */

public class ContentDatePicker: Codable {













    /** Text to show in the title. */
    public var title: String?
    /** Text to show in the description. */
    public var subtitle: String?
    /** URL of an image */
    public var imageUrl: String?
    /** The minimum Date Enabled in the datepicker calendar. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateMinimum: Date?
    /** The maximum Date Enabled in the datepicker calendar. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateMaximum: Date?
    /** An array of available times objects. */
    public var availableTimes: [ContentDatePickerAvailableTime]?

    public init(title: String?, subtitle: String?, imageUrl: String?, dateMinimum: Date?, dateMaximum: Date?, availableTimes: [ContentDatePickerAvailableTime]?) {
        self.title = title
        self.subtitle = subtitle
        self.imageUrl = imageUrl
        self.dateMinimum = dateMinimum
        self.dateMaximum = dateMaximum
        self.availableTimes = availableTimes
    }


}




public class ContentFilterItem: Codable {



    public enum ModelType: String, Codable { 
        case number = "NUMBER"
        case string = "STRING"
        case date = "DATE"
        case boolean = "BOOLEAN"
        case list = "LIST"
    }

    public enum Operator: String, Codable { 
        case _in = "IN"
        case range = "RANGE"
        case equals = "EQUALS"
        case notequals = "NOTEQUALS"
        case lessthan = "LESSTHAN"
        case lessthanequals = "LESSTHANEQUALS"
        case greaterthan = "GREATERTHAN"
        case greaterthanequals = "GREATERTHANEQUALS"
        case contains = "CONTAINS"
    }



    public var name: String?
    public var type: ModelType?
    public var _operator: Operator?
    public var values: [String]?

    public init(name: String?, type: ModelType?, _operator: Operator?, values: [String]?) {
        self.name = name
        self.type = type
        self._operator = _operator
        self.values = values
    }

    public enum CodingKeys: String, CodingKey { 
        case name
        case type
        case _operator = "operator"
        case values
    }


}




public class ContentManagementSingleDocumentTopicDocumentDataV2: Codable {





























    public var _id: String?
    public var name: String?
    public var dateCreated: Date?
    public var dateModified: Date?
    public var workspace: ContentManagementSingleDocumentTopicWorkspaceData?
    public var createdBy: ContentManagementSingleDocumentTopicUserData?
    public var contentType: String?
    public var contentLength: Int64?
    public var filename: String?
    public var changeNumber: Int64?
    public var dateUploaded: Date?
    public var uploadedBy: ContentManagementSingleDocumentTopicUserData?
    public var lockInfo: ContentManagementSingleDocumentTopicLockData?
    public var selfUri: String?

    public init(_id: String?, name: String?, dateCreated: Date?, dateModified: Date?, workspace: ContentManagementSingleDocumentTopicWorkspaceData?, createdBy: ContentManagementSingleDocumentTopicUserData?, contentType: String?, contentLength: Int64?, filename: String?, changeNumber: Int64?, dateUploaded: Date?, uploadedBy: ContentManagementSingleDocumentTopicUserData?, lockInfo: ContentManagementSingleDocumentTopicLockData?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.workspace = workspace
        self.createdBy = createdBy
        self.contentType = contentType
        self.contentLength = contentLength
        self.filename = filename
        self.changeNumber = changeNumber
        self.dateUploaded = dateUploaded
        self.uploadedBy = uploadedBy
        self.lockInfo = lockInfo
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case dateCreated
        case dateModified
        case workspace
        case createdBy
        case contentType
        case contentLength
        case filename
        case changeNumber
        case dateUploaded
        case uploadedBy
        case lockInfo
        case selfUri
    }


}




public class ContentOffer: Codable {



    public enum DisplayMode: String, Codable { 
        case modal = "Modal"
        case overlay = "Overlay"
        case toast = "Toast"
    }

    public enum LayoutMode: String, Codable { 
        case textOnly = "TextOnly"
        case imageOnly = "ImageOnly"
        case leftText = "LeftText"
        case rightText = "RightText"
        case topText = "TopText"
        case bottomText = "BottomText"
    }













    /** URL for image displayed to the customer when displaying content offer. */
    public var imageUrl: String?
    /** The display mode of Genesys Widgets when displaying content offer. */
    public var displayMode: DisplayMode?
    /** The layout mode of the text shown to the user when displaying content offer. */
    public var layoutMode: LayoutMode?
    /** Title used in the header of the content offer. */
    public var title: String?
    /** Headline displayed above the body text of the content offer. */
    public var headline: String?
    /** Body text of the content offer. */
    public var body: String?
    /** Properties customizing the call to action button on the content offer. */
    public var callToAction: CallToAction?
    /** Properties customizing the styling of the content offer. */
    public var style: ContentOfferStylingConfiguration?
    /** Image description text for accessibility compliance and assistive technology support. */
    public var imageAltText: String?

    public init(imageUrl: String?, displayMode: DisplayMode?, layoutMode: LayoutMode?, title: String?, headline: String?, body: String?, callToAction: CallToAction?, style: ContentOfferStylingConfiguration?, imageAltText: String?) {
        self.imageUrl = imageUrl
        self.displayMode = displayMode
        self.layoutMode = layoutMode
        self.title = title
        self.headline = headline
        self.body = body
        self.callToAction = callToAction
        self.style = style
        self.imageAltText = imageAltText
    }


}




public class ContestCompleteData: Codable {



    public enum Anonymization: String, Codable { 
        case noAnonymization = "NoAnonymization"
        case all = "All"
        case allExceptTop = "AllExceptTop"
    }







    /** End date of the contest. Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd */
    public var dateEnd: Date?
    /** Anonymization of the contest */
    public var anonymization: Anonymization?
    /** Metrics of the contest */
    public var metrics: [ContestDataMetrics]?
    /** Prizes of the contest */
    public var prizes: [ContestDataPrizes]?
    /** Winners of the contest */
    public var winners: [ContestDataWinners]?

    public init(dateEnd: Date?, anonymization: Anonymization?, metrics: [ContestDataMetrics]?, prizes: [ContestDataPrizes]?, winners: [ContestDataWinners]?) {
        self.dateEnd = dateEnd
        self.anonymization = anonymization
        self.metrics = metrics
        self.prizes = prizes
        self.winners = winners
    }


}




public class ContestRequesingParticipantDailyInfo: Codable {





    /** Workday of the contest info. Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd */
    public var dateWorkday: Date?
    /** The Contest score */
    public var contestScore: ContestScoreRanked?

    public init(dateWorkday: Date?, contestScore: ContestScoreRanked?) {
        self.dateWorkday = dateWorkday
        self.contestScore = contestScore
    }


}




public class ContestScore: Codable {







    /** The Contest score */
    public var score: Double?
    /** The Contest totalPoints */
    public var totalPoints: Double?
    /** The Contest percentOfGoal */
    public var percentOfGoal: Double?

    public init(score: Double?, totalPoints: Double?, percentOfGoal: Double?) {
        self.score = score
        self.totalPoints = totalPoints
        self.percentOfGoal = percentOfGoal
    }


}




public class ContestScoresAgents: Codable {









    /** The Contest score */
    public var contestScore: ContestScoreRanked?
    /** The Contest metric scores */
    public var metricScores: [ContestMetricScoreRanked]?
    /** Indicates whether an agent is disqualified or not */
    public var disqualified: Bool?
    /** The Contest Scores Leaderboard user */
    public var user: UserReference?

    public init(contestScore: ContestScoreRanked?, metricScores: [ContestMetricScoreRanked]?, disqualified: Bool?, user: UserReference?) {
        self.contestScore = contestScore
        self.metricScores = metricScores
        self.disqualified = disqualified
        self.user = user
    }


}




public class ContestsFinalizeRequest: Codable {

    public enum Status: String, Codable { 
        case completed = "Completed"
        case cancelled = "Cancelled"
    }





    /** The Contest finalization status */
    public var status: Status?
    /** The Contest finalization winners */
    public var winners: [ContestWinnersRequest]?
    /** The Contest finalization disqualified agents */
    public var disqualifiedAgents: [ContestDisqualifiedAgents]?

    public init(status: Status?, winners: [ContestWinnersRequest]?, disqualifiedAgents: [ContestDisqualifiedAgents]?) {
        self.status = status
        self.winners = winners
        self.disqualifiedAgents = disqualifiedAgents
    }


}




public class ContractItems: Codable {





    public var type: [String]?
    public var pattern: String?

    public init(type: [String]?, pattern: String?) {
        self.type = type
        self.pattern = pattern
    }


}




public class ConversationActivityQuery: Codable {




    public enum GroupBy: String, Codable { 
        case activerouting = "activeRouting"
        case addressfrom = "addressFrom"
        case addressto = "addressTo"
        case agentscore = "agentScore"
        case ani = "ani"
        case conversationid = "conversationId"
        case convertedfrom = "convertedFrom"
        case convertedto = "convertedTo"
        case direction = "direction"
        case dnis = "dnis"
        case mediatype = "mediaType"
        case participantname = "participantName"
        case queueid = "queueId"
        case requestedlanguageid = "requestedLanguageId"
        case requestedrouting = "requestedRouting"
        case requestedroutingskillid = "requestedRoutingSkillId"
        case routingpriority = "routingPriority"
        case scoredagentid = "scoredAgentId"
        case sessionid = "sessionId"
        case teamid = "teamId"
        case usedrouting = "usedRouting"
        case userid = "userId"
    }


    public enum Order: String, Codable { 
        case asc = "asc"
        case desc = "desc"
        case unordered = "unordered"
    }

    /** List of requested metrics */
    public var metrics: [ConversationActivityQueryMetric]?
    /** Dimension(s) to group by */
    public var groupBy: [GroupBy]?
    /** Filter to return a subset of observations. Expresses boolean logical predicates as well as dimensional filters */
    public var filter: ConversationActivityQueryFilter?
    /** Sort the result set in ascending/descending order. Default is ascending */
    public var order: Order?

    public init(metrics: [ConversationActivityQueryMetric]?, groupBy: [GroupBy]?, filter: ConversationActivityQueryFilter?, order: Order?) {
        self.metrics = metrics
        self.groupBy = groupBy
        self.filter = filter
        self.order = order
    }


}




public class ConversationActivityQueryClause: Codable {

    public enum ModelType: String, Codable { 
        case and = "and"
        case or = "or"
    }



    /** Boolean operation to apply to the provided predicates */
    public var type: ModelType?
    /** Like a three-word sentence: (attribute-name) (operator) (target-value). */
    public var predicates: [ConversationActivityQueryPredicate]?

    public init(type: ModelType?, predicates: [ConversationActivityQueryPredicate]?) {
        self.type = type
        self.predicates = predicates
    }


}




public class ConversationAggregateQueryResponse: Codable {



    public var results: [ConversationAggregateDataContainer]?

    public init(results: [ConversationAggregateDataContainer]?) {
        self.results = results
    }


}




public class ConversationAggregationView: Codable {

    public enum Target: String, Codable { 
        case nblindtransferred = "nBlindTransferred"
        case nbotinteractions = "nBotInteractions"
        case ncobrowsesessions = "nCobrowseSessions"
        case nconnected = "nConnected"
        case nconsult = "nConsult"
        case nconsulttransferred = "nConsultTransferred"
        case nconversations = "nConversations"
        case nerror = "nError"
        case noffered = "nOffered"
        case noutbound = "nOutbound"
        case noutboundabandoned = "nOutboundAbandoned"
        case noutboundattempted = "nOutboundAttempted"
        case noutboundconnected = "nOutboundConnected"
        case noversla = "nOverSla"
        case nstatetransitionerror = "nStateTransitionError"
        case ntransferred = "nTransferred"
        case oaudiomessagecount = "oAudioMessageCount"
        case oexternalaudiomessagecount = "oExternalAudioMessageCount"
        case oexternalmediacount = "oExternalMediaCount"
        case omediacount = "oMediaCount"
        case omessagecount = "oMessageCount"
        case omessagesegmentcount = "oMessageSegmentCount"
        case omessageturn = "oMessageTurn"
        case oservicelevel = "oServiceLevel"
        case oservicetarget = "oServiceTarget"
        case tabandon = "tAbandon"
        case tacd = "tAcd"
        case tactivecallback = "tActiveCallback"
        case tactivecallbackcomplete = "tActiveCallbackComplete"
        case tacw = "tAcw"
        case tagentresponsetime = "tAgentResponseTime"
        case tagentvideoconnected = "tAgentVideoConnected"
        case talert = "tAlert"
        case tanswered = "tAnswered"
        case taverageagentresponsetime = "tAverageAgentResponseTime"
        case taveragecustomerresponsetime = "tAverageCustomerResponseTime"
        case tbarging = "tBarging"
        case tcoaching = "tCoaching"
        case tcoachingcomplete = "tCoachingComplete"
        case tconnected = "tConnected"
        case tcontacting = "tContacting"
        case tdialing = "tDialing"
        case tfirstconnect = "tFirstConnect"
        case tfirstdial = "tFirstDial"
        case tfirstengagement = "tFirstEngagement"
        case tfirstresponse = "tFirstResponse"
        case tflowout = "tFlowOut"
        case thandle = "tHandle"
        case theld = "tHeld"
        case theldcomplete = "tHeldComplete"
        case tivr = "tIvr"
        case tmonitoring = "tMonitoring"
        case tmonitoringcomplete = "tMonitoringComplete"
        case tnotresponding = "tNotResponding"
        case tpark = "tPark"
        case tparkcomplete = "tParkComplete"
        case tshortabandon = "tShortAbandon"
        case ttalk = "tTalk"
        case ttalkcomplete = "tTalkComplete"
        case tuserresponsetime = "tUserResponseTime"
        case tvoicemail = "tVoicemail"
        case twait = "tWait"
    }



    public enum Function: String, Codable { 
        case rangebound = "rangeBound"
    }



    /** Target metric name */
    public var target: Target?
    /** A unique name for this view. Must be distinct from other views and built-in metric names. */
    public var name: String?
    /** Type of view you wish to create */
    public var function: Function?
    /** Range of numbers for slicing up data */
    public var range: AggregationRange?

    public init(target: Target?, name: String?, function: Function?, range: AggregationRange?) {
        self.target = target
        self.name = name
        self.function = function
        self.range = range
    }


}




public class ConversationAssociation: Codable {







    public enum MediaType: String, Codable { 
        case call = "CALL"
        case callback = "CALLBACK"
        case chat = "CHAT"
        case cobrowse = "COBROWSE"
        case email = "EMAIL"
        case message = "MESSAGE"
        case internalMessage = "INTERNAL_MESSAGE"
        case socialExpression = "SOCIAL_EXPRESSION"
        case video = "VIDEO"
        case screenshare = "SCREENSHARE"
    }

    /** An external contact ID.  If not supplied, implies the conversation should be disassociated with any external contact. */
    public var externalContactId: String?
    /** Conversation ID */
    public var conversationId: String?
    /** Communication ID */
    public var communicationId: String?
    /** Media type */
    public var mediaType: MediaType?

    public init(externalContactId: String?, conversationId: String?, communicationId: String?, mediaType: MediaType?) {
        self.externalContactId = externalContactId
        self.conversationId = conversationId
        self.communicationId = communicationId
        self.mediaType = mediaType
    }


}



/** Silent Call timeout configuration. */

public class ConversationCallEventTopicDispositionSilentCallTimeout: Codable {







    /** Configured Silent Call timeout value. */
    public var timeoutMs: Int64?
    /** Timer start time, measured in epoch milliseconds. */
    public var timerStartTime: Double?
    /** Timer end time, measured in epoch milliseconds. */
    public var timerEndTime: Double?

    public init(timeoutMs: Int64?, timerStartTime: Double?, timerEndTime: Double?) {
        self.timeoutMs = timeoutMs
        self.timerStartTime = timerStartTime
        self.timerEndTime = timerEndTime
    }


}




public class ConversationCallEventTopicDivisionEntityRef: Codable {







    public var _id: String?
    public var selfUri: String?
    /** The time the entity division was last updated. */
    public var dateDivisionUpdated: Date?

    public init(_id: String?, selfUri: String?, dateDivisionUpdated: Date?) {
        self._id = _id
        self.selfUri = selfUri
        self.dateDivisionUpdated = dateDivisionUpdated
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
        case dateDivisionUpdated
    }


}



/** A subset of the Journey System's action data relevant to a part of a conversation (for external linkage and internal usage/context) */

public class ConversationCallEventTopicJourneyAction: Codable {





    /** The ID of an action from the Journey System (an action is spawned from an actionMap) */
    public var _id: String?
    public var actionMap: ConversationCallEventTopicJourneyActionMap?

    public init(_id: String?, actionMap: ConversationCallEventTopicJourneyActionMap?) {
        self._id = _id
        self.actionMap = actionMap
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case actionMap
    }


}




public class ConversationCallEventTopicJourneyContext: Codable {







    public var customer: ConversationCallEventTopicJourneyCustomer?
    public var customerSession: ConversationCallEventTopicJourneyCustomerSession?
    public var triggeringAction: ConversationCallEventTopicJourneyAction?

    public init(customer: ConversationCallEventTopicJourneyCustomer?, customerSession: ConversationCallEventTopicJourneyCustomerSession?, triggeringAction: ConversationCallEventTopicJourneyAction?) {
        self.customer = customer
        self.customerSession = customerSession
        self.triggeringAction = triggeringAction
    }


}




public class ConversationCallEventTopicWrapup: Codable {











    /** The user configured wrap up code name. */
    public var code: String?
    /** Text entered by the agent to describe the call or disposition. */
    public var notes: String?
    /** List of tags selected by the agent to describe the call or disposition. */
    public var tags: [String]?
    /** The length of time in seconds that the agent spent doing after call work., Note, the format of utc-millisec should be ignored, our code generator needs it to generate a Long for us internally */
    public var durationSeconds: Int64?
    /** The timestamp when the wrapup was finished. */
    public var endTime: Date?

    public init(code: String?, notes: String?, tags: [String]?, durationSeconds: Int64?, endTime: Date?) {
        self.code = code
        self.notes = notes
        self.tags = tags
        self.durationSeconds = durationSeconds
        self.endTime = endTime
    }


}




public class ConversationCallbackEventTopicConversationDivisionMembership: Codable {





    public var division: ConversationCallbackEventTopicDomainEntityRef?
    public var entities: [ConversationCallbackEventTopicDivisionEntityRef]?

    public init(division: ConversationCallbackEventTopicDomainEntityRef?, entities: [ConversationCallbackEventTopicDivisionEntityRef]?) {
        self.division = division
        self.entities = entities
    }


}



/** A subset of the Journey System's customer data at a point-in-time (for external linkage and internal usage/context) */

public class ConversationCallbackEventTopicJourneyCustomer: Codable {





    /** An ID of a customer within the Journey System at a point-in-time.  Note that a customer entity can have multiple customerIds based on the stitching process.  Depending on the context within the PureCloud conversation, this may or may not be mutable. */
    public var _id: String?
    /** The type of the customerId within the Journey System (e.g. cookie). */
    public var idType: String?

    public init(_id: String?, idType: String?) {
        self._id = _id
        self.idType = idType
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case idType
    }


}



/** A subset of the Journey System's tracked customer session data at a point-in-time (for external linkage and internal usage/context) */

public class ConversationCallbackEventTopicJourneyCustomerSession: Codable {





    /** An ID of a Customer/User's session within the Journey System at a point-in-time */
    public var _id: String?
    /** The type of the Customer/User's session within the Journey System (e.g. web, app) */
    public var type: String?

    public init(_id: String?, type: String?) {
        self._id = _id
        self.type = type
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case type
    }


}




public class ConversationCallbackEventTopicScoredAgent: Codable {





    /** A UriReference for a resource */
    public var agent: ConversationCallbackEventTopicUriReference?
    /** Agent's score for the current conversation, from 0 - 100, higher being better */
    public var score: Int64?

    public init(agent: ConversationCallbackEventTopicUriReference?, score: Int64?) {
        self.agent = agent
        self.score = score
    }


}




public class ConversationChat: Codable {

    public enum State: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case _none = "none"
    }

    public enum InitialState: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case _none = "none"
    }











    public enum Direction: String, Codable { 
        case inbound = "inbound"
        case outbound = "outbound"
    }

    public enum DisconnectType: String, Codable { 
        case endpoint = "endpoint"
        case client = "client"
        case system = "system"
        case transfer = "transfer"
        case transferConference = "transfer.conference"
        case transferConsult = "transfer.consult"
        case transferForward = "transfer.forward"
        case error = "error"
        case peer = "peer"
        case other = "other"
        case uncallable = "uncallable"
        case timeout = "timeout"
    }



























    /** The connection state of this communication. */
    public var state: State?
    /** The initial connection state of this communication. */
    public var initialState: InitialState?
    /** A globally unique identifier for this communication. */
    public var _id: String?
    /** The room id for the chat. */
    public var roomId: String?
    /** A globally unique identifier for the recording associated with this chat. */
    public var recordingId: String?
    /** The time line of the participant's chat, divided into activity segments. */
    public var segments: [Segment]?
    /** True if this call is held and the person on this side hears silence. */
    public var held: Bool?
    /** The direction of the chat */
    public var direction: Direction?
    /** System defined string indicating what caused the communication to disconnect. Will be null until the communication disconnects. */
    public var disconnectType: DisconnectType?
    /** The timestamp the chat was placed on hold in the cloud clock if the chat is currently on hold. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var startHoldTime: Date?
    /** The timestamp the communication has when it is first put into an alerting state. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var startAlertingTime: Date?
    /** The timestamp when this communication was connected in the cloud clock. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var connectedTime: Date?
    /** The timestamp when this communication disconnected from the conversation in the provider clock. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var disconnectedTime: Date?
    /** The source provider for the email. */
    public var provider: String?
    /** The UUID of the script to use. */
    public var scriptId: String?
    /** The id of the peer communication corresponding to a matching leg for this communication. */
    public var peerId: String?
    /** If available, the URI to the avatar image of this communication. */
    public var avatarImageUrl: String?
    /** A subset of the Journey System's data relevant to a part of a conversation (for external linkage and internal usage/context). */
    public var journeyContext: JourneyContext?
    /** Call wrap up or disposition data. */
    public var wrapup: Wrapup?
    /** After-call work for the communication. */
    public var afterCallWork: AfterCallWork?
    /** Indicates if after-call work is required for a communication. Only used when the ACW Setting is Agent Requested. */
    public var afterCallWorkRequired: Bool?
    /** Represents the queue settings for this media type. */
    public var queueMediaSettings: ConversationQueueMediaSettings?

    public init(state: State?, initialState: InitialState?, _id: String?, roomId: String?, recordingId: String?, segments: [Segment]?, held: Bool?, direction: Direction?, disconnectType: DisconnectType?, startHoldTime: Date?, startAlertingTime: Date?, connectedTime: Date?, disconnectedTime: Date?, provider: String?, scriptId: String?, peerId: String?, avatarImageUrl: String?, journeyContext: JourneyContext?, wrapup: Wrapup?, afterCallWork: AfterCallWork?, afterCallWorkRequired: Bool?, queueMediaSettings: ConversationQueueMediaSettings?) {
        self.state = state
        self.initialState = initialState
        self._id = _id
        self.roomId = roomId
        self.recordingId = recordingId
        self.segments = segments
        self.held = held
        self.direction = direction
        self.disconnectType = disconnectType
        self.startHoldTime = startHoldTime
        self.startAlertingTime = startAlertingTime
        self.connectedTime = connectedTime
        self.disconnectedTime = disconnectedTime
        self.provider = provider
        self.scriptId = scriptId
        self.peerId = peerId
        self.avatarImageUrl = avatarImageUrl
        self.journeyContext = journeyContext
        self.wrapup = wrapup
        self.afterCallWork = afterCallWork
        self.afterCallWorkRequired = afterCallWorkRequired
        self.queueMediaSettings = queueMediaSettings
    }

    public enum CodingKeys: String, CodingKey { 
        case state
        case initialState
        case _id = "id"
        case roomId
        case recordingId
        case segments
        case held
        case direction
        case disconnectType
        case startHoldTime
        case startAlertingTime
        case connectedTime
        case disconnectedTime
        case provider
        case scriptId
        case peerId
        case avatarImageUrl
        case journeyContext
        case wrapup
        case afterCallWork
        case afterCallWorkRequired
        case queueMediaSettings
    }


}




public class ConversationChatEventTopicChatMediaParticipant: Codable {

















    public enum State: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case converting = "converting"
        case uploading = "uploading"
        case transmitting = "transmitting"
        case scheduled = "scheduled"
        case parked = "parked"
        case _none = "none"
    }

    public enum InitialState: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case converting = "converting"
        case uploading = "uploading"
        case transmitting = "transmitting"
        case scheduled = "scheduled"
        case parked = "parked"
        case _none = "none"
    }

    public enum Direction: String, Codable { 
        case inbound = "inbound"
        case outbound = "outbound"
    }

    public enum DisconnectType: String, Codable { 
        case endpoint = "endpoint"
        case endpointDnd = "endpoint.dnd"
        case client = "client"
        case system = "system"
        case transfer = "transfer"
        case timeout = "timeout"
        case transferConference = "transfer.conference"
        case transferConsult = "transfer.consult"
        case transferForward = "transfer.forward"
        case transferNoanswer = "transfer.noanswer"
        case transferNotavailable = "transfer.notavailable"
        case transferDnd = "transfer.dnd"
        case transportFailure = "transport.failure"
        case error = "error"
        case peer = "peer"
        case other = "other"
        case spam = "spam"
        case uncallable = "uncallable"
        case inactivity = "inactivity"
        case sessionExpired = "session.expired"
    }









































    public enum FlaggedReason: String, Codable { 
        case general = "general"
    }



















    public var _id: String?
    public var name: String?
    public var address: String?
    public var startTime: Date?
    public var connectedTime: Date?
    public var endTime: Date?
    public var startHoldTime: Date?
    public var purpose: String?
    public var state: State?
    public var initialState: InitialState?
    public var direction: Direction?
    public var disconnectType: DisconnectType?
    public var held: Bool?
    public var wrapupRequired: Bool?
    public var wrapupPrompt: String?
    public var user: ConversationChatEventTopicUriReference?
    public var queue: ConversationChatEventTopicUriReference?
    public var team: ConversationChatEventTopicUriReference?
    public var attributes: [String:String]?
    public var errorInfo: ConversationChatEventTopicErrorBody?
    public var script: ConversationChatEventTopicUriReference?
    public var wrapupTimeoutMs: Int64?
    public var wrapupSkipped: Bool?
    public var alertingTimeoutMs: Int64?
    public var provider: String?
    public var externalContact: ConversationChatEventTopicUriReference?
    public var externalContactInitialDivisionId: String?
    public var externalOrganization: ConversationChatEventTopicUriReference?
    public var wrapup: ConversationChatEventTopicWrapup?
    public var conversationRoutingData: ConversationChatEventTopicConversationRoutingData?
    public var peer: String?
    public var screenRecordingState: String?
    public var flaggedReason: FlaggedReason?
    public var journeyContext: ConversationChatEventTopicJourneyContext?
    public var startAcwTime: Date?
    public var endAcwTime: Date?
    public var resumeTime: Date?
    public var parkTime: Date?
    public var mediaRoles: [String]?
    public var queueMediaSettings: ConversationChatEventTopicQueueMediaSettings?
    public var roomId: String?
    public var avatarImageUrl: String?

    public init(_id: String?, name: String?, address: String?, startTime: Date?, connectedTime: Date?, endTime: Date?, startHoldTime: Date?, purpose: String?, state: State?, initialState: InitialState?, direction: Direction?, disconnectType: DisconnectType?, held: Bool?, wrapupRequired: Bool?, wrapupPrompt: String?, user: ConversationChatEventTopicUriReference?, queue: ConversationChatEventTopicUriReference?, team: ConversationChatEventTopicUriReference?, attributes: [String:String]?, errorInfo: ConversationChatEventTopicErrorBody?, script: ConversationChatEventTopicUriReference?, wrapupTimeoutMs: Int64?, wrapupSkipped: Bool?, alertingTimeoutMs: Int64?, provider: String?, externalContact: ConversationChatEventTopicUriReference?, externalContactInitialDivisionId: String?, externalOrganization: ConversationChatEventTopicUriReference?, wrapup: ConversationChatEventTopicWrapup?, conversationRoutingData: ConversationChatEventTopicConversationRoutingData?, peer: String?, screenRecordingState: String?, flaggedReason: FlaggedReason?, journeyContext: ConversationChatEventTopicJourneyContext?, startAcwTime: Date?, endAcwTime: Date?, resumeTime: Date?, parkTime: Date?, mediaRoles: [String]?, queueMediaSettings: ConversationChatEventTopicQueueMediaSettings?, roomId: String?, avatarImageUrl: String?) {
        self._id = _id
        self.name = name
        self.address = address
        self.startTime = startTime
        self.connectedTime = connectedTime
        self.endTime = endTime
        self.startHoldTime = startHoldTime
        self.purpose = purpose
        self.state = state
        self.initialState = initialState
        self.direction = direction
        self.disconnectType = disconnectType
        self.held = held
        self.wrapupRequired = wrapupRequired
        self.wrapupPrompt = wrapupPrompt
        self.user = user
        self.queue = queue
        self.team = team
        self.attributes = attributes
        self.errorInfo = errorInfo
        self.script = script
        self.wrapupTimeoutMs = wrapupTimeoutMs
        self.wrapupSkipped = wrapupSkipped
        self.alertingTimeoutMs = alertingTimeoutMs
        self.provider = provider
        self.externalContact = externalContact
        self.externalContactInitialDivisionId = externalContactInitialDivisionId
        self.externalOrganization = externalOrganization
        self.wrapup = wrapup
        self.conversationRoutingData = conversationRoutingData
        self.peer = peer
        self.screenRecordingState = screenRecordingState
        self.flaggedReason = flaggedReason
        self.journeyContext = journeyContext
        self.startAcwTime = startAcwTime
        self.endAcwTime = endAcwTime
        self.resumeTime = resumeTime
        self.parkTime = parkTime
        self.mediaRoles = mediaRoles
        self.queueMediaSettings = queueMediaSettings
        self.roomId = roomId
        self.avatarImageUrl = avatarImageUrl
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case address
        case startTime
        case connectedTime
        case endTime
        case startHoldTime
        case purpose
        case state
        case initialState
        case direction
        case disconnectType
        case held
        case wrapupRequired
        case wrapupPrompt
        case user
        case queue
        case team
        case attributes
        case errorInfo
        case script
        case wrapupTimeoutMs
        case wrapupSkipped
        case alertingTimeoutMs
        case provider
        case externalContact
        case externalContactInitialDivisionId
        case externalOrganization
        case wrapup
        case conversationRoutingData
        case peer
        case screenRecordingState
        case flaggedReason
        case journeyContext
        case startAcwTime
        case endAcwTime
        case resumeTime
        case parkTime
        case mediaRoles
        case queueMediaSettings
        case roomId
        case avatarImageUrl
    }


}




public class ConversationChatEventTopicDetail: Codable {









    public var errorCode: String?
    public var fieldName: String?
    public var entityId: String?
    public var entityName: String?

    public init(errorCode: String?, fieldName: String?, entityId: String?, entityName: String?) {
        self.errorCode = errorCode
        self.fieldName = fieldName
        self.entityId = entityId
        self.entityName = entityName
    }


}




public class ConversationChatEventTopicErrorBody: Codable {























    public var message: String?
    public var code: String?
    public var status: Int64?
    public var entityId: String?
    public var entityName: String?
    public var messageWithParams: String?
    public var messageParams: [String:String]?
    public var contextId: String?
    public var details: [ConversationChatEventTopicDetail]?
    public var errors: [ConversationChatEventTopicErrorBody]?
    public var limit: ConversationChatEventTopicLimit?

    public init(message: String?, code: String?, status: Int64?, entityId: String?, entityName: String?, messageWithParams: String?, messageParams: [String:String]?, contextId: String?, details: [ConversationChatEventTopicDetail]?, errors: [ConversationChatEventTopicErrorBody]?, limit: ConversationChatEventTopicLimit?) {
        self.message = message
        self.code = code
        self.status = status
        self.entityId = entityId
        self.entityName = entityName
        self.messageWithParams = messageWithParams
        self.messageParams = messageParams
        self.contextId = contextId
        self.details = details
        self.errors = errors
        self.limit = limit
    }


}



/** Details about the action map from the Journey System which triggered this action */

public class ConversationChatEventTopicJourneyActionMap: Codable {





    /** The ID of the actionMap in the Journey System which triggered this action */
    public var _id: String?
    /** The version number of the actionMap in the Journey System at the time this action was triggered */
    public var version: Int64?

    public init(_id: String?, version: Int64?) {
        self._id = _id
        self.version = version
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case version
    }


}




public class ConversationChatEventTopicUriReference: Codable {





    /** The ID of the resource */
    public var _id: String?
    /** The name of the resource */
    public var name: String?

    public init(_id: String?, name: String?) {
        self._id = _id
        self.name = name
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
    }


}




public class ConversationCobrowseEventTopicConversationDivisionMembership: Codable {





    public var division: ConversationCobrowseEventTopicDomainEntityRef?
    public var entities: [ConversationCobrowseEventTopicDivisionEntityRef]?

    public init(division: ConversationCobrowseEventTopicDomainEntityRef?, entities: [ConversationCobrowseEventTopicDivisionEntityRef]?) {
        self.division = division
        self.entities = entities
    }


}



/** A subset of the Journey System's customer data at a point-in-time (for external linkage and internal usage/context) */

public class ConversationCobrowseEventTopicJourneyCustomer: Codable {





    /** An ID of a customer within the Journey System at a point-in-time.  Note that a customer entity can have multiple customerIds based on the stitching process.  Depending on the context within the PureCloud conversation, this may or may not be mutable. */
    public var _id: String?
    /** The type of the customerId within the Journey System (e.g. cookie). */
    public var idType: String?

    public init(_id: String?, idType: String?) {
        self._id = _id
        self.idType = idType
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case idType
    }


}



/** A subset of the Journey System's tracked customer session data at a point-in-time (for external linkage and internal usage/context) */

public class ConversationCobrowseEventTopicJourneyCustomerSession: Codable {





    /** An ID of a Customer/User's session within the Journey System at a point-in-time */
    public var _id: String?
    /** The type of the Customer/User's session within the Journey System (e.g. web, app) */
    public var type: String?

    public init(_id: String?, type: String?) {
        self._id = _id
        self.type = type
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case type
    }


}




public class ConversationCobrowseEventTopicScoredAgent: Codable {





    /** A UriReference for a resource */
    public var agent: ConversationCobrowseEventTopicUriReference?
    /** Agent's score for the current conversation, from 0 - 100, higher being better */
    public var score: Int64?

    public init(agent: ConversationCobrowseEventTopicUriReference?, score: Int64?) {
        self.agent = agent
        self.score = score
    }


}



/** Attachment object. */

public class ConversationContentAttachment: Codable {



    public enum MediaType: String, Codable { 
        case image = "Image"
        case video = "Video"
        case audio = "Audio"
        case file = "File"
        case link = "Link"
    }













    /** Provider specific ID for attachment. */
    public var _id: String?
    /** The type of attachment this instance represents. */
    public var mediaType: MediaType?
    /** URL of the attachment. */
    public var url: String?
    /** Attachment mime type (https://www.iana.org/assignments/media-types/media-types.xhtml). */
    public var mime: String?
    /** Text associated with attachment such as an image caption. */
    public var text: String?
    /** Secure hash of the attachment content. */
    public var sha256: String?
    /** Suggested file name for attachment. */
    public var filename: String?
    /** Size in bytes of the attachment content. */
    public var contentSizeBytes: Int64?

    public init(_id: String?, mediaType: MediaType?, url: String?, mime: String?, text: String?, sha256: String?, filename: String?, contentSizeBytes: Int64?) {
        self._id = _id
        self.mediaType = mediaType
        self.url = url
        self.mime = mime
        self.text = text
        self.sha256 = sha256
        self.filename = filename
        self.contentSizeBytes = contentSizeBytes
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case mediaType
        case url
        case mime
        case text
        case sha256
        case filename
        case contentSizeBytes
    }


}



/** Button response object representing the click of a structured message button, such as a quick reply. */

public class ConversationContentButtonResponse: Codable {



    public enum ModelType: String, Codable { 
        case button = "Button"
        case quickReply = "QuickReply"
        case datePicker = "DatePicker"
        case listPicker = "ListPicker"
        case form = "Form"
    }





    /** Reference to the ID of the original message (e.g., list picker) this button response is replying to. */
    public var originatingMessageId: String?
    /** Describes the button that resulted in the Button Response. */
    public var type: ModelType?
    /** The response text from the button click. */
    public var text: String?
    /** The response payload associated with the clicked button. */
    public var payload: String?

    public init(originatingMessageId: String?, type: ModelType?, text: String?, payload: String?) {
        self.originatingMessageId = originatingMessageId
        self.type = type
        self.text = text
        self.payload = payload
    }


}



/** Card content object. */

public class ConversationContentCard: Codable {













    /** Text to show in the title. */
    public var title: String?
    /** Text to show in the description. */
    public var _description: String?
    /** URL of an image. */
    public var image: String?
    /** URL of a video. */
    public var video: String?
    /** The default button action. */
    public var defaultAction: ConversationContentCardAction?
    /** An array of action objects. */
    public var actions: [ConversationContentCardAction]?

    public init(title: String?, _description: String?, image: String?, video: String?, defaultAction: ConversationContentCardAction?, actions: [ConversationContentCardAction]?) {
        self.title = title
        self._description = _description
        self.image = image
        self.video = video
        self.defaultAction = defaultAction
        self.actions = actions
    }

    public enum CodingKeys: String, CodingKey { 
        case title
        case _description = "description"
        case image
        case video
        case defaultAction
        case actions
    }


}




public class DID: Codable {



















    public enum State: String, Codable { 
        case active = "active"
        case inactive = "inactive"
        case deleted = "deleted"
    }











    public enum OwnerType: String, Codable { 
        case user = "USER"
        case phone = "PHONE"
        case ivrConfig = "IVR_CONFIG"
        case group = "GROUP"
    }



    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The name of the entity. */
    public var name: String?
    /** The division to which this entity belongs. */
    public var division: Division?
    /** The resource's description. */
    public var _description: String?
    /** The current version of the resource. */
    public var version: Int?
    /** The date the resource was created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** The date of the last modification to the resource. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** The ID of the user that last modified the resource. */
    public var modifiedBy: String?
    /** The ID of the user that created the resource. */
    public var createdBy: String?
    /** Indicates if the resource is active, inactive, or deleted. */
    public var state: State?
    /** The application that last modified the resource. */
    public var modifiedByApp: String?
    /** The application that created the resource. */
    public var createdByApp: String?
    public var phoneNumber: String?
    public var didPool: DomainEntityRef?
    /** A Uri reference to the owner of this DID, which is either a User or an IVR */
    public var owner: DomainEntityRef?
    public var ownerType: OwnerType?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, division: Division?, _description: String?, version: Int?, dateCreated: Date?, dateModified: Date?, modifiedBy: String?, createdBy: String?, state: State?, modifiedByApp: String?, createdByApp: String?, phoneNumber: String?, didPool: DomainEntityRef?, owner: DomainEntityRef?, ownerType: OwnerType?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.division = division
        self._description = _description
        self.version = version
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.modifiedBy = modifiedBy
        self.createdBy = createdBy
        self.state = state
        self.modifiedByApp = modifiedByApp
        self.createdByApp = createdByApp
        self.phoneNumber = phoneNumber
        self.didPool = didPool
        self.owner = owner
        self.ownerType = ownerType
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case division
        case _description = "description"
        case version
        case dateCreated
        case dateModified
        case modifiedBy
        case createdBy
        case state
        case modifiedByApp
        case createdByApp
        case phoneNumber
        case didPool
        case owner
        case ownerType
        case selfUri
    }


}



/** DateTimePicker content object. */

public class ConversationContentDatePicker: Codable {

















    public enum DateDisplayFormat: String, Codable { 
        case daymonthyear = "dayMonthYear"
        case monthdayyear = "monthDayYear"
        case yearmonthday = "yearMonthDay"
    }

    /** Optional unique identifier to help map component replies to form messages where multiple DatePickers can be present. */
    public var _id: String?
    /** Text to show in the title. */
    public var title: String?
    /** Text to show in the description. */
    public var subtitle: String?
    /** URL of an image */
    public var imageUrl: String?
    /** The minimum Date Enabled in the datepicker calendar, format: ISO 8601. */
    public var dateMinimum: Date?
    /** The maximum Date Enabled in the datepicker calendar, format: ISO 8601. */
    public var dateMaximum: Date?
    /** Location of the event. */
    public var location: ConversationContentLocation?
    /** An array of available times objects. */
    public var availableTimes: [ConversationContentDatePickerAvailableTime]?
    /** The format the date should be presented to the end user. */
    public var dateDisplayFormat: DateDisplayFormat?

    public init(_id: String?, title: String?, subtitle: String?, imageUrl: String?, dateMinimum: Date?, dateMaximum: Date?, location: ConversationContentLocation?, availableTimes: [ConversationContentDatePickerAvailableTime]?, dateDisplayFormat: DateDisplayFormat?) {
        self._id = _id
        self.title = title
        self.subtitle = subtitle
        self.imageUrl = imageUrl
        self.dateMinimum = dateMinimum
        self.dateMaximum = dateMaximum
        self.location = location
        self.availableTimes = availableTimes
        self.dateDisplayFormat = dateDisplayFormat
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case title
        case subtitle
        case imageUrl
        case dateMinimum
        case dateMaximum
        case location
        case availableTimes
        case dateDisplayFormat
    }


}



/** Single or multiline text input component. */

public class ConversationContentInput: Codable {













    /** Unique identifier for the input */
    public var _id: String?
    /** The main text displayed for the input field(s). */
    public var title: String?
    /** Additional text providing more details about the input field(s). */
    public var subtitle: String?
    /** Placeholder text for input field(s). */
    public var placeholderText: String?
    /** Whether the input field(s) are required to be filled in. */
    public var isRequired: Bool?
    /** Whether the input should allow multiple lines of text. */
    public var isMultipleLine: Bool?

    public init(_id: String?, title: String?, subtitle: String?, placeholderText: String?, isRequired: Bool?, isMultipleLine: Bool?) {
        self._id = _id
        self.title = title
        self.subtitle = subtitle
        self.placeholderText = placeholderText
        self.isRequired = isRequired
        self.isMultipleLine = isMultipleLine
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case title
        case subtitle
        case placeholderText
        case isRequired
        case isMultipleLine
    }


}



/** List Picker object for presenting multiple sections of selectable items. */

public class ConversationContentListPicker: Codable {









    /** Optional unique identifier to help map component replies to form messages where multiple ListPickers can be present. */
    public var _id: String?
    /** An array of sections in the List Picker. */
    public var sections: [ConversationContentListPickerSection]?
    /** The reply message after the user has selected the options from the List Picker. */
    public var replyMessage: ConversationContentReceivedReplyMessage?
    /** The message prompt to select options in the List Picker sections. */
    public var receivedMessage: ConversationContentReceivedReplyMessage?

    public init(_id: String?, sections: [ConversationContentListPickerSection]?, replyMessage: ConversationContentReceivedReplyMessage?, receivedMessage: ConversationContentReceivedReplyMessage?) {
        self._id = _id
        self.sections = sections
        self.replyMessage = replyMessage
        self.receivedMessage = receivedMessage
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case sections
        case replyMessage
        case receivedMessage
    }


}



/** List Picker object for presenting a section of selectable items. */

public class ConversationContentListPickerSection: Codable {







    /** Required title for the section. */
    public var title: String?
    /** Whether multiple items can be selected in this section. */
    public var multipleSelection: Bool?
    /** List of items to choice from in the section */
    public var items: [ConversationContentListPickerItem]?

    public init(title: String?, multipleSelection: Bool?, items: [ConversationContentListPickerItem]?) {
        self.title = title
        self.multipleSelection = multipleSelection
        self.items = items
    }


}



/** Template notification object. */

public class ConversationContentNotificationTemplate: Codable {













    /** The identifier of the message template in 'your-namespace@your-template-id/name' format. For External vendor (e.g WhatsApp), 'your-namespace@your-template-name'. For GenesysCloud canned response message template use 'cannedresponse' as your-namespace and use response ID as your-template-id (e.g. response ID=1234 then 'cannedresponse@1234') */
    public var _id: String?
    /** Template language. */
    public var language: String?
    /** The template header. */
    public var header: ConversationNotificationTemplateHeader?
    /** The template body. */
    public var body: ConversationNotificationTemplateBody?
    /** Template buttons */
    public var buttons: [ConversationNotificationTemplateButton]?
    /** The template footer. */
    public var footer: ConversationNotificationTemplateFooter?

    public init(_id: String?, language: String?, header: ConversationNotificationTemplateHeader?, body: ConversationNotificationTemplateBody?, buttons: [ConversationNotificationTemplateButton]?, footer: ConversationNotificationTemplateFooter?) {
        self._id = _id
        self.language = language
        self.header = header
        self.body = body
        self.buttons = buttons
        self.footer = footer
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case language
        case header
        case body
        case buttons
        case footer
    }


}



/** Quick reply object. */

public class ConversationContentQuickReply: Codable {







    public enum Action: String, Codable { 
        case message = "Message"
    }



    /** Text to show inside the quick reply. This is also used as the response text after clicking on the quick reply. */
    public var text: String?
    /** Content of the payload included in the quick reply response. Could be an ID identifying the quick reply response. */
    public var payload: String?
    /** URL of an image associated with the quick reply. */
    public var image: String?
    /** Specifies the type of action that is triggered upon clicking the quick reply. */
    public var action: Action?
    /** Summary of what the quick reply relates to. */
    public var summaryText: String?

    public init(text: String?, payload: String?, image: String?, action: Action?, summaryText: String?) {
        self.text = text
        self.payload = payload
        self.image = image
        self.action = action
        self.summaryText = summaryText
    }


}



/** Contact fields a merchant requires to complete a payment request. */

public class ConversationContentRequiredContactField: Codable {

    public enum ContactField: String, Codable { 
        case address = "Address"
        case name = "Name"
        case phone = "Phone"
        case email = "Email"
    }

    /** The name of the contact field */
    public var contactField: ContactField?

    public init(contactField: ContactField?) {
        self.contactField = contactField
    }


}




public class ConversationDetailQueryClause: Codable {

    public enum ModelType: String, Codable { 
        case and = "and"
        case or = "or"
    }



    /** Boolean operation to apply to the provided predicates */
    public var type: ModelType?
    /** Like a three-word sentence: (attribute-name) (operator) (target-value). */
    public var predicates: [ConversationDetailQueryPredicate]?

    public init(type: ModelType?, predicates: [ConversationDetailQueryPredicate]?) {
        self.type = type
        self.predicates = predicates
    }


}




public class ConversationEditedInput: Codable {





    /** The text of the edited input. */
    public var text: String?
    /** The modification date of the edited input. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?

    public init(text: String?, dateModified: Date?) {
        self.text = text
        self.dateModified = dateModified
    }


}




public class ConversationEmailEventTopicLimit: Codable {



    public enum Namespace: String, Codable { 
        case agentAssistant = "agent.assistant"
        case analyticsAlerting = "analytics.alerting"
        case analytics = "analytics"
        case analyticsRealtime = "analytics.realtime"
        case analyticsReportingSettings = "analytics.reporting.settings"
        case architect = "architect"
        case audiohook = "audiohook"
        case audit = "audit"
        case authApi = "auth.api"
        case authorization = "authorization"
        case automationTesting = "automation.testing"
        case bots = "bots"
        case botsVoice = "bots.voice"
        case callback = "callback"
        case cobrowse = "cobrowse"
        case contentManagement = "content.management"
        case conversation = "conversation"
        case dataactions = "dataactions"
        case datatables = "datatables"
        case directory = "directory"
        case email = "email"
        case eventOrchestration = "event.orchestration"
        case externalContacts = "external.contacts"
        case gcv = "gcv"
        case gdpr = "gdpr"
        case groups = "groups"
        case historicalAdherence = "historical.adherence"
        case infrastructureascode = "infrastructureascode"
        case integrations = "integrations"
        case intentMiner = "intent.miner"
        case journey = "journey"
        case knowledge = "knowledge"
        case languageUnderstanding = "language.understanding"
        case learning = "learning"
        case limitRegistry = "limit.registry"
        case marketplace = "marketplace"
        case mediaCommunications = "media.communications"
        case messaging = "messaging"
        case notifications = "notifications"
        case onboarding = "onboarding"
        case outbound = "outbound"
        case platformApi = "platform.api"
        case predictiveRouting = "predictive.routing"
        case presence = "presence"
        case quality = "quality"
        case recording = "recording"
        case responseManagement = "response.management"
        case routing = "routing"
        case scim = "scim"
        case search = "search"
        case secondaryAutomationTesting = "secondary.automation.testing"
        case skills = "skills"
        case speechAndTextAnalytics = "speech.and.text.analytics"
        case speechIntegration = "speech.integration"
        case supportability = "supportability"
        case taskManagement = "task.management"
        case telephonyConfiguration = "telephony.configuration"
        case usage = "usage"
        case users = "users"
        case webDeployments = "web.deployments"
        case webMessaging = "web.messaging"
        case webchat = "webchat"
        case webhooks = "webhooks"
        case workforceManagement = "workforce.management"
    }





    public var key: String?
    public var namespace: Namespace?
    public var value: Int64?
    public var documented: Bool?

    public init(key: String?, namespace: Namespace?, value: Int64?, documented: Bool?) {
        self.key = key
        self.namespace = namespace
        self.value = value
        self.documented = documented
    }


}




public class ConversationEmailEventTopicQueueMediaSettings: Codable {









    /** Specifies how long the agent has to answer an interaction before being marked as not responding. */
    public var alertingTimeoutSeconds: Int64?
    /** Specifies the duration of the alerting sound to be played for auto answered interactions. */
    public var autoAnswerAlertToneSeconds: Double?
    /** Specifies the duration of the alerting sound to be played for manually answered interactions */
    public var manualAnswerAlertToneSeconds: Double?
    /** Flag to indicate if auto answer is enabled for the given media type or media subtype. */
    public var enableAutoAnswer: Bool?

    public init(alertingTimeoutSeconds: Int64?, autoAnswerAlertToneSeconds: Double?, manualAnswerAlertToneSeconds: Double?, enableAutoAnswer: Bool?) {
        self.alertingTimeoutSeconds = alertingTimeoutSeconds
        self.autoAnswerAlertToneSeconds = autoAnswerAlertToneSeconds
        self.manualAnswerAlertToneSeconds = manualAnswerAlertToneSeconds
        self.enableAutoAnswer = enableAutoAnswer
    }


}



/** Sentiment analysis of this message. */

public class ConversationEnrichmentSentimentV2: Codable {

    public enum Tag: String, Codable { 
        case unknown = "Unknown"
        case positive = "Positive"
        case negative = "Negative"
        case neutral = "Neutral"
    }

    /** Detected Sentiment tag */
    public var tag: Tag?

    public init(tag: Tag?) {
        self.tag = tag
    }


}




public class ConversationEventTopicChat: Codable {

    public enum State: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case _none = "none"
    }

    public enum InitialState: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case _none = "none"
    }















    public enum DisconnectType: String, Codable { 
        case endpoint = "endpoint"
        case endpointDnd = "endpoint.dnd"
        case client = "client"
        case system = "system"
        case timeout = "timeout"
        case transfer = "transfer"
        case transferConference = "transfer.conference"
        case transferConsult = "transfer.consult"
        case transferForward = "transfer.forward"
        case transferNoanswer = "transfer.noanswer"
        case transferNotavailable = "transfer.notavailable"
        case transferDnd = "transfer.dnd"
        case transportFailure = "transport.failure"
        case error = "error"
        case peer = "peer"
        case other = "other"
        case spam = "spam"
        case uncallable = "uncallable"
    }

















    public var state: State?
    public var initialState: InitialState?
    /** A globally unique identifier for this communication. */
    public var _id: String?
    /** The source provider of the chat. */
    public var provider: String?
    /** The UUID of the script to use. */
    public var scriptId: String?
    /** The id of the peer communication corresponding to a matching leg for this communication. */
    public var peerId: String?
    /** The room id for the chat. */
    public var roomId: String?
    /** The avatar for the chat (if available). */
    public var avatarImageUrl: String?
    /** True if this call is held and the person on this side hears silence. */
    public var held: Bool?
    /** System defined string indicating what caused the communication to disconnect. Will be null until the communication disconnects. */
    public var disconnectType: DisconnectType?
    /** The timestamp the chat was placed on hold in the cloud clock if the chat is currently on hold. */
    public var startHoldTime: Date?
    /** The timestamp when this communication was connected in the cloud clock. */
    public var connectedTime: Date?
    /** The timestamp when this communication disconnected from the conversation in the provider clock. */
    public var disconnectedTime: Date?
    public var journeyContext: ConversationEventTopicJourneyContext?
    /** Call wrap up or disposition data. */
    public var wrapup: ConversationEventTopicWrapup?
    /** A communication's after-call work data. */
    public var afterCallWork: ConversationEventTopicAfterCallWork?
    /** Indicates if after-call is required for a communication. Only used when the ACW Setting is Agent Requested. */
    public var afterCallWorkRequired: Bool?
    /** Represents the queue setting for this media. */
    public var queueMediaSettings: ConversationEventTopicQueueMediaSettings?

    public init(state: State?, initialState: InitialState?, _id: String?, provider: String?, scriptId: String?, peerId: String?, roomId: String?, avatarImageUrl: String?, held: Bool?, disconnectType: DisconnectType?, startHoldTime: Date?, connectedTime: Date?, disconnectedTime: Date?, journeyContext: ConversationEventTopicJourneyContext?, wrapup: ConversationEventTopicWrapup?, afterCallWork: ConversationEventTopicAfterCallWork?, afterCallWorkRequired: Bool?, queueMediaSettings: ConversationEventTopicQueueMediaSettings?) {
        self.state = state
        self.initialState = initialState
        self._id = _id
        self.provider = provider
        self.scriptId = scriptId
        self.peerId = peerId
        self.roomId = roomId
        self.avatarImageUrl = avatarImageUrl
        self.held = held
        self.disconnectType = disconnectType
        self.startHoldTime = startHoldTime
        self.connectedTime = connectedTime
        self.disconnectedTime = disconnectedTime
        self.journeyContext = journeyContext
        self.wrapup = wrapup
        self.afterCallWork = afterCallWork
        self.afterCallWorkRequired = afterCallWorkRequired
        self.queueMediaSettings = queueMediaSettings
    }

    public enum CodingKeys: String, CodingKey { 
        case state
        case initialState
        case _id = "id"
        case provider
        case scriptId
        case peerId
        case roomId
        case avatarImageUrl
        case held
        case disconnectType
        case startHoldTime
        case connectedTime
        case disconnectedTime
        case journeyContext
        case wrapup
        case afterCallWork
        case afterCallWorkRequired
        case queueMediaSettings
    }


}



/** Silent Call timeout configuration. */

public class ConversationEventTopicDispositionSilentCallTimeout: Codable {







    /** Configured Silent Call timeout value. */
    public var timeoutMs: Int64?
    /** Timer start time, measured in epoch milliseconds. */
    public var timerStartTime: Double?
    /** Timer end time, measured in epoch milliseconds. */
    public var timerEndTime: Double?

    public init(timeoutMs: Int64?, timerStartTime: Double?, timerEndTime: Double?) {
        self.timeoutMs = timeoutMs
        self.timerStartTime = timerStartTime
        self.timerEndTime = timerEndTime
    }


}




public class ConversationEventTopicDivisionEntityRef: Codable {







    public var _id: String?
    public var selfUri: String?
    /** The time the entity division was last updated. */
    public var dateDivisionUpdated: Date?

    public init(_id: String?, selfUri: String?, dateDivisionUpdated: Date?) {
        self._id = _id
        self.selfUri = selfUri
        self.dateDivisionUpdated = dateDivisionUpdated
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
        case dateDivisionUpdated
    }


}



/** A subset of the Journey System's action data relevant to a part of a conversation (for external linkage and internal usage/context) */

public class ConversationEventTopicJourneyAction: Codable {





    /** The ID of an action from the Journey System (an action is spawned from an actionMap) */
    public var _id: String?
    public var actionMap: ConversationEventTopicJourneyActionMap?

    public init(_id: String?, actionMap: ConversationEventTopicJourneyActionMap?) {
        self._id = _id
        self.actionMap = actionMap
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case actionMap
    }


}



/** A subset of the Journey System's data relevant to a part of a conversation (for external linkage and internal usage/context). */

public class ConversationEventTopicJourneyContext: Codable {







    public var customer: ConversationEventTopicJourneyCustomer?
    public var customerSession: ConversationEventTopicJourneyCustomerSession?
    public var triggeringAction: ConversationEventTopicJourneyAction?

    public init(customer: ConversationEventTopicJourneyCustomer?, customerSession: ConversationEventTopicJourneyCustomerSession?, triggeringAction: ConversationEventTopicJourneyAction?) {
        self.customer = customer
        self.customerSession = customerSession
        self.triggeringAction = triggeringAction
    }


}




public class ConversationEventTopicMessage: Codable {



    public enum State: String, Codable { 
        case alerting = "alerting"
        case connected = "connected"
        case disconnected = "disconnected"
    }

    public enum InitialState: String, Codable { 
        case alerting = "alerting"
        case connected = "connected"
        case disconnected = "disconnected"
    }

    public enum Direction: String, Codable { 
        case outbound = "outbound"
        case inbound = "inbound"
    }











    public enum DisconnectType: String, Codable { 
        case endpoint = "endpoint"
        case endpointDnd = "endpoint.dnd"
        case client = "client"
        case system = "system"
        case timeout = "timeout"
        case transfer = "transfer"
        case transferConference = "transfer.conference"
        case transferConsult = "transfer.consult"
        case transferForward = "transfer.forward"
        case transferNoanswer = "transfer.noanswer"
        case transferNotavailable = "transfer.notavailable"
        case transferDnd = "transfer.dnd"
        case transportFailure = "transport.failure"
        case error = "error"
        case peer = "peer"
        case other = "other"
        case spam = "spam"
        case uncallable = "uncallable"
        case inactivity = "inactivity"
        case sessionExpired = "session.expired"
    }















    public enum ModelType: String, Codable { 
        case unknown = "unknown"
        case sms = "sms"
        case twitter = "twitter"
        case facebook = "facebook"
        case line = "line"
        case viber = "viber"
        case wechat = "wechat"
        case whatsapp = "whatsapp"
        case telegram = "telegram"
        case kakao = "kakao"
        case webmessaging = "webmessaging"
        case _open = "open"
        case instagram = "instagram"
        case apple = "apple"
    }





















    /** A globally unique identifier for this communication. */
    public var _id: String?
    public var state: State?
    public var initialState: InitialState?
    /** Whether a message is inbound or outbound. */
    public var direction: Direction?
    /** True if this call is held and the person on this side hears silence. */
    public var held: Bool?
    /** Detailed information about an error response. */
    public var errorInfo: ConversationEventTopicErrorDetails?
    /** The source provider of the email. */
    public var provider: String?
    /** The UUID of the script to use. */
    public var scriptId: String?
    /** The id of the peer communication corresponding to a matching leg for this communication. */
    public var peerId: String?
    /** System defined string indicating what caused the communication to disconnect. Will be null until the communication disconnects. */
    public var disconnectType: DisconnectType?
    /** The timestamp the email was placed on hold in the cloud clock if the email is currently on hold. */
    public var startHoldTime: Date?
    /** The timestamp when this communication was connected in the cloud clock. */
    public var connectedTime: Date?
    /** The timestamp when this communication disconnected from the conversation in the provider clock. */
    public var disconnectedTime: Date?
    /** Address and name data for a call endpoint. */
    public var toAddress: ConversationEventTopicAddress?
    /** Address and name data for a call endpoint. */
    public var fromAddress: ConversationEventTopicAddress?
    /** The messages sent on this communication channel. */
    public var messages: [ConversationEventTopicMessageDetails]?
    /** the messages transcript file uri. */
    public var messagesTranscriptUri: String?
    /** Indicates the type of message platform from which the message originated. */
    public var type: ModelType?
    /** Indicates the country where the recipient is associated in ISO 3166-1 alpha-2 format. */
    public var recipientCountry: String?
    /** The type of the recipient. Eg: Provisioned phoneNumber is the recipient for sms message type. */
    public var recipientType: String?
    /** A subset of the Journey System's data relevant to a part of a conversation (for external linkage and internal usage/context). */
    public var journeyContext: ConversationEventTopicJourneyContext?
    /** Call wrap up or disposition data. */
    public var wrapup: ConversationEventTopicWrapup?
    /** A communication's after-call work data. */
    public var afterCallWork: ConversationEventTopicAfterCallWork?
    /** Indicates if after-call is required for a communication. Only used when the ACW Setting is Agent Requested. */
    public var afterCallWorkRequired: Bool?
    /** UUID of virtual agent assistant that provide suggestions to the agent participant during the conversation. */
    public var agentAssistantId: String?
    /** Provide more visibility into what integrations customers are creating with Open Messaging. String values are defined in the Constants.java named ENGAGEMENT_SOURCE_* */
    public var engagementSource: String?
    public var byoSmsIntegrationId: String?
    /** Represents the queue setting for this media. */
    public var queueMediaSettings: ConversationEventTopicQueueMediaSettings?

    public init(_id: String?, state: State?, initialState: InitialState?, direction: Direction?, held: Bool?, errorInfo: ConversationEventTopicErrorDetails?, provider: String?, scriptId: String?, peerId: String?, disconnectType: DisconnectType?, startHoldTime: Date?, connectedTime: Date?, disconnectedTime: Date?, toAddress: ConversationEventTopicAddress?, fromAddress: ConversationEventTopicAddress?, messages: [ConversationEventTopicMessageDetails]?, messagesTranscriptUri: String?, type: ModelType?, recipientCountry: String?, recipientType: String?, journeyContext: ConversationEventTopicJourneyContext?, wrapup: ConversationEventTopicWrapup?, afterCallWork: ConversationEventTopicAfterCallWork?, afterCallWorkRequired: Bool?, agentAssistantId: String?, engagementSource: String?, byoSmsIntegrationId: String?, queueMediaSettings: ConversationEventTopicQueueMediaSettings?) {
        self._id = _id
        self.state = state
        self.initialState = initialState
        self.direction = direction
        self.held = held
        self.errorInfo = errorInfo
        self.provider = provider
        self.scriptId = scriptId
        self.peerId = peerId
        self.disconnectType = disconnectType
        self.startHoldTime = startHoldTime
        self.connectedTime = connectedTime
        self.disconnectedTime = disconnectedTime
        self.toAddress = toAddress
        self.fromAddress = fromAddress
        self.messages = messages
        self.messagesTranscriptUri = messagesTranscriptUri
        self.type = type
        self.recipientCountry = recipientCountry
        self.recipientType = recipientType
        self.journeyContext = journeyContext
        self.wrapup = wrapup
        self.afterCallWork = afterCallWork
        self.afterCallWorkRequired = afterCallWorkRequired
        self.agentAssistantId = agentAssistantId
        self.engagementSource = engagementSource
        self.byoSmsIntegrationId = byoSmsIntegrationId
        self.queueMediaSettings = queueMediaSettings
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case state
        case initialState
        case direction
        case held
        case errorInfo
        case provider
        case scriptId
        case peerId
        case disconnectType
        case startHoldTime
        case connectedTime
        case disconnectedTime
        case toAddress
        case fromAddress
        case messages
        case messagesTranscriptUri
        case type
        case recipientCountry
        case recipientType
        case journeyContext
        case wrapup
        case afterCallWork
        case afterCallWorkRequired
        case agentAssistantId
        case engagementSource
        case byoSmsIntegrationId
        case queueMediaSettings
    }


}




public class ConversationEventTopicMessageDetails: Codable {





    public enum MessageStatus: String, Codable { 
        case queued = "queued"
        case sent = "sent"
        case failed = "failed"
        case received = "received"
        case deliverySuccess = "delivery-success"
        case deliveryFailed = "delivery-failed"
        case read = "read"
        case removed = "removed"
        case published = "published"
    }











    public enum SocialVisibility: String, Codable { 
        case _private = "private"
        case _public = "public"
    }

    /** UUID identifying the message media. */
    public var messageId: String?
    /** The time when the message was sent or received. */
    public var messageTime: Date?
    /** Indicates the delivery status of the message. */
    public var messageStatus: MessageStatus?
    /** The message segment count, greater than 1 if the message content was split into multiple parts for this message type, e.g. SMS character limits. */
    public var messageSegmentCount: Int64?
    /** The media (images, files, etc) associated with this message, if any */
    public var media: [ConversationEventTopicMessageMedia]?
    /** Detailed information about an error response. */
    public var errorInfo: ConversationEventTopicErrorDetails?
    /** A list of stickers included in the message */
    public var stickers: [ConversationEventTopicMessageSticker]?
    public var messageMetadata: ConversationEventTopicMessageMetadata?
    /** For social media messages, the visibility of the message in the originating social platform */
    public var socialVisibility: SocialVisibility?

    public init(messageId: String?, messageTime: Date?, messageStatus: MessageStatus?, messageSegmentCount: Int64?, media: [ConversationEventTopicMessageMedia]?, errorInfo: ConversationEventTopicErrorDetails?, stickers: [ConversationEventTopicMessageSticker]?, messageMetadata: ConversationEventTopicMessageMetadata?, socialVisibility: SocialVisibility?) {
        self.messageId = messageId
        self.messageTime = messageTime
        self.messageStatus = messageStatus
        self.messageSegmentCount = messageSegmentCount
        self.media = media
        self.errorInfo = errorInfo
        self.stickers = stickers
        self.messageMetadata = messageMetadata
        self.socialVisibility = socialVisibility
    }


}




public class ConversationEventTopicMessageMedia: Codable {











    /** The location of the media, useful for retrieving it */
    public var url: String?
    /** The optional internet media type of the the media object.  If null then the media type should be dictated by the url */
    public var mediaType: String?
    /** The optional content length of the the media object, in bytes. */
    public var contentLengthBytes: Int64?
    /** The optional name of the the media object. */
    public var name: String?
    /** The optional id of the the media object. */
    public var _id: String?

    public init(url: String?, mediaType: String?, contentLengthBytes: Int64?, name: String?, _id: String?) {
        self.url = url
        self.mediaType = mediaType
        self.contentLengthBytes = contentLengthBytes
        self.name = name
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case url
        case mediaType
        case contentLengthBytes
        case name
        case _id = "id"
    }


}




public class ConversationEventTopicMessageMetadataEvent: Codable {





    /** Type of this event element. */
    public var eventType: String?
    /** Event subtype, if any */
    public var subType: String?

    public init(eventType: String?, subType: String?) {
        self.eventType = eventType
        self.subType = subType
    }


}




public class ConversationEventTopicMessageSticker: Codable {





    /** The location of the sticker, useful for retrieving it */
    public var url: String?
    /** The unique id of the the sticker object. */
    public var _id: String?

    public init(url: String?, _id: String?) {
        self.url = url
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case url
        case _id = "id"
    }


}



/** Fields identifying the initiator of a given conversation command. */

public class ConversationEventTopicTransferInitiator: Codable {



    /** The id of the user who initiated the command if it was initiated by a user. */
    public var userId: String?

    public init(userId: String?) {
        self.userId = userId
    }


}




public class ConversationEventTopicTransferResponse: Codable {



    public enum State: String, Codable { 
        case pending = "pending"
        case active = "active"
        case complete = "complete"
        case canceled = "canceled"
        case failed = "failed"
        case timeout = "timeout"
        case unknown = "unknown"
    }









    public enum TransferType: String, Codable { 
        case attended = "attended"
        case unattended = "unattended"
    }

    /** The id of the command. */
    public var _id: String?
    public var state: State?
    /** The date/time that this command was issued. */
    public var dateIssued: Date?
    public var initiator: ConversationEventTopicTransferInitiator?
    public var modifiedBy: ConversationEventTopicTransferModifedBy?
    public var destination: ConversationEventTopicTransferDestination?
    /** The type of transfer to perform. */
    public var transferType: TransferType?

    public init(_id: String?, state: State?, dateIssued: Date?, initiator: ConversationEventTopicTransferInitiator?, modifiedBy: ConversationEventTopicTransferModifedBy?, destination: ConversationEventTopicTransferDestination?, transferType: TransferType?) {
        self._id = _id
        self.state = state
        self.dateIssued = dateIssued
        self.initiator = initiator
        self.modifiedBy = modifiedBy
        self.destination = destination
        self.transferType = transferType
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case state
        case dateIssued
        case initiator
        case modifiedBy
        case destination
        case transferType
    }


}



/** Information about the workflow. */

public class ConversationEventTopicWorkflow: Codable {



    /** The id of the workflow */
    public var workflowId: String?

    public init(workflowId: String?) {
        self.workflowId = workflowId
    }


}



/** Call wrap up or disposition data. */

public class ConversationEventTopicWrapup: Codable {











    /** The user configured wrap up code name. */
    public var code: String?
    /** Text entered by the agent to describe the call or disposition. */
    public var notes: String?
    /** List of tags selected by the agent to describe the call or disposition. */
    public var tags: [String]?
    /** The length of time in seconds that the agent spent doing after call work., Note, the format of utc-millisec should be ignored, our code generator needs it to generate a Long for us internally */
    public var durationSeconds: Int64?
    /** The timestamp when the wrapup was finished. */
    public var endTime: Date?

    public init(code: String?, notes: String?, tags: [String]?, durationSeconds: Int64?, endTime: Date?) {
        self.code = code
        self.notes = notes
        self.tags = tags
        self.durationSeconds = durationSeconds
        self.endTime = endTime
    }


}



/** A Typing event. */

public class ConversationEventTyping: Codable {

    public enum ModelType: String, Codable { 
        case on = "On"
    }



    /** Describes the type of Typing event. */
    public var type: ModelType?
    /** The duration of the Typing event in milliseconds. */
    public var duration: Int64?

    public init(type: ModelType?, duration: Int64?) {
        self.type = type
        self.duration = duration
    }


}




public class ConversationIntentSuggestionsTopicSuggestedIntentSlot: Codable {









    public var slotName: String?
    public var entityType: String?
    public var slotValue: String?
    public var probability: Double?

    public init(slotName: String?, entityType: String?, slotValue: String?, probability: Double?) {
        self.slotName = slotName
        self.entityType = entityType
        self.slotValue = slotValue
        self.probability = probability
    }


}




public class ConversationKnowledgeArticleSuggestionsTopicSuggestedIntentSlot: Codable {









    public var slotName: String?
    public var entityType: String?
    public var slotValue: String?
    public var probability: Double?

    public init(slotName: String?, entityType: String?, slotValue: String?, probability: Double?) {
        self.slotName = slotName
        self.entityType = entityType
        self.slotValue = slotValue
        self.probability = probability
    }


}




public class ConversationKnowledgeSearchSuggestionsTopicSuggestedIntentSlot: Codable {









    public var slotName: String?
    public var entityType: String?
    public var slotValue: String?
    public var probability: Double?

    public init(slotName: String?, entityType: String?, slotValue: String?, probability: Double?) {
        self.slotName = slotName
        self.entityType = entityType
        self.slotValue = slotValue
        self.probability = probability
    }


}




public class ConversationMessageEventTopicDetail: Codable {









    public var errorCode: String?
    public var fieldName: String?
    public var entityId: String?
    public var entityName: String?

    public init(errorCode: String?, fieldName: String?, entityId: String?, entityName: String?) {
        self.errorCode = errorCode
        self.fieldName = fieldName
        self.entityId = entityId
        self.entityName = entityName
    }


}




public class ConversationMessageEventTopicErrorBody: Codable {























    public var message: String?
    public var code: String?
    public var status: Int64?
    public var entityId: String?
    public var entityName: String?
    public var messageWithParams: String?
    public var messageParams: [String:String]?
    public var contextId: String?
    public var details: [ConversationMessageEventTopicDetail]?
    public var errors: [ConversationMessageEventTopicErrorBody]?
    public var limit: ConversationMessageEventTopicLimit?

    public init(message: String?, code: String?, status: Int64?, entityId: String?, entityName: String?, messageWithParams: String?, messageParams: [String:String]?, contextId: String?, details: [ConversationMessageEventTopicDetail]?, errors: [ConversationMessageEventTopicErrorBody]?, limit: ConversationMessageEventTopicLimit?) {
        self.message = message
        self.code = code
        self.status = status
        self.entityId = entityId
        self.entityName = entityName
        self.messageWithParams = messageWithParams
        self.messageParams = messageParams
        self.contextId = contextId
        self.details = details
        self.errors = errors
        self.limit = limit
    }


}



/** Details about the action map from the Journey System which triggered this action */

public class ConversationMessageEventTopicJourneyActionMap: Codable {





    /** The ID of the actionMap in the Journey System which triggered this action */
    public var _id: String?
    /** The version number of the actionMap in the Journey System at the time this action was triggered */
    public var version: Int64?

    public init(_id: String?, version: Int64?) {
        self._id = _id
        self.version = version
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case version
    }


}




public class ConversationMessageEventTopicMessageMediaParticipant: Codable {

















    public enum State: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case converting = "converting"
        case uploading = "uploading"
        case transmitting = "transmitting"
        case scheduled = "scheduled"
        case parked = "parked"
        case _none = "none"
    }

    public enum InitialState: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case converting = "converting"
        case uploading = "uploading"
        case transmitting = "transmitting"
        case scheduled = "scheduled"
        case parked = "parked"
        case _none = "none"
    }

    public enum Direction: String, Codable { 
        case inbound = "inbound"
        case outbound = "outbound"
    }

    public enum DisconnectType: String, Codable { 
        case endpoint = "endpoint"
        case endpointDnd = "endpoint.dnd"
        case client = "client"
        case system = "system"
        case transfer = "transfer"
        case timeout = "timeout"
        case transferConference = "transfer.conference"
        case transferConsult = "transfer.consult"
        case transferForward = "transfer.forward"
        case transferNoanswer = "transfer.noanswer"
        case transferNotavailable = "transfer.notavailable"
        case transferDnd = "transfer.dnd"
        case transportFailure = "transport.failure"
        case error = "error"
        case peer = "peer"
        case other = "other"
        case spam = "spam"
        case uncallable = "uncallable"
        case inactivity = "inactivity"
        case sessionExpired = "session.expired"
    }









































    public enum FlaggedReason: String, Codable { 
        case general = "general"
    }

















    public enum ModelType: String, Codable { 
        case unknown = "unknown"
        case sms = "sms"
        case twitter = "twitter"
        case facebook = "facebook"
        case line = "line"
        case viber = "viber"
        case wechat = "wechat"
        case whatsapp = "whatsapp"
        case telegram = "telegram"
        case kakao = "kakao"
        case webmessaging = "webmessaging"
        case _open = "open"
        case instagram = "instagram"
        case apple = "apple"
    }











    public var _id: String?
    public var name: String?
    public var address: String?
    public var startTime: Date?
    public var connectedTime: Date?
    public var endTime: Date?
    public var startHoldTime: Date?
    public var purpose: String?
    public var state: State?
    public var initialState: InitialState?
    public var direction: Direction?
    public var disconnectType: DisconnectType?
    public var held: Bool?
    public var wrapupRequired: Bool?
    public var wrapupPrompt: String?
    public var user: ConversationMessageEventTopicUriReference?
    public var queue: ConversationMessageEventTopicUriReference?
    public var team: ConversationMessageEventTopicUriReference?
    public var attributes: [String:String]?
    public var errorInfo: ConversationMessageEventTopicErrorBody?
    public var script: ConversationMessageEventTopicUriReference?
    public var wrapupTimeoutMs: Int64?
    public var wrapupSkipped: Bool?
    public var alertingTimeoutMs: Int64?
    public var provider: String?
    public var externalContact: ConversationMessageEventTopicUriReference?
    public var externalContactInitialDivisionId: String?
    public var externalOrganization: ConversationMessageEventTopicUriReference?
    public var wrapup: ConversationMessageEventTopicWrapup?
    public var conversationRoutingData: ConversationMessageEventTopicConversationRoutingData?
    public var peer: String?
    public var screenRecordingState: String?
    public var flaggedReason: FlaggedReason?
    public var journeyContext: ConversationMessageEventTopicJourneyContext?
    public var startAcwTime: Date?
    public var endAcwTime: Date?
    public var resumeTime: Date?
    public var parkTime: Date?
    public var mediaRoles: [String]?
    public var queueMediaSettings: ConversationMessageEventTopicQueueMediaSettings?
    public var messages: [ConversationMessageEventTopicMessageDetails]?
    public var type: ModelType?
    public var recipientCountry: String?
    public var recipientType: String?
    public var byoSmsIntegrationId: String?
    public var engagementSource: String?
    public var monitoredParticipantId: String?

    public init(_id: String?, name: String?, address: String?, startTime: Date?, connectedTime: Date?, endTime: Date?, startHoldTime: Date?, purpose: String?, state: State?, initialState: InitialState?, direction: Direction?, disconnectType: DisconnectType?, held: Bool?, wrapupRequired: Bool?, wrapupPrompt: String?, user: ConversationMessageEventTopicUriReference?, queue: ConversationMessageEventTopicUriReference?, team: ConversationMessageEventTopicUriReference?, attributes: [String:String]?, errorInfo: ConversationMessageEventTopicErrorBody?, script: ConversationMessageEventTopicUriReference?, wrapupTimeoutMs: Int64?, wrapupSkipped: Bool?, alertingTimeoutMs: Int64?, provider: String?, externalContact: ConversationMessageEventTopicUriReference?, externalContactInitialDivisionId: String?, externalOrganization: ConversationMessageEventTopicUriReference?, wrapup: ConversationMessageEventTopicWrapup?, conversationRoutingData: ConversationMessageEventTopicConversationRoutingData?, peer: String?, screenRecordingState: String?, flaggedReason: FlaggedReason?, journeyContext: ConversationMessageEventTopicJourneyContext?, startAcwTime: Date?, endAcwTime: Date?, resumeTime: Date?, parkTime: Date?, mediaRoles: [String]?, queueMediaSettings: ConversationMessageEventTopicQueueMediaSettings?, messages: [ConversationMessageEventTopicMessageDetails]?, type: ModelType?, recipientCountry: String?, recipientType: String?, byoSmsIntegrationId: String?, engagementSource: String?, monitoredParticipantId: String?) {
        self._id = _id
        self.name = name
        self.address = address
        self.startTime = startTime
        self.connectedTime = connectedTime
        self.endTime = endTime
        self.startHoldTime = startHoldTime
        self.purpose = purpose
        self.state = state
        self.initialState = initialState
        self.direction = direction
        self.disconnectType = disconnectType
        self.held = held
        self.wrapupRequired = wrapupRequired
        self.wrapupPrompt = wrapupPrompt
        self.user = user
        self.queue = queue
        self.team = team
        self.attributes = attributes
        self.errorInfo = errorInfo
        self.script = script
        self.wrapupTimeoutMs = wrapupTimeoutMs
        self.wrapupSkipped = wrapupSkipped
        self.alertingTimeoutMs = alertingTimeoutMs
        self.provider = provider
        self.externalContact = externalContact
        self.externalContactInitialDivisionId = externalContactInitialDivisionId
        self.externalOrganization = externalOrganization
        self.wrapup = wrapup
        self.conversationRoutingData = conversationRoutingData
        self.peer = peer
        self.screenRecordingState = screenRecordingState
        self.flaggedReason = flaggedReason
        self.journeyContext = journeyContext
        self.startAcwTime = startAcwTime
        self.endAcwTime = endAcwTime
        self.resumeTime = resumeTime
        self.parkTime = parkTime
        self.mediaRoles = mediaRoles
        self.queueMediaSettings = queueMediaSettings
        self.messages = messages
        self.type = type
        self.recipientCountry = recipientCountry
        self.recipientType = recipientType
        self.byoSmsIntegrationId = byoSmsIntegrationId
        self.engagementSource = engagementSource
        self.monitoredParticipantId = monitoredParticipantId
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case address
        case startTime
        case connectedTime
        case endTime
        case startHoldTime
        case purpose
        case state
        case initialState
        case direction
        case disconnectType
        case held
        case wrapupRequired
        case wrapupPrompt
        case user
        case queue
        case team
        case attributes
        case errorInfo
        case script
        case wrapupTimeoutMs
        case wrapupSkipped
        case alertingTimeoutMs
        case provider
        case externalContact
        case externalContactInitialDivisionId
        case externalOrganization
        case wrapup
        case conversationRoutingData
        case peer
        case screenRecordingState
        case flaggedReason
        case journeyContext
        case startAcwTime
        case endAcwTime
        case resumeTime
        case parkTime
        case mediaRoles
        case queueMediaSettings
        case messages
        case type
        case recipientCountry
        case recipientType
        case byoSmsIntegrationId
        case engagementSource
        case monitoredParticipantId
    }


}




public class ConversationMessageEventTopicMessageMetadata: Codable {







    /** Message type. */
    public var type: String?
    /** List of message events, if any */
    public var events: [ConversationMessageEventTopicMessageMetadataEvent]?
    /** List of message content, if any */
    public var content: [ConversationMessageEventTopicMessageMetadataContent]?

    public init(type: String?, events: [ConversationMessageEventTopicMessageMetadataEvent]?, content: [ConversationMessageEventTopicMessageMetadataContent]?) {
        self.type = type
        self.events = events
        self.content = content
    }


}




public class ConversationMessageEventTopicUriReference: Codable {





    /** The ID of the resource */
    public var _id: String?
    /** The name of the resource */
    public var name: String?

    public init(_id: String?, name: String?) {
        self._id = _id
        self.name = name
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
    }


}



/** Metadata information about a message event. */

public class ConversationMessageMetadataEvent: Codable {

    public enum EventType: String, Codable { 
        case coBrowse = "CoBrowse"
        case typing = "Typing"
        case presence = "Presence"
        case video = "Video"
        case unknown = "Unknown"
    }

    public enum SubType: String, Codable { 
        case on = "On"
        case join = "Join"
        case offering = "Offering"
        case offeringExpired = "OfferingExpired"
        case offeringAccepted = "OfferingAccepted"
        case offeringRejected = "OfferingRejected"
        case disconnect = "Disconnect"
        case clear = "Clear"
        case signIn = "SignIn"
        case sessionExpired = "SessionExpired"
        case authenticate = "Authenticate"
        case authenticateFailure = "AuthenticateFailure"
        case authenticateCancel = "AuthenticateCancel"
        case unknown = "Unknown"
    }

    /** Type of this event element */
    public var eventType: EventType?
    /** Event subtype */
    public var subType: SubType?

    public init(eventType: EventType?, subType: SubType?) {
        self.eventType = eventType
        self.subType = subType
    }


}



/** General rich media message structure with normalized feature support across many messaging channels. */

public class ConversationNormalizedMessage: Codable {





    public enum ModelType: String, Codable { 
        case text = "Text"
        case structured = "Structured"
        case receipt = "Receipt"
        case event = "Event"
        case message = "Message"
        case unknown = "Unknown"
    }







    public enum Status: String, Codable { 
        case sent = "Sent"
        case delivered = "Delivered"
        case read = "Read"
        case failed = "Failed"
        case published = "Published"
        case removed = "Removed"
    }



    public enum OriginatingEntity: String, Codable { 
        case human = "Human"
        case bot = "Bot"
    }



    public enum Direction: String, Codable { 
        case inbound = "Inbound"
        case outbound = "Outbound"
    }









    /** Unique ID of the message. Message receipts will have the same ID as the message they reference. */
    public var _id: String?
    /** Channel-specific information that describes the message and the message channel/provider. */
    public var channel: ConversationMessagingChannel?
    /** Message type. */
    public var type: ModelType?
    /** Message text. */
    public var text: String?
    /** List of content elements. */
    public var content: [ConversationMessageContent]?
    /** List of event elements. */
    public var events: [ConversationMessageEvent]?
    /** Message receipt status, only used with type Receipt. */
    public var status: Status?
    /** List of reasons for a message receipt that indicates the message has failed. Only used with Failed status. */
    public var reasons: [ConversationReason]?
    /** Specifies if this message was sent by a human agent or bot. The platform may use this to apply appropriate provider policies. */
    public var originatingEntity: OriginatingEntity?
    /** Indicates if this is the last message receipt for this message, or if another message receipt can be expected. */
    public var isFinalReceipt: Bool?
    /** The direction of the message. */
    public var direction: Direction?
    /** A list of messages related to this one. */
    public var relatedMessages: [ConversationNormalizedMessage]?
    /** Additional metadata about this message. */
    public var metadata: [String:String]?
    /** Metadata enrichments provided by the platform. */
    public var enrichment: ConversationEnrichment?
    /** The internal id representing the customer supplied sms integration message. */
    public var byoSmsIntegrationId: String?

    public init(_id: String?, channel: ConversationMessagingChannel?, type: ModelType?, text: String?, content: [ConversationMessageContent]?, events: [ConversationMessageEvent]?, status: Status?, reasons: [ConversationReason]?, originatingEntity: OriginatingEntity?, isFinalReceipt: Bool?, direction: Direction?, relatedMessages: [ConversationNormalizedMessage]?, metadata: [String:String]?, enrichment: ConversationEnrichment?, byoSmsIntegrationId: String?) {
        self._id = _id
        self.channel = channel
        self.type = type
        self.text = text
        self.content = content
        self.events = events
        self.status = status
        self.reasons = reasons
        self.originatingEntity = originatingEntity
        self.isFinalReceipt = isFinalReceipt
        self.direction = direction
        self.relatedMessages = relatedMessages
        self.metadata = metadata
        self.enrichment = enrichment
        self.byoSmsIntegrationId = byoSmsIntegrationId
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case channel
        case type
        case text
        case content
        case events
        case status
        case reasons
        case originatingEntity
        case isFinalReceipt
        case direction
        case relatedMessages
        case metadata
        case enrichment
        case byoSmsIntegrationId
    }


}



/** Template button object */

public class ConversationNotificationTemplateButton: Codable {

    public enum ModelType: String, Codable { 
        case quickReply = "QuickReply"
        case phoneNumber = "PhoneNumber"
        case url = "Url"
    }











    /** Specifies the type of the button. */
    public var type: ModelType?
    /** Button text message. */
    public var text: String?
    /** index of the button in the list. */
    public var index: Int64?
    /** Button phone number. */
    public var phoneNumber: String?
    /** Button URL link. */
    public var url: String?
    /** Template parameters for placeholders in the button. */
    public var parameters: [ConversationNotificationTemplateParameter]?

    public init(type: ModelType?, text: String?, index: Int64?, phoneNumber: String?, url: String?, parameters: [ConversationNotificationTemplateParameter]?) {
        self.type = type
        self.text = text
        self.index = index
        self.phoneNumber = phoneNumber
        self.url = url
        self.parameters = parameters
    }


}




public class ConversationParticipantSearchRequest: Codable {

    public enum SortOrder: String, Codable { 
        case asc = "ASC"
        case desc = "DESC"
        case score = "SCORE"
    }











    /** The sort order for results */
    public var sortOrder: SortOrder?
    /** The field in the resource that you want to sort the results by */
    public var sortBy: String?
    /** Multi-value sort order, list of multiple sort values */
    public var sort: [SearchSort]?
    public var returnFields: [String]?
    public var query: [ConversationParticipantSearchCriteria]?
    public var cursor: String?

    public init(sortOrder: SortOrder?, sortBy: String?, sort: [SearchSort]?, returnFields: [String]?, query: [ConversationParticipantSearchCriteria]?, cursor: String?) {
        self.sortOrder = sortOrder
        self.sortBy = sortBy
        self.sort = sort
        self.returnFields = returnFields
        self.query = query
        self.cursor = cursor
    }


}




public class ConversationProperties: Codable {

























    /** Indicates filtering for waiting */
    public var isWaiting: Bool?
    /** Indicates filtering for active */
    public var isActive: Bool?
    /** Indicates filtering for Acd */
    public var isAcd: Bool?
    /** Indicates filtering for Preferred Agent Routing */
    public var isPreferred: Bool?
    /** Indicates filtering for screenshare */
    public var isScreenshare: Bool?
    /** Indicates filtering for Cobrowse */
    public var isCobrowse: Bool?
    /** Indicates filtering for Voice mail */
    public var isVoicemail: Bool?
    /** Indicates filtering for flagged */
    public var isFlagged: Bool?
    /** Indicates filtering for monitored */
    public var isMonitored: Bool?
    /** Indicates filtering for screenMonitored */
    public var isScreenMonitored: Bool?
    /** Indicates filtering for WrapUpNotes */
    public var filterWrapUpNotes: Bool?
    /** Indicates comparison operation, TRUE indicates filters will use AND logic, FALSE indicates OR logic */
    public var matchAll: Bool?

    public init(isWaiting: Bool?, isActive: Bool?, isAcd: Bool?, isPreferred: Bool?, isScreenshare: Bool?, isCobrowse: Bool?, isVoicemail: Bool?, isFlagged: Bool?, isMonitored: Bool?, isScreenMonitored: Bool?, filterWrapUpNotes: Bool?, matchAll: Bool?) {
        self.isWaiting = isWaiting
        self.isActive = isActive
        self.isAcd = isAcd
        self.isPreferred = isPreferred
        self.isScreenshare = isScreenshare
        self.isCobrowse = isCobrowse
        self.isVoicemail = isVoicemail
        self.isFlagged = isFlagged
        self.isMonitored = isMonitored
        self.isScreenMonitored = isScreenMonitored
        self.filterWrapUpNotes = filterWrapUpNotes
        self.matchAll = matchAll
    }


}




public class ConversationQuery: Codable {











    public enum Order: String, Codable { 
        case asc = "asc"
        case desc = "desc"
        case unordered = "unordered"
    }

    public enum OrderBy: String, Codable { 
        case conversationstart = "conversationStart"
        case conversationend = "conversationEnd"
        case segmentstart = "segmentStart"
        case segmentend = "segmentEnd"
    }







    /** Filters that target conversation-level data */
    public var conversationFilters: [ConversationDetailQueryFilter]?
    /** Filters that target individual segments within a conversation */
    public var segmentFilters: [SegmentDetailQueryFilter]?
    /** Filters that target evaluations */
    public var evaluationFilters: [EvaluationDetailQueryFilter]?
    /** Filters that target surveys */
    public var surveyFilters: [SurveyDetailQueryFilter]?
    /** Filters that target resolutions */
    public var resolutionFilters: [ResolutionDetailQueryFilter]?
    /** Sort the result set in ascending/descending order. Default is ascending */
    public var order: Order?
    /** Specify which data element within the result set to use for sorting. The options  to use as a basis for sorting the results: conversationStart, segmentStart, and segmentEnd. If not specified, the default is conversationStart */
    public var orderBy: OrderBy?
    /** Specifies the date and time range of data being queried. Results will only include conversations that started on a day touched by the interval. Intervals are represented as an ISO-8601 string. For example: YYYY-MM-DDThh:mm:ss/YYYY-MM-DDThh:mm:ss */
    public var interval: String?
    /** Include faceted search and aggregate roll-ups describing your search results. This does not function as a filter, but rather, summary data about the data matching your filters */
    public var aggregations: [AnalyticsQueryAggregation]?
    /** Page size and number to control iterating through large result sets. Default page size is 25 */
    public var paging: PagingSpec?

    public init(conversationFilters: [ConversationDetailQueryFilter]?, segmentFilters: [SegmentDetailQueryFilter]?, evaluationFilters: [EvaluationDetailQueryFilter]?, surveyFilters: [SurveyDetailQueryFilter]?, resolutionFilters: [ResolutionDetailQueryFilter]?, order: Order?, orderBy: OrderBy?, interval: String?, aggregations: [AnalyticsQueryAggregation]?, paging: PagingSpec?) {
        self.conversationFilters = conversationFilters
        self.segmentFilters = segmentFilters
        self.evaluationFilters = evaluationFilters
        self.surveyFilters = surveyFilters
        self.resolutionFilters = resolutionFilters
        self.order = order
        self.orderBy = orderBy
        self.interval = interval
        self.aggregations = aggregations
        self.paging = paging
    }


}




public class ConversationResponseSuggestionsTopicSuggestionFeedback: Codable {

    public enum Rating: String, Codable { 
        case unknown = "Unknown"
        case negative = "Negative"
        case positive = "Positive"
    }

    public var rating: Rating?

    public init(rating: Rating?) {
        self.rating = rating
    }


}




public class ConversationScreenShareEventTopicConversationRoutingData: Codable {











    /** A UriReference for a resource */
    public var queue: ConversationScreenShareEventTopicUriReference?
    /** A UriReference for a resource */
    public var language: ConversationScreenShareEventTopicUriReference?
    /** The priority of the conversation to use for routing decisions */
    public var priority: Int64?
    /** The skills to use for routing decisions */
    public var skills: [ConversationScreenShareEventTopicUriReference]?
    /** A collection of agents and their assigned scores for this conversation (0 - 100, higher being better), for use in routing to preferred agents */
    public var scoredAgents: [ConversationScreenShareEventTopicScoredAgent]?

    public init(queue: ConversationScreenShareEventTopicUriReference?, language: ConversationScreenShareEventTopicUriReference?, priority: Int64?, skills: [ConversationScreenShareEventTopicUriReference]?, scoredAgents: [ConversationScreenShareEventTopicScoredAgent]?) {
        self.queue = queue
        self.language = language
        self.priority = priority
        self.skills = skills
        self.scoredAgents = scoredAgents
    }


}



/** A reference to another domain entity. */

public class ConversationScreenShareEventTopicDomainEntityRef: Codable {





    public var _id: String?
    public var selfUri: String?

    public init(_id: String?, selfUri: String?) {
        self._id = _id
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
    }


}




public class ConversationScreenShareEventTopicScreenShareConversation: Codable {

















    public var _id: String?
    public var name: String?
    public var participants: [ConversationScreenShareEventTopicScreenShareMediaParticipant]?
    public var otherMediaUris: [String]?
    public var address: String?
    public var utilizationLabelId: String?
    public var inactivityTimeout: Date?
    public var divisions: [ConversationScreenShareEventTopicConversationDivisionMembership]?

    public init(_id: String?, name: String?, participants: [ConversationScreenShareEventTopicScreenShareMediaParticipant]?, otherMediaUris: [String]?, address: String?, utilizationLabelId: String?, inactivityTimeout: Date?, divisions: [ConversationScreenShareEventTopicConversationDivisionMembership]?) {
        self._id = _id
        self.name = name
        self.participants = participants
        self.otherMediaUris = otherMediaUris
        self.address = address
        self.utilizationLabelId = utilizationLabelId
        self.inactivityTimeout = inactivityTimeout
        self.divisions = divisions
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case participants
        case otherMediaUris
        case address
        case utilizationLabelId
        case inactivityTimeout
        case divisions
    }


}




public class ConversationScriptSuggestionsTopicSuggestedIntent: Codable {









    public var intent: String?
    public var intentId: String?
    public var confidence: Double?
    public var detectedSlots: [ConversationScriptSuggestionsTopicSuggestedIntentSlot]?

    public init(intent: String?, intentId: String?, confidence: Double?, detectedSlots: [ConversationScriptSuggestionsTopicSuggestedIntentSlot]?) {
        self.intent = intent
        self.intentId = intentId
        self.confidence = confidence
        self.detectedSlots = detectedSlots
    }


}




public class ConversationScriptSuggestionsTopicSuggestionContext: Codable {



    public enum MediaType: String, Codable { 
        case unknown = "UNKNOWN"
        case voice = "VOICE"
        case message = "MESSAGE"
        case email = "EMAIL"
    }













    public var queueId: UUID?
    public var mediaType: MediaType?
    public var userId: UUID?
    public var externalContactId: UUID?
    public var assistantId: UUID?
    public var utteranceId: UUID?
    public var messageId: String?
    public var queryStatement: String?

    public init(queueId: UUID?, mediaType: MediaType?, userId: UUID?, externalContactId: UUID?, assistantId: UUID?, utteranceId: UUID?, messageId: String?, queryStatement: String?) {
        self.queueId = queueId
        self.mediaType = mediaType
        self.userId = userId
        self.externalContactId = externalContactId
        self.assistantId = assistantId
        self.utteranceId = utteranceId
        self.messageId = messageId
        self.queryStatement = queryStatement
    }


}




public class ConversationSocialExpressionEventTopicDivisionEntityRef: Codable {







    public var _id: String?
    public var selfUri: String?
    /** The time the entity division was last updated. */
    public var dateDivisionUpdated: Date?

    public init(_id: String?, selfUri: String?, dateDivisionUpdated: Date?) {
        self._id = _id
        self.selfUri = selfUri
        self.dateDivisionUpdated = dateDivisionUpdated
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
        case dateDivisionUpdated
    }


}



/** A subset of the Journey System's action data relevant to a part of a conversation (for external linkage and internal usage/context) */

public class ConversationSocialExpressionEventTopicJourneyAction: Codable {





    /** The ID of an action from the Journey System (an action is spawned from an actionMap) */
    public var _id: String?
    public var actionMap: ConversationSocialExpressionEventTopicJourneyActionMap?

    public init(_id: String?, actionMap: ConversationSocialExpressionEventTopicJourneyActionMap?) {
        self._id = _id
        self.actionMap = actionMap
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case actionMap
    }


}




public class ConversationSocialExpressionEventTopicJourneyContext: Codable {







    public var customer: ConversationSocialExpressionEventTopicJourneyCustomer?
    public var customerSession: ConversationSocialExpressionEventTopicJourneyCustomerSession?
    public var triggeringAction: ConversationSocialExpressionEventTopicJourneyAction?

    public init(customer: ConversationSocialExpressionEventTopicJourneyCustomer?, customerSession: ConversationSocialExpressionEventTopicJourneyCustomerSession?, triggeringAction: ConversationSocialExpressionEventTopicJourneyAction?) {
        self.customer = customer
        self.customerSession = customerSession
        self.triggeringAction = triggeringAction
    }


}




public class ConversationSocialExpressionEventTopicSocialMediaParticipant: Codable {

















    public enum State: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case converting = "converting"
        case uploading = "uploading"
        case transmitting = "transmitting"
        case scheduled = "scheduled"
        case parked = "parked"
        case _none = "none"
    }

    public enum InitialState: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case converting = "converting"
        case uploading = "uploading"
        case transmitting = "transmitting"
        case scheduled = "scheduled"
        case parked = "parked"
        case _none = "none"
    }

    public enum Direction: String, Codable { 
        case inbound = "inbound"
        case outbound = "outbound"
    }

    public enum DisconnectType: String, Codable { 
        case endpoint = "endpoint"
        case endpointDnd = "endpoint.dnd"
        case client = "client"
        case system = "system"
        case transfer = "transfer"
        case timeout = "timeout"
        case transferConference = "transfer.conference"
        case transferConsult = "transfer.consult"
        case transferForward = "transfer.forward"
        case transferNoanswer = "transfer.noanswer"
        case transferNotavailable = "transfer.notavailable"
        case transferDnd = "transfer.dnd"
        case transportFailure = "transport.failure"
        case error = "error"
        case peer = "peer"
        case other = "other"
        case spam = "spam"
        case uncallable = "uncallable"
        case inactivity = "inactivity"
        case sessionExpired = "session.expired"
    }









































    public enum FlaggedReason: String, Codable { 
        case general = "general"
    }























    public var _id: String?
    public var name: String?
    public var address: String?
    public var startTime: Date?
    public var connectedTime: Date?
    public var endTime: Date?
    public var startHoldTime: Date?
    public var purpose: String?
    public var state: State?
    public var initialState: InitialState?
    public var direction: Direction?
    public var disconnectType: DisconnectType?
    public var held: Bool?
    public var wrapupRequired: Bool?
    public var wrapupPrompt: String?
    public var user: ConversationSocialExpressionEventTopicUriReference?
    public var queue: ConversationSocialExpressionEventTopicUriReference?
    public var team: ConversationSocialExpressionEventTopicUriReference?
    public var attributes: [String:String]?
    public var errorInfo: ConversationSocialExpressionEventTopicErrorBody?
    public var script: ConversationSocialExpressionEventTopicUriReference?
    public var wrapupTimeoutMs: Int64?
    public var wrapupSkipped: Bool?
    public var alertingTimeoutMs: Int64?
    public var provider: String?
    public var externalContact: ConversationSocialExpressionEventTopicUriReference?
    public var externalContactInitialDivisionId: String?
    public var externalOrganization: ConversationSocialExpressionEventTopicUriReference?
    public var wrapup: ConversationSocialExpressionEventTopicWrapup?
    public var conversationRoutingData: ConversationSocialExpressionEventTopicConversationRoutingData?
    public var peer: String?
    public var screenRecordingState: String?
    public var flaggedReason: FlaggedReason?
    public var journeyContext: ConversationSocialExpressionEventTopicJourneyContext?
    public var startAcwTime: Date?
    public var endAcwTime: Date?
    public var resumeTime: Date?
    public var parkTime: Date?
    public var mediaRoles: [String]?
    public var queueMediaSettings: ConversationSocialExpressionEventTopicQueueMediaSettings?
    public var socialMediaId: String?
    public var socialMediaHub: String?
    public var socialUserName: String?
    public var previewText: String?

    public init(_id: String?, name: String?, address: String?, startTime: Date?, connectedTime: Date?, endTime: Date?, startHoldTime: Date?, purpose: String?, state: State?, initialState: InitialState?, direction: Direction?, disconnectType: DisconnectType?, held: Bool?, wrapupRequired: Bool?, wrapupPrompt: String?, user: ConversationSocialExpressionEventTopicUriReference?, queue: ConversationSocialExpressionEventTopicUriReference?, team: ConversationSocialExpressionEventTopicUriReference?, attributes: [String:String]?, errorInfo: ConversationSocialExpressionEventTopicErrorBody?, script: ConversationSocialExpressionEventTopicUriReference?, wrapupTimeoutMs: Int64?, wrapupSkipped: Bool?, alertingTimeoutMs: Int64?, provider: String?, externalContact: ConversationSocialExpressionEventTopicUriReference?, externalContactInitialDivisionId: String?, externalOrganization: ConversationSocialExpressionEventTopicUriReference?, wrapup: ConversationSocialExpressionEventTopicWrapup?, conversationRoutingData: ConversationSocialExpressionEventTopicConversationRoutingData?, peer: String?, screenRecordingState: String?, flaggedReason: FlaggedReason?, journeyContext: ConversationSocialExpressionEventTopicJourneyContext?, startAcwTime: Date?, endAcwTime: Date?, resumeTime: Date?, parkTime: Date?, mediaRoles: [String]?, queueMediaSettings: ConversationSocialExpressionEventTopicQueueMediaSettings?, socialMediaId: String?, socialMediaHub: String?, socialUserName: String?, previewText: String?) {
        self._id = _id
        self.name = name
        self.address = address
        self.startTime = startTime
        self.connectedTime = connectedTime
        self.endTime = endTime
        self.startHoldTime = startHoldTime
        self.purpose = purpose
        self.state = state
        self.initialState = initialState
        self.direction = direction
        self.disconnectType = disconnectType
        self.held = held
        self.wrapupRequired = wrapupRequired
        self.wrapupPrompt = wrapupPrompt
        self.user = user
        self.queue = queue
        self.team = team
        self.attributes = attributes
        self.errorInfo = errorInfo
        self.script = script
        self.wrapupTimeoutMs = wrapupTimeoutMs
        self.wrapupSkipped = wrapupSkipped
        self.alertingTimeoutMs = alertingTimeoutMs
        self.provider = provider
        self.externalContact = externalContact
        self.externalContactInitialDivisionId = externalContactInitialDivisionId
        self.externalOrganization = externalOrganization
        self.wrapup = wrapup
        self.conversationRoutingData = conversationRoutingData
        self.peer = peer
        self.screenRecordingState = screenRecordingState
        self.flaggedReason = flaggedReason
        self.journeyContext = journeyContext
        self.startAcwTime = startAcwTime
        self.endAcwTime = endAcwTime
        self.resumeTime = resumeTime
        self.parkTime = parkTime
        self.mediaRoles = mediaRoles
        self.queueMediaSettings = queueMediaSettings
        self.socialMediaId = socialMediaId
        self.socialMediaHub = socialMediaHub
        self.socialUserName = socialUserName
        self.previewText = previewText
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case address
        case startTime
        case connectedTime
        case endTime
        case startHoldTime
        case purpose
        case state
        case initialState
        case direction
        case disconnectType
        case held
        case wrapupRequired
        case wrapupPrompt
        case user
        case queue
        case team
        case attributes
        case errorInfo
        case script
        case wrapupTimeoutMs
        case wrapupSkipped
        case alertingTimeoutMs
        case provider
        case externalContact
        case externalContactInitialDivisionId
        case externalOrganization
        case wrapup
        case conversationRoutingData
        case peer
        case screenRecordingState
        case flaggedReason
        case journeyContext
        case startAcwTime
        case endAcwTime
        case resumeTime
        case parkTime
        case mediaRoles
        case queueMediaSettings
        case socialMediaId
        case socialMediaHub
        case socialUserName
        case previewText
    }


}




public class ConversationSocialExpressionEventTopicWrapup: Codable {











    /** The user configured wrap up code name. */
    public var code: String?
    /** Text entered by the agent to describe the call or disposition. */
    public var notes: String?
    /** List of tags selected by the agent to describe the call or disposition. */
    public var tags: [String]?
    /** The length of time in seconds that the agent spent doing after call work., Note, the format of utc-millisec should be ignored, our code generator needs it to generate a Long for us internally */
    public var durationSeconds: Int64?
    /** The timestamp when the wrapup was finished. */
    public var endTime: Date?

    public init(code: String?, notes: String?, tags: [String]?, durationSeconds: Int64?, endTime: Date?) {
        self.code = code
        self.notes = notes
        self.tags = tags
        self.durationSeconds = durationSeconds
        self.endTime = endTime
    }


}




public class ConversationSummaryExtractedEntity: Codable {





    /** The label for the extracted entity */
    public var label: String?
    /** The value for the extracted entity */
    public var value: String?

    public init(label: String?, value: String?) {
        self.label = label
        self.value = value
    }


}




public class ConversationSummaryTopicVirtualAgentsConversationSummary: Codable {





    public var text: String?
    public var score: Double?

    public init(text: String?, score: Double?) {
        self.text = text
        self.score = score
    }


}




public class ConversationThreadingWindowSetting: Codable {

    public enum MessengerType: String, Codable { 
        case sms = "sms"
        case facebook = "facebook"
        case twitter = "twitter"
        case whatsapp = "whatsapp"
        case webmessaging = "webmessaging"
        case instagram = "instagram"
        case _open = "open"
        case apple = "apple"
    }



    /** The type of messenger */
    public var messengerType: MessengerType?
    /** The conversation threading window timeout (Minutes) of specified messenger type */
    public var timeoutInMinutes: Int64?

    public init(messengerType: MessengerType?, timeoutInMinutes: Int64?) {
        self.messengerType = messengerType
        self.timeoutInMinutes = timeoutInMinutes
    }


}




public class ConversationVideoEventTopicLimit: Codable {



    public enum Namespace: String, Codable { 
        case agentAssistant = "agent.assistant"
        case analyticsAlerting = "analytics.alerting"
        case analytics = "analytics"
        case analyticsRealtime = "analytics.realtime"
        case analyticsReportingSettings = "analytics.reporting.settings"
        case architect = "architect"
        case audiohook = "audiohook"
        case audit = "audit"
        case authApi = "auth.api"
        case authorization = "authorization"
        case automationTesting = "automation.testing"
        case bots = "bots"
        case botsVoice = "bots.voice"
        case callback = "callback"
        case cobrowse = "cobrowse"
        case contentManagement = "content.management"
        case conversation = "conversation"
        case dataactions = "dataactions"
        case datatables = "datatables"
        case directory = "directory"
        case email = "email"
        case eventOrchestration = "event.orchestration"
        case externalContacts = "external.contacts"
        case gcv = "gcv"
        case gdpr = "gdpr"
        case groups = "groups"
        case historicalAdherence = "historical.adherence"
        case infrastructureascode = "infrastructureascode"
        case integrations = "integrations"
        case intentMiner = "intent.miner"
        case journey = "journey"
        case knowledge = "knowledge"
        case languageUnderstanding = "language.understanding"
        case learning = "learning"
        case limitRegistry = "limit.registry"
        case marketplace = "marketplace"
        case mediaCommunications = "media.communications"
        case messaging = "messaging"
        case notifications = "notifications"
        case onboarding = "onboarding"
        case outbound = "outbound"
        case platformApi = "platform.api"
        case predictiveRouting = "predictive.routing"
        case presence = "presence"
        case quality = "quality"
        case recording = "recording"
        case responseManagement = "response.management"
        case routing = "routing"
        case scim = "scim"
        case search = "search"
        case secondaryAutomationTesting = "secondary.automation.testing"
        case skills = "skills"
        case speechAndTextAnalytics = "speech.and.text.analytics"
        case speechIntegration = "speech.integration"
        case supportability = "supportability"
        case taskManagement = "task.management"
        case telephonyConfiguration = "telephony.configuration"
        case usage = "usage"
        case users = "users"
        case webDeployments = "web.deployments"
        case webMessaging = "web.messaging"
        case webchat = "webchat"
        case webhooks = "webhooks"
        case workforceManagement = "workforce.management"
    }





    public var key: String?
    public var namespace: Namespace?
    public var value: Int64?
    public var documented: Bool?

    public init(key: String?, namespace: Namespace?, value: Int64?, documented: Bool?) {
        self.key = key
        self.namespace = namespace
        self.value = value
        self.documented = documented
    }


}




public class ConversationVideoEventTopicQueueMediaSettings: Codable {









    /** Specifies how long the agent has to answer an interaction before being marked as not responding. */
    public var alertingTimeoutSeconds: Int64?
    /** Specifies the duration of the alerting sound to be played for auto answered interactions. */
    public var autoAnswerAlertToneSeconds: Double?
    /** Specifies the duration of the alerting sound to be played for manually answered interactions */
    public var manualAnswerAlertToneSeconds: Double?
    /** Flag to indicate if auto answer is enabled for the given media type or media subtype. */
    public var enableAutoAnswer: Bool?

    public init(alertingTimeoutSeconds: Int64?, autoAnswerAlertToneSeconds: Double?, manualAnswerAlertToneSeconds: Double?, enableAutoAnswer: Bool?) {
        self.alertingTimeoutSeconds = alertingTimeoutSeconds
        self.autoAnswerAlertToneSeconds = autoAnswerAlertToneSeconds
        self.manualAnswerAlertToneSeconds = manualAnswerAlertToneSeconds
        self.enableAutoAnswer = enableAutoAnswer
    }


}




public class CopyAttachmentsRequest: Codable {





    /** A reference to the email message within the current conversation that owns the attachments to be copied */
    public var sourceMessage: DomainEntityRef?
    /** A list of attachments that will be copied from the source message to the current draft */
    public var attachments: [Attachment]?

    public init(sourceMessage: DomainEntityRef?, attachments: [Attachment]?) {
        self.sourceMessage = sourceMessage
        self.attachments = attachments
    }


}




public class CreateBenefitAssessmentRequest: Codable {



    /** The list of queue ids that are to be assessed for Predictive Routing benefit. */
    public var queueIds: [String]?

    public init(queueIds: [String]?) {
        self.queueIds = queueIds
    }


}




public class CreateCallbackOnConversationCommand: Codable {























    /** The identifier of the script to be used for the callback */
    public var scriptId: String?
    /** The identifier of the queue to be used for the callback. Either queueId or routingData is required. */
    public var queueId: String?
    /** The routing data to be used for the callback. Either queueId or routingData is required. */
    public var routingData: RoutingData?
    /** The name of the party to be called back. */
    public var callbackUserName: String?
    /** A list of phone numbers for the callback. */
    public var callbackNumbers: [String]?
    /** The scheduled date-time for the callback as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss.SSSZ */
    public var callbackScheduledTime: Date?
    /** The country code to be associated with the callback numbers. */
    public var countryCode: String?
    /** Whether or not to validate the callback numbers for phone number format. */
    public var validateCallbackNumbers: Bool?
    /** A map of key-value pairs containing additional data that can be associated to the callback. These values will appear in the attributes property on the conversation participant. Example: { \"notes\": \"ready to close the deal!\", \"customerPreferredName\": \"Doc\" } */
    public var data: [String:String]?
    /** The phone number displayed to recipients when a phone call is placed as part of the callback. Must conform to the E.164 format. May be overridden by other settings in the system such as external trunk settings. Telco support for \"callerId\" varies. */
    public var callerId: String?
    /** The name displayed to recipients when a phone call is placed as part of the callback. May be overridden by other settings in the system such as external trunk settings. Telco support for \"callerIdName\" varies. */
    public var callerIdName: String?

    public init(scriptId: String?, queueId: String?, routingData: RoutingData?, callbackUserName: String?, callbackNumbers: [String]?, callbackScheduledTime: Date?, countryCode: String?, validateCallbackNumbers: Bool?, data: [String:String]?, callerId: String?, callerIdName: String?) {
        self.scriptId = scriptId
        self.queueId = queueId
        self.routingData = routingData
        self.callbackUserName = callbackUserName
        self.callbackNumbers = callbackNumbers
        self.callbackScheduledTime = callbackScheduledTime
        self.countryCode = countryCode
        self.validateCallbackNumbers = validateCallbackNumbers
        self.data = data
        self.callerId = callerId
        self.callerIdName = callerIdName
    }


}




public class CreateCallbackResponse: Codable {





    /** The conversation associated with the callback */
    public var conversation: DomainEntityRef?
    /** The list of communication identifiers for the callback participants */
    public var callbackIdentifiers: [CallbackIdentifier]?

    public init(conversation: DomainEntityRef?, callbackIdentifiers: [CallbackIdentifier]?) {
        self.conversation = conversation
        self.callbackIdentifiers = callbackIdentifiers
    }


}



/** Create coaching appointment request */

public class CreateCoachingAppointmentRequest: Codable {

























    /** The name of coaching appointment. */
    public var name: String?
    /** The description of coaching appointment. */
    public var _description: String?
    /** The date/time the coaching appointment starts. Times will be rounded down to the minute. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateStart: Date?
    /** The duration of coaching appointment in minutes. */
    public var lengthInMinutes: Int?
    /** The facilitator ID of coaching appointment. */
    public var facilitatorId: String?
    /** IDs of attendees in the coaching appointment. */
    public var attendeeIds: [String]?
    /** IDs of conversations associated with this coaching appointment. */
    public var conversationIds: [String]?
    /** IDs of documents associated with this coaching appointment. */
    public var documentIds: [String]?
    /** The Workforce Management schedule the appointment is associated with. */
    public var wfmSchedule: WfmScheduleReference?
    /** The list of external links related to the appointment */
    public var externalLinks: [String]?
    /** The location of the appointment */
    public var location: String?
    /** Whether to share the insight data */
    public var shareInsightsData: Bool?

    public init(name: String?, _description: String?, dateStart: Date?, lengthInMinutes: Int?, facilitatorId: String?, attendeeIds: [String]?, conversationIds: [String]?, documentIds: [String]?, wfmSchedule: WfmScheduleReference?, externalLinks: [String]?, location: String?, shareInsightsData: Bool?) {
        self.name = name
        self._description = _description
        self.dateStart = dateStart
        self.lengthInMinutes = lengthInMinutes
        self.facilitatorId = facilitatorId
        self.attendeeIds = attendeeIds
        self.conversationIds = conversationIds
        self.documentIds = documentIds
        self.wfmSchedule = wfmSchedule
        self.externalLinks = externalLinks
        self.location = location
        self.shareInsightsData = shareInsightsData
    }

    public enum CodingKeys: String, CodingKey { 
        case name
        case _description = "description"
        case dateStart
        case lengthInMinutes
        case facilitatorId
        case attendeeIds
        case conversationIds
        case documentIds
        case wfmSchedule
        case externalLinks
        case location
        case shareInsightsData
    }


}




public class CreateEmailRequest: Codable {

























    public enum Direction: String, Codable { 
        case outbound = "OUTBOUND"
        case inbound = "INBOUND"
    }









    /** The ID of the queue to use for routing the email conversation. This field is mutually exclusive with flowId */
    public var queueId: String?
    /** The ID of the flow to use for routing email conversation. This field is mutually exclusive with queueId */
    public var flowId: String?
    /** The name of the provider that is sourcing the emails. The Provider \"PureCloud Email\" is reserved for native emails. */
    public var provider: String?
    /** The list of skill ID's to use for routing. */
    public var skillIds: [String]?
    /** The ID of the language to use for routing. */
    public var languageId: String?
    /** The priority to assign to the conversation for routing. */
    public var priority: Int64?
    /** The list of attributes to associate with the customer participant. */
    public var attributes: [String:String]?
    /** The email address of the recipient of the email. */
    public var toAddress: String?
    /** The name of the recipient of the email. */
    public var toName: String?
    /** The email address of the sender of the email. */
    public var fromAddress: String?
    /** The name of the sender of the email. */
    public var fromName: String?
    /** The subject of the email */
    public var subject: String?
    /** Specify OUTBOUND to send an email on behalf of a queue, or INBOUND to create an external conversation. An external conversation is one where the provider is not PureCloud based. */
    public var direction: Direction?
    /** An HTML body content of the email. */
    public var htmlBody: String?
    /** A text body content of the email. */
    public var textBody: String?
    /** The external contact with which the email should be associated. This field is only valid for OUTBOUND email. */
    public var externalContactId: String?
    /** Optional. The ID of the label to controls the number of agent interactions for INBOUND communications */
    public var utilizationLabel: String?

    public init(queueId: String?, flowId: String?, provider: String?, skillIds: [String]?, languageId: String?, priority: Int64?, attributes: [String:String]?, toAddress: String?, toName: String?, fromAddress: String?, fromName: String?, subject: String?, direction: Direction?, htmlBody: String?, textBody: String?, externalContactId: String?, utilizationLabel: String?) {
        self.queueId = queueId
        self.flowId = flowId
        self.provider = provider
        self.skillIds = skillIds
        self.languageId = languageId
        self.priority = priority
        self.attributes = attributes
        self.toAddress = toAddress
        self.toName = toName
        self.fromAddress = fromAddress
        self.fromName = fromName
        self.subject = subject
        self.direction = direction
        self.htmlBody = htmlBody
        self.textBody = textBody
        self.externalContactId = externalContactId
        self.utilizationLabel = utilizationLabel
    }


}




public class CreateObjective: Codable {











    public enum MediaTypes: String, Codable { 
        case callback = "callback"
        case chat = "chat"
        case cobrowse = "cobrowse"
        case email = "email"
        case internalmessage = "internalmessage"
        case message = "message"
        case screenshare = "screenshare"
        case unknown = "unknown"
        case video = "video"
        case voice = "voice"
    }



    public enum TopicIdsFilterType: String, Codable { 
        case and = "and"
        case or = "or"
    }



    public enum InitialDirection: String, Codable { 
        case inbound = "inbound"
        case outbound = "outbound"
    }



    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The id of this objective's base template */
    public var templateId: String?
    /** Objective zone specifies min,max points and values for the associated metric */
    public var zones: [ObjectiveZone]?
    /** A flag for whether this objective is enabled for the related metric */
    public var enabled: Bool?
    /** A list of topic ids for detected topic metrics */
    public var topicIds: [String]?
    /** A list of media types for the metric */
    public var mediaTypes: [MediaTypes]?
    /** A list of queue ids for the metric */
    public var queueIds: [String]?
    /** A filter type for topic Ids. It's only used for objectives with topicIds. Default filter behavior is \"or\". */
    public var topicIdsFilterType: TopicIdsFilterType?
    /** The ids of associated evaluation form context, for Quality Evaluation Score metrics */
    public var evaluationFormContextIds: [String]?
    /** The initial direction to filter on */
    public var initialDirection: InitialDirection?
    /** start date of the objective. Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd */
    public var dateStart: Date?

    public init(_id: String?, templateId: String?, zones: [ObjectiveZone]?, enabled: Bool?, topicIds: [String]?, mediaTypes: [MediaTypes]?, queueIds: [String]?, topicIdsFilterType: TopicIdsFilterType?, evaluationFormContextIds: [String]?, initialDirection: InitialDirection?, dateStart: Date?) {
        self._id = _id
        self.templateId = templateId
        self.zones = zones
        self.enabled = enabled
        self.topicIds = topicIds
        self.mediaTypes = mediaTypes
        self.queueIds = queueIds
        self.topicIdsFilterType = topicIdsFilterType
        self.evaluationFormContextIds = evaluationFormContextIds
        self.initialDirection = initialDirection
        self.dateStart = dateStart
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case templateId
        case zones
        case enabled
        case topicIds
        case mediaTypes
        case queueIds
        case topicIdsFilterType
        case evaluationFormContextIds
        case initialDirection
        case dateStart
    }


}




public class CreatePlanningGroupRequest: Codable {







    /** The name of the planning group */
    public var name: String?
    /** Set of route paths to associate with the planning group */
    public var routePaths: [RoutePathRequest]?
    /** The ID of the service goal template to associate with this planning group */
    public var serviceGoalTemplateId: String?

    public init(name: String?, routePaths: [RoutePathRequest]?, serviceGoalTemplateId: String?) {
        self.name = name
        self.routePaths = routePaths
        self.serviceGoalTemplateId = serviceGoalTemplateId
    }


}




public class CreateRecognition: Codable {



    public enum ModelType: String, Codable { 
        case thankYou = "ThankYou"
        case congratulations = "Congratulations"
        case highPerformance = "HighPerformance"
        case companyValues = "CompanyValues"
    }





    public enum ContextType: String, Codable { 
        case interaction = "Interaction"
        case insights = "Insights"
        case development = "Development"
        case scorecard = "Scorecard"
    }



    /** The recipient of the recognition */
    public var recipientId: String?
    /** The type of the recognition */
    public var type: ModelType?
    /** The title of the recognition. Max length of 100 characters (optional) */
    public var title: String?
    /** The note of the recognition. Max length of 800 characters (optional) */
    public var note: String?
    /** The context type (optional) */
    public var contextType: ContextType?
    /** The context id (optional) */
    public var contextId: String?

    public init(recipientId: String?, type: ModelType?, title: String?, note: String?, contextType: ContextType?, contextId: String?) {
        self.recipientId = recipientId
        self.type = type
        self.title = title
        self.note = note
        self.contextType = contextType
        self.contextId = contextId
    }


}




public class CreateRoomRequest: Codable {







    /** Room's description */
    public var _description: String?
    /** Room's subject */
    public var subject: String?
    /** Users to add to the room */
    public var userIds: [String]?

    public init(_description: String?, subject: String?, userIds: [String]?) {
        self._description = _description
        self.subject = subject
        self.userIds = userIds
    }

    public enum CodingKeys: String, CodingKey { 
        case _description = "description"
        case subject
        case userIds
    }


}




public class CreateStaffingGroupAllocation: Codable {









    /** The ID of the staffing group used in this capacity plan */
    public var staffingGroupId: String?
    /** The shrinkage percentage of the staffing group that can be used for all weeks in the planning period, in the scale of 0 - 100 */
    public var initialShrinkagePercentage: Double?
    /** The attrition percentage of the staffing group that can be used for all weeks in the planning period, in the scale of 0 - 100 */
    public var initialAttritionPercentage: Double?
    /** The weekly count of full time equivalent agents in the staffing group that can be used for the first week of the planning period */
    public var startingWeeklyFullTimeEquivalentCount: Double?

    public init(staffingGroupId: String?, initialShrinkagePercentage: Double?, initialAttritionPercentage: Double?, startingWeeklyFullTimeEquivalentCount: Double?) {
        self.staffingGroupId = staffingGroupId
        self.initialShrinkagePercentage = initialShrinkagePercentage
        self.initialAttritionPercentage = initialAttritionPercentage
        self.startingWeeklyFullTimeEquivalentCount = startingWeeklyFullTimeEquivalentCount
    }


}




public class CreateStaffingGroupRequest: Codable {









    /** The name of the staffing group */
    public var name: String?
    /** The set of user IDs to associate with the staffing group */
    public var userIds: [String]?
    /** The ID of the management unit to which the staffing group users belong. If undefined the staffing group can include users from the entire business unit */
    public var managementUnitId: String?
    /** The set of planning group IDs to associate with the staffing group */
    public var planningGroupIds: [String]?

    public init(name: String?, userIds: [String]?, managementUnitId: String?, planningGroupIds: [String]?) {
        self.name = name
        self.userIds = userIds
        self.managementUnitId = managementUnitId
        self.planningGroupIds = planningGroupIds
    }


}




public class CreateTimeOffLimitRequest: Codable {

    public enum Granularity: String, Codable { 
        case daily = "Daily"
    }



    /** Granularity choice for time off limit. If not specified, 'Daily' is assumed */
    public var granularity: Granularity?
    /** The default limit value in minutes per granularity. If not specified, then 0 is assumed, which means there are no time off minutes available */
    public var defaultLimitMinutes: Int?

    public init(granularity: Granularity?, defaultLimitMinutes: Int?) {
        self.granularity = granularity
        self.defaultLimitMinutes = defaultLimitMinutes
    }


}




public class CreateTimeOffPlanManagementUnitAssociation: Codable {





    /** The ID of the management unit to which this time-off plan belongs */
    public var managementUnitId: String?
    /** A IDs of staffing groups to which this time-off plan applies. If not defined, the plan is applied to the management unit */
    public var staffingGroupIds: [String]?

    public init(managementUnitId: String?, staffingGroupIds: [String]?) {
        self.managementUnitId = managementUnitId
        self.staffingGroupIds = staffingGroupIds
    }


}




public class CreateUploadSourceUrlJobRequest: Codable {



    /** The URL of the content to upload. */
    public var uploadUrl: String?

    public init(uploadUrl: String?) {
        self.uploadUrl = uploadUrl
    }


}




public class Credential: Codable {











    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** The type of credential. */
    public var type: CredentialType?
    public var credentialFields: [String:String]?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, type: CredentialType?, credentialFields: [String:String]?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.type = type
        self.credentialFields = credentialFields
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case type
        case credentialFields
        case selfUri
    }


}



/** Specifies the requirements for a credential that can be provided for configuring an integration */

public class CredentialSpecification: Codable {







    /** Indicates if the credential must be provided in order for the integration configuration to be valid. */
    public var _required: Bool?
    /** Title describing the usage for this credential. */
    public var title: String?
    /** List of acceptable credential types that can be provided for this credential. */
    public var credentialTypes: [String]?

    public init(_required: Bool?, title: String?, credentialTypes: [String]?) {
        self._required = _required
        self.title = title
        self.credentialTypes = credentialTypes
    }

    public enum CodingKeys: String, CodingKey { 
        case _required = "required"
        case title
        case credentialTypes
    }


}




public class Criteria: Codable {







    public enum Operator: String, Codable { 
        case containsall = "containsAll"
        case containsany = "containsAny"
        case notcontainsall = "notContainsAll"
        case notcontainsany = "notContainsAny"
        case equal = "equal"
        case notequal = "notEqual"
        case greaterthan = "greaterThan"
        case greaterthanorequal = "greaterThanOrEqual"
        case lessthan = "lessThan"
        case lessthanorequal = "lessThanOrEqual"
        case startswith = "startsWith"
        case endswith = "endsWith"
    }

    /** The criteria key. */
    public var key: String?
    /** The criteria values. */
    public var values: [String]?
    /** Should criteria be case insensitive. */
    public var shouldIgnoreCase: Bool?
    /** The comparison operator. */
    public var _operator: Operator?

    public init(key: String?, values: [String]?, shouldIgnoreCase: Bool?, _operator: Operator?) {
        self.key = key
        self.values = values
        self.shouldIgnoreCase = shouldIgnoreCase
        self._operator = _operator
    }

    public enum CodingKeys: String, CodingKey { 
        case key
        case values
        case shouldIgnoreCase
        case _operator = "operator"
    }


}



/** A group of logical or a singular criteria used to create a query of executionData */

public class CriteriaGroup: Codable {









    /** These criteriaItems will be AND'd together to find a match. */
    public var and: [CriteriaItem]?
    /** These criteriaItems will be OR'd together to find a match. */
    public var or: [CriteriaItem]?
    /** These criteriaItems must all be false to find a match. */
    public var not: [CriteriaItem]?
    /** A singular critieriaItem to match. */
    public var criteria: CriteriaItem?

    public init(and: [CriteriaItem]?, or: [CriteriaItem]?, not: [CriteriaItem]?, criteria: CriteriaItem?) {
        self.and = and
        self.or = or
        self.not = not
        self.criteria = criteria
    }


}




public class CrossPlatformPolicyActions: Codable {





















    /** true to retain the recording associated with the conversation. Default = true */
    public var retainRecording: Bool?
    /** true to delete the recording associated with the conversation. If retainRecording = true, this will be ignored. Default = false */
    public var deleteRecording: Bool?
    /** true to delete the recording associated with the conversation regardless of the values of retainRecording or deleteRecording. Default = false */
    public var alwaysDelete: Bool?
    public var assignEvaluations: [EvaluationAssignment]?
    public var assignMeteredEvaluations: [MeteredEvaluationAssignment]?
    public var assignMeteredAssignmentByAgent: [MeteredAssignmentByAgent]?
    public var assignCalibrations: [CalibrationAssignment]?
    public var retentionDuration: RetentionDuration?
    public var mediaTranscriptions: [MediaTranscription]?
    /** Policy action for exporting recordings using an integration to 3rd party s3. */
    public var integrationExport: IntegrationExport?

    public init(retainRecording: Bool?, deleteRecording: Bool?, alwaysDelete: Bool?, assignEvaluations: [EvaluationAssignment]?, assignMeteredEvaluations: [MeteredEvaluationAssignment]?, assignMeteredAssignmentByAgent: [MeteredAssignmentByAgent]?, assignCalibrations: [CalibrationAssignment]?, retentionDuration: RetentionDuration?, mediaTranscriptions: [MediaTranscription]?, integrationExport: IntegrationExport?) {
        self.retainRecording = retainRecording
        self.deleteRecording = deleteRecording
        self.alwaysDelete = alwaysDelete
        self.assignEvaluations = assignEvaluations
        self.assignMeteredEvaluations = assignMeteredEvaluations
        self.assignMeteredAssignmentByAgent = assignMeteredAssignmentByAgent
        self.assignCalibrations = assignCalibrations
        self.retentionDuration = retentionDuration
        self.mediaTranscriptions = mediaTranscriptions
        self.integrationExport = integrationExport
    }


}




public class CrossPlatformPolicyCreate: Codable {

























    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The policy name. */
    public var name: String?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var modifiedDate: Date?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var createdDate: Date?
    public var order: Int?
    public var _description: String?
    public var enabled: Bool?
    /** Conditions and actions per media type */
    public var mediaPolicies: CrossPlatformMediaPolicies?
    /** Conditions */
    public var conditions: PolicyConditions?
    /** Actions */
    public var actions: CrossPlatformPolicyActions?
    public var policyErrors: PolicyErrors?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, modifiedDate: Date?, createdDate: Date?, order: Int?, _description: String?, enabled: Bool?, mediaPolicies: CrossPlatformMediaPolicies?, conditions: PolicyConditions?, actions: CrossPlatformPolicyActions?, policyErrors: PolicyErrors?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.modifiedDate = modifiedDate
        self.createdDate = createdDate
        self.order = order
        self._description = _description
        self.enabled = enabled
        self.mediaPolicies = mediaPolicies
        self.conditions = conditions
        self.actions = actions
        self.policyErrors = policyErrors
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case modifiedDate
        case createdDate
        case order
        case _description = "description"
        case enabled
        case mediaPolicies
        case conditions
        case actions
        case policyErrors
        case selfUri
    }


}




public class CrossPlatformPolicyUpdate: Codable {



    public var enabled: Bool?

    public init(enabled: Bool?) {
        self.enabled = enabled
    }


}




public class CsvSettings: Codable {









    /** The globally unique identifier for the object. */
    public var _id: String?
    /** Id of the external settings */
    public var externalSettingsId: String?
    /** Mappings for the transformation */
    public var mappings: [CsvMappingEntry]?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, externalSettingsId: String?, mappings: [CsvMappingEntry]?, selfUri: String?) {
        self._id = _id
        self.externalSettingsId = externalSettingsId
        self.mappings = mappings
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case externalSettingsId
        case mappings
        case selfUri
    }


}




public class CtaButtonStyleProperties: Codable {







    public enum TextAlign: String, Codable { 
        case _left = "Left"
        case _right = "Right"
        case center = "Center"
    }



    /** Color of the text. (eg. #FFFFFF) */
    public var color: String?
    /** Font of the text. (eg. Helvetica) */
    public var font: String?
    /** Font size of the text. (eg. '12') */
    public var fontSize: String?
    /** Text alignment. */
    public var textAlign: TextAlign?
    /** Background color of the CTA button. (eg. #FF0000) */
    public var backgroundColor: String?

    public init(color: String?, font: String?, fontSize: String?, textAlign: TextAlign?, backgroundColor: String?) {
        self.color = color
        self.font = font
        self.fontSize = fontSize
        self.textAlign = textAlign
        self.backgroundColor = backgroundColor
    }


}




public class CursorContactListing: Codable {











    public var entities: [ExternalContact]?
    public var nextUri: String?
    public var selfUri: String?
    public var previousUri: String?
    /** The cursor that points to the next set of entities being returned. */
    public var cursors: Cursors?

    public init(entities: [ExternalContact]?, nextUri: String?, selfUri: String?, previousUri: String?, cursors: Cursors?) {
        self.entities = entities
        self.nextUri = nextUri
        self.selfUri = selfUri
        self.previousUri = previousUri
        self.cursors = cursors
    }


}




public class CursorNoteListing: Codable {











    public var entities: [Note]?
    public var nextUri: String?
    public var selfUri: String?
    public var previousUri: String?
    /** The cursor that points to the next set of entities being returned. */
    public var cursors: Cursors?

    public init(entities: [Note]?, nextUri: String?, selfUri: String?, previousUri: String?, cursors: Cursors?) {
        self.entities = entities
        self.nextUri = nextUri
        self.selfUri = selfUri
        self.previousUri = previousUri
        self.cursors = cursors
    }


}




public class CursorRelationshipListing: Codable {











    public var entities: [Relationship]?
    public var nextUri: String?
    public var selfUri: String?
    public var previousUri: String?
    /** The cursor that points to the next set of entities being returned. */
    public var cursors: Cursors?

    public init(entities: [Relationship]?, nextUri: String?, selfUri: String?, previousUri: String?, cursors: Cursors?) {
        self.entities = entities
        self.nextUri = nextUri
        self.selfUri = selfUri
        self.previousUri = previousUri
        self.cursors = cursors
    }


}




public class CustomEventAttributeList: Codable {





    /** The data type of the custom attributes. */
    public var dataType: String?
    /** The list of custom event attribute values. */
    public var values: [String]?

    public init(dataType: String?, values: [String]?) {
        self.dataType = dataType
        self.values = values
    }


}




public class DIDPool: Codable {



















    public enum State: String, Codable { 
        case active = "active"
        case inactive = "inactive"
        case deleted = "deleted"
    }











    public enum Provider: String, Codable { 
        case pureCloud = "PURE_CLOUD"
        case pureCloudVoice = "PURE_CLOUD_VOICE"
    }



    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The name of the entity. */
    public var name: String?
    /** The division to which this entity belongs. */
    public var division: Division?
    /** The resource's description. */
    public var _description: String?
    /** The current version of the resource. */
    public var version: Int?
    /** The date the resource was created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** The date of the last modification to the resource. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** The ID of the user that last modified the resource. */
    public var modifiedBy: String?
    /** The ID of the user that created the resource. */
    public var createdBy: String?
    /** Indicates if the resource is active, inactive, or deleted. */
    public var state: State?
    /** The application that last modified the resource. */
    public var modifiedByApp: String?
    /** The application that created the resource. */
    public var createdByApp: String?
    /** The starting phone number for the range of this DID pool. Must be in E.164 format */
    public var startPhoneNumber: String?
    /** The ending phone number for the range of this DID pool. Must be in E.164 format */
    public var endPhoneNumber: String?
    public var comments: String?
    /** The provider for this DID pool */
    public var provider: Provider?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, division: Division?, _description: String?, version: Int?, dateCreated: Date?, dateModified: Date?, modifiedBy: String?, createdBy: String?, state: State?, modifiedByApp: String?, createdByApp: String?, startPhoneNumber: String?, endPhoneNumber: String?, comments: String?, provider: Provider?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.division = division
        self._description = _description
        self.version = version
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.modifiedBy = modifiedBy
        self.createdBy = createdBy
        self.state = state
        self.modifiedByApp = modifiedByApp
        self.createdByApp = createdByApp
        self.startPhoneNumber = startPhoneNumber
        self.endPhoneNumber = endPhoneNumber
        self.comments = comments
        self.provider = provider
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case division
        case _description = "description"
        case version
        case dateCreated
        case dateModified
        case modifiedBy
        case createdBy
        case state
        case modifiedByApp
        case createdByApp
        case startPhoneNumber
        case endPhoneNumber
        case comments
        case provider
        case selfUri
    }


}




public class DashboardUser: Codable {









    public enum State: String, Codable { 
        case active = "active"
        case inactive = "inactive"
    }



    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** The count of dashboards for the user */
    public var dashboardCount: Int?
    /** The count of public dashboards for the user */
    public var publicDashboardCount: Int?
    /** The state of the user */
    public var state: State?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, dashboardCount: Int?, publicDashboardCount: Int?, state: State?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.dashboardCount = dashboardCount
        self.publicDashboardCount = publicDashboardCount
        self.state = state
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case dashboardCount
        case publicDashboardCount
        case state
        case selfUri
    }


}




public class DashboardUserListing: Codable {





















    public var entities: [DashboardUser]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var previousUri: String?
    public var nextUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [DashboardUser]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, previousUri: String?, nextUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.previousUri = previousUri
        self.nextUri = nextUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class DataIngestionRuleCriteria: Codable {

    public enum EffectivePlatform: String, Codable { 
        case facebook = "Facebook"
        case instagram = "Instagram"
        case twitter = "Twitter"
        case _open = "Open"
        case googleBusinessProfile = "GoogleBusinessProfile"
    }





    /** The effective platform for the data ingestion rule. */
    public var effectivePlatform: EffectivePlatform?
    /** The ID of the data ingestion rule. */
    public var _id: String?
    /** The name of the data ingestion rule. Only populated when expanded. */
    public var name: String?

    public init(effectivePlatform: EffectivePlatform?, _id: String?, name: String?) {
        self.effectivePlatform = effectivePlatform
        self._id = _id
        self.name = name
    }

    public enum CodingKeys: String, CodingKey { 
        case effectivePlatform
        case _id = "id"
        case name
    }


}




public class DataIngestionRuleResponseEntityListing: Codable {





















    public var entities: [DataIngestionRuleResponse]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var previousUri: String?
    public var nextUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [DataIngestionRuleResponse]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, previousUri: String?, nextUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.previousUri = previousUri
        self.nextUri = nextUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}



/** State information for an import job of rows to a datatable */

public class DataTableImportJob: Codable {







    public enum Status: String, Codable { 
        case waitingForUpload = "WaitingForUpload"
        case processing = "Processing"
        case failed = "Failed"
        case succeeded = "Succeeded"
    }







    public enum ImportMode: String, Codable { 
        case replaceAll = "ReplaceAll"
        case append = "Append"
    }













    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** The PureCloud user who started the import job */
    public var owner: AddressableEntityRef?
    /** The status of the import job */
    public var status: Status?
    /** The timestamp of when the import began. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** The timestamp of when the import stopped (either successfully or unsuccessfully). Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCompleted: Date?
    /** The URL of the location at which the caller can upload the file to be imported */
    public var uploadURI: String?
    /** The indication of whether the processing should remove rows that don't appear in the import file */
    public var importMode: ImportMode?
    /** Any error information, or null of the processing is not in an error state */
    public var errorInformation: ErrorBody?
    /** The current count of the number of records processed */
    public var countRecordsUpdated: Int?
    /** The current count of the number of records deleted */
    public var countRecordsDeleted: Int?
    /** The current count of the number of records that failed to import */
    public var countRecordsFailed: Int?
    /** Required headers when uploading a file through PUT request to the URL in the 'uploadURI' field */
    public var uploadHeaders: [String:String]?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, owner: AddressableEntityRef?, status: Status?, dateCreated: Date?, dateCompleted: Date?, uploadURI: String?, importMode: ImportMode?, errorInformation: ErrorBody?, countRecordsUpdated: Int?, countRecordsDeleted: Int?, countRecordsFailed: Int?, uploadHeaders: [String:String]?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.owner = owner
        self.status = status
        self.dateCreated = dateCreated
        self.dateCompleted = dateCompleted
        self.uploadURI = uploadURI
        self.importMode = importMode
        self.errorInformation = errorInformation
        self.countRecordsUpdated = countRecordsUpdated
        self.countRecordsDeleted = countRecordsDeleted
        self.countRecordsFailed = countRecordsFailed
        self.uploadHeaders = uploadHeaders
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case owner
        case status
        case dateCreated
        case dateCompleted
        case uploadURI
        case importMode
        case errorInformation
        case countRecordsUpdated
        case countRecordsDeleted
        case countRecordsFailed
        case uploadHeaders
        case selfUri
    }


}




public class DateRangeWithOptionalEnd: Codable {





    /** The start date for work plan rotation or an agent, interpreted in the business unit's time zone. Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd */
    public var startBusinessUnitDate: Date?
    /** The end date for work plan rotation or an agent, interpreted in the business unit's time zone. Null denotes open ended date range. Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd */
    public var endBusinessUnitDate: Date?

    public init(startBusinessUnitDate: Date?, endBusinessUnitDate: Date?) {
        self.startBusinessUnitDate = startBusinessUnitDate
        self.endBusinessUnitDate = endBusinessUnitDate
    }


}



/** Must provide a valid value for exactly one of the fields in this class. */

public class DecisionTableColumnDefaultRowValue: Codable {





    public enum Special: String, Codable { 
        case wildcard = "Wildcard"
        case null = "Null"
        case empty = "Empty"
        case currentTime = "CurrentTime"
    }

    /** A default string value for this column, will be cast to appropriate type according to the relevant contract schema property. */
    public var value: String?
    /** A default list of values for this column, items will be cast to appropriate type according to the relevant contract schema property */
    public var values: [String]?
    /** A default special value enum for this column. */
    public var special: Special?

    public init(value: String?, values: [String]?, special: Special?) {
        self.value = value
        self.values = values
        self.special = special
    }


}




public class DecisionTableColumns: Codable {





    /** The input columns of the decision table. */
    public var inputs: [DecisionTableInputColumn]?
    /** The output columns of the decision table. */
    public var outputs: [DecisionTableOutputColumn]?

    public init(inputs: [DecisionTableInputColumn]?, outputs: [DecisionTableOutputColumn]?) {
        self.inputs = inputs
        self.outputs = outputs
    }


}




public class DecisionTableInputColumnExpression: Codable {



    public enum Comparator: String, Codable { 
        case equals = "Equals"
        case notEquals = "NotEquals"
        case greaterThan = "GreaterThan"
        case greaterThanOrEquals = "GreaterThanOrEquals"
        case lessThan = "LessThan"
        case lessThanOrEquals = "LessThanOrEquals"
        case startsWith = "StartsWith"
        case notStartsWith = "NotStartsWith"
        case endsWith = "EndsWith"
        case notEndsWith = "NotEndsWith"
        case contains = "Contains"
        case notContains = "NotContains"
        case containsAny = "ContainsAny"
        case notContainsAny = "NotContainsAny"
        case containsAll = "ContainsAll"
        case notContainsAll = "NotContainsAll"
        case containsExactly = "ContainsExactly"
        case notContainsExactly = "NotContainsExactly"
        case containsSequence = "ContainsSequence"
        case notContainsSequence = "NotContainsSequence"
        case isSubset = "IsSubset"
        case notIsSubset = "NotIsSubset"
        case isSubsequence = "IsSubsequence"
        case notIsSubsequence = "NotIsSubsequence"
    }

    /** A value that is defined by a contract schema and used to form the left side of a logical condition. */
    public var contractual: Contractual?
    /** A comparator used to join the left and right sides of a logical condition. */
    public var comparator: Comparator?

    public init(contractual: Contractual?, comparator: Comparator?) {
        self.contractual = contractual
        self.comparator = comparator
    }


}




public class DecisionTableRow: Codable {

















    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The decision table to which this row belongs */
    public var table: DecisionTableVersionEntity?
    /** The absolute index of this row in the decision table, starting at 1 */
    public var rowIndex: Int?
    /** The date when this row was created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** The date when this row was last modified. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** The map input values of the row being created. At least one value must be provided. The key for this map is the column ID the row value relates */
    public var inputs: [String:DecisionTableRowParameterValue]?
    /** The map output values of the row being created. At least one value must be provided. The key for this map is the column ID the row value relates */
    public var outputs: [String:DecisionTableRowParameterValue]?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, table: DecisionTableVersionEntity?, rowIndex: Int?, dateCreated: Date?, dateModified: Date?, inputs: [String:DecisionTableRowParameterValue]?, outputs: [String:DecisionTableRowParameterValue]?, selfUri: String?) {
        self._id = _id
        self.table = table
        self.rowIndex = rowIndex
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.inputs = inputs
        self.outputs = outputs
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case table
        case rowIndex
        case dateCreated
        case dateModified
        case inputs
        case outputs
        case selfUri
    }


}




public class DecisionTableRowExecutionOutput: Codable {







    /** Unique rule identifier. */
    public var rowId: String?
    /** Unique rule identifier. */
    public var rowIndex: Int?
    /** The JSON output produced by this rule. Valid according to the execution output contract. In the case of enum decision table output columns, the enum options key will be provided as the value, not the enum options label as this can be changed. For business rules queue columns both queue and id keys will always be returned  regardless of the business rules queue attribute key and these do not change. */
    public var outputs: [String:JSON]?

    public init(rowId: String?, rowIndex: Int?, outputs: [String:JSON]?) {
        self.rowId = rowId
        self.rowIndex = rowIndex
        self.outputs = outputs
    }


}




public class DecisionTableRowListing: Codable {





















    public var entities: [DecisionTableRow]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var previousUri: String?
    public var nextUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [DecisionTableRow]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, previousUri: String?, nextUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.previousUri = previousUri
        self.nextUri = nextUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class DecisionTableVersion: Codable {









    public enum Status: String, Codable { 
        case draft = "Draft"
        case published = "Published"
        case error = "Error"
        case preparing = "Preparing"
        case superseded = "Superseded"
    }



















    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** The division to which this entity belongs. */
    public var division: Division?
    /** The decision table version. */
    public var version: Int?
    /** Current status of this decision table version */
    public var status: Status?
    /** The decision table description. */
    public var _description: String?
    /** The number of rows in this decision table version. */
    public var rowCount: Int?
    /** The rows URI for this decision table version. */
    public var rowsUri: String?
    /** UTC date time indicating when this decision table version was created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** UTC date time indicating when this decision table version was last updated. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** UTC date time indicating when this decision table version was published. Null if never published. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var datePublished: Date?
    /** The column definitions of this decision table version. */
    public var columns: DecisionTableColumns?
    /** The contract information for this decision table version. */
    public var contract: DecisionTableContract?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, division: Division?, version: Int?, status: Status?, _description: String?, rowCount: Int?, rowsUri: String?, dateCreated: Date?, dateModified: Date?, datePublished: Date?, columns: DecisionTableColumns?, contract: DecisionTableContract?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.division = division
        self.version = version
        self.status = status
        self._description = _description
        self.rowCount = rowCount
        self.rowsUri = rowsUri
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.datePublished = datePublished
        self.columns = columns
        self.contract = contract
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case division
        case version
        case status
        case _description = "description"
        case rowCount
        case rowsUri
        case dateCreated
        case dateModified
        case datePublished
        case columns
        case contract
        case selfUri
    }


}




public class DecisionTableVersionListing: Codable {









    public var entities: [DecisionTableVersion]?
    public var nextUri: String?
    public var selfUri: String?
    public var previousUri: String?

    public init(entities: [DecisionTableVersion]?, nextUri: String?, selfUri: String?, previousUri: String?) {
        self.entities = entities
        self.nextUri = nextUri
        self.selfUri = selfUri
        self.previousUri = previousUri
    }


}




public class DeletableUserReference: Codable {







    /** The globally unique identifier for the object. */
    public var _id: String?
    /** If marked true, the user will be removed an associated entity */
    public var delete: Bool?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, delete: Bool?, selfUri: String?) {
        self._id = _id
        self.delete = delete
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case delete
        case selfUri
    }


}




public class DependencyObjectEntityListing: Codable {





















    public var entities: [DependencyObject]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var previousUri: String?
    public var nextUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [DependencyObject]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, previousUri: String?, nextUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.previousUri = previousUri
        self.nextUri = nextUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class DeploymentWebAction: Codable {



    public enum MediaType: String, Codable { 
        case webchat = "webchat"
        case webmessagingoffer = "webMessagingOffer"
        case contentoffer = "contentOffer"
        case integrationaction = "integrationAction"
        case architectflow = "architectFlow"
        case openaction = "openAction"
    }

















    /** System-generated UUID for the action. */
    public var _id: String?
    /** Action media type used to deliver the action. */
    public var mediaType: MediaType?
    /** ID string of the customer that the action was triggered for. */
    public var customerId: String?
    /** Type of the customer ID that the action was triggered for. */
    public var customerIdType: String?
    /** ID of the action map that triggered the action. */
    public var actionMapId: String?
    /** Version of the action map that triggered the action. */
    public var actionMapVersion: Int?
    /** ID of the session that the action was triggered for. */
    public var sessionId: String?
    /** Web messaging offer specific properties. */
    public var webMessagingOfferProperties: WebMessagingOfferProperties?
    /** Content offer specific properties. */
    public var contentOfferProperties: ContentOffer?
    /** Open action specific properties. */
    public var openActionProperties: OpenActionProperties?

    public init(_id: String?, mediaType: MediaType?, customerId: String?, customerIdType: String?, actionMapId: String?, actionMapVersion: Int?, sessionId: String?, webMessagingOfferProperties: WebMessagingOfferProperties?, contentOfferProperties: ContentOffer?, openActionProperties: OpenActionProperties?) {
        self._id = _id
        self.mediaType = mediaType
        self.customerId = customerId
        self.customerIdType = customerIdType
        self.actionMapId = actionMapId
        self.actionMapVersion = actionMapVersion
        self.sessionId = sessionId
        self.webMessagingOfferProperties = webMessagingOfferProperties
        self.contentOfferProperties = contentOfferProperties
        self.openActionProperties = openActionProperties
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case mediaType
        case customerId
        case customerIdType
        case actionMapId
        case actionMapVersion
        case sessionId
        case webMessagingOfferProperties
        case contentOfferProperties
        case openActionProperties
    }


}




public class Destination: Codable {









    /** Address or phone number. */
    public var address: String?
    /** The name of the internal user. */
    public var name: String?
    /** The user ID. */
    public var userId: String?
    /** The queue ID. */
    public var queueId: String?

    public init(address: String?, name: String?, userId: String?, queueId: String?) {
        self.address = address
        self.name = name
        self.userId = userId
        self.queueId = queueId
    }


}




public class DetectedDialogAct: Codable {





    /** The name of the detected dialog act. */
    public var name: String?
    /** The probability of the detected dialog act. */
    public var probability: Double?

    public init(name: String?, probability: Double?) {
        self.name = name
        self.probability = probability
    }


}




public class DetectedNamedEntity: Codable {









    /** The name of the detected named entity. */
    public var name: String?
    /** The type of the detected named entity. */
    public var entityType: String?
    /** The probability of the detected named entity. */
    public var probability: Double?
    /** The value of the detected named entity. */
    public var value: DetectedNamedEntityValue?

    public init(name: String?, entityType: String?, probability: Double?, value: DetectedNamedEntityValue?) {
        self.name = name
        self.entityType = entityType
        self.probability = probability
        self.value = value
    }


}




public class DialerAction: Codable {

    public enum ModelType: String, Codable { 
        case action = "Action"
        case modifycontactattribute = "modifyContactAttribute"
        case dataactionbehavior = "dataActionBehavior"
    }

    public enum ActionTypeName: String, Codable { 
        case doNotDial = "DO_NOT_DIAL"
        case modifyContactAttribute = "MODIFY_CONTACT_ATTRIBUTE"
        case switchToPreview = "SWITCH_TO_PREVIEW"
        case appendNumberToDncList = "APPEND_NUMBER_TO_DNC_LIST"
        case appendCustomEntryToDncList = "APPEND_CUSTOM_ENTRY_TO_DNC_LIST"
        case scheduleCallback = "SCHEDULE_CALLBACK"
        case contactUncallable = "CONTACT_UNCALLABLE"
        case numberUncallable = "NUMBER_UNCALLABLE"
        case setCallerId = "SET_CALLER_ID"
        case setSkills = "SET_SKILLS"
        case dataAction = "DATA_ACTION"
    }

    public enum UpdateOption: String, Codable { 
        case _set = "SET"
        case increment = "INCREMENT"
        case decrement = "DECREMENT"
        case currentTime = "CURRENT_TIME"
    }













    /** The type of this DialerAction. */
    public var type: ModelType?
    /** Additional type specification for this DialerAction. */
    public var actionTypeName: ActionTypeName?
    /** Specifies how a contact attribute should be updated. Required for MODIFY_CONTACT_ATTRIBUTE. */
    public var updateOption: UpdateOption?
    /** A map of key-value pairs pertinent to the DialerAction. Different types of DialerActions require different properties. MODIFY_CONTACT_ATTRIBUTE with an updateOption of SET takes a contact column as the key and accepts any value. SCHEDULE_CALLBACK takes a key 'callbackOffset' that specifies how far in the future the callback should be scheduled, in minutes. SET_CALLER_ID takes two keys: 'callerAddress', which should be the caller id phone number, and 'callerName'. For either key, you can also specify a column on the contact to get the value from. To do this, specify 'contact.Column', where 'Column' is the name of the contact column from which to get the value. SET_SKILLS takes a key 'skills' with an array of skill ids wrapped into a string (Example: {'skills': '['skillIdHere']'} ). */
    public var properties: [String:String]?
    /** The Data Action to use for this action. Required for a dataActionBehavior. */
    public var dataAction: DomainEntityRef?
    /** A list of mappings defining which contact data fields will be passed to which data action input fields for this condition. Valid for a dataActionBehavior. */
    public var contactColumnToDataActionFieldMappings: [ContactColumnToDataActionFieldMapping]?
    /** The input field from the data action that the contactId will be passed to for this condition. Valid for a dataActionBehavior. */
    public var contactIdField: String?
    /** The input field from the data action that the callAnalysisResult will be passed to for this condition. Valid for a wrapup dataActionBehavior. */
    public var callAnalysisResultField: String?
    /** The input field from the data action that the agentWrapup will be passed to for this condition. Valid for a wrapup dataActionBehavior. */
    public var agentWrapupField: String?

    public init(type: ModelType?, actionTypeName: ActionTypeName?, updateOption: UpdateOption?, properties: [String:String]?, dataAction: DomainEntityRef?, contactColumnToDataActionFieldMappings: [ContactColumnToDataActionFieldMapping]?, contactIdField: String?, callAnalysisResultField: String?, agentWrapupField: String?) {
        self.type = type
        self.actionTypeName = actionTypeName
        self.updateOption = updateOption
        self.properties = properties
        self.dataAction = dataAction
        self.contactColumnToDataActionFieldMappings = contactColumnToDataActionFieldMappings
        self.contactIdField = contactIdField
        self.callAnalysisResultField = callAnalysisResultField
        self.agentWrapupField = agentWrapupField
    }


}




public class DialerAttemptLimitsConfigChangeRecallEntry: Codable {









    /** The number of recall attempts to make */
    public var nbrAttempts: Int64?
    /** How long to wait between recall attempts */
    public var minutesBetweenAttempts: Int64?
    public var additionalProperties: [String:JSON]?
    public var getAdditionalProperties: [String:JSON]?

    public init(nbrAttempts: Int64?, minutesBetweenAttempts: Int64?, additionalProperties: [String:JSON]?, getAdditionalProperties: [String:JSON]?) {
        self.nbrAttempts = nbrAttempts
        self.minutesBetweenAttempts = minutesBetweenAttempts
        self.additionalProperties = additionalProperties
        self.getAdditionalProperties = getAdditionalProperties
    }


}




public class DialerCampaignConfigChangeRestErrorDetail: Codable {









    /** name of the error */
    public var error: String?
    /** additional information regarding the error */
    public var details: String?
    public var additionalProperties: [String:JSON]?
    public var getAdditionalProperties: [String:JSON]?

    public init(error: String?, details: String?, additionalProperties: [String:JSON]?, getAdditionalProperties: [String:JSON]?) {
        self.error = error
        self.details = details
        self.additionalProperties = additionalProperties
        self.getAdditionalProperties = getAdditionalProperties
    }


}




public class DialerCampaignRuleConfigChangeCampaignRule: Codable {

























    public var campaignRuleEntities: DialerCampaignRuleConfigChangeCampaignRuleEntities?
    /** The list of conditions that will trigger this Campaign Rule */
    public var campaignRuleConditions: [DialerCampaignRuleConfigChangeCampaignRuleCondition]?
    /** The list of actions that will be taken when this Campaign Rule's conditions are met */
    public var campaignRuleActions: [DialerCampaignRuleConfigChangeCampaignRuleAction]?
    /** Whether this Campaign Rule should match any conditions (inclusive OR) or match all conditions (ALL) */
    public var matchAnyConditions: Bool?
    /** Whether this campaign rule is enabled */
    public var enabled: Bool?
    public var additionalProperties: [String:JSON]?
    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The UI-visible name of the object */
    public var name: String?
    /** Creation time of the entity */
    public var dateCreated: Date?
    /** Last modified time of the entity */
    public var dateModified: Date?
    /** Required for updates, must match the version number of the most recent update */
    public var version: Int64?
    public var getAdditionalProperties: [String:JSON]?

    public init(campaignRuleEntities: DialerCampaignRuleConfigChangeCampaignRuleEntities?, campaignRuleConditions: [DialerCampaignRuleConfigChangeCampaignRuleCondition]?, campaignRuleActions: [DialerCampaignRuleConfigChangeCampaignRuleAction]?, matchAnyConditions: Bool?, enabled: Bool?, additionalProperties: [String:JSON]?, _id: String?, name: String?, dateCreated: Date?, dateModified: Date?, version: Int64?, getAdditionalProperties: [String:JSON]?) {
        self.campaignRuleEntities = campaignRuleEntities
        self.campaignRuleConditions = campaignRuleConditions
        self.campaignRuleActions = campaignRuleActions
        self.matchAnyConditions = matchAnyConditions
        self.enabled = enabled
        self.additionalProperties = additionalProperties
        self._id = _id
        self.name = name
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.version = version
        self.getAdditionalProperties = getAdditionalProperties
    }

    public enum CodingKeys: String, CodingKey { 
        case campaignRuleEntities
        case campaignRuleConditions
        case campaignRuleActions
        case matchAnyConditions
        case enabled
        case additionalProperties
        case _id = "id"
        case name
        case dateCreated
        case dateModified
        case version
        case getAdditionalProperties
    }


}




public class DialerCampaignRuleConfigChangeCampaignRuleCondition: Codable {





    public enum ConditionType: String, Codable { 
        case campaignprogress = "campaignProgress"
        case campaignagents = "campaignAgents"
    }





    /** The globally unique identifier for the condition */
    public var _id: String?
    /** The parameters to match this condition */
    public var parameters: [String:String]?
    /** The type of this condition */
    public var conditionType: ConditionType?
    public var additionalProperties: [String:JSON]?
    public var getAdditionalProperties: [String:JSON]?

    public init(_id: String?, parameters: [String:String]?, conditionType: ConditionType?, additionalProperties: [String:JSON]?, getAdditionalProperties: [String:JSON]?) {
        self._id = _id
        self.parameters = parameters
        self.conditionType = conditionType
        self.additionalProperties = additionalProperties
        self.getAdditionalProperties = getAdditionalProperties
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case parameters
        case conditionType
        case additionalProperties
        case getAdditionalProperties
    }


}




public class DialerCampaignScheduleConfigChangeAlteration: Codable {

    public enum ModelType: String, Codable { 
        case exclusion = "Exclusion"
        case inclusion = "Inclusion"
    }









    public var type: ModelType?
    /** the end date of an alteration range as an ISO-8601 string */
    public var start: String?
    /** the end date of an alteration range as an ISO-8601 string */
    public var end: String?
    public var additionalProperties: [String:JSON]?
    public var getAdditionalProperties: [String:JSON]?

    public init(type: ModelType?, start: String?, end: String?, additionalProperties: [String:JSON]?, getAdditionalProperties: [String:JSON]?) {
        self.type = type
        self.start = start
        self.end = end
        self.additionalProperties = additionalProperties
        self.getAdditionalProperties = getAdditionalProperties
    }


}




public class DialerCampaignScheduleConfigChangeCampaignSchedule: Codable {























    /** a list of start and end times */
    public var intervals: [DialerCampaignScheduleConfigChangeScheduleInterval]?
    /** a list of recurrences for a schedule */
    public var recurrences: [DialerCampaignScheduleConfigChangeScheduleRecurrence]?
    /** time zone identifier to be applied to the intervals; for example Africa/Abidjan */
    public var timeZone: String?
    public var campaign: DialerCampaignScheduleConfigChangeUriReference?
    public var additionalProperties: [String:JSON]?
    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The UI-visible name of the object */
    public var name: String?
    /** Creation time of the entity */
    public var dateCreated: Date?
    /** Last modified time of the entity */
    public var dateModified: Date?
    /** Required for updates, must match the version number of the most recent update */
    public var version: Int64?
    public var getAdditionalProperties: [String:JSON]?

    public init(intervals: [DialerCampaignScheduleConfigChangeScheduleInterval]?, recurrences: [DialerCampaignScheduleConfigChangeScheduleRecurrence]?, timeZone: String?, campaign: DialerCampaignScheduleConfigChangeUriReference?, additionalProperties: [String:JSON]?, _id: String?, name: String?, dateCreated: Date?, dateModified: Date?, version: Int64?, getAdditionalProperties: [String:JSON]?) {
        self.intervals = intervals
        self.recurrences = recurrences
        self.timeZone = timeZone
        self.campaign = campaign
        self.additionalProperties = additionalProperties
        self._id = _id
        self.name = name
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.version = version
        self.getAdditionalProperties = getAdditionalProperties
    }

    public enum CodingKeys: String, CodingKey { 
        case intervals
        case recurrences
        case timeZone
        case campaign
        case additionalProperties
        case _id = "id"
        case name
        case dateCreated
        case dateModified
        case version
        case getAdditionalProperties
    }


}




public class DialerContact: Codable {































    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** The identifier of the contact list containing this contact. */
    public var contactListId: String?
    /** An ordered map of the contact's columns and corresponding values. */
    public var data: [String:String]?
    /** A map of call records for the contact phone columns. */
    public var callRecords: [String:CallRecord]?
    /** A map of SMS records for the contact phone columns. */
    public var latestSmsEvaluations: [String:MessageEvaluation]?
    /** A map of email records for the contact email columns. */
    public var latestEmailEvaluations: [String:MessageEvaluation]?
    /** A map of whatsapp records for the contact whatsapp columns. */
    public var latestWhatsAppEvaluations: [String:MessageEvaluation]?
    /** Indicates whether or not the contact can be called. */
    public var callable: Bool?
    /** A map of phone number columns to PhoneNumberStatuses, which indicate if the phone number is callable or not. */
    public var phoneNumberStatus: [String:PhoneNumberStatus]?
    /** A map of media types (Voice, SMS and Email) to ContactableStatus, which indicates if the contact can be contacted using the specified media type. */
    public var contactableStatus: [String:ContactableStatus]?
    /** Map containing data about the timezone the contact is mapped to. This will only be populated if the contact list has automatic timezone mapping turned on. The key is the column name. The value is the timezone it mapped to and the type of column: Phone or Zip */
    public var contactColumnTimeZones: [String:ContactColumnTimeZone]?
    /** the priority property within ConfigurationOverides indicates whether or not the contact to be placed in front of the queue or at the end of the queue */
    public var configurationOverrides: ConfigurationOverrides?
    /** Timestamp for when the contact was added. Contacts added prior to 2023 September 1 may be missing this value. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, contactListId: String?, data: [String:String]?, callRecords: [String:CallRecord]?, latestSmsEvaluations: [String:MessageEvaluation]?, latestEmailEvaluations: [String:MessageEvaluation]?, latestWhatsAppEvaluations: [String:MessageEvaluation]?, callable: Bool?, phoneNumberStatus: [String:PhoneNumberStatus]?, contactableStatus: [String:ContactableStatus]?, contactColumnTimeZones: [String:ContactColumnTimeZone]?, configurationOverrides: ConfigurationOverrides?, dateCreated: Date?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.contactListId = contactListId
        self.data = data
        self.callRecords = callRecords
        self.latestSmsEvaluations = latestSmsEvaluations
        self.latestEmailEvaluations = latestEmailEvaluations
        self.latestWhatsAppEvaluations = latestWhatsAppEvaluations
        self.callable = callable
        self.phoneNumberStatus = phoneNumberStatus
        self.contactableStatus = contactableStatus
        self.contactColumnTimeZones = contactColumnTimeZones
        self.configurationOverrides = configurationOverrides
        self.dateCreated = dateCreated
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case contactListId
        case data
        case callRecords
        case latestSmsEvaluations
        case latestEmailEvaluations
        case latestWhatsAppEvaluations
        case callable
        case phoneNumberStatus
        case contactableStatus
        case contactColumnTimeZones
        case configurationOverrides
        case dateCreated
        case selfUri
    }


}




public class DialerContactlistConfigChangeContactPhoneNumberColumn: Codable {











    /** name of the phone column */
    public var columnName: String?
    /** type of the phone column, for example, 'cell' or 'home' */
    public var type: String?
    /** name of the column indicating the timezone to be considered for determining callable times */
    public var callableTimeColumn: String?
    public var additionalProperties: [String:JSON]?
    public var getAdditionalProperties: [String:JSON]?

    public init(columnName: String?, type: String?, callableTimeColumn: String?, additionalProperties: [String:JSON]?, getAdditionalProperties: [String:JSON]?) {
        self.columnName = columnName
        self.type = type
        self.callableTimeColumn = callableTimeColumn
        self.additionalProperties = additionalProperties
        self.getAdditionalProperties = getAdditionalProperties
    }


}



/** A UriReference for a resource */

public class DialerContactlistfilterConfigChangeUriReference: Codable {





    /** The ID of the resource */
    public var _id: String?
    /** The name of the resource */
    public var name: String?

    public init(_id: String?, name: String?) {
        self._id = _id
        self.name = name
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
    }


}



/** A UriReference for a resource */

public class DialerDnclistConfigChangeUriReference: Codable {





    /** The ID of the resource */
    public var _id: String?
    /** The name of the resource */
    public var name: String?

    public init(_id: String?, name: String?) {
        self._id = _id
        self.name = name
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
    }


}




public class DialerEventEntityListing: Codable {





















    public var entities: [EventLog]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var previousUri: String?
    public var nextUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [EventLog]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, previousUri: String?, nextUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.previousUri = previousUri
        self.nextUri = nextUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}



/** The time interval to place outbound calls */

public class DialerOutboundSettingsConfigChangeAtzmTimeSlot: Codable {





    /** The earliest time to dial a contact */
    public var earliestCallableTime: String?
    /** The latest time to dial a contact */
    public var latestCallableTime: String?

    public init(earliestCallableTime: String?, latestCallableTime: String?) {
        self.earliestCallableTime = earliestCallableTime
        self.latestCallableTime = latestCallableTime
    }


}




public class DialerResponsesetConfigChangeResponseSet: Codable {



















    /** Map of disposition identifiers to reactions. For example: {\"disposition.classification.callable.person\": {\"reactionType\": \"transfer\"}} */
    public var responses: [String:DialerResponsesetConfigChangeReaction]?
    /** When beep detection is enabled, answering machine detection will wait for the beep before transferring the call */
    public var beepDetectionEnabled: Bool?
    public var additionalProperties: [String:JSON]?
    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The UI-visible name of the object */
    public var name: String?
    /** Creation time of the entity */
    public var dateCreated: Date?
    /** Last modified time of the entity */
    public var dateModified: Date?
    /** Required for updates, must match the version number of the most recent update */
    public var version: Int64?
    public var getAdditionalProperties: [String:JSON]?

    public init(responses: [String:DialerResponsesetConfigChangeReaction]?, beepDetectionEnabled: Bool?, additionalProperties: [String:JSON]?, _id: String?, name: String?, dateCreated: Date?, dateModified: Date?, version: Int64?, getAdditionalProperties: [String:JSON]?) {
        self.responses = responses
        self.beepDetectionEnabled = beepDetectionEnabled
        self.additionalProperties = additionalProperties
        self._id = _id
        self.name = name
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.version = version
        self.getAdditionalProperties = getAdditionalProperties
    }

    public enum CodingKeys: String, CodingKey { 
        case responses
        case beepDetectionEnabled
        case additionalProperties
        case _id = "id"
        case name
        case dateCreated
        case dateModified
        case version
        case getAdditionalProperties
    }


}




public class DialerRulesetConfigChangeAction: Codable {













    /** Type of the action */
    public var type: String?
    /** Identifier of the action */
    public var actionTypeName: String?
    /** Indicator of the type of update action (applicable only to certain types of actions) */
    public var updateOption: String?
    /** Map of key-value pairs pertinent to the action (different actions require different properties) */
    public var properties: [String:String]?
    public var additionalProperties: [String:JSON]?
    public var getAdditionalProperties: [String:JSON]?

    public init(type: String?, actionTypeName: String?, updateOption: String?, properties: [String:String]?, additionalProperties: [String:JSON]?, getAdditionalProperties: [String:JSON]?) {
        self.type = type
        self.actionTypeName = actionTypeName
        self.updateOption = updateOption
        self.properties = properties
        self.additionalProperties = additionalProperties
        self.getAdditionalProperties = getAdditionalProperties
    }


}




public class DialerSequenceScheduleConfigChangeAlteration: Codable {

    public enum ModelType: String, Codable { 
        case exclusion = "Exclusion"
        case inclusion = "Inclusion"
    }









    public var type: ModelType?
    /** the end date of an alteration range as an ISO-8601 string */
    public var start: String?
    /** the end date of an alteration range as an ISO-8601 string */
    public var end: String?
    public var additionalProperties: [String:JSON]?
    public var getAdditionalProperties: [String:JSON]?

    public init(type: ModelType?, start: String?, end: String?, additionalProperties: [String:JSON]?, getAdditionalProperties: [String:JSON]?) {
        self.type = type
        self.start = start
        self.end = end
        self.additionalProperties = additionalProperties
        self.getAdditionalProperties = getAdditionalProperties
    }


}




public class DialerSequenceScheduleConfigChangeSequenceSchedule: Codable {























    /** a list of start and end times */
    public var intervals: [DialerSequenceScheduleConfigChangeScheduleInterval]?
    /** a list of recurrences for a schedule */
    public var recurrences: [DialerSequenceScheduleConfigChangeScheduleRecurrence]?
    /** time zone identifier to be applied to the intervals; for example Africa/Abidjan */
    public var timeZone: String?
    public var sequence: DialerSequenceScheduleConfigChangeUriReference?
    public var additionalProperties: [String:JSON]?
    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The UI-visible name of the object */
    public var name: String?
    /** Creation time of the entity */
    public var dateCreated: Date?
    /** Last modified time of the entity */
    public var dateModified: Date?
    /** Required for updates, must match the version number of the most recent update */
    public var version: Int64?
    public var getAdditionalProperties: [String:JSON]?

    public init(intervals: [DialerSequenceScheduleConfigChangeScheduleInterval]?, recurrences: [DialerSequenceScheduleConfigChangeScheduleRecurrence]?, timeZone: String?, sequence: DialerSequenceScheduleConfigChangeUriReference?, additionalProperties: [String:JSON]?, _id: String?, name: String?, dateCreated: Date?, dateModified: Date?, version: Int64?, getAdditionalProperties: [String:JSON]?) {
        self.intervals = intervals
        self.recurrences = recurrences
        self.timeZone = timeZone
        self.sequence = sequence
        self.additionalProperties = additionalProperties
        self._id = _id
        self.name = name
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.version = version
        self.getAdditionalProperties = getAdditionalProperties
    }

    public enum CodingKeys: String, CodingKey { 
        case intervals
        case recurrences
        case timeZone
        case sequence
        case additionalProperties
        case _id = "id"
        case name
        case dateCreated
        case dateModified
        case version
        case getAdditionalProperties
    }


}




public class DialogflowAgentSummaryEntityListing: Codable {





















    public var entities: [DialogflowAgentSummary]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var previousUri: String?
    public var nextUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [DialogflowAgentSummary]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, previousUri: String?, nextUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.previousUri = previousUri
        self.nextUri = nextUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class DialogflowCXAgentSummaryEntityListing: Codable {





















    public var entities: [DialogflowCXAgentSummary]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var previousUri: String?
    public var nextUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [DialogflowCXAgentSummary]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, previousUri: String?, nextUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.previousUri = previousUri
        self.nextUri = nextUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class DialogflowCXProject: Codable {





    public var _id: String?
    public var name: String?

    public init(_id: String?, name: String?) {
        self._id = _id
        self.name = name
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
    }


}




public class DialogflowProject: Codable {





    public var _id: String?
    public var name: String?

    public init(_id: String?, name: String?) {
        self._id = _id
        self.name = name
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
    }


}




public class DictionaryFeedback: Codable {









    public enum Source: String, Codable { 
        case manual = "Manual"
    }















    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The dictionary term which needs to be added to dictionary feedback system */
    public var term: String?
    /** The dialect for the given term, dialect format is {language}-{country} where language follows ISO 639-1 standard and country follows ISO 3166-1 alpha 2 standard */
    public var dialect: String?
    /** A weighted value assigned to a phrase. The higher the value, the higher the likelihood that the system will choose the word or phrase from the possible alternatives. Boost range is from 1.0 to 10.0. Default is 2.0 */
    public var boostValue: Float?
    /** The source of the given dictionary feedback */
    public var source: Source?
    /** The Timestamp when dictionary feedback created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** The Id of the user who created the dictionary feedback */
    public var createdBy: UserReference?
    /** The Timestamp when dictionary feedback modified. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** The Id of the user who modified the dictionary feedback */
    public var modifiedBy: UserReference?
    /** A list of at least 3 and up to 20 unique phrases that are example usage of the term */
    public var examplePhrases: [DictionaryFeedbackExamplePhrase]?
    /** A list of up to 10 terms that give examples of how the term sounds */
    public var soundsLike: [String]?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, term: String?, dialect: String?, boostValue: Float?, source: Source?, dateCreated: Date?, createdBy: UserReference?, dateModified: Date?, modifiedBy: UserReference?, examplePhrases: [DictionaryFeedbackExamplePhrase]?, soundsLike: [String]?, selfUri: String?) {
        self._id = _id
        self.term = term
        self.dialect = dialect
        self.boostValue = boostValue
        self.source = source
        self.dateCreated = dateCreated
        self.createdBy = createdBy
        self.dateModified = dateModified
        self.modifiedBy = modifiedBy
        self.examplePhrases = examplePhrases
        self.soundsLike = soundsLike
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case term
        case dialect
        case boostValue
        case source
        case dateCreated
        case createdBy
        case dateModified
        case modifiedBy
        case examplePhrases
        case soundsLike
        case selfUri
    }


}




public class DigitalDataActionConditionPredicate: Codable {



    public enum OutputOperator: String, Codable { 
        case equals = "Equals"
        case lessThan = "LessThan"
        case lessThanEquals = "LessThanEquals"
        case greaterThan = "GreaterThan"
        case greaterThanEquals = "GreaterThanEquals"
        case contains = "Contains"
        case beginsWith = "BeginsWith"
        case endsWith = "EndsWith"
        case before = "Before"
        case after = "After"
    }







    /** The name of an output field from the data action's output to use for this condition */
    public var outputField: String?
    /** The operation with which to evaluate this condition */
    public var outputOperator: OutputOperator?
    /** The value to compare against for this condition */
    public var comparisonValue: String?
    /** If true, inverts the result of evaluating this Predicate. Default is false. */
    public var inverted: Bool?
    /** The result of this predicate if the requested output field is missing from the data action's result */
    public var outputFieldMissingResolution: Bool?

    public init(outputField: String?, outputOperator: OutputOperator?, comparisonValue: String?, inverted: Bool?, outputFieldMissingResolution: Bool?) {
        self.outputField = outputField
        self.outputOperator = outputOperator
        self.comparisonValue = comparisonValue
        self.inverted = inverted
        self.outputFieldMissingResolution = outputFieldMissingResolution
    }


}




public class DispositionSilentCallTimeout: Codable {







    /** Configured silent call timeout value. */
    public var timeoutMs: Int?
    /** Timer start time. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var timerStartTime: Date?
    /** Timer end time. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var timerEndTime: Date?

    public init(timeoutMs: Int?, timerStartTime: Date?, timerEndTime: Date?) {
        self.timeoutMs = timeoutMs
        self.timerStartTime = timerStartTime
        self.timerEndTime = timerEndTime
    }


}




public class DivisionEntityRef: Codable {









    public var _id: String?
    public var name: String?
    public var selfUri: String?
    /** The time the entity division was last updated. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateDivisionUpdated: Date?

    public init(_id: String?, name: String?, selfUri: String?, dateDivisionUpdated: Date?) {
        self._id = _id
        self.name = name
        self.selfUri = selfUri
        self.dateDivisionUpdated = dateDivisionUpdated
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case selfUri
        case dateDivisionUpdated
    }


}




public class DncList: Codable {















    public enum DncSourceType: String, Codable { 
        case rds = "rds"
        case rdsCustom = "rds_custom"
        case dncCom = "dnc.com"
        case gryphon = "gryphon"
    }

    public enum ContactMethod: String, Codable { 
        case email = "Email"
        case phone = "Phone"
        case any = "Any"
        case whatsApp = "WhatsApp"
    }















    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The name of the DncList. */
    public var name: String?
    /** Creation time of the entity. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** Last modified time of the entity. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** Required for updates, must match the version number of the most recent update */
    public var version: Int?
    /** The status of the import process */
    public var importStatus: ImportStatus?
    /** The total number of phone numbers in the DncList. */
    public var size: Int64?
    /** The type of the DncList. */
    public var dncSourceType: DncSourceType?
    /** The contact method. Required if dncSourceType is rds. */
    public var contactMethod: ContactMethod?
    /** A dnc.com loginId. Required if the dncSourceType is dnc.com. */
    public var loginId: String?
    /** A dnc.com campaignId. Optional if the dncSourceType is dnc.com. */
    public var campaignId: String?
    /** The list of dnc.com codes to be treated as DNC. Required if the dncSourceType is dnc.com. */
    public var dncCodes: [String]?
    /** A gryphon license number. Required if the dncSourceType is gryphon. */
    public var licenseId: String?
    /** The division this DncList belongs to. */
    public var division: DomainEntityRef?
    /** The column to evaluate exclusion against. Required if the dncSourceType is rds_custom. */
    public var customExclusionColumn: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, dateCreated: Date?, dateModified: Date?, version: Int?, importStatus: ImportStatus?, size: Int64?, dncSourceType: DncSourceType?, contactMethod: ContactMethod?, loginId: String?, campaignId: String?, dncCodes: [String]?, licenseId: String?, division: DomainEntityRef?, customExclusionColumn: String?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.version = version
        self.importStatus = importStatus
        self.size = size
        self.dncSourceType = dncSourceType
        self.contactMethod = contactMethod
        self.loginId = loginId
        self.campaignId = campaignId
        self.dncCodes = dncCodes
        self.licenseId = licenseId
        self.division = division
        self.customExclusionColumn = customExclusionColumn
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case dateCreated
        case dateModified
        case version
        case importStatus
        case size
        case dncSourceType
        case contactMethod
        case loginId
        case campaignId
        case dncCodes
        case licenseId
        case division
        case customExclusionColumn
        case selfUri
    }


}




public class DncPatchCustomExclusionColumnsRequest: Codable {

    public enum Action: String, Codable { 
        case add = "Add"
        case remove = "Remove"
    }





    /** The action to perform */
    public var action: Action?
    /** The list of custom exclusion column entries to Add to / Remove from the DNC list  */
    public var customExclusionColumnEntries: [String]?
    /** Expiration date for DNC customExclusionColumnEntries in yyyy-MM-ddTHH:mmZ format */
    public var expirationDateTime: String?

    public init(action: Action?, customExclusionColumnEntries: [String]?, expirationDateTime: String?) {
        self.action = action
        self.customExclusionColumnEntries = customExclusionColumnEntries
        self.expirationDateTime = expirationDateTime
    }


}




public class DnclistImportStatusImportStatus: Codable {

    public enum ImportState: String, Codable { 
        case inProgress = "IN_PROGRESS"
        case failed = "FAILED"
    }

















    /** current status of the import */
    public var importState: ImportState?
    /** total number of records to be imported */
    public var totalRecords: Int64?
    /** number of records finished importing */
    public var completedRecords: Int64?
    /** percentage of records finished importing */
    public var percentageComplete: Int64?
    /** if the import has failed, the reason for the failure */
    public var failureReason: String?
    /** The ids for target contact lists */
    public var targetContactListIds: [String]?
    /** The prefix used for target contact list names */
    public var listNamePrefix: String?
    public var additionalProperties: [String:JSON]?
    public var getAdditionalProperties: [String:JSON]?

    public init(importState: ImportState?, totalRecords: Int64?, completedRecords: Int64?, percentageComplete: Int64?, failureReason: String?, targetContactListIds: [String]?, listNamePrefix: String?, additionalProperties: [String:JSON]?, getAdditionalProperties: [String:JSON]?) {
        self.importState = importState
        self.totalRecords = totalRecords
        self.completedRecords = completedRecords
        self.percentageComplete = percentageComplete
        self.failureReason = failureReason
        self.targetContactListIds = targetContactListIds
        self.listNamePrefix = listNamePrefix
        self.additionalProperties = additionalProperties
        self.getAdditionalProperties = getAdditionalProperties
    }


}




public class DocumentAttribute: Codable {





    public var attribute: Attribute?
    public var values: [String]?

    public init(attribute: Attribute?, values: [String]?) {
        self.attribute = attribute
        self.values = values
    }


}




public class DocumentBody: Codable {



    /** The list of building blocks for the document body. */
    public var blocks: [DocumentBodyBlock]?

    public init(blocks: [DocumentBodyBlock]?) {
        self.blocks = blocks
    }


}




public class DocumentBodyListBlockWithHighlight: Codable {

    public enum ModelType: String, Codable { 
        case listItem = "ListItem"
    }





    /** The type of the list block. */
    public var type: ModelType?
    /** The properties for the list block. */
    public var properties: DocumentBodyListItemProperties?
    /** The list of items for an OrderedList or an UnorderedList. */
    public var blocks: [DocumentListContentBlockWithHighlight]?

    public init(type: ModelType?, properties: DocumentBodyListItemProperties?, blocks: [DocumentListContentBlockWithHighlight]?) {
        self.type = type
        self.properties = properties
        self.blocks = blocks
    }


}




public class DocumentBodyListItemProperties: Codable {



    public enum Align: String, Codable { 
        case center = "Center"
        case _left = "Left"
        case _right = "Right"
        case justify = "Justify"
    }



    public enum FontSize: String, Codable { 
        case xxSmall = "XxSmall"
        case xsmall = "XSmall"
        case small = "Small"
        case medium = "Medium"
        case large = "Large"
        case xlarge = "XLarge"
        case xxLarge = "XxLarge"
        case xxxLarge = "XxxLarge"
    }

    public enum FontType: String, Codable { 
        case paragraph = "Paragraph"
        case heading1 = "Heading1"
        case heading2 = "Heading2"
        case heading3 = "Heading3"
        case heading4 = "Heading4"
        case heading5 = "Heading5"
        case heading6 = "Heading6"
        case preformatted = "Preformatted"
    }



    public enum UnorderedType: String, Codable { 
        case normal = "Normal"
        case square = "Square"
        case circle = "Circle"
        case _none = "None"
    }

    public enum OrderedType: String, Codable { 
        case number = "Number"
        case lowerAlpha = "LowerAlpha"
        case lowerGreek = "LowerGreek"
        case lowerRoman = "LowerRoman"
        case upperAlpha = "UpperAlpha"
        case upperRoman = "UpperRoman"
        case _none = "None"
    }

    /** The background color for the list item. The valid values in hex color code representation. For example black color - #000000 */
    public var backgroundColor: String?
    /** The align type for the list item. */
    public var align: Align?
    /** The indentation property for the list item. The valid values in 'em'. */
    public var indentation: Float?
    /** The font size for the list item. The valid values in 'em'. */
    public var fontSize: FontSize?
    /** The font type for the list item. */
    public var fontType: FontType?
    /** The text color for the list item. The valid values in hex color code representation. For example black color - #000000 */
    public var textColor: String?
    /** The type of icon for the unordered list. */
    public var unorderedType: UnorderedType?
    /** The type of icon for the ordered list. */
    public var orderedType: OrderedType?

    public init(backgroundColor: String?, align: Align?, indentation: Float?, fontSize: FontSize?, fontType: FontType?, textColor: String?, unorderedType: UnorderedType?, orderedType: OrderedType?) {
        self.backgroundColor = backgroundColor
        self.align = align
        self.indentation = indentation
        self.fontSize = fontSize
        self.fontType = fontType
        self.textColor = textColor
        self.unorderedType = unorderedType
        self.orderedType = orderedType
    }


}




public class DocumentBodyParagraphWithHighlight: Codable {





    /** The list of blocks for the paragraph. */
    public var blocks: [DocumentContentBlockWithHighlight]?
    /** The properties for the paragraph. */
    public var properties: DocumentBodyParagraphProperties?

    public init(blocks: [DocumentContentBlockWithHighlight]?, properties: DocumentBodyParagraphProperties?) {
        self.blocks = blocks
        self.properties = properties
    }


}




public class DocumentBodyRequest: Codable {



    /** The list of building blocks for the document body. */
    public var blocks: [DocumentBodyBlock]?

    public init(blocks: [DocumentBodyBlock]?) {
        self.blocks = blocks
    }


}




public class DocumentBodyTableCaptionItem: Codable {

    public enum ModelType: String, Codable { 
        case text = "Text"
        case paragraph = "Paragraph"
        case image = "Image"
        case video = "Video"
        case orderedList = "OrderedList"
        case unorderedList = "UnorderedList"
    }











    /** The type of the caption item. */
    public var type: ModelType?
    /** Text. It must contain a value if the type of the block is Text. */
    public var text: DocumentText?
    /** Paragraph. It must contain a value if the type of the block is Paragraph. */
    public var paragraph: DocumentBodyParagraph?
    /** Image. It must contain a value if the type of the block is Image. */
    public var image: DocumentBodyImage?
    /** Video. It must contain a value if the type of the block is Video. */
    public var video: DocumentBodyVideo?
    /** List. It must contain a value if the type of the block is UnorderedList or OrderedList. */
    public var list: DocumentBodyList?

    public init(type: ModelType?, text: DocumentText?, paragraph: DocumentBodyParagraph?, image: DocumentBodyImage?, video: DocumentBodyVideo?, list: DocumentBodyList?) {
        self.type = type
        self.text = text
        self.paragraph = paragraph
        self.image = image
        self.video = video
        self.list = list
    }


}




public class DocumentBodyTableCellBlockWithHighlight: Codable {





    /** The properties for the table cell. */
    public var properties: DocumentBodyTableCellBlockProperties?
    /** The list of content blocks for the table. */
    public var blocks: [DocumentTableContentBlockWithHighlight]?

    public init(properties: DocumentBodyTableCellBlockProperties?, blocks: [DocumentTableContentBlockWithHighlight]?) {
        self.properties = properties
        self.blocks = blocks
    }


}




public class DocumentBodyTableRowBlockProperties: Codable {

    public enum RowType: String, Codable { 
        case header = "Header"
        case footer = "Footer"
        case body = "Body"
    }

    public enum Alignment: String, Codable { 
        case center = "Center"
        case _left = "Left"
        case _right = "Right"
    }



    public enum BorderStyle: String, Codable { 
        case solid = "Solid"
        case dotted = "Dotted"
        case dashed = "Dashed"
        case double = "Double"
        case groove = "Groove"
        case ridge = "Ridge"
        case inset = "Inset"
        case outset = "Outset"
        case hidden = "Hidden"
        case _none = "None"
    }





    /** The type of the table row. */
    public var rowType: RowType?
    /** The alignment for the table row. */
    public var alignment: Alignment?
    /** The height for the table row. */
    public var height: Float?
    /** The border style for the table row. */
    public var borderStyle: BorderStyle?
    /** The border color for the table row. For example black color - #000000 */
    public var borderColor: String?
    /** The background color for the table row. For example black color - #000000 */
    public var backgroundColor: String?

    public init(rowType: RowType?, alignment: Alignment?, height: Float?, borderStyle: BorderStyle?, borderColor: String?, backgroundColor: String?) {
        self.rowType = rowType
        self.alignment = alignment
        self.height = height
        self.borderStyle = borderStyle
        self.borderColor = borderColor
        self.backgroundColor = backgroundColor
    }


}




public class DocumentBodyTableWithHighlight: Codable {





    /** The properties for the table. */
    public var properties: DocumentBodyTableProperties?
    /** The list of rows for the table. */
    public var rows: [DocumentBodyTableRowBlockWithHighlight]?

    public init(properties: DocumentBodyTableProperties?, rows: [DocumentBodyTableRowBlockWithHighlight]?) {
        self.properties = properties
        self.rows = rows
    }


}




public class DocumentUpload: Codable {









    /** The name of the document */
    public var name: String?
    /** The workspace the document will be uploaded to */
    public var workspace: DomainEntityRef?
    public var tags: [String]?
    public var tagIds: [String]?

    public init(name: String?, workspace: DomainEntityRef?, tags: [String]?, tagIds: [String]?) {
        self.name = name
        self.workspace = workspace
        self.tags = tags
        self.tagIds = tagIds
    }


}




public class DocumentVariationResponse: Codable {





















    /** The globally unique identifier for the variation. */
    public var _id: String?
    /** The creation date-time for the document variation. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** The last modification date-time for the document variation. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** The version of the document. */
    public var documentVersion: AddressableEntityRef?
    /** The context values associated with the variation. */
    public var contexts: [DocumentVariationContext]?
    /** The reference to document to which the variation is associated. */
    public var document: KnowledgeDocumentReference?
    /** The priority of the variation. */
    public var priority: Int?
    /** The name of the variation. */
    public var name: String?
    /** The content for the variation. */
    public var body: DocumentBodyResponse?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, dateCreated: Date?, dateModified: Date?, documentVersion: AddressableEntityRef?, contexts: [DocumentVariationContext]?, document: KnowledgeDocumentReference?, priority: Int?, name: String?, body: DocumentBodyResponse?, selfUri: String?) {
        self._id = _id
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.documentVersion = documentVersion
        self.contexts = contexts
        self.document = document
        self.priority = priority
        self.name = name
        self.body = body
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case dateCreated
        case dateModified
        case documentVersion
        case contexts
        case document
        case priority
        case name
        case body
        case selfUri
    }


}




public class DocumentVariationResponseListing: Codable {









    public var entities: [DocumentVariationResponse]?
    public var nextUri: String?
    public var selfUri: String?
    public var previousUri: String?

    public init(entities: [DocumentVariationResponse]?, nextUri: String?, selfUri: String?, previousUri: String?) {
        self.entities = entities
        self.nextUri = nextUri
        self.selfUri = selfUri
        self.previousUri = previousUri
    }


}




public class DocumentationResult: Codable {









































    /** The globally unique identifier for the object. */
    public var _id: Int?
    /** The category of the documentation entity. Will be returned in responses for certain entities. */
    public var categories: [Int]?
    /** The description of the documentation entity. Will be returned in responses for certain entities. */
    public var _description: String?
    /** The text or html content for the documentation entity. Will be returned in responses for certain entities. */
    public var content: String?
    /** The excerpt of the documentation entity. Will be returned in responses for certain entities. */
    public var excerpt: String?
    /** URL link for the documentation entity. Will be returned in responses for certain entities. */
    public var link: String?
    /** The modified date for the documentation entity. Will be returned in responses for certain entities. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var modified: Date?
    /** The name of the documentation entity. Will be returned in responses for certain entities. */
    public var name: String?
    /** The service of the documentation entity. Will be returned in responses for certain entities. */
    public var service: [Int]?
    /** The slug of the documentation entity. Will be returned in responses for certain entities. */
    public var slug: String?
    /** The title of the documentation entity. Will be returned in responses for certain entities. */
    public var title: String?
    /** The search type. Will be returned in responses for certain entities. */
    public var getType: String?
    /** The facet feature of the documentation entity. Will be returned in responses for certain entities. */
    public var facetFeature: [Int]?
    /** The facet role of the documentation entity. Will be returned in responses for certain entities. */
    public var facetRole: [Int]?
    /** The facet service of the documentation entity. Will be returned in responses for certain entities. */
    public var facetService: [Int]?
    /** The faq categories of the documentation entity. Will be returned in responses for certain entities. */
    public var faqCategories: [Int]?
    /** The releasenote category of the documentation entity. Will be returned in responses for certain entities. */
    public var releasenoteCategory: [Int]?
    /** The releasenote tag of the documentation entity. Will be returned in responses for certain entities. */
    public var releasenoteTag: [Int]?
    /** The service area of the documentation entity. Will be returned in responses for certain entities. */
    public var serviceArea: [Int]?
    /** The video categories of the documentation entity. Will be returned in responses for certain entities. */
    public var videoCategories: [Int]?

    public init(_id: Int?, categories: [Int]?, _description: String?, content: String?, excerpt: String?, link: String?, modified: Date?, name: String?, service: [Int]?, slug: String?, title: String?, getType: String?, facetFeature: [Int]?, facetRole: [Int]?, facetService: [Int]?, faqCategories: [Int]?, releasenoteCategory: [Int]?, releasenoteTag: [Int]?, serviceArea: [Int]?, videoCategories: [Int]?) {
        self._id = _id
        self.categories = categories
        self._description = _description
        self.content = content
        self.excerpt = excerpt
        self.link = link
        self.modified = modified
        self.name = name
        self.service = service
        self.slug = slug
        self.title = title
        self.getType = getType
        self.facetFeature = facetFeature
        self.facetRole = facetRole
        self.facetService = facetService
        self.faqCategories = faqCategories
        self.releasenoteCategory = releasenoteCategory
        self.releasenoteTag = releasenoteTag
        self.serviceArea = serviceArea
        self.videoCategories = videoCategories
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case categories
        case _description = "description"
        case content
        case excerpt
        case link
        case modified
        case name
        case service
        case slug
        case title
        case getType = "get_type"
        case facetFeature = "facet_feature"
        case facetRole = "facet_role"
        case facetService = "facet_service"
        case faqCategories = "faq_categories"
        case releasenoteCategory = "releasenote_category"
        case releasenoteTag = "releasenote_tag"
        case serviceArea = "service-area"
        case videoCategories = "video_categories"
    }


}




public class DomainEntityListingEvaluationForm: Codable {





















    public var entities: [EvaluationForm]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var previousUri: String?
    public var nextUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [EvaluationForm]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, previousUri: String?, nextUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.previousUri = previousUri
        self.nextUri = nextUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class DomainPermissionPolicy: Codable {

















    public var domain: String?
    public var entityName: String?
    public var policyName: String?
    public var policyDescription: String?
    public var actionSet: [String]?
    public var namedResources: [String]?
    public var allowConditions: Bool?
    public var resourceConditionNode: DomainResourceConditionNode?

    public init(domain: String?, entityName: String?, policyName: String?, policyDescription: String?, actionSet: [String]?, namedResources: [String]?, allowConditions: Bool?, resourceConditionNode: DomainResourceConditionNode?) {
        self.domain = domain
        self.entityName = entityName
        self.policyName = policyName
        self.policyDescription = policyDescription
        self.actionSet = actionSet
        self.namedResources = namedResources
        self.allowConditions = allowConditions
        self.resourceConditionNode = resourceConditionNode
    }


}




public class DomainResourceConditionValue: Codable {









    public enum ModelType: String, Codable { 
        case scalar = "SCALAR"
        case variable = "VARIABLE"
        case user = "USER"
        case team = "TEAM"
        case queue = "QUEUE"
    }

    public var user: User?
    public var queue: Queue?
    public var team: Team?
    public var value: String?
    public var type: ModelType?

    public init(user: User?, queue: Queue?, team: Team?, value: String?, type: ModelType?) {
        self.user = user
        self.queue = queue
        self.team = team
        self.value = value
        self.type = type
    }


}




public class DynamicContactQueueingSettings: Codable {





    /** Whether to sort contacts dynamically */
    public var sort: Bool?
    /** Whether to filter contacts dynamically */
    public var filter: Bool?

    public init(sort: Bool?, filter: Bool?) {
        self.sort = sort
        self.filter = filter
    }


}




public class EdgeChangeTopicEdge: Codable {



    public enum OnlineStatus: String, Codable { 
        case online = "ONLINE"
        case offline = "OFFLINE"
    }

    public var _id: String?
    public var onlineStatus: OnlineStatus?

    public init(_id: String?, onlineStatus: OnlineStatus?) {
        self._id = _id
        self.onlineStatus = onlineStatus
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case onlineStatus
    }


}




public class EdgeConnectionInfo: Codable {















    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** Interface used for the connection on the edge */
    public var interfaceName: String?
    /** IP address of the interface */
    public var interfaceIpAddress: String?
    /** Connection errors */
    public var connectionErrors: [String]?
    public var site: AddressableEntityRef?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, interfaceName: String?, interfaceIpAddress: String?, connectionErrors: [String]?, site: AddressableEntityRef?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.interfaceName = interfaceName
        self.interfaceIpAddress = interfaceIpAddress
        self.connectionErrors = connectionErrors
        self.site = site
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case interfaceName
        case interfaceIpAddress
        case connectionErrors
        case site
        case selfUri
    }


}




public class EdgeLogsJobUploadRequest: Codable {



    /** A list of file ids to upload. */
    public var fileIds: [String]?

    public init(fileIds: [String]?) {
        self.fileIds = fileIds
    }


}




public class EdgeMetricsTopicEdgeMetricMemory: Codable {







    public var type: String?
    public var availableBytes: Int64?
    public var totalBytes: Int64?

    public init(type: String?, availableBytes: Int64?, totalBytes: Int64?) {
        self.type = type
        self.availableBytes = availableBytes
        self.totalBytes = totalBytes
    }


}




public class EdgeTrunkBase: Codable {



















    public enum State: String, Codable { 
        case active = "active"
        case inactive = "inactive"
        case deleted = "deleted"
    }









    public enum TrunkType: String, Codable { 
        case external = "EXTERNAL"
        case phone = "PHONE"
        case edge = "EDGE"
    }







    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The name of the entity. */
    public var name: String?
    /** The division to which this entity belongs. */
    public var division: Division?
    /** The resource's description. */
    public var _description: String?
    /** The current version of the resource. */
    public var version: Int?
    /** The date the resource was created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** The date of the last modification to the resource. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** The ID of the user that last modified the resource. */
    public var modifiedBy: String?
    /** The ID of the user that created the resource. */
    public var createdBy: String?
    /** Indicates if the resource is active, inactive, or deleted. */
    public var state: State?
    /** The application that last modified the resource. */
    public var modifiedByApp: String?
    /** The application that created the resource. */
    public var createdByApp: String?
    /** The meta-base this trunk is based on. */
    public var trunkMetabase: DomainEntityRef?
    public var properties: [String:JSON]?
    /** The type of this trunk base. */
    public var trunkType: TrunkType?
    /** Used to determine the media regions for inbound and outbound calls through a trunk. Also determines the dial plan to use for calls that came in on a trunk and have to be sent out on it as well. */
    public var site: DomainEntityRef?
    /** Allows a customer to set the site to which inbound calls will be routed */
    public var inboundSite: DomainEntityRef?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, division: Division?, _description: String?, version: Int?, dateCreated: Date?, dateModified: Date?, modifiedBy: String?, createdBy: String?, state: State?, modifiedByApp: String?, createdByApp: String?, trunkMetabase: DomainEntityRef?, properties: [String:JSON]?, trunkType: TrunkType?, site: DomainEntityRef?, inboundSite: DomainEntityRef?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.division = division
        self._description = _description
        self.version = version
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.modifiedBy = modifiedBy
        self.createdBy = createdBy
        self.state = state
        self.modifiedByApp = modifiedByApp
        self.createdByApp = createdByApp
        self.trunkMetabase = trunkMetabase
        self.properties = properties
        self.trunkType = trunkType
        self.site = site
        self.inboundSite = inboundSite
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case division
        case _description = "description"
        case version
        case dateCreated
        case dateModified
        case modifiedBy
        case createdBy
        case state
        case modifiedByApp
        case createdByApp
        case trunkMetabase
        case properties
        case trunkType
        case site
        case inboundSite
        case selfUri
    }


}




public class Education: Codable {











    public var school: String?
    public var fieldOfStudy: String?
    /** Notes about education has a 2000 character limit */
    public var notes: String?
    /** Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd */
    public var dateStart: Date?
    /** Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd */
    public var dateEnd: Date?

    public init(school: String?, fieldOfStudy: String?, notes: String?, dateStart: Date?, dateEnd: Date?) {
        self.school = school
        self.fieldOfStudy = fieldOfStudy
        self.notes = notes
        self.dateStart = dateStart
        self.dateEnd = dateEnd
    }


}




public class EmailCommunicationDispositionAppliedEvent: Codable {















    /** A unique (V4 UUID) eventId for this event */
    public var eventId: String?
    /** A Date Time representing the time this event occurred. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var eventDateTime: Date?
    /** A unique Id (V4 UUID) identifying this conversation */
    public var conversationId: String?
    /** A unique Id (V4 UUID) identifying this communication */
    public var communicationId: String?
    /** The wrapup-code (V4 UUID) used to disposition this interaction. If this value is not provided the disposition is considered skipped. */
    public var code: String?
    /** Text entered by the agent to describe the interaction or disposition. Ignored if the disposition is considered skipped. */
    public var notes: String?
    /** The list of tags selected by the agent to describe the interaction or disposition. Ignored if the disposition is considered skipped. */
    public var tags: [String]?

    public init(eventId: String?, eventDateTime: Date?, conversationId: String?, communicationId: String?, code: String?, notes: String?, tags: [String]?) {
        self.eventId = eventId
        self.eventDateTime = eventDateTime
        self.conversationId = conversationId
        self.communicationId = communicationId
        self.code = code
        self.notes = notes
        self.tags = tags
    }


}




public class EmailHoldUpdatedEvent: Codable {











    /** A unique (V4 UUID) eventId for this event */
    public var eventId: String?
    /** A Date Time representing the time this event occurred. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var eventDateTime: Date?
    /** A unique Id (V4 UUID) identifying this conversation */
    public var conversationId: String?
    /** A unique Id (V4 UUID) identifying this communication */
    public var communicationId: String?
    /** Indicates whether this communication is held. */
    public var held: Bool?

    public init(eventId: String?, eventDateTime: Date?, conversationId: String?, communicationId: String?, held: Bool?) {
        self.eventId = eventId
        self.eventDateTime = eventDateTime
        self.conversationId = conversationId
        self.communicationId = communicationId
        self.held = held
    }


}




public class EmailMediaParticipant: Codable {



















    public enum State: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case converting = "converting"
        case uploading = "uploading"
        case transmitting = "transmitting"
        case parked = "parked"
        case _none = "none"
    }

    public enum Direction: String, Codable { 
        case inbound = "inbound"
        case outbound = "outbound"
    }

    public enum DisconnectType: String, Codable { 
        case endpoint = "endpoint"
        case endpointDonotdisturb = "endpoint.donotdisturb"
        case client = "client"
        case system = "system"
        case transfer = "transfer"
        case transferConference = "transfer.conference"
        case transferConsult = "transfer.consult"
        case transferDonotdisturb = "transfer.donotdisturb"
        case transferForward = "transfer.forward"
        case transferNoanswer = "transfer.noanswer"
        case transferNotavailable = "transfer.notavailable"
        case transportFailure = "transport.failure"
        case error = "error"
        case peer = "peer"
        case other = "other"
        case spam = "spam"
        case inactivity = "inactivity"
        case sessionExpired = "session.expired"
    }







































    public enum FlaggedReason: String, Codable { 
        case general = "general"
    }

























    /** The unique participant ID. */
    public var _id: String?
    /** The display friendly name of the participant. */
    public var name: String?
    /** The participant address. */
    public var address: String?
    /** The time when this participant first joined the conversation. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var startTime: Date?
    /** The timestamp when it is first put into an alerting state. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var startAlertingTime: Date?
    /** The time when this participant went connected for this media (eg: video connected time). Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var connectedTime: Date?
    /** The time when this participant went disconnected for this media (eg: video disconnected time). Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var endTime: Date?
    /** The time when this participant's hold started. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var startHoldTime: Date?
    /** The participant's purpose.  Values can be: 'agent', 'user', 'customer', 'external', 'acd', 'ivr */
    public var purpose: String?
    /** The participant's state.  Values can be: 'alerting', 'connected', 'disconnected', 'dialing', 'contacting */
    public var state: State?
    /** The participant's direction.  Values can be: 'inbound' or 'outbound' */
    public var direction: Direction?
    /** The reason the participant was disconnected from the conversation. */
    public var disconnectType: DisconnectType?
    /** Value is true when the participant is on hold. */
    public var held: Bool?
    /** Value is true when the participant requires wrap-up. */
    public var wrapupRequired: Bool?
    /** The wrap-up prompt indicating the type of wrap-up to be performed. */
    public var wrapupPrompt: String?
    /** List of roles this participant's media has had on the conversation, ie monitor, coach, etc */
    public var mediaRoles: [String]?
    /** The PureCloud user for this participant. */
    public var user: DomainEntityRef?
    /** The PureCloud queue for this participant. */
    public var queue: DomainEntityRef?
    /** The PureCloud team for this participant. */
    public var team: DomainEntityRef?
    /** A list of ad-hoc attributes for the participant. */
    public var attributes: [String:String]?
    /** If the conversation ends in error, contains additional error details. */
    public var errorInfo: ErrorInfo?
    /** The Engage script that should be used by this participant. */
    public var script: DomainEntityRef?
    /** The amount of time the participant has to complete wrap-up. */
    public var wrapupTimeoutMs: Int?
    /** Value is true when the participant has skipped wrap-up. */
    public var wrapupSkipped: Bool?
    /** Specifies how long the agent has to answer an interaction before being marked as not responding. */
    public var alertingTimeoutMs: Int?
    /** The source provider for the communication. */
    public var provider: String?
    /** If this participant represents an external contact, then this will be the reference for the external contact. */
    public var externalContact: DomainEntityRef?
    /** If this participant represents an external contact, then this will be the initial division for the external contact. This value will not be updated if the external contact is reassigned. */
    public var externalContactInitialDivisionId: String?
    /** If this participant represents an external org, then this will be the reference for the external org. */
    public var externalOrganization: DomainEntityRef?
    /** Wrapup for this participant, if it has been applied. */
    public var wrapup: Wrapup?
    /** The peer communication corresponding to a matching leg for this communication. */
    public var peer: String?
    /** The reason specifying why participant flagged the conversation. */
    public var flaggedReason: FlaggedReason?
    /** Journey System data/context that is applicable to this communication.  When used for historical purposes, the context should be immutable.  When null, there is no applicable Journey System context. */
    public var journeyContext: JourneyContext?
    /** Information on how a communication should be routed to an agent. */
    public var conversationRoutingData: ConversationRoutingData?
    /** The timestamp when this participant started after-call work. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var startAcwTime: Date?
    /** The timestamp when this participant ended after-call work. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var endAcwTime: Date?
    /** The time when this participant's communication was last parked.  Does not reset on resume. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var parkTime: Date?
    /** The time when this participant's communications will resume. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var resumeTime: Date?
    /** The subject of the email. */
    public var subject: String?
    /** The number of messages that have been sent in this email conversation. */
    public var messagesSent: Int?
    /** Indicates that the email was auto-generated like an Out of Office reply. */
    public var autoGenerated: Bool?
    /** A list of uploaded attachments on the email draft. */
    public var draftAttachments: [Attachment]?
    /** Indicates if the inbound email was marked as spam. */
    public var spam: Bool?
    /** A globally unique identifier for the stored content of this communication. */
    public var messageId: String?

    public init(_id: String?, name: String?, address: String?, startTime: Date?, startAlertingTime: Date?, connectedTime: Date?, endTime: Date?, startHoldTime: Date?, purpose: String?, state: State?, direction: Direction?, disconnectType: DisconnectType?, held: Bool?, wrapupRequired: Bool?, wrapupPrompt: String?, mediaRoles: [String]?, user: DomainEntityRef?, queue: DomainEntityRef?, team: DomainEntityRef?, attributes: [String:String]?, errorInfo: ErrorInfo?, script: DomainEntityRef?, wrapupTimeoutMs: Int?, wrapupSkipped: Bool?, alertingTimeoutMs: Int?, provider: String?, externalContact: DomainEntityRef?, externalContactInitialDivisionId: String?, externalOrganization: DomainEntityRef?, wrapup: Wrapup?, peer: String?, flaggedReason: FlaggedReason?, journeyContext: JourneyContext?, conversationRoutingData: ConversationRoutingData?, startAcwTime: Date?, endAcwTime: Date?, parkTime: Date?, resumeTime: Date?, subject: String?, messagesSent: Int?, autoGenerated: Bool?, draftAttachments: [Attachment]?, spam: Bool?, messageId: String?) {
        self._id = _id
        self.name = name
        self.address = address
        self.startTime = startTime
        self.startAlertingTime = startAlertingTime
        self.connectedTime = connectedTime
        self.endTime = endTime
        self.startHoldTime = startHoldTime
        self.purpose = purpose
        self.state = state
        self.direction = direction
        self.disconnectType = disconnectType
        self.held = held
        self.wrapupRequired = wrapupRequired
        self.wrapupPrompt = wrapupPrompt
        self.mediaRoles = mediaRoles
        self.user = user
        self.queue = queue
        self.team = team
        self.attributes = attributes
        self.errorInfo = errorInfo
        self.script = script
        self.wrapupTimeoutMs = wrapupTimeoutMs
        self.wrapupSkipped = wrapupSkipped
        self.alertingTimeoutMs = alertingTimeoutMs
        self.provider = provider
        self.externalContact = externalContact
        self.externalContactInitialDivisionId = externalContactInitialDivisionId
        self.externalOrganization = externalOrganization
        self.wrapup = wrapup
        self.peer = peer
        self.flaggedReason = flaggedReason
        self.journeyContext = journeyContext
        self.conversationRoutingData = conversationRoutingData
        self.startAcwTime = startAcwTime
        self.endAcwTime = endAcwTime
        self.parkTime = parkTime
        self.resumeTime = resumeTime
        self.subject = subject
        self.messagesSent = messagesSent
        self.autoGenerated = autoGenerated
        self.draftAttachments = draftAttachments
        self.spam = spam
        self.messageId = messageId
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case address
        case startTime
        case startAlertingTime
        case connectedTime
        case endTime
        case startHoldTime
        case purpose
        case state
        case direction
        case disconnectType
        case held
        case wrapupRequired
        case wrapupPrompt
        case mediaRoles
        case user
        case queue
        case team
        case attributes
        case errorInfo
        case script
        case wrapupTimeoutMs
        case wrapupSkipped
        case alertingTimeoutMs
        case provider
        case externalContact
        case externalContactInitialDivisionId
        case externalOrganization
        case wrapup
        case peer
        case flaggedReason
        case journeyContext
        case conversationRoutingData
        case startAcwTime
        case endAcwTime
        case parkTime
        case resumeTime
        case subject
        case messagesSent
        case autoGenerated
        case draftAttachments
        case spam
        case messageId
    }


}




public class EmailRoutingEstablishedEvent: Codable {





















    /** A unique (V4 UUID) eventId for this event */
    public var eventId: String?
    /** A Date Time representing the time this event occurred. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var eventDateTime: Date?
    /** A unique Id (V4 UUID) identifying this conversation */
    public var conversationId: String?
    /** A unique Id (V4 UUID) identifying this communication. */
    public var communicationId: String?
    /** The id of the queue that is routing this conversation. */
    public var queueId: String?
    /** The unique identifiers for the skills that should be used to determine the destination for the conversation. */
    public var skillIds: [String]?
    /** The unique identifier for the language that should be used to determine the destination for the conversation. */
    public var languageId: String?
    /** An optional label that categorizes the conversation. Max-utilization settings can be configured at a per-label level. */
    public var label: String?
    /** Metadata about this communication. */
    public var initialConfiguration: EmailInitialConfiguration?
    /** Metadata about the source of this communication's interaction. */
    public var sourceConfiguration: SourceConfiguration?

    public init(eventId: String?, eventDateTime: Date?, conversationId: String?, communicationId: String?, queueId: String?, skillIds: [String]?, languageId: String?, label: String?, initialConfiguration: EmailInitialConfiguration?, sourceConfiguration: SourceConfiguration?) {
        self.eventId = eventId
        self.eventDateTime = eventDateTime
        self.conversationId = conversationId
        self.communicationId = communicationId
        self.queueId = queueId
        self.skillIds = skillIds
        self.languageId = languageId
        self.label = label
        self.initialConfiguration = initialConfiguration
        self.sourceConfiguration = sourceConfiguration
    }


}




public class EmailUserTransferEvent: Codable {







    public enum TransferType: String, Codable { 
        case attended = "Attended"
        case unattended = "Unattended"
    }











    /** A unique (V4 UUID) eventId for this event */
    public var eventId: String?
    /** A Date Time representing the time this event occurred. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var eventDateTime: Date?
    /** A unique Id (V4 UUID) identifying this conversation */
    public var conversationId: String?
    /** Indicates the desired type of transfer. */
    public var transferType: TransferType?
    /** The id (V4 UUID) used by the external platform to refer to the transfer in subsequent Transfer events. */
    public var commandId: String?
    /** The id (V4 UUID) of the communication representing the participant that is initiating the transfer. */
    public var initiatingCommunicationId: String?
    /** The id (V4 UUID) of the communication that is being transferred away from. In many cases this will be the same as the `initiatingCommunicationId`. */
    public var targetCommunicationId: String?
    /** The id (V4 UUID) of the communication that is being transferred. */
    public var objectCommunicationId: String?
    /** The id (V4 UUID) of the desired destination user that the object communication should be transferred to. */
    public var destinationUserId: String?

    public init(eventId: String?, eventDateTime: Date?, conversationId: String?, transferType: TransferType?, commandId: String?, initiatingCommunicationId: String?, targetCommunicationId: String?, objectCommunicationId: String?, destinationUserId: String?) {
        self.eventId = eventId
        self.eventDateTime = eventDateTime
        self.conversationId = conversationId
        self.transferType = transferType
        self.commandId = commandId
        self.initiatingCommunicationId = initiatingCommunicationId
        self.targetCommunicationId = targetCommunicationId
        self.objectCommunicationId = objectCommunicationId
        self.destinationUserId = destinationUserId
    }


}




public class EmbeddedIntegration: Codable {





    public var enableWhitelist: Bool?
    public var domainWhitelist: [String]?

    public init(enableWhitelist: Bool?, domainWhitelist: [String]?) {
        self.enableWhitelist = enableWhitelist
        self.domainWhitelist = domainWhitelist
    }


}




public class EncryptionKey: Codable {













    public enum KeyConfigurationType: String, Codable { 
        case kmsSymmetric = "KmsSymmetric"
        case localKeyManager = "LocalKeyManager"
        case native = "Native"
        case _none = "None"
    }





    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** create date of the key pair. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var createDate: Date?
    /** key data summary (base 64 encoded public key) */
    public var keydataSummary: String?
    /** user that requested generation of public key */
    public var user: User?
    /** Local configuration */
    public var localEncryptionConfiguration: LocalEncryptionConfiguration?
    /** Key type used in this configuration */
    public var keyConfigurationType: KeyConfigurationType?
    /** ARN of internal key to be wrapped by AWS KMS Symmetric key */
    public var kmsKeyArn: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, createDate: Date?, keydataSummary: String?, user: User?, localEncryptionConfiguration: LocalEncryptionConfiguration?, keyConfigurationType: KeyConfigurationType?, kmsKeyArn: String?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.createDate = createDate
        self.keydataSummary = keydataSummary
        self.user = user
        self.localEncryptionConfiguration = localEncryptionConfiguration
        self.keyConfigurationType = keyConfigurationType
        self.kmsKeyArn = kmsKeyArn
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case createDate
        case keydataSummary
        case user
        case localEncryptionConfiguration
        case keyConfigurationType
        case kmsKeyArn
        case selfUri
    }


}




public class EndConsultTransferEvent: Codable {







    /** A unique (V4 UUID) eventId for this event */
    public var eventId: String?
    /** A Date Time representing the time this event occurred. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var eventDateTime: Date?
    /** A unique Id (V4 UUID) identifying this conversation */
    public var conversationId: String?

    public init(eventId: String?, eventDateTime: Date?, conversationId: String?) {
        self.eventId = eventId
        self.eventDateTime = eventDateTime
        self.conversationId = conversationId
    }


}




public class EngagementRequest: Codable {

    public enum Visibility: String, Codable { 
        case presented = "Presented"
        case notPresented = "NotPresented"
        case unknown = "Unknown"
    }

    public enum Status: String, Codable { 
        case copied = "Copied"
        case notCopied = "NotCopied"
        case unknown = "Unknown"
    }

    /** Represents the visibility of summary */
    public var visibility: Visibility?
    /** Represents the engagements made by the agent in response to the generated summary */
    public var status: Status?

    public init(visibility: Visibility?, status: Status?) {
        self.visibility = visibility
        self.status = status
    }


}




public class EngineIntegration: Codable {





    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, selfUri: String?) {
        self._id = _id
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
    }


}




public class EntityChange: Codable {











    /** Id of the entity that was changed */
    public var entityId: String?
    /** Name of the entity that was changed */
    public var entityName: String?
    /** Type of the entity that was changed */
    public var entityType: String?
    /** Previous values for the entity. */
    public var oldValues: [String]?
    /** New values for the entity. */
    public var newValues: [String]?

    public init(entityId: String?, entityName: String?, entityType: String?, oldValues: [String]?, newValues: [String]?) {
        self.entityId = entityId
        self.entityName = entityName
        self.entityType = entityType
        self.oldValues = oldValues
        self.newValues = newValues
    }


}




public class EntityTypeCriteria: Codable {







    public enum Operator: String, Codable { 
        case containsall = "containsAll"
        case containsany = "containsAny"
        case notcontainsall = "notContainsAll"
        case notcontainsany = "notContainsAny"
        case equal = "equal"
        case notequal = "notEqual"
        case greaterthan = "greaterThan"
        case greaterthanorequal = "greaterThanOrEqual"
        case lessthan = "lessThan"
        case lessthanorequal = "lessThanOrEqual"
        case startswith = "startsWith"
        case endswith = "endsWith"
    }

    public enum EntityType: String, Codable { 
        case visit = "visit"
    }

    /** The criteria key. */
    public var key: String?
    /** The criteria values. */
    public var values: [String]?
    /** Should criteria be case insensitive. */
    public var shouldIgnoreCase: Bool?
    /** The comparison operator. */
    public var _operator: Operator?
    /** The entity to match the pattern against. */
    public var entityType: EntityType?

    public init(key: String?, values: [String]?, shouldIgnoreCase: Bool?, _operator: Operator?, entityType: EntityType?) {
        self.key = key
        self.values = values
        self.shouldIgnoreCase = shouldIgnoreCase
        self._operator = _operator
        self.entityType = entityType
    }

    public enum CodingKeys: String, CodingKey { 
        case key
        case values
        case shouldIgnoreCase
        case _operator = "operator"
        case entityType
    }


}




public class EstimateAvailableTimeOffResponse: Codable {











    /** Full day dates. partialDayDates must be empty if this field is populated */
    public var fullDayDates: [EstimateAvailableFullDayTimeOffResponse]?
    /** Partial day dates. fullDayDates must be empty if this field is populated */
    public var partialDayDates: [EstimateAvailablePartialDayTimeOffResponse]?
    /** The user to whom the time off request belongs */
    public var user: UserReference?
    /** The ID of the activity code associated with the time off request. Activity code must be of the TimeOff category */
    public var activityCodeId: String?
    /** Whether this estimate is for a paid time off request */
    public var paid: Bool?

    public init(fullDayDates: [EstimateAvailableFullDayTimeOffResponse]?, partialDayDates: [EstimateAvailablePartialDayTimeOffResponse]?, user: UserReference?, activityCodeId: String?, paid: Bool?) {
        self.fullDayDates = fullDayDates
        self.partialDayDates = partialDayDates
        self.user = user
        self.activityCodeId = activityCodeId
        self.paid = paid
    }


}




public class EvaluationAggregateQueryFilter: Codable {

    public enum ModelType: String, Codable { 
        case and = "and"
        case or = "or"
    }





    /** Boolean operation to apply to the provided predicates and clauses */
    public var type: ModelType?
    /** Boolean 'and/or' logic with up to two-levels of nesting */
    public var clauses: [EvaluationAggregateQueryClause]?
    /** Like a three-word sentence: (attribute-name) (operator) (target-value). */
    public var predicates: [EvaluationAggregateQueryPredicate]?

    public init(type: ModelType?, clauses: [EvaluationAggregateQueryClause]?, predicates: [EvaluationAggregateQueryPredicate]?) {
        self.type = type
        self.clauses = clauses
        self.predicates = predicates
    }


}




public class EvaluationCreateConversation: Codable {





    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, selfUri: String?) {
        self._id = _id
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
    }


}




public class EvaluationCreateUser: Codable {





    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, selfUri: String?) {
        self._id = _id
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
    }


}




public class EvaluationFormResponse: Codable {













    public enum WeightMode: String, Codable { 
        case scaled = "SCALED"
        case off = "OFF"
    }









    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The evaluation form name */
    public var name: String?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var modifiedDate: Date?
    public var published: Bool?
    public var contextId: String?
    /** A list of question groups */
    public var questionGroups: [EvaluationQuestionGroup]?
    /** Mode for evaluation form weight */
    public var weightMode: WeightMode?
    /** Settings for evaluations associated with this form */
    public var evaluationSettings: EvaluationSettings?
    /** A list of the published versions of this form. Not populated by default, its availability depends on the endpoint. Use the 'expand=publishHistory' query parameter to retrieve this data where applicable (refer to the endpoint description to see if it is applicable). */
    public var publishedVersions: DomainEntityListingEvaluationForm?
    /** AI scoring settings for the evaluation form. */
    public var aiScoring: AiScoringSettings?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, modifiedDate: Date?, published: Bool?, contextId: String?, questionGroups: [EvaluationQuestionGroup]?, weightMode: WeightMode?, evaluationSettings: EvaluationSettings?, publishedVersions: DomainEntityListingEvaluationForm?, aiScoring: AiScoringSettings?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.modifiedDate = modifiedDate
        self.published = published
        self.contextId = contextId
        self.questionGroups = questionGroups
        self.weightMode = weightMode
        self.evaluationSettings = evaluationSettings
        self.publishedVersions = publishedVersions
        self.aiScoring = aiScoring
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case modifiedDate
        case published
        case contextId
        case questionGroups
        case weightMode
        case evaluationSettings
        case publishedVersions
        case aiScoring
        case selfUri
    }


}




public class EvaluationQualityV2TopicEvaluationReference: Codable {



    public var _id: String?

    public init(_id: String?) {
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
    }


}




public class EvaluationQualityV2TopicEvaluationV2: Codable {



















    public enum Status: String, Codable { 
        case pending = "Pending"
        case inProgress = "InProgress"
        case finished = "Finished"
        case inReview = "InReview"
        case retracted = "Retracted"
    }







































    public enum PreviousStatus: String, Codable { 
        case pending = "Pending"
        case inProgress = "InProgress"
        case finished = "Finished"
        case inReview = "InReview"
        case retracted = "Retracted"
    }















    public var _id: String?
    public var conversationId: String?
    public var agent: EvaluationQualityV2TopicUser?
    public var evaluator: EvaluationQualityV2TopicUser?
    public var eventTime: Date?
    public var evaluationFormId: String?
    public var formName: String?
    public var scoringSet: EvaluationQualityV2TopicEvaluationScoringSet?
    public var contextId: String?
    public var status: Status?
    public var agentHasRead: Bool?
    public var releaseDate: Date?
    public var assignedDate: Date?
    public var changedDate: Date?
    public var eventType: String?
    public var resourceId: String?
    public var resourceType: String?
    public var divisionIds: [String]?
    public var rescore: Bool?
    public var conversationDate: Date?
    public var mediaType: [String]?
    public var calibration: EvaluationQualityV2TopicCalibration?
    public var evaluationSource: EvaluationQualityV2TopicEvaluationSource?
    public var assigneeUserId: String?
    public var previousAssigneeUserId: String?
    public var assigneeApplicable: Bool?
    public var evaluationContextId: String?
    public var disputeCount: Int64?
    public var version: Int64?
    public var previousStatus: PreviousStatus?
    public var declinedReview: Bool?
    public var retractedEvaluation: EvaluationQualityV2TopicEvaluationReference?
    public var rescoreCount: Int64?
    public var evaluatorCommentHasUpdated: Bool?
    public var agentCommentHasUpdated: Bool?
    public var previousRescoreCount: Int64?
    public var previousEvaluatorUserId: String?

    public init(_id: String?, conversationId: String?, agent: EvaluationQualityV2TopicUser?, evaluator: EvaluationQualityV2TopicUser?, eventTime: Date?, evaluationFormId: String?, formName: String?, scoringSet: EvaluationQualityV2TopicEvaluationScoringSet?, contextId: String?, status: Status?, agentHasRead: Bool?, releaseDate: Date?, assignedDate: Date?, changedDate: Date?, eventType: String?, resourceId: String?, resourceType: String?, divisionIds: [String]?, rescore: Bool?, conversationDate: Date?, mediaType: [String]?, calibration: EvaluationQualityV2TopicCalibration?, evaluationSource: EvaluationQualityV2TopicEvaluationSource?, assigneeUserId: String?, previousAssigneeUserId: String?, assigneeApplicable: Bool?, evaluationContextId: String?, disputeCount: Int64?, version: Int64?, previousStatus: PreviousStatus?, declinedReview: Bool?, retractedEvaluation: EvaluationQualityV2TopicEvaluationReference?, rescoreCount: Int64?, evaluatorCommentHasUpdated: Bool?, agentCommentHasUpdated: Bool?, previousRescoreCount: Int64?, previousEvaluatorUserId: String?) {
        self._id = _id
        self.conversationId = conversationId
        self.agent = agent
        self.evaluator = evaluator
        self.eventTime = eventTime
        self.evaluationFormId = evaluationFormId
        self.formName = formName
        self.scoringSet = scoringSet
        self.contextId = contextId
        self.status = status
        self.agentHasRead = agentHasRead
        self.releaseDate = releaseDate
        self.assignedDate = assignedDate
        self.changedDate = changedDate
        self.eventType = eventType
        self.resourceId = resourceId
        self.resourceType = resourceType
        self.divisionIds = divisionIds
        self.rescore = rescore
        self.conversationDate = conversationDate
        self.mediaType = mediaType
        self.calibration = calibration
        self.evaluationSource = evaluationSource
        self.assigneeUserId = assigneeUserId
        self.previousAssigneeUserId = previousAssigneeUserId
        self.assigneeApplicable = assigneeApplicable
        self.evaluationContextId = evaluationContextId
        self.disputeCount = disputeCount
        self.version = version
        self.previousStatus = previousStatus
        self.declinedReview = declinedReview
        self.retractedEvaluation = retractedEvaluation
        self.rescoreCount = rescoreCount
        self.evaluatorCommentHasUpdated = evaluatorCommentHasUpdated
        self.agentCommentHasUpdated = agentCommentHasUpdated
        self.previousRescoreCount = previousRescoreCount
        self.previousEvaluatorUserId = previousEvaluatorUserId
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case conversationId
        case agent
        case evaluator
        case eventTime
        case evaluationFormId
        case formName
        case scoringSet
        case contextId
        case status
        case agentHasRead
        case releaseDate
        case assignedDate
        case changedDate
        case eventType
        case resourceId
        case resourceType
        case divisionIds
        case rescore
        case conversationDate
        case mediaType
        case calibration
        case evaluationSource
        case assigneeUserId
        case previousAssigneeUserId
        case assigneeApplicable
        case evaluationContextId
        case disputeCount
        case version
        case previousStatus
        case declinedReview
        case retractedEvaluation
        case rescoreCount
        case evaluatorCommentHasUpdated
        case agentCommentHasUpdated
        case previousRescoreCount
        case previousEvaluatorUserId
    }


}




public class EvaluationQuestion: Codable {









    public enum ModelType: String, Codable { 
        case multiplechoicequestion = "multipleChoiceQuestion"
        case multipleselectquestion = "multipleSelectQuestion"
        case freetextquestion = "freeTextQuestion"
        case npsquestion = "npsQuestion"
        case readonlytextblockquestion = "readOnlyTextBlockQuestion"
    }















    public var _id: String?
    /** An identifier for this question that stays the same across versions of the form. */
    public var contextId: String?
    public var text: String?
    public var helpText: String?
    public var type: ModelType?
    public var naEnabled: Bool?
    public var commentsRequired: Bool?
    public var visibilityCondition: VisibilityCondition?
    /** Options from which to choose an answer for this question. Only used by Multiple Choice type questions. */
    public var answerOptions: [AnswerOption]?
    /** Only used by Multiple Select type questions. A list of multiple choice questions representing selectable options. */
    public var multipleSelectOptionQuestions: [EvaluationQuestion]?
    public var isCritical: Bool?
    public var isKill: Bool?

    public init(_id: String?, contextId: String?, text: String?, helpText: String?, type: ModelType?, naEnabled: Bool?, commentsRequired: Bool?, visibilityCondition: VisibilityCondition?, answerOptions: [AnswerOption]?, multipleSelectOptionQuestions: [EvaluationQuestion]?, isCritical: Bool?, isKill: Bool?) {
        self._id = _id
        self.contextId = contextId
        self.text = text
        self.helpText = helpText
        self.type = type
        self.naEnabled = naEnabled
        self.commentsRequired = commentsRequired
        self.visibilityCondition = visibilityCondition
        self.answerOptions = answerOptions
        self.multipleSelectOptionQuestions = multipleSelectOptionQuestions
        self.isCritical = isCritical
        self.isKill = isKill
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case contextId
        case text
        case helpText
        case type
        case naEnabled
        case commentsRequired
        case visibilityCondition
        case answerOptions
        case multipleSelectOptionQuestions
        case isCritical
        case isKill
    }


}




public class EvaluationQuestionGroup: Codable {























    public var _id: String?
    /** An identifier for this question group that stays the same across versions of the form. */
    public var contextId: String?
    public var name: String?
    public var type: String?
    public var defaultAnswersToHighest: Bool?
    public var defaultAnswersToNA: Bool?
    public var naEnabled: Bool?
    public var weight: Float?
    public var manualWeight: Bool?
    public var questions: [EvaluationQuestion]?
    public var visibilityCondition: VisibilityCondition?

    public init(_id: String?, contextId: String?, name: String?, type: String?, defaultAnswersToHighest: Bool?, defaultAnswersToNA: Bool?, naEnabled: Bool?, weight: Float?, manualWeight: Bool?, questions: [EvaluationQuestion]?, visibilityCondition: VisibilityCondition?) {
        self._id = _id
        self.contextId = contextId
        self.name = name
        self.type = type
        self.defaultAnswersToHighest = defaultAnswersToHighest
        self.defaultAnswersToNA = defaultAnswersToNA
        self.naEnabled = naEnabled
        self.weight = weight
        self.manualWeight = manualWeight
        self.questions = questions
        self.visibilityCondition = visibilityCondition
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case contextId
        case name
        case type
        case defaultAnswersToHighest
        case defaultAnswersToNA
        case naEnabled
        case weight
        case manualWeight
        case questions
        case visibilityCondition
    }


}




public class EvaluationReference: Codable {





    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, selfUri: String?) {
        self._id = _id
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
    }


}




public class EvaluatorActivityEntityListing: Codable {





















    public var entities: [EvaluatorActivity]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var previousUri: String?
    public var nextUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [EvaluatorActivity]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, previousUri: String?, nextUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.previousUri = previousUri
        self.nextUri = nextUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class Event: Codable {

























    /** System-generated UUID for the event. */
    public var _id: String?
    /** UUID corresponding to triggering action that caused this event (e.g. HTTP POST, SIP invite, another event). */
    public var correlationId: String?
    /** Primary identifier of the customer in the source of the events. */
    public var customerId: String?
    /** Type of primary identifier (e.g. cookie, email, phone). */
    public var customerIdType: String?
    /** The session that the event belongs to. */
    public var session: EventSession?
    /** The name representing the type of event. */
    public var eventType: String?
    /** Event where a customer has achieved a specific outcome or goal. */
    public var outcomeAchievedEvent: OutcomeAchievedEvent?
    /** Event that represents a segment being assigned. */
    public var segmentAssignmentEvent: SegmentAssignmentEvent?
    /** Event triggered by web actions. */
    public var webActionEvent: WebActionEvent?
    /** Event that tracks user interactions with content in a browser such as pageviews, downloads, mobile ad clicks, etc. */
    public var webEvent: WebEvent?
    /** Event that tracks user interactions with content in an application such as screen views, searches, etc. */
    public var appEvent: AppEvent?
    /** Timestamp indicating when the event actually took place. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var createdDate: Date?

    public init(_id: String?, correlationId: String?, customerId: String?, customerIdType: String?, session: EventSession?, eventType: String?, outcomeAchievedEvent: OutcomeAchievedEvent?, segmentAssignmentEvent: SegmentAssignmentEvent?, webActionEvent: WebActionEvent?, webEvent: WebEvent?, appEvent: AppEvent?, createdDate: Date?) {
        self._id = _id
        self.correlationId = correlationId
        self.customerId = customerId
        self.customerIdType = customerIdType
        self.session = session
        self.eventType = eventType
        self.outcomeAchievedEvent = outcomeAchievedEvent
        self.segmentAssignmentEvent = segmentAssignmentEvent
        self.webActionEvent = webActionEvent
        self.webEvent = webEvent
        self.appEvent = appEvent
        self.createdDate = createdDate
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case correlationId
        case customerId
        case customerIdType
        case session
        case eventType
        case outcomeAchievedEvent
        case segmentAssignmentEvent
        case webActionEvent
        case webEvent
        case appEvent
        case createdDate
    }


}




public class EventAggregatesResponse: Codable {





    /** Interval for returned aggregates. Intervals are represented as an ISO-8601 string. For example: YYYY-MM-DDThh:mm:ss/YYYY-MM-DDThh:mm:ss */
    public var interval: String?
    /** Aggregates by event definition */
    public var eventDefinitionAggregates: [EventDefinitionAggregates]?

    public init(interval: String?, eventDefinitionAggregates: [EventDefinitionAggregates]?) {
        self.interval = interval
        self.eventDefinitionAggregates = eventDefinitionAggregates
    }


}




public class EventCondition: Codable {





    public enum Operator: String, Codable { 
        case containsall = "containsAll"
        case containsany = "containsAny"
        case notcontainsall = "notContainsAll"
        case notcontainsany = "notContainsAny"
        case equal = "equal"
        case notequal = "notEqual"
        case greaterthan = "greaterThan"
        case greaterthanorequal = "greaterThanOrEqual"
        case lessthan = "lessThan"
        case lessthanorequal = "lessThanOrEqual"
        case startswith = "startsWith"
        case endswith = "endsWith"
    }

    public enum StreamType: String, Codable { 
        case web = "Web"
        case custom = "Custom"
        case conversation = "Conversation"
        case app = "App"
    }





    /** The event key. */
    public var key: String?
    /** The event values. */
    public var values: [String]?
    /** The comparison operator. */
    public var _operator: Operator?
    /** The stream type for which this condition can be satisfied. */
    public var streamType: StreamType?
    /** The session type for which this condition can be satisfied. */
    public var sessionType: String?
    /** The name of the event for which this condition can be satisfied. */
    public var eventName: String?

    public init(key: String?, values: [String]?, _operator: Operator?, streamType: StreamType?, sessionType: String?, eventName: String?) {
        self.key = key
        self.values = values
        self._operator = _operator
        self.streamType = streamType
        self.sessionType = sessionType
        self.eventName = eventName
    }

    public enum CodingKeys: String, CodingKey { 
        case key
        case values
        case _operator = "operator"
        case streamType
        case sessionType
        case eventName
    }


}




public class EventListing: Codable {









    public var entities: [Event]?
    public var nextUri: String?
    public var selfUri: String?
    public var previousUri: String?

    public init(entities: [Event]?, nextUri: String?, selfUri: String?, previousUri: String?) {
        self.entities = entities
        self.nextUri = nextUri
        self.selfUri = selfUri
        self.previousUri = previousUri
    }


}




public class EventLog: Codable {











    public enum Level: String, Codable { 
        case info = "INFO"
        case warning = "WARNING"
        case error = "ERROR"
    }

    public enum Category: String, Codable { 
        case callback = "CALLBACK"
        case callRestriction = "CALL_RESTRICTION"
        case callRule = "CALL_RULE"
        case campaign = "CAMPAIGN"
        case campaignRule = "CAMPAIGN_RULE"
        case contact = "CONTACT"
        case contactListFilter = "CONTACT_LIST_FILTER"
        case digitalRule = "DIGITAL_RULE"
        case dncList = "DNC_LIST"
        case entityLimit = "ENTITY_LIMIT"
        case importError = "IMPORT_ERROR"
        case messageRestriction = "MESSAGE_RESTRICTION"
        case messagingCampaign = "MESSAGING_CAMPAIGN"
        case importTemplate = "IMPORT_TEMPLATE"
        case organizationConfiguration = "ORGANIZATION_CONFIGURATION"
        case schedule = "SCHEDULE"
        case messagingCampaignSchedule = "MESSAGING_CAMPAIGN_SCHEDULE"
        case emailCampaignSchedule = "EMAIL_CAMPAIGN_SCHEDULE"
        case whatsappCampaignSchedule = "WHATSAPP_CAMPAIGN_SCHEDULE"
    }







    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    public var errorEntity: DomainEntityRef?
    public var relatedEntity: DomainEntityRef?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var timestamp: Date?
    public var level: Level?
    public var category: Category?
    public var correlationId: String?
    public var eventMessage: EventMessage?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, errorEntity: DomainEntityRef?, relatedEntity: DomainEntityRef?, timestamp: Date?, level: Level?, category: Category?, correlationId: String?, eventMessage: EventMessage?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.errorEntity = errorEntity
        self.relatedEntity = relatedEntity
        self.timestamp = timestamp
        self.level = level
        self.category = category
        self.correlationId = correlationId
        self.eventMessage = eventMessage
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case errorEntity
        case relatedEntity
        case timestamp
        case level
        case category
        case correlationId
        case eventMessage
        case selfUri
    }


}




public class EventSession: Codable {







    /** The ID of the session. */
    public var _id: String?
    public var selfUri: String?
    /** Session types indicate the type or category of sessions (e.g. web, app). */
    public var type: String?

    public init(_id: String?, selfUri: String?, type: String?) {
        self._id = _id
        self.selfUri = selfUri
        self.type = type
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
        case type
    }


}




public class ExpiredEdgeListing: Codable {



    public var entities: [DomainEntityRef]?

    public init(entities: [DomainEntityRef]?) {
        self.entities = entities
    }


}




public class ExtensionEntityListing: Codable {























    public var entities: [Extension]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    /** The total organization-wide number of entities. */
    public var totalNumberOfEntities: Int64?
    public var firstUri: String?
    public var previousUri: String?
    public var nextUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [Extension]?, pageSize: Int?, pageNumber: Int?, total: Int64?, totalNumberOfEntities: Int64?, firstUri: String?, previousUri: String?, nextUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.totalNumberOfEntities = totalNumberOfEntities
        self.firstUri = firstUri
        self.previousUri = previousUri
        self.nextUri = nextUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class ExtensionPoolEntityListing: Codable {























    public var entities: [ExtensionPool]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    /** The total organization-wide number of entities. */
    public var totalNumberOfEntities: Int64?
    public var firstUri: String?
    public var previousUri: String?
    public var nextUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [ExtensionPool]?, pageSize: Int?, pageNumber: Int?, total: Int64?, totalNumberOfEntities: Int64?, firstUri: String?, previousUri: String?, nextUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.totalNumberOfEntities = totalNumberOfEntities
        self.firstUri = firstUri
        self.previousUri = previousUri
        self.nextUri = nextUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class ExternalContactsContactChangedTopicExternalOrganization: Codable {







































    public var _id: String?
    public var division: ExternalContactsContactChangedTopicDivision?
    public var name: String?
    public var companyType: String?
    public var industry: String?
    public var primaryContactId: String?
    public var address: ExternalContactsContactChangedTopicContactAddress?
    public var phoneNumber: ExternalContactsContactChangedTopicPhoneNumber?
    public var faxNumber: ExternalContactsContactChangedTopicPhoneNumber?
    public var employeeCount: Int64?
    public var revenue: Int64?
    public var tags: [String]?
    public var websites: [String]?
    public var tickers: [ExternalContactsContactChangedTopicTicker]?
    public var twitterId: ExternalContactsContactChangedTopicTwitterId?
    public var externalSystemUrl: String?
    public var customFields: [String:JSON]?
    public var createDate: Date?
    public var modifyDate: Date?

    public init(_id: String?, division: ExternalContactsContactChangedTopicDivision?, name: String?, companyType: String?, industry: String?, primaryContactId: String?, address: ExternalContactsContactChangedTopicContactAddress?, phoneNumber: ExternalContactsContactChangedTopicPhoneNumber?, faxNumber: ExternalContactsContactChangedTopicPhoneNumber?, employeeCount: Int64?, revenue: Int64?, tags: [String]?, websites: [String]?, tickers: [ExternalContactsContactChangedTopicTicker]?, twitterId: ExternalContactsContactChangedTopicTwitterId?, externalSystemUrl: String?, customFields: [String:JSON]?, createDate: Date?, modifyDate: Date?) {
        self._id = _id
        self.division = division
        self.name = name
        self.companyType = companyType
        self.industry = industry
        self.primaryContactId = primaryContactId
        self.address = address
        self.phoneNumber = phoneNumber
        self.faxNumber = faxNumber
        self.employeeCount = employeeCount
        self.revenue = revenue
        self.tags = tags
        self.websites = websites
        self.tickers = tickers
        self.twitterId = twitterId
        self.externalSystemUrl = externalSystemUrl
        self.customFields = customFields
        self.createDate = createDate
        self.modifyDate = modifyDate
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case division
        case name
        case companyType
        case industry
        case primaryContactId
        case address
        case phoneNumber
        case faxNumber
        case employeeCount
        case revenue
        case tags
        case websites
        case tickers
        case twitterId
        case externalSystemUrl
        case customFields
        case createDate
        case modifyDate
    }


}




public class ExternalContactsOrganizationChangedTopicContactAddress: Codable {













    public var address1: String?
    public var address2: String?
    public var city: String?
    public var state: String?
    public var postalCode: String?
    public var countryCode: String?

    public init(address1: String?, address2: String?, city: String?, state: String?, postalCode: String?, countryCode: String?) {
        self.address1 = address1
        self.address2 = address2
        self.city = city
        self.state = state
        self.postalCode = postalCode
        self.countryCode = countryCode
    }


}




public class ExternalContactsOrganizationNoteChangedTopicUser: Codable {



    public var _id: String?

    public init(_id: String?) {
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
    }


}




public class ExternalContactsRelationshipChangedTopicExternalOrganization: Codable {







































    public var _id: String?
    public var division: ExternalContactsRelationshipChangedTopicDivision?
    public var name: String?
    public var companyType: String?
    public var industry: String?
    public var primaryContactId: String?
    public var address: ExternalContactsRelationshipChangedTopicContactAddress?
    public var phoneNumber: ExternalContactsRelationshipChangedTopicPhoneNumber?
    public var faxNumber: ExternalContactsRelationshipChangedTopicPhoneNumber?
    public var employeeCount: Int64?
    public var revenue: Int64?
    public var tags: [String]?
    public var websites: [String]?
    public var tickers: [ExternalContactsRelationshipChangedTopicTicker]?
    public var twitterId: ExternalContactsRelationshipChangedTopicTwitterId?
    public var externalSystemUrl: String?
    public var customFields: [String:JSON]?
    public var createDate: Date?
    public var modifyDate: Date?

    public init(_id: String?, division: ExternalContactsRelationshipChangedTopicDivision?, name: String?, companyType: String?, industry: String?, primaryContactId: String?, address: ExternalContactsRelationshipChangedTopicContactAddress?, phoneNumber: ExternalContactsRelationshipChangedTopicPhoneNumber?, faxNumber: ExternalContactsRelationshipChangedTopicPhoneNumber?, employeeCount: Int64?, revenue: Int64?, tags: [String]?, websites: [String]?, tickers: [ExternalContactsRelationshipChangedTopicTicker]?, twitterId: ExternalContactsRelationshipChangedTopicTwitterId?, externalSystemUrl: String?, customFields: [String:JSON]?, createDate: Date?, modifyDate: Date?) {
        self._id = _id
        self.division = division
        self.name = name
        self.companyType = companyType
        self.industry = industry
        self.primaryContactId = primaryContactId
        self.address = address
        self.phoneNumber = phoneNumber
        self.faxNumber = faxNumber
        self.employeeCount = employeeCount
        self.revenue = revenue
        self.tags = tags
        self.websites = websites
        self.tickers = tickers
        self.twitterId = twitterId
        self.externalSystemUrl = externalSystemUrl
        self.customFields = customFields
        self.createDate = createDate
        self.modifyDate = modifyDate
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case division
        case name
        case companyType
        case industry
        case primaryContactId
        case address
        case phoneNumber
        case faxNumber
        case employeeCount
        case revenue
        case tags
        case websites
        case tickers
        case twitterId
        case externalSystemUrl
        case customFields
        case createDate
        case modifyDate
    }


}




public class ExternalContactsUnresolvedContactChangedTopicContact: Codable {







    public enum ModelType: String, Codable { 
        case ephemeral = "Ephemeral"
        case identified = "Identified"
        case curated = "Curated"
    }































































    public var _id: String?
    public var division: ExternalContactsUnresolvedContactChangedTopicDivision?
    public var externalOrganization: ExternalContactsUnresolvedContactChangedTopicExternalOrganization?
    public var type: ModelType?
    public var firstName: String?
    public var middleName: String?
    public var lastName: String?
    public var salutation: String?
    public var title: String?
    public var workPhone: ExternalContactsUnresolvedContactChangedTopicPhoneNumber?
    public var cellPhone: ExternalContactsUnresolvedContactChangedTopicPhoneNumber?
    public var homePhone: ExternalContactsUnresolvedContactChangedTopicPhoneNumber?
    public var otherPhone: ExternalContactsUnresolvedContactChangedTopicPhoneNumber?
    public var workEmail: String?
    public var personalEmail: String?
    public var otherEmail: String?
    public var address: ExternalContactsUnresolvedContactChangedTopicContactAddress?
    public var surveyOptOut: Bool?
    public var externalSystemUrl: String?
    public var twitterId: ExternalContactsUnresolvedContactChangedTopicTwitterId?
    public var lineId: ExternalContactsUnresolvedContactChangedTopicLineId?
    public var whatsAppId: ExternalContactsUnresolvedContactChangedTopicWhatsAppId?
    public var facebookId: ExternalContactsUnresolvedContactChangedTopicFacebookId?
    public var instagramId: ExternalContactsUnresolvedContactChangedTopicInstagramId?
    public var externalIds: [ExternalContactsUnresolvedContactChangedTopicExternalId]?
    public var appleOpaqueIds: [ExternalContactsUnresolvedContactChangedTopicAppleOpaqueId]?
    public var canonicalContactId: String?
    public var schema: ExternalContactsUnresolvedContactChangedTopicDataSchema?
    public var customFields: [String:JSON]?
    public var mergeSet: [String]?
    public var mergedFrom: [String]?
    public var mergedTo: String?
    public var mergeOperation: ExternalContactsUnresolvedContactChangedTopicMergeOperation?
    public var createDate: Date?
    public var modifyDate: Date?

    public init(_id: String?, division: ExternalContactsUnresolvedContactChangedTopicDivision?, externalOrganization: ExternalContactsUnresolvedContactChangedTopicExternalOrganization?, type: ModelType?, firstName: String?, middleName: String?, lastName: String?, salutation: String?, title: String?, workPhone: ExternalContactsUnresolvedContactChangedTopicPhoneNumber?, cellPhone: ExternalContactsUnresolvedContactChangedTopicPhoneNumber?, homePhone: ExternalContactsUnresolvedContactChangedTopicPhoneNumber?, otherPhone: ExternalContactsUnresolvedContactChangedTopicPhoneNumber?, workEmail: String?, personalEmail: String?, otherEmail: String?, address: ExternalContactsUnresolvedContactChangedTopicContactAddress?, surveyOptOut: Bool?, externalSystemUrl: String?, twitterId: ExternalContactsUnresolvedContactChangedTopicTwitterId?, lineId: ExternalContactsUnresolvedContactChangedTopicLineId?, whatsAppId: ExternalContactsUnresolvedContactChangedTopicWhatsAppId?, facebookId: ExternalContactsUnresolvedContactChangedTopicFacebookId?, instagramId: ExternalContactsUnresolvedContactChangedTopicInstagramId?, externalIds: [ExternalContactsUnresolvedContactChangedTopicExternalId]?, appleOpaqueIds: [ExternalContactsUnresolvedContactChangedTopicAppleOpaqueId]?, canonicalContactId: String?, schema: ExternalContactsUnresolvedContactChangedTopicDataSchema?, customFields: [String:JSON]?, mergeSet: [String]?, mergedFrom: [String]?, mergedTo: String?, mergeOperation: ExternalContactsUnresolvedContactChangedTopicMergeOperation?, createDate: Date?, modifyDate: Date?) {
        self._id = _id
        self.division = division
        self.externalOrganization = externalOrganization
        self.type = type
        self.firstName = firstName
        self.middleName = middleName
        self.lastName = lastName
        self.salutation = salutation
        self.title = title
        self.workPhone = workPhone
        self.cellPhone = cellPhone
        self.homePhone = homePhone
        self.otherPhone = otherPhone
        self.workEmail = workEmail
        self.personalEmail = personalEmail
        self.otherEmail = otherEmail
        self.address = address
        self.surveyOptOut = surveyOptOut
        self.externalSystemUrl = externalSystemUrl
        self.twitterId = twitterId
        self.lineId = lineId
        self.whatsAppId = whatsAppId
        self.facebookId = facebookId
        self.instagramId = instagramId
        self.externalIds = externalIds
        self.appleOpaqueIds = appleOpaqueIds
        self.canonicalContactId = canonicalContactId
        self.schema = schema
        self.customFields = customFields
        self.mergeSet = mergeSet
        self.mergedFrom = mergedFrom
        self.mergedTo = mergedTo
        self.mergeOperation = mergeOperation
        self.createDate = createDate
        self.modifyDate = modifyDate
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case division
        case externalOrganization
        case type
        case firstName
        case middleName
        case lastName
        case salutation
        case title
        case workPhone
        case cellPhone
        case homePhone
        case otherPhone
        case workEmail
        case personalEmail
        case otherEmail
        case address
        case surveyOptOut
        case externalSystemUrl
        case twitterId
        case lineId
        case whatsAppId
        case facebookId
        case instagramId
        case externalIds
        case appleOpaqueIds
        case canonicalContactId
        case schema
        case customFields
        case mergeSet
        case mergedFrom
        case mergedTo
        case mergeOperation
        case createDate
        case modifyDate
    }


}




public class ExternalContactsUnresolvedContactChangedTopicContactAddress: Codable {













    public var address1: String?
    public var address2: String?
    public var city: String?
    public var state: String?
    public var postalCode: String?
    public var countryCode: String?

    public init(address1: String?, address2: String?, city: String?, state: String?, postalCode: String?, countryCode: String?) {
        self.address1 = address1
        self.address2 = address2
        self.city = city
        self.state = state
        self.postalCode = postalCode
        self.countryCode = countryCode
    }


}




public class ExternalContactsUnresolvedContactChangedTopicDataSchema: Codable {





    public var _id: String?
    public var version: Int64?

    public init(_id: String?, version: Int64?) {
        self._id = _id
        self.version = version
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case version
    }


}




public class ExternalContactsUnresolvedContactChangedTopicMergeOperation: Codable {







    public var sourceContactId: String?
    public var targetContactId: String?
    public var resultingContactId: String?

    public init(sourceContactId: String?, targetContactId: String?, resultingContactId: String?) {
        self.sourceContactId = sourceContactId
        self.targetContactId = targetContactId
        self.resultingContactId = resultingContactId
    }


}




public class ExternalContactsUnresolvedContactChangedTopicWhatsAppId: Codable {





    public var phoneNumber: ExternalContactsUnresolvedContactChangedTopicPhoneNumber?
    public var displayName: String?

    public init(phoneNumber: ExternalContactsUnresolvedContactChangedTopicPhoneNumber?, displayName: String?) {
        self.phoneNumber = phoneNumber
        self.displayName = displayName
    }


}




public class ExternalMetricDataItem: Codable {













    public enum ModelType: String, Codable { 
        case total = "Total"
        case cumulative = "Cumulative"
    }

    /** The user ID. Must provide either userId or userEmail, but not both. */
    public var userId: String?
    /** The user main email used in user's GenesysCloud account. Must provide either userId or userEmail, but not both. */
    public var userEmail: String?
    /** The ID of the external metric definition */
    public var metricId: String?
    /** The date of the metric data. Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd */
    public var dateOccurred: Date?
    /** The value of the metric data. When value is null, the metric data will be deleted. */
    public var value: Double?
    /** The number of data points. The default value is 0 when type is Cumulative and the metric data already exists, otherwise 1. When total count reaches 0, the metric data will be deleted. */
    public var count: Int?
    /** The type of the metric data. The default value is Total. */
    public var type: ModelType?

    public init(userId: String?, userEmail: String?, metricId: String?, dateOccurred: Date?, value: Double?, count: Int?, type: ModelType?) {
        self.userId = userId
        self.userEmail = userEmail
        self.metricId = metricId
        self.dateOccurred = dateOccurred
        self.value = value
        self.count = count
        self.type = type
    }


}




public class ExternalOrganization: Codable {

















































    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The name of the company. */
    public var name: String?
    /** The division to which this entity belongs. */
    public var division: WritableStarrableDivision?
    public var companyType: String?
    public var industry: String?
    public var address: ContactAddress?
    public var phoneNumber: PhoneNumber?
    public var faxNumber: PhoneNumber?
    public var employeeCount: Int64?
    public var revenue: Int64?
    public var tags: [String]?
    public var websites: [String]?
    public var tickers: [Ticker]?
    public var twitterId: TwitterId?
    /** A string that identifies an external system-of-record resource that may have more detailed information on the organization. It should be a valid URL (including the http/https protocol, port, and path [if any]). The value is automatically trimmed of any leading and trailing whitespace. */
    public var externalSystemUrl: String?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var modifyDate: Date?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var createDate: Date?
    public var trustor: Trustor?
    /** The schema defining custom fields for this contact */
    public var schema: DataSchema?
    /** Custom fields defined in the schema referenced by schemaId and schemaVersion. */
    public var customFields: [String:JSON]?
    /** Identifiers claimed by this external org */
    public var identifiers: [ExternalOrganizationIdentifier]?
    /** A list of external identifiers that identify this External Organization in an external system */
    public var externalIds: [ExternalId]?
    /** Links to the sources of data (e.g. one source might be a CRM) that contributed data to this record.  Read-only, and only populated when requested via expand param. */
    public var externalDataSources: [ExternalDataSource]?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, division: WritableStarrableDivision?, companyType: String?, industry: String?, address: ContactAddress?, phoneNumber: PhoneNumber?, faxNumber: PhoneNumber?, employeeCount: Int64?, revenue: Int64?, tags: [String]?, websites: [String]?, tickers: [Ticker]?, twitterId: TwitterId?, externalSystemUrl: String?, modifyDate: Date?, createDate: Date?, trustor: Trustor?, schema: DataSchema?, customFields: [String:JSON]?, identifiers: [ExternalOrganizationIdentifier]?, externalIds: [ExternalId]?, externalDataSources: [ExternalDataSource]?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.division = division
        self.companyType = companyType
        self.industry = industry
        self.address = address
        self.phoneNumber = phoneNumber
        self.faxNumber = faxNumber
        self.employeeCount = employeeCount
        self.revenue = revenue
        self.tags = tags
        self.websites = websites
        self.tickers = tickers
        self.twitterId = twitterId
        self.externalSystemUrl = externalSystemUrl
        self.modifyDate = modifyDate
        self.createDate = createDate
        self.trustor = trustor
        self.schema = schema
        self.customFields = customFields
        self.identifiers = identifiers
        self.externalIds = externalIds
        self.externalDataSources = externalDataSources
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case division
        case companyType
        case industry
        case address
        case phoneNumber
        case faxNumber
        case employeeCount
        case revenue
        case tags
        case websites
        case tickers
        case twitterId
        case externalSystemUrl
        case modifyDate
        case createDate
        case trustor
        case schema
        case customFields
        case identifiers
        case externalIds
        case externalDataSources
        case selfUri
    }


}




public class ExternalOrganizationListing: Codable {























    public var entities: [ExternalOrganization]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var partialResults: Bool?
    public var firstUri: String?
    public var previousUri: String?
    public var nextUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [ExternalOrganization]?, pageSize: Int?, pageNumber: Int?, total: Int64?, partialResults: Bool?, firstUri: String?, previousUri: String?, nextUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.partialResults = partialResults
        self.firstUri = firstUri
        self.previousUri = previousUri
        self.nextUri = nextUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class FacebookDataIngestionRuleRequest: Codable {







    /** The name of the data ingestion rule. */
    public var name: String?
    /** A description of the data ingestion rule. */
    public var _description: String?
    /** The Integration Id from which to ingest public social posts. This entity is created using the /conversations/messaging/integrations/facebook resource */
    public var integrationId: String?

    public init(name: String?, _description: String?, integrationId: String?) {
        self.name = name
        self._description = _description
        self.integrationId = integrationId
    }

    public enum CodingKeys: String, CodingKey { 
        case name
        case _description = "description"
        case integrationId
    }


}



/** Facebook Permissions Model */

public class FacebookPermission: Codable {



    public enum ModelType: String, Codable { 
        case facebookPrivate = "FacebookPrivate"
        case facebookPublic = "FacebookPublic"
        case instagramPrivate = "InstagramPrivate"
        case instagramPublic = "InstagramPublic"
        case whatsAppPrivate = "WhatsAppPrivate"
    }

    /** Facebook permission name */
    public var name: String?
    /** Facebook permission type */
    public var type: ModelType?

    public init(name: String?, type: ModelType?) {
        self.name = name
        self.type = type
    }


}




public class Fallback: Codable {





    /** Fallback actions are enabled. */
    public var enabled: Bool?
    /** Fallback actions. */
    public var actions: [CopilotFallbackAction]?

    public init(enabled: Bool?, actions: [CopilotFallbackAction]?) {
        self.enabled = enabled
        self.actions = actions
    }


}




public class FaxTopicFaxDataV2: Codable {



































    public var _id: String?
    public var name: String?
    public var dateCreated: Date?
    public var dateModified: Date?
    public var workspace: FaxTopicWorkspaceData?
    public var createdBy: FaxTopicUserData?
    public var contentType: String?
    public var contentLength: Int64?
    public var filename: String?
    public var changeNumber: Int64?
    public var dateUploaded: Date?
    public var uploadedBy: FaxTopicUserData?
    public var lockInfo: FaxTopicLockData?
    public var selfUri: String?
    public var callerAddress: String?
    public var receiverAddress: String?
    public var read: Bool?

    public init(_id: String?, name: String?, dateCreated: Date?, dateModified: Date?, workspace: FaxTopicWorkspaceData?, createdBy: FaxTopicUserData?, contentType: String?, contentLength: Int64?, filename: String?, changeNumber: Int64?, dateUploaded: Date?, uploadedBy: FaxTopicUserData?, lockInfo: FaxTopicLockData?, selfUri: String?, callerAddress: String?, receiverAddress: String?, read: Bool?) {
        self._id = _id
        self.name = name
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.workspace = workspace
        self.createdBy = createdBy
        self.contentType = contentType
        self.contentLength = contentLength
        self.filename = filename
        self.changeNumber = changeNumber
        self.dateUploaded = dateUploaded
        self.uploadedBy = uploadedBy
        self.lockInfo = lockInfo
        self.selfUri = selfUri
        self.callerAddress = callerAddress
        self.receiverAddress = receiverAddress
        self.read = read
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case dateCreated
        case dateModified
        case workspace
        case createdBy
        case contentType
        case contentLength
        case filename
        case changeNumber
        case dateUploaded
        case uploadedBy
        case lockInfo
        case selfUri
        case callerAddress
        case receiverAddress
        case read
    }


}




public class FaxTopicLockData: Codable {







    public var lockedBy: FaxTopicUserData?
    public var dateCreated: Date?
    public var dateExpires: Date?

    public init(lockedBy: FaxTopicUserData?, dateCreated: Date?, dateExpires: Date?) {
        self.lockedBy = lockedBy
        self.dateCreated = dateCreated
        self.dateExpires = dateExpires
    }


}




public class FaxTopicWorkspaceData: Codable {



    public var _id: String?

    public init(_id: String?) {
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
    }


}




public class FeatureState: Codable {



    public var enabled: Bool?

    public init(enabled: Bool?) {
        self.enabled = enabled
    }


}




public class FeedbackUpdateRequest: Codable {

    public enum Rating: String, Codable { 
        case positive = "Positive"
        case negative = "Negative"
        case unknown = "Unknown"
    }



    /** Agents rating for the system-generated summary. */
    public var rating: Rating?
    /** Agent's summary for the conversation */
    public var summary: String?

    public init(rating: Rating?, summary: String?) {
        self.rating = rating
        self.summary = summary
    }


}




public class FileSpecificationTemplateEntityListing: Codable {





















    public var entities: [FileSpecificationTemplate]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var previousUri: String?
    public var nextUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [FileSpecificationTemplate]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, previousUri: String?, nextUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.previousUri = previousUri
        self.nextUri = nextUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class Filter: Codable {









    /** The name of the field by which to filter. */
    public var name: String?
    /** The type of the filter, DATE or STRING. */
    public var type: String?
    /** The operation that the filter performs. */
    public var _operator: String?
    /** The values to make the filter comparison against. */
    public var values: [String]?

    public init(name: String?, type: String?, _operator: String?, values: [String]?) {
        self.name = name
        self.type = type
        self._operator = _operator
        self.values = values
    }

    public enum CodingKeys: String, CodingKey { 
        case name
        case type
        case _operator = "operator"
        case values
    }


}




public class FilterPreviewResponse: Codable {







    public var filteredContacts: Int64?
    public var totalContacts: Int64?
    public var preview: [DialerContact]?

    public init(filteredContacts: Int64?, totalContacts: Int64?, preview: [DialerContact]?) {
        self.filteredContacts = filteredContacts
        self.totalContacts = totalContacts
        self.preview = preview
    }


}




public class FixedAvailability: Codable {





    public enum DaysOfWeek: String, Codable { 
        case sunday = "Sunday"
        case monday = "Monday"
        case tuesday = "Tuesday"
        case wednesday = "Wednesday"
        case thursday = "Thursday"
        case friday = "Friday"
        case saturday = "Saturday"
    }

    /** The range of time of day the activity can be scheduled */
    public var availabilityRange: AvailabilityRange?
    /** The range of date for which the activity plan could be scheduled */
    public var dateRange: RequiredLocalDateRange?
    /** The days of week available for scheduling. Empty list or null means daysOfWeek is not considered */
    public var daysOfWeek: [DaysOfWeek]?

    public init(availabilityRange: AvailabilityRange?, dateRange: RequiredLocalDateRange?, daysOfWeek: [DaysOfWeek]?) {
        self.availabilityRange = availabilityRange
        self.dateRange = dateRange
        self.daysOfWeek = daysOfWeek
    }


}




public class FlowActivityMetricValue: Codable {

    public enum Metric: String, Codable { 
        case oflow = "oFlow"
    }







    /** Metric */
    public var metric: Metric?
    /** Metric qualifier */
    public var qualifier: String?
    /** Entity ids for matching entities if details were requested */
    public var entityIds: [String]?
    /** Metric count */
    public var count: Int?

    public init(metric: Metric?, qualifier: String?, entityIds: [String]?, count: Int?) {
        self.metric = metric
        self.qualifier = qualifier
        self.entityIds = entityIds
        self.count = count
    }


}




public class FlowActivityQueryMetric: Codable {

    public enum Metric: String, Codable { 
        case oflow = "oFlow"
    }



    /** The requested metric */
    public var metric: Metric?
    /** Flag for including observation details for this metric in the response */
    public var details: Bool?

    public init(metric: Metric?, details: Bool?) {
        self.metric = metric
        self.details = details
    }


}




public class FlowAggregateQueryFilter: Codable {

    public enum ModelType: String, Codable { 
        case and = "and"
        case or = "or"
    }





    /** Boolean operation to apply to the provided predicates and clauses */
    public var type: ModelType?
    /** Boolean 'and/or' logic with up to two-levels of nesting */
    public var clauses: [FlowAggregateQueryClause]?
    /** Like a three-word sentence: (attribute-name) (operator) (target-value). */
    public var predicates: [FlowAggregateQueryPredicate]?

    public init(type: ModelType?, clauses: [FlowAggregateQueryClause]?, predicates: [FlowAggregateQueryPredicate]?) {
        self.type = type
        self.clauses = clauses
        self.predicates = predicates
    }


}



/** Parameters for launching a flow. */

public class FlowExecutionLaunchRequest: Codable {









    /** ID of the flow to launch. */
    public var flowId: String?
    /** The version of the flow to launch. Omit this value (or supply null/empty) to use the latest published version. */
    public var flowVersion: String?
    /** Input values to the flow. Valid values are defined by a flow's input JSON schema. */
    public var inputData: [String:JSON]?
    /** A displayable name to assign to the new flow execution */
    public var name: String?

    public init(flowId: String?, flowVersion: String?, inputData: [String:JSON]?, name: String?) {
        self.flowId = flowId
        self.flowVersion = flowVersion
        self.inputData = inputData
        self.name = name
    }


}




public class FlowHealthErrorInfo: Codable {









    public var message: String?
    public var code: String?
    /** Error message with params included. */
    public var messageWithParams: String?
    /** Map of variables and params for the error message. */
    public var messageParams: [String:JSON]?

    public init(message: String?, code: String?, messageWithParams: String?, messageParams: [String:JSON]?) {
        self.message = message
        self.code = code
        self.messageWithParams = messageWithParams
        self.messageParams = messageParams
    }


}




public class FlowHealthVersionInfo: Codable {





    /** Given flow's Version Info. */
    public var flowVersion: AddressableEntityRef?
    /** NLU Domain Info for this flow version. */
    public var nluDomain: AddressableEntityRef?

    public init(flowVersion: AddressableEntityRef?, nluDomain: AddressableEntityRef?) {
        self.flowVersion = flowVersion
        self.nluDomain = nluDomain
    }


}



/** Defines a characteristic that can be captured by data providers */

public class FlowLogLevelCharacteristicsDefinition: Codable {



    public enum MinimumLevel: String, Codable { 
        case unknown = "Unknown"
        case disabled = "Disabled"
        case base = "Base"
        case notes = "Notes"
        case verboseNotes = "VerboseNotes"
        case all = "All"
    }



    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The minimum level required for this characteristic to be enabled. */
    public var minimumLevel: MinimumLevel?
    /** If set, this is the id of the characteristic that this one depends on and it must be enabled for this to be enabled. */
    public var dependsOn: FlowCharacteristics?

    public init(_id: String?, minimumLevel: MinimumLevel?, dependsOn: FlowCharacteristics?) {
        self._id = _id
        self.minimumLevel = minimumLevel
        self.dependsOn = dependsOn
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case minimumLevel
        case dependsOn
    }


}



/** A set of available characteristic definitions */

public class FlowLogLevelCharacteristicsDefinitions: Codable {





    /** A list of flow log levels available to the organization. */
    public var logLevels: [FlowLogLevel]?
    /** A list of characteristics that the loglevels will have that are available to the organization.. */
    public var characteristics: [FlowLogLevelCharacteristicsDefinition]?

    public init(logLevels: [FlowLogLevel]?, characteristics: [FlowLogLevelCharacteristicsDefinition]?) {
        self.logLevels = logLevels
        self.characteristics = characteristics
    }


}




public class FlowObservationQueryPredicate: Codable {

    public enum ModelType: String, Codable { 
        case dimension = "dimension"
        case property = "property"
        case metric = "metric"
    }

    public enum Dimension: String, Codable { 
        case flowid = "flowId"
        case mediatype = "mediaType"
    }

    public enum Operator: String, Codable { 
        case matches = "matches"
        case exists = "exists"
        case notexists = "notExists"
    }





    /** Optional type, can usually be inferred */
    public var type: ModelType?
    /** Left hand side for dimension predicates */
    public var dimension: Dimension?
    /** Optional operator, default is matches */
    public var _operator: Operator?
    /** Right hand side for dimension predicates */
    public var value: String?
    /** Right hand side for dimension predicates */
    public var range: NumericRange?

    public init(type: ModelType?, dimension: Dimension?, _operator: Operator?, value: String?, range: NumericRange?) {
        self.type = type
        self.dimension = dimension
        self._operator = _operator
        self.value = value
        self.range = range
    }

    public enum CodingKeys: String, CodingKey { 
        case type
        case dimension
        case _operator = "operator"
        case value
        case range
    }


}




public class FlowOutcomeDetailEventTopicFlowOutcomeEvent: Codable {









    public enum MediaType: String, Codable { 
        case unknown = "UNKNOWN"
        case voice = "VOICE"
        case chat = "CHAT"
        case email = "EMAIL"
        case callback = "CALLBACK"
        case cobrowse = "COBROWSE"
        case video = "VIDEO"
        case screenshare = "SCREENSHARE"
        case message = "MESSAGE"
        case internalmessage = "INTERNALMESSAGE"
    }



    public enum Direction: String, Codable { 
        case unknown = "UNKNOWN"
        case inbound = "INBOUND"
        case outbound = "OUTBOUND"
    }











    public enum MessageType: String, Codable { 
        case unknown = "UNKNOWN"
        case sms = "SMS"
        case twitter = "TWITTER"
        case facebook = "FACEBOOK"
        case line = "LINE"
        case whatsapp = "WHATSAPP"
        case webmessaging = "WEBMESSAGING"
        case _open = "OPEN"
        case instagram = "INSTAGRAM"
        case apple = "APPLE"
    }

    public enum FlowType: String, Codable { 
        case unknown = "UNKNOWN"
        case inboundcall = "INBOUNDCALL"
        case outboundcall = "OUTBOUNDCALL"
        case inqueuecall = "INQUEUECALL"
        case securecall = "SECURECALL"
        case inboundemail = "INBOUNDEMAIL"
        case surveyinvite = "SURVEYINVITE"
        case inboundshortmessage = "INBOUNDSHORTMESSAGE"
        case inboundchat = "INBOUNDCHAT"
        case workflow = "WORKFLOW"
        case bot = "BOT"
        case digitalbot = "DIGITALBOT"
        case commonmodule = "COMMONMODULE"
        case inqueueemail = "INQUEUEEMAIL"
        case inqueueshortmessage = "INQUEUESHORTMESSAGE"
        case voice = "VOICE"
        case voicemail = "VOICEMAIL"
        case workitem = "WORKITEM"
        case voicesurvey = "VOICESURVEY"
    }













    public enum FlowOutcomeValue: String, Codable { 
        case unknown = "UNKNOWN"
        case success = "SUCCESS"
        case failure = "FAILURE"
    }







    public var eventTime: Int64?
    public var conversationId: String?
    public var participantId: String?
    public var sessionId: String?
    public var mediaType: MediaType?
    public var provider: String?
    public var direction: Direction?
    public var ani: String?
    public var dnis: String?
    public var addressTo: String?
    public var addressFrom: String?
    public var subject: String?
    public var messageType: MessageType?
    public var flowType: FlowType?
    public var flowId: String?
    public var divisionId: String?
    public var flowVersion: String?
    public var flowOutcomeId: UUID?
    public var flowOutcomeStartTime: Int64?
    public var flowOutcomeEndTime: Int64?
    public var flowOutcomeValue: FlowOutcomeValue?
    public var flowMilestones: [FlowOutcomeDetailEventTopicFlowMilestone]?
    public var conversationExternalContactIds: [String]?
    public var conversationExternalOrganizationIds: [String]?

    public init(eventTime: Int64?, conversationId: String?, participantId: String?, sessionId: String?, mediaType: MediaType?, provider: String?, direction: Direction?, ani: String?, dnis: String?, addressTo: String?, addressFrom: String?, subject: String?, messageType: MessageType?, flowType: FlowType?, flowId: String?, divisionId: String?, flowVersion: String?, flowOutcomeId: UUID?, flowOutcomeStartTime: Int64?, flowOutcomeEndTime: Int64?, flowOutcomeValue: FlowOutcomeValue?, flowMilestones: [FlowOutcomeDetailEventTopicFlowMilestone]?, conversationExternalContactIds: [String]?, conversationExternalOrganizationIds: [String]?) {
        self.eventTime = eventTime
        self.conversationId = conversationId
        self.participantId = participantId
        self.sessionId = sessionId
        self.mediaType = mediaType
        self.provider = provider
        self.direction = direction
        self.ani = ani
        self.dnis = dnis
        self.addressTo = addressTo
        self.addressFrom = addressFrom
        self.subject = subject
        self.messageType = messageType
        self.flowType = flowType
        self.flowId = flowId
        self.divisionId = divisionId
        self.flowVersion = flowVersion
        self.flowOutcomeId = flowOutcomeId
        self.flowOutcomeStartTime = flowOutcomeStartTime
        self.flowOutcomeEndTime = flowOutcomeEndTime
        self.flowOutcomeValue = flowOutcomeValue
        self.flowMilestones = flowMilestones
        self.conversationExternalContactIds = conversationExternalContactIds
        self.conversationExternalOrganizationIds = conversationExternalOrganizationIds
    }


}




public class FlowPathsElement: Codable {



    public enum ModelType: String, Codable { 
        case abandoned = "Abandoned"
        case agentEscalation = "AgentEscalation"
        case disconnect = "Disconnect"
        case error = "Error"
        case exit = "Exit"
        case milestone = "Milestone"
        case outcome = "Outcome"
        case recognitionFailure = "RecognitionFailure"
        case root = "Root"
        case transferReturnToAgent = "TransferReturnToAgent"
        case transferToAcd = "TransferToAcd"
        case transferToAcdVoicemail = "TransferToAcdVoicemail"
        case transferToFlow = "TransferToFlow"
        case transferToGroup = "TransferToGroup"
        case transferToGroupVoicemail = "TransferToGroupVoicemail"
        case transferToNumber = "TransferToNumber"
        case transferToSecureFlow = "TransferToSecureFlow"
        case transferToUser = "TransferToUser"
        case transferToUserVoicemail = "TransferToUserVoicemail"
    }





    public enum FlowOutcomeValue: String, Codable { 
        case failure = "FAILURE"
        case success = "SUCCESS"
        case unknown = "UNKNOWN"
    }





    /** Unique identifier of the parent element. Will be null for the root element. */
    public var parentId: String?
    /** Type of the element. */
    public var type: ModelType?
    /** Count of all journeys that include this element. */
    public var count: Int?
    /** Details of flows involved in journeys that include this element. */
    public var flows: [FlowPathsFlowDetails]?
    /** The value of the flow outcome, if the element type is Outcome. */
    public var flowOutcomeValue: FlowOutcomeValue?
    /** The flow milestone, set if the element type is Milestone. */
    public var flowMilestone: AddressableEntityRef?
    /** The flow outcome, set if the element type is Outcome or Milestone. */
    public var flowOutcome: AddressableEntityRef?

    public init(parentId: String?, type: ModelType?, count: Int?, flows: [FlowPathsFlowDetails]?, flowOutcomeValue: FlowOutcomeValue?, flowMilestone: AddressableEntityRef?, flowOutcome: AddressableEntityRef?) {
        self.parentId = parentId
        self.type = type
        self.count = count
        self.flows = flows
        self.flowOutcomeValue = flowOutcomeValue
        self.flowMilestone = flowMilestone
        self.flowOutcome = flowOutcome
    }


}




public class FlowPathsQuery: Codable {

    public enum Category: String, Codable { 
        case all = "All"
        case abandoned = "Abandoned"
        case agentEscalation = "AgentEscalation"
        case complete = "Complete"
        case disconnect = "Disconnect"
        case error = "Error"
        case recognitionFailure = "RecognitionFailure"
        case transfer = "Transfer"
    }



    /** Category (use case) of the paths within a given domain. */
    public var category: Category?
    /** List of flows to query the paths result. */
    public var flows: [FlowPathsFlowFilter]?

    public init(category: Category?, flows: [FlowPathsFlowFilter]?) {
        self.category = category
        self.flows = flows
    }


}




public class FlowResultEntityListing: Codable {





















    public var entities: [FlowExecutionDataQueryResult]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var previousUri: String?
    public var nextUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [FlowExecutionDataQueryResult]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, previousUri: String?, nextUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.previousUri = previousUri
        self.nextUri = nextUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}



/** This is a table of settings per a loglevel that define what will be logged in executionData when enabled (true) */

public class FlowSettingsResponse: Codable {





    public enum ModelType: String, Codable { 
        case bot = "bot"
        case commonmodule = "commonmodule"
        case digitalbot = "digitalbot"
        case inboundcall = "inboundcall"
        case inboundchat = "inboundchat"
        case inboundemail = "inboundemail"
        case inboundshortmessage = "inboundshortmessage"
        case inqueuecall = "inqueuecall"
        case inqueueshortmessage = "inqueueshortmessage"
        case inqueueemail = "inqueueemail"
        case outboundcall = "outboundcall"
        case securecall = "securecall"
        case surveyinvite = "surveyinvite"
        case voice = "voice"
        case voicemail = "voicemail"
        case voicesurvey = "voicesurvey"
        case workflow = "workflow"
        case workitem = "workitem"
    }











    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** The Flow Type */
    public var type: ModelType?
    /** User that last changed the log level setting. */
    public var modifiedBy: UserReference?
    /** OAuth client that last changed the log level setting. */
    public var modifiedByClient: DomainEntityRef?
    /** The time this log level was set. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** The log level set for this flow */
    public var logLevelCharacteristics: FlowLogLevel?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, type: ModelType?, modifiedBy: UserReference?, modifiedByClient: DomainEntityRef?, dateModified: Date?, logLevelCharacteristics: FlowLogLevel?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.type = type
        self.modifiedBy = modifiedBy
        self.modifiedByClient = modifiedByClient
        self.dateModified = dateModified
        self.logLevelCharacteristics = logLevelCharacteristics
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case type
        case modifiedBy
        case modifiedByClient
        case dateModified
        case logLevelCharacteristics
        case selfUri
    }


}




public class ForecastMetadata: Codable {







    public enum Source: String, Codable { 
        case automaticBestMethod = "AutomaticBestMethod"
        case mainForecast = "MainForecast"
    }





    /** Forecast creation date. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** Forecast ID */
    public var forecastId: String?
    /** Interval length */
    public var intervalLengthInMinutes: String?
    /** Forecast source */
    public var source: Source?
    /** Forecast start date. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateStart: Date?
    /** Timezone of the business unit */
    public var timeZone: String?

    public init(dateCreated: Date?, forecastId: String?, intervalLengthInMinutes: String?, source: Source?, dateStart: Date?, timeZone: String?) {
        self.dateCreated = dateCreated
        self.forecastId = forecastId
        self.intervalLengthInMinutes = intervalLengthInMinutes
        self.source = source
        self.dateStart = dateStart
        self.timeZone = timeZone
    }


}




public class ForecastPlanningGroupData: Codable {







    /** The ID of the planning group to which this data applies. Note this is a snapshot of the planning group at the time of forecast creation and may not correspond to the current configuration */
    public var planningGroupId: String?
    /** Forecast offered counts per 15 minute interval for this week of the forecast */
    public var offeredPerInterval: [Double]?
    /** Forecast average handle time per 15 minute interval in seconds */
    public var averageHandleTimeSecondsPerInterval: [Double]?

    public init(planningGroupId: String?, offeredPerInterval: [Double]?, averageHandleTimeSecondsPerInterval: [Double]?) {
        self.planningGroupId = planningGroupId
        self.offeredPerInterval = offeredPerInterval
        self.averageHandleTimeSecondsPerInterval = averageHandleTimeSecondsPerInterval
    }


}




public class ForecastServiceGoalTemplateImpactOverrideResponse: Codable {







    /** Allowed service level percent increase and decrease; undefined if the goal is not enabled */
    public var serviceLevel: WfmServiceGoalImpact?
    /** Allowed average speed of answer percent increase and decrease; undefined if the goal is not enabled */
    public var averageSpeedOfAnswer: WfmServiceGoalImpact?
    /** Allowed abandon rate percent increase and decrease; undefined if the goal is not enabled */
    public var abandonRate: WfmServiceGoalImpact?

    public init(serviceLevel: WfmServiceGoalImpact?, averageSpeedOfAnswer: WfmServiceGoalImpact?, abandonRate: WfmServiceGoalImpact?) {
        self.serviceLevel = serviceLevel
        self.averageSpeedOfAnswer = averageSpeedOfAnswer
        self.abandonRate = abandonRate
    }


}



/** Form configuration for response management */

public class Form: Codable {













    /** Description of the form */
    public var formDescription: String?
    /** Message displayed when response is received */
    public var receivedMessage: FormMessage?
    /** Message displayed as reply */
    public var replyMessage: FormMessage?
    /** Introduction section of the form */
    public var introduction: FormIntroduction?
    /** Pages of the form */
    public var formPages: [FormPage]?
    /** Whether to show a summary after form completion */
    public var showSummary: Bool?

    public init(formDescription: String?, receivedMessage: FormMessage?, replyMessage: FormMessage?, introduction: FormIntroduction?, formPages: [FormPage]?, showSummary: Bool?) {
        self.formDescription = formDescription
        self.receivedMessage = receivedMessage
        self.replyMessage = replyMessage
        self.introduction = introduction
        self.formPages = formPages
        self.showSummary = showSummary
    }


}



/** Details about a forms tracking event trigger */

public class FormsTrackTrigger: Codable {









    /** Form element that triggers the form submitted or abandoned event. */
    public var selector: String?
    /** Prefix for the form submitted or abandoned event name. */
    public var formName: String?
    /** Whether to capture the form data in the form abandoned event. */
    public var captureDataOnFormAbandon: Bool?
    /** Whether to capture the form data in the form submitted event. */
    public var captureDataOnFormSubmit: Bool?

    public init(selector: String?, formName: String?, captureDataOnFormAbandon: Bool?, captureDataOnFormSubmit: Bool?) {
        self.selector = selector
        self.formName = formName
        self.captureDataOnFormAbandon = captureDataOnFormAbandon
        self.captureDataOnFormSubmit = captureDataOnFormSubmit
    }


}




public class GDPRJourneyCustomer: Codable {





    /** The type of the customerId within the Journey System (e.g. cookie). Required if `id` is defined. */
    public var type: String?
    /** An ID of a customer within the Journey System at a point-in-time. Required if `type` is defined. */
    public var _id: String?

    public init(type: String?, _id: String?) {
        self.type = type
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case type
        case _id = "id"
    }


}




public class GKNDocumentationSearchResponse: Codable {



















    /** The total number of results found */
    public var total: Int64?
    /** The total number of pages */
    public var pageCount: Int?
    /** The current page size */
    public var pageSize: Int?
    /** The current page number */
    public var pageNumber: Int?
    /** Q64 value for the previous page of results */
    public var previousPage: String?
    /** Q64 value for the current page of results */
    public var currentPage: String?
    /** Q64 value for the next page of results */
    public var nextPage: String?
    /** Resource types the search was performed against */
    public var types: [String]?
    /** Search results */
    public var results: [GKNDocumentationResult]?

    public init(total: Int64?, pageCount: Int?, pageSize: Int?, pageNumber: Int?, previousPage: String?, currentPage: String?, nextPage: String?, types: [String]?, results: [GKNDocumentationResult]?) {
        self.total = total
        self.pageCount = pageCount
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.previousPage = previousPage
        self.currentPage = currentPage
        self.nextPage = nextPage
        self.types = types
        self.results = results
    }


}




public class GenericTemplate: Codable {











    /** Text to show in the title. */
    public var title: String?
    /** Text to show in the description. */
    public var _description: String?
    /** URL of an image. */
    public var url: String?
    /** List of button components offered with this message content. */
    public var components: [RecordingButtonComponent]?
    /** Actions to be taken. */
    public var actions: RecordingContentActions?

    public init(title: String?, _description: String?, url: String?, components: [RecordingButtonComponent]?, actions: RecordingContentActions?) {
        self.title = title
        self._description = _description
        self.url = url
        self.components = components
        self.actions = actions
    }

    public enum CodingKeys: String, CodingKey { 
        case title
        case _description = "description"
        case url
        case components
        case actions
    }


}




public class GeolocationEventGeolocation: Codable {











    public var userId: String?
    public var type: String?
    public var country: String?
    public var region: String?
    public var city: String?

    public init(userId: String?, type: String?, country: String?, region: String?, city: String?) {
        self.userId = userId
        self.type = type
        self.country = country
        self.region = region
        self.city = city
    }


}




public class GeolocationSettings: Codable {











    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    public var enabled: Bool?
    public var mapboxKey: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, enabled: Bool?, mapboxKey: String?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.enabled = enabled
        self.mapboxKey = mapboxKey
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case enabled
        case mapboxKey
        case selfUri
    }


}



/** This is a list of executionData links that can be used to download the complete executionData */

public class GetFlowExecutionDataJobResult: Codable {







    public enum JobState: String, Codable { 
        case registered = "Registered"
        case running = "Running"
        case success = "Success"
        case failed = "Failed"
    }



    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** On jobState = Success this field will be populated with the list of results of files for download. */
    public var entities: [ExecutionDataEntity]?
    /** The state of the backend process to prep the files for download. */
    public var jobState: JobState?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, entities: [ExecutionDataEntity]?, jobState: JobState?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.entities = entities
        self.jobState = jobState
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case entities
        case jobState
        case selfUri
    }


}




public class GraphApiSettings: Codable {



    public enum Status: String, Codable { 
        case active = "Active"
        case error = "Error"
        case inactive = "Inactive"
        case integrationDeleted = "IntegrationDeleted"
        case unknown = "Unknown"
    }



    /** The Graph API server integration to use for emails. */
    public var integration: DomainEntityRef?
    /** Graph API Server Status */
    public var status: Status?
    /** Additional Graph API Server error information */
    public var errorInfo: EmailErrorInfo?

    public init(integration: DomainEntityRef?, status: Status?, errorInfo: EmailErrorInfo?) {
        self.integration = integration
        self.status = status
        self.errorInfo = errorInfo
    }


}




public class GreetingOwner: Codable {







    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case selfUri
    }


}




public class GroupGreetingEventGreetingOwner: Codable {



    public var _id: String?

    public init(_id: String?) {
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
    }


}




public class GroupSettings: Codable {









    /** The minimum size of a group for a session */
    public var minimumGroupSize: Int?
    /** The maximum size of a group for a session */
    public var maximumGroupSize: Int?
    /** The maximum total number of sessions */
    public var maximumTotalSessions: Int?
    /** The maximum number of sessions that can be scheduled concurrently */
    public var maximumConcurrentSessions: Int?

    public init(minimumGroupSize: Int?, maximumGroupSize: Int?, maximumTotalSessions: Int?, maximumConcurrentSessions: Int?) {
        self.minimumGroupSize = minimumGroupSize
        self.maximumGroupSize = maximumGroupSize
        self.maximumTotalSessions = maximumTotalSessions
        self.maximumConcurrentSessions = maximumConcurrentSessions
    }


}




public class HealthInfo: Codable {

    public enum Status: String, Codable { 
        case inProgress = "InProgress"
        case completed = "Completed"
        case error = "Error"
    }







    public enum StaticValidationResults: String, Codable { 
        case tooFewUtterances = "TooFewUtterances"
        case tooManyUtterances = "TooManyUtterances"
        case utteranceTooShort = "UtteranceTooShort"
        case utteranceTooLong = "UtteranceTooLong"
    }



    /** Status of health computation for this intent. */
    public var status: Status?
    /** Error details for the intent, if any. */
    public var errorInfo: FlowHealthErrorInfo?
    /** Overall health score for the intent ranged between 0 and 100 as 100 is the perfect health score. */
    public var overallScore: Float?
    /** Number of issues found in the intent. */
    public var issueCount: Int64?
    /** Validation results for the intent. */
    public var staticValidationResults: [StaticValidationResults]?
    /** Utterances for this intent. */
    public var utterances: [FlowHealthIntentUtterance]?

    public init(status: Status?, errorInfo: FlowHealthErrorInfo?, overallScore: Float?, issueCount: Int64?, staticValidationResults: [StaticValidationResults]?, utterances: [FlowHealthIntentUtterance]?) {
        self.status = status
        self.errorInfo = errorInfo
        self.overallScore = overallScore
        self.issueCount = issueCount
        self.staticValidationResults = staticValidationResults
        self.utterances = utterances
    }


}




public class HistoricalAdherenceActuals: Codable {

    public enum ActualActivityCategory: String, Codable { 
        case onQueueWork = "OnQueueWork"
        case _break = "Break"
        case meal = "Meal"
        case meeting = "Meeting"
        case offQueueWork = "OffQueueWork"
        case timeOff = "TimeOff"
        case training = "Training"
        case unavailable = "Unavailable"
        case unscheduled = "Unscheduled"
    }







    /** Activity in which the user is actually engaged */
    public var actualActivityCategory: ActualActivityCategory?
    /** The lookup ID used to retrieve the actual secondary status from map of lookup ID to corresponding secondary presence ID */
    public var actualSecondaryPresenceLookupId: String?
    /** Actual start offset in seconds relative to query start time */
    public var startOffsetSeconds: Int?
    /** Actual end offset in seconds relative to query start time */
    public var endOffsetSeconds: Int?

    public init(actualActivityCategory: ActualActivityCategory?, actualSecondaryPresenceLookupId: String?, startOffsetSeconds: Int?, endOffsetSeconds: Int?) {
        self.actualActivityCategory = actualActivityCategory
        self.actualSecondaryPresenceLookupId = actualSecondaryPresenceLookupId
        self.startOffsetSeconds = startOffsetSeconds
        self.endOffsetSeconds = endOffsetSeconds
    }


}




public class HistoricalDataDisallowedDeleteEntity: Codable {



    public enum Reason: String, Codable { 
        case invalidRequest = "InvalidRequest"
        case validationInProgress = "ValidationInProgress"
        case deleteInProgress = "DeleteInProgress"
        case requestIdNotFound = "RequestIdNotFound"
    }

    /** The requestId associated with this disallowed entity */
    public var requestId: String?
    /** The error code explaining why the delete request for the requestId was disallowed */
    public var reason: Reason?

    public init(requestId: String?, reason: Reason?) {
        self.requestId = requestId
        self.reason = reason
    }


}




public class HistoricalDataJobEntityStatus: Codable {



    public enum State: String, Codable { 
        case processing = "Processing"
        case complete = "Complete"
        case error = "Error"
    }



    /** The Job Id Request */
    public var _id: String?
    /** Property denoting the status of the delete job */
    public var state: State?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, state: State?, selfUri: String?) {
        self._id = _id
        self.state = state
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case state
        case selfUri
    }


}




public class HistoricalImportDeleteFilesJobRequest: Codable {



    /** List of requestIds to be deleted. Max number of RequestIds should be 100 */
    public var requestIds: [String]?

    public init(requestIds: [String]?) {
        self.requestIds = requestIds
    }


}




public class HistoryEntry: Codable {

    public enum Action: String, Codable { 
        case checkin = "CHECKIN"
        case checkout = "CHECKOUT"
        case create = "CREATE"
        case deactivate = "DEACTIVATE"
        case debug = "DEBUG"
        case delete = "DELETE"
        case publish = "PUBLISH"
        case revert = "REVERT"
        case save = "SAVE"
        case transcode = "TRANSCODE"
        case update = "UPDATE"
        case upload = "UPLOAD"
    }

















    /** The action performed */
    public var action: Action?
    /** For actions performed not on the item itself, but on a sub-item, this field identifies the sub-item by name.  For example, for actions performed on prompt resources, this will be the prompt resource name. */
    public var resource: String?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var timestamp: Date?
    /** User associated with this entry. */
    public var user: User?
    /** OAuth client associated with this entry. */
    public var client: DomainEntityRef?
    public var version: String?
    public var secure: Bool?
    public var virtualAgentEnabled: Bool?
    public var agenticVirtualAgentEnabled: Bool?

    public init(action: Action?, resource: String?, timestamp: Date?, user: User?, client: DomainEntityRef?, version: String?, secure: Bool?, virtualAgentEnabled: Bool?, agenticVirtualAgentEnabled: Bool?) {
        self.action = action
        self.resource = resource
        self.timestamp = timestamp
        self.user = user
        self.client = client
        self.version = version
        self.secure = secure
        self.virtualAgentEnabled = virtualAgentEnabled
        self.agenticVirtualAgentEnabled = agenticVirtualAgentEnabled
    }


}




public class HistoryListing: Codable {

















    public enum ActionName: String, Codable { 
        case create = "CREATE"
        case checkin = "CHECKIN"
        case checkout = "CHECKOUT"
        case debug = "DEBUG"
        case delete = "DELETE"
        case history = "HISTORY"
        case publish = "PUBLISH"
        case revert = "REVERT"
        case save = "SAVE"
        case stateChange = "STATE_CHANGE"
        case update = "UPDATE"
        case validate = "VALIDATE"
    }

    public enum ActionStatus: String, Codable { 
        case locked = "LOCKED"
        case unlocked = "UNLOCKED"
        case started = "STARTED"
        case pendingGeneration = "PENDING_GENERATION"
        case pendingBackendNotification = "PENDING_BACKEND_NOTIFICATION"
        case success = "SUCCESS"
        case failure = "FAILURE"
    }





















    public var _id: String?
    public var complete: Bool?
    public var user: User?
    public var client: DomainEntityRef?
    public var errorMessage: String?
    public var errorCode: String?
    public var errorDetails: [Detail]?
    public var errorMessageParams: [String:String]?
    /** Action name */
    public var actionName: ActionName?
    /** Action status */
    public var actionStatus: ActionStatus?
    public var name: String?
    public var _description: String?
    public var system: Bool?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var started: Date?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var completed: Date?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var entities: [HistoryEntry]?
    public var pageCount: Int?

    public init(_id: String?, complete: Bool?, user: User?, client: DomainEntityRef?, errorMessage: String?, errorCode: String?, errorDetails: [Detail]?, errorMessageParams: [String:String]?, actionName: ActionName?, actionStatus: ActionStatus?, name: String?, _description: String?, system: Bool?, started: Date?, completed: Date?, pageSize: Int?, pageNumber: Int?, total: Int64?, entities: [HistoryEntry]?, pageCount: Int?) {
        self._id = _id
        self.complete = complete
        self.user = user
        self.client = client
        self.errorMessage = errorMessage
        self.errorCode = errorCode
        self.errorDetails = errorDetails
        self.errorMessageParams = errorMessageParams
        self.actionName = actionName
        self.actionStatus = actionStatus
        self.name = name
        self._description = _description
        self.system = system
        self.started = started
        self.completed = completed
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.entities = entities
        self.pageCount = pageCount
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case complete
        case user
        case client
        case errorMessage
        case errorCode
        case errorDetails
        case errorMessageParams
        case actionName
        case actionStatus
        case name
        case _description = "description"
        case system
        case started
        case completed
        case pageSize
        case pageNumber
        case total
        case entities
        case pageCount
    }


}




public class HomerRecord: Codable {







































































































    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** metadata associated to the SIP calls. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var date: Date?
    /** metadata associated to the SIP calls */
    public var milliTs: String?
    /** metadata associated to the SIP calls */
    public var microTs: String?
    /** metadata associated to the SIP calls */
    public var method: String?
    /** metadata associated to the SIP calls */
    public var replyReason: String?
    /** metadata associated to the SIP calls */
    public var ruri: String?
    /** metadata associated to the SIP calls */
    public var ruriUser: String?
    /** metadata associated to the SIP calls */
    public var ruriDomain: String?
    /** metadata associated to the SIP calls */
    public var fromUser: String?
    /** metadata associated to the SIP calls */
    public var fromDomain: String?
    /** metadata associated to the SIP calls */
    public var fromTag: String?
    /** metadata associated to the SIP calls */
    public var toUser: String?
    /** metadata associated to the SIP calls */
    public var toDomain: String?
    /** metadata associated to the SIP calls */
    public var toTag: String?
    /** metadata associated to the SIP calls */
    public var pidUser: String?
    /** metadata associated to the SIP calls */
    public var contactUser: String?
    /** metadata associated to the SIP calls */
    public var authUser: String?
    /** metadata associated to the SIP calls */
    public var callid: String?
    /** metadata associated to the SIP calls */
    public var callidAleg: String?
    /** metadata associated to the SIP calls */
    public var via1: String?
    /** metadata associated to the SIP calls */
    public var via1Branch: String?
    /** metadata associated to the SIP calls */
    public var cseq: String?
    /** metadata associated to the SIP calls */
    public var diversion: String?
    /** metadata associated to the SIP calls */
    public var reason: String?
    /** metadata associated to the SIP calls */
    public var contentType: String?
    /** metadata associated to the SIP calls */
    public var auth: String?
    /** metadata associated to the SIP calls */
    public var userAgent: String?
    /** metadata associated to the SIP calls */
    public var sourceIp: String?
    /** metadata associated to the SIP calls */
    public var sourcePort: String?
    /** metadata associated to the SIP calls */
    public var destinationIp: String?
    /** metadata associated to the SIP calls */
    public var destinationPort: String?
    /** metadata associated to the SIP calls */
    public var contactIp: String?
    /** metadata associated to the SIP calls */
    public var contactPort: String?
    /** metadata associated to the SIP calls */
    public var originatorIp: String?
    /** metadata associated to the SIP calls */
    public var originatorPort: String?
    /** metadata associated to the SIP calls */
    public var correlationId: String?
    /** metadata associated to the SIP calls */
    public var proto: String?
    /** metadata associated to the SIP calls */
    public var family: String?
    /** metadata associated to the SIP calls */
    public var rtpStat: String?
    /** metadata associated to the SIP calls */
    public var type: String?
    /** metadata associated to the SIP calls */
    public var node: String?
    /** metadata associated to the SIP calls */
    public var trans: String?
    /** metadata associated to the SIP calls */
    public var dbnode: String?
    /** metadata associated to the SIP calls */
    public var msg: String?
    /** metadata associated to the SIP calls */
    public var sourceAlias: String?
    /** metadata associated to the SIP calls */
    public var destinationAlias: String?
    /** metadata associated to the SIP calls */
    public var conversationId: String?
    /** metadata associated to the SIP calls */
    public var participantId: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, date: Date?, milliTs: String?, microTs: String?, method: String?, replyReason: String?, ruri: String?, ruriUser: String?, ruriDomain: String?, fromUser: String?, fromDomain: String?, fromTag: String?, toUser: String?, toDomain: String?, toTag: String?, pidUser: String?, contactUser: String?, authUser: String?, callid: String?, callidAleg: String?, via1: String?, via1Branch: String?, cseq: String?, diversion: String?, reason: String?, contentType: String?, auth: String?, userAgent: String?, sourceIp: String?, sourcePort: String?, destinationIp: String?, destinationPort: String?, contactIp: String?, contactPort: String?, originatorIp: String?, originatorPort: String?, correlationId: String?, proto: String?, family: String?, rtpStat: String?, type: String?, node: String?, trans: String?, dbnode: String?, msg: String?, sourceAlias: String?, destinationAlias: String?, conversationId: String?, participantId: String?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.date = date
        self.milliTs = milliTs
        self.microTs = microTs
        self.method = method
        self.replyReason = replyReason
        self.ruri = ruri
        self.ruriUser = ruriUser
        self.ruriDomain = ruriDomain
        self.fromUser = fromUser
        self.fromDomain = fromDomain
        self.fromTag = fromTag
        self.toUser = toUser
        self.toDomain = toDomain
        self.toTag = toTag
        self.pidUser = pidUser
        self.contactUser = contactUser
        self.authUser = authUser
        self.callid = callid
        self.callidAleg = callidAleg
        self.via1 = via1
        self.via1Branch = via1Branch
        self.cseq = cseq
        self.diversion = diversion
        self.reason = reason
        self.contentType = contentType
        self.auth = auth
        self.userAgent = userAgent
        self.sourceIp = sourceIp
        self.sourcePort = sourcePort
        self.destinationIp = destinationIp
        self.destinationPort = destinationPort
        self.contactIp = contactIp
        self.contactPort = contactPort
        self.originatorIp = originatorIp
        self.originatorPort = originatorPort
        self.correlationId = correlationId
        self.proto = proto
        self.family = family
        self.rtpStat = rtpStat
        self.type = type
        self.node = node
        self.trans = trans
        self.dbnode = dbnode
        self.msg = msg
        self.sourceAlias = sourceAlias
        self.destinationAlias = destinationAlias
        self.conversationId = conversationId
        self.participantId = participantId
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case date
        case milliTs
        case microTs
        case method
        case replyReason
        case ruri
        case ruriUser
        case ruriDomain
        case fromUser
        case fromDomain
        case fromTag
        case toUser
        case toDomain
        case toTag
        case pidUser
        case contactUser
        case authUser
        case callid
        case callidAleg
        case via1
        case via1Branch
        case cseq
        case diversion
        case reason
        case contentType
        case auth
        case userAgent
        case sourceIp
        case sourcePort
        case destinationIp
        case destinationPort
        case contactIp
        case contactPort
        case originatorIp
        case originatorPort
        case correlationId
        case proto
        case family
        case rtpStat
        case type
        case node
        case trans
        case dbnode
        case msg
        case sourceAlias
        case destinationAlias
        case conversationId
        case participantId
        case selfUri
    }


}



/** An ivr. */

public class IVRDivisionView: Codable {









    /** The ivr identifier */
    public var _id: String?
    /** The ivr name */
    public var name: String?
    /** The division to which this entity belongs. */
    public var division: WritableDivision?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, division: WritableDivision?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.division = division
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case division
        case selfUri
    }


}




public class IgnoredActivityCodeIds: Codable {



    /** List of activity code IDs */
    public var values: [String]?

    public init(values: [String]?) {
        self.values = values
    }


}




public class ImportScheduleUploadSchema: Codable {













    /** The description for the imported schedule */
    public var _description: String?
    /** The number of weeks the imported schedule will cover */
    public var weekCount: Int?
    /** Whether the imported schedule should be immediately published */
    public var published: Bool?
    /** The short term forecast to associate with the imported schedule */
    public var shortTermForecast: BuShortTermForecastReference?
    /** The headcount forecast to associate with the imported schedule */
    public var headcountForecast: BuHeadcountForecastBuPlanningGroupHeadcountForecastUploadSchema?
    /** Individual agent schedules */
    public var agentSchedules: [BuImportAgentScheduleUploadSchema]?

    public init(_description: String?, weekCount: Int?, published: Bool?, shortTermForecast: BuShortTermForecastReference?, headcountForecast: BuHeadcountForecastBuPlanningGroupHeadcountForecastUploadSchema?, agentSchedules: [BuImportAgentScheduleUploadSchema]?) {
        self._description = _description
        self.weekCount = weekCount
        self.published = published
        self.shortTermForecast = shortTermForecast
        self.headcountForecast = headcountForecast
        self.agentSchedules = agentSchedules
    }

    public enum CodingKeys: String, CodingKey { 
        case _description = "description"
        case weekCount
        case published
        case shortTermForecast
        case headcountForecast
        case agentSchedules
    }


}




public class ImportStatus: Codable {

    public enum State: String, Codable { 
        case inProgress = "IN_PROGRESS"
        case failed = "FAILED"
    }













    /** current status of the import */
    public var state: State?
    /** total number of records to be imported */
    public var totalRecords: Int64?
    /** number of records finished importing */
    public var completedRecords: Int64?
    /** percentage of records finished importing */
    public var percentComplete: Int?
    /** if the import has failed, the reason for the failure */
    public var failureReason: String?
    /** The contact list Ids for target contact lists. */
    public var targetContactListIds: [String]?
    /** The prefix for the contact list name */
    public var listNamePrefix: String?

    public init(state: State?, totalRecords: Int64?, completedRecords: Int64?, percentComplete: Int?, failureReason: String?, targetContactListIds: [String]?, listNamePrefix: String?) {
        self.state = state
        self.totalRecords = totalRecords
        self.completedRecords = completedRecords
        self.percentComplete = percentComplete
        self.failureReason = failureReason
        self.targetContactListIds = targetContactListIds
        self.listNamePrefix = listNamePrefix
    }


}




public class ImportStatusRequest: Codable {



    /** New status for existing import operation */
    public var status: String?

    public init(status: String?) {
        self.status = status
    }


}




public class InboundDomain: Codable {





    public enum MxRecordStatus: String, Codable { 
        case valid = "VALID"
        case invalid = "INVALID"
        case notAvailable = "NOT_AVAILABLE"
    }











    /** Unique Id of the domain such as: example.com */
    public var _id: String?
    public var name: String?
    /** Mx Record Status */
    public var mxRecordStatus: MxRecordStatus?
    /** Indicates if this a PureCloud sub-domain.  If true, then the appropriate DNS records are created for sending/receiving email. */
    public var subDomain: Bool?
    /** The DNS settings if the inbound domain is using a custom Mail From. These settings can only be used on InboundDomains where subDomain is false. */
    public var mailFromSettings: MailFromResult?
    /** The custom SMTP server integration to use when sending outbound emails from this domain. */
    public var customSMTPServer: DomainEntityRef?
    /** The email settings associated with this domain. */
    public var emailSetting: EmailSetting?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, mxRecordStatus: MxRecordStatus?, subDomain: Bool?, mailFromSettings: MailFromResult?, customSMTPServer: DomainEntityRef?, emailSetting: EmailSetting?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.mxRecordStatus = mxRecordStatus
        self.subDomain = subDomain
        self.mailFromSettings = mailFromSettings
        self.customSMTPServer = customSMTPServer
        self.emailSetting = emailSetting
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case mxRecordStatus
        case subDomain
        case mailFromSettings
        case customSMTPServer
        case emailSetting
        case selfUri
    }


}




public class InfixOperator: Codable {

    public enum OperatorType: String, Codable { 
        case or = "Or"
        case and = "And"
        case near = "Near"
    }



    /** The logical operation that is applied on the operand against the following operand */
    public var operatorType: OperatorType?
    /** Dictates when the following operand should occur relative to current operand */
    public var operatorPosition: OperatorPosition?

    public init(operatorType: OperatorType?, operatorPosition: OperatorPosition?) {
        self.operatorType = operatorType
        self.operatorPosition = operatorPosition
    }


}




public class InsightsDetailsOverallPeriodPoints: Codable {













    /** Points scored */
    public var points: Int?
    /** Max possible points */
    public var maxPoints: Int?
    /** Number of data points */
    public var dataPointCount: Int?
    /** Percentage of the goal */
    public var percentOfGoal: Double?
    /** The agent's rank in leader board for points on this metric */
    public var rankTotalPoints: Int?
    /** The agent's rank in leader board for percentage on this metric */
    public var rankPercentagePoints: Int?

    public init(points: Int?, maxPoints: Int?, dataPointCount: Int?, percentOfGoal: Double?, rankTotalPoints: Int?, rankPercentagePoints: Int?) {
        self.points = points
        self.maxPoints = maxPoints
        self.dataPointCount = dataPointCount
        self.percentOfGoal = percentOfGoal
        self.rankTotalPoints = rankTotalPoints
        self.rankPercentagePoints = rankPercentagePoints
    }


}




public class InsightsSummaryOverallPeriodPoints: Codable {









    /** Points scored */
    public var points: Int?
    /** Max possible points */
    public var maxPoints: Int?
    /** Number of data points */
    public var dataPointCount: Int?
    /** Percentage of the goal */
    public var percentOfGoal: Double?

    public init(points: Int?, maxPoints: Int?, dataPointCount: Int?, percentOfGoal: Double?) {
        self.points = points
        self.maxPoints = maxPoints
        self.dataPointCount = dataPointCount
        self.percentOfGoal = percentOfGoal
    }


}




public class InstagramDataIngestionRuleRequest: Codable {







    /** The name of the data ingestion rule. */
    public var name: String?
    /** A description of the data ingestion rule. */
    public var _description: String?
    /** The Integration Id from which public social posts are ingested. This entity is created using the /conversations/messaging/integrations/instagram resource */
    public var integrationId: String?

    public init(name: String?, _description: String?, integrationId: String?) {
        self.name = name
        self._description = _description
        self.integrationId = integrationId
    }

    public enum CodingKeys: String, CodingKey { 
        case name
        case _description = "description"
        case integrationId
    }


}



/** Configuration for an Integration */

public class IntegrationConfiguration: Codable {

















    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The name of the integration, used to distinguish this integration from others of the same type. */
    public var name: String?
    /** Version number required for updates. */
    public var version: Int?
    /** Key-value configuration settings described by the schema in the propertiesSchemaUri field. */
    public var properties: JSON?
    /** Advanced configuration described by the schema in the advancedSchemaUri field. */
    public var advanced: JSON?
    /** Notes about the integration. */
    public var notes: String?
    /** Credentials required by the integration. The required keys are indicated in the credentials property of the Integration Type */
    public var credentials: [String:CredentialInfo]?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, version: Int?, properties: JSON?, advanced: JSON?, notes: String?, credentials: [String:CredentialInfo]?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.version = version
        self.properties = properties
        self.advanced = advanced
        self.notes = notes
        self.credentials = credentials
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case version
        case properties
        case advanced
        case notes
        case credentials
        case selfUri
    }


}



/** Descriptor for a type of Integration. */

public class IntegrationType: Codable {

















































    /** The ID of the integration type. */
    public var _id: String?
    public var name: String?
    /** Description of the integration type. */
    public var _description: String?
    /** PureCloud provider of the integration type. */
    public var provider: String?
    /** Category describing the integration type. */
    public var category: String?
    /** Collection of logos. */
    public var images: [Image]?
    /** URI of the schema describing the key-value properties needed to configure an integration of this type. */
    public var configPropertiesSchemaUri: String?
    /** URI of the schema describing the advanced JSON document needed to configure an integration of this type. */
    public var configAdvancedSchemaUri: String?
    /** URI of a page with more information about the integration type */
    public var helpUri: String?
    /** URI of a page with terms and conditions for the integration type */
    public var termsOfServiceUri: String?
    /** Name of the vendor of this integration type */
    public var vendorName: String?
    /** URI of the vendor's website */
    public var vendorWebsiteUri: String?
    /** URI of the marketplace listing for this integration type */
    public var marketplaceUri: String?
    /** URI of frequently asked questions about the integration type */
    public var faqUri: String?
    /** URI of a privacy policy for users of the integration type */
    public var privacyPolicyUri: String?
    /** URI for vendor support */
    public var supportContactUri: String?
    /** URI for vendor sales information */
    public var salesContactUri: String?
    /** List of links to additional help resources */
    public var helpLinks: [HelpLink]?
    /** Map of credentials for integrations of this type. The key is the name of a credential that can be provided in the credentials property of the integration configuration. */
    public var credentials: [String:CredentialSpecification]?
    /** Indicates if the integration type is installable or not. */
    public var nonInstallable: Bool?
    /** The maximum number of integration instances allowable for this integration type */
    public var maxInstances: Int?
    /** List of permissions required to permit user access to the integration type. */
    public var userPermissions: [String]?
    /** List of OAuth Client IDs that must be authorized when the integration is created. */
    public var vendorOAuthClientIds: [String]?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, _description: String?, provider: String?, category: String?, images: [Image]?, configPropertiesSchemaUri: String?, configAdvancedSchemaUri: String?, helpUri: String?, termsOfServiceUri: String?, vendorName: String?, vendorWebsiteUri: String?, marketplaceUri: String?, faqUri: String?, privacyPolicyUri: String?, supportContactUri: String?, salesContactUri: String?, helpLinks: [HelpLink]?, credentials: [String:CredentialSpecification]?, nonInstallable: Bool?, maxInstances: Int?, userPermissions: [String]?, vendorOAuthClientIds: [String]?, selfUri: String?) {
        self._id = _id
        self.name = name
        self._description = _description
        self.provider = provider
        self.category = category
        self.images = images
        self.configPropertiesSchemaUri = configPropertiesSchemaUri
        self.configAdvancedSchemaUri = configAdvancedSchemaUri
        self.helpUri = helpUri
        self.termsOfServiceUri = termsOfServiceUri
        self.vendorName = vendorName
        self.vendorWebsiteUri = vendorWebsiteUri
        self.marketplaceUri = marketplaceUri
        self.faqUri = faqUri
        self.privacyPolicyUri = privacyPolicyUri
        self.supportContactUri = supportContactUri
        self.salesContactUri = salesContactUri
        self.helpLinks = helpLinks
        self.credentials = credentials
        self.nonInstallable = nonInstallable
        self.maxInstances = maxInstances
        self.userPermissions = userPermissions
        self.vendorOAuthClientIds = vendorOAuthClientIds
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case _description = "description"
        case provider
        case category
        case images
        case configPropertiesSchemaUri
        case configAdvancedSchemaUri
        case helpUri
        case termsOfServiceUri
        case vendorName
        case vendorWebsiteUri
        case marketplaceUri
        case faqUri
        case privacyPolicyUri
        case supportContactUri
        case salesContactUri
        case helpLinks
        case credentials
        case nonInstallable
        case maxInstances
        case userPermissions
        case vendorOAuthClientIds
        case selfUri
    }


}




public class IntentDefinition: Codable {















    /** ID of the intent. */
    public var _id: String?
    /** The name of the intent. */
    public var name: String?
    /** The description of the intent. */
    public var _description: String?
    /** The bindings for the named entity types used in this intent.This field is mutually exclusive with entityNameReferences and entities */
    public var entityTypeBindings: [NamedEntityTypeBinding]?
    /** The references for the named entity used in this intent.This field is mutually exclusive with entityTypeBindings */
    public var entityNameReferences: [String]?
    /** The utterances that act as training phrases for the intent. */
    public var utterances: [NluUtterance]?
    /** Additional languages for intents */
    public var additionalLanguages: [String:AdditionalLanguagesIntent]?

    public init(_id: String?, name: String?, _description: String?, entityTypeBindings: [NamedEntityTypeBinding]?, entityNameReferences: [String]?, utterances: [NluUtterance]?, additionalLanguages: [String:AdditionalLanguagesIntent]?) {
        self._id = _id
        self.name = name
        self._description = _description
        self.entityTypeBindings = entityTypeBindings
        self.entityNameReferences = entityNameReferences
        self.utterances = utterances
        self.additionalLanguages = additionalLanguages
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case _description = "description"
        case entityTypeBindings
        case entityNameReferences
        case utterances
        case additionalLanguages
    }


}




public class IntentFeedback: Codable {







    public enum Assessment: String, Codable { 
        case incorrect = "Incorrect"
        case correct = "Correct"
        case unknown = "Unknown"
        case disabled = "Disabled"
    }

    /** The name of the detected intent. */
    public var name: String?
    /** The probability of the detected intent. */
    public var probability: Double?
    /** The collection of named entities detected. */
    public var entities: [DetectedNamedEntity]?
    /** The assessment on the detection for feedback text. */
    public var assessment: Assessment?

    public init(name: String?, probability: Double?, entities: [DetectedNamedEntity]?, assessment: Assessment?) {
        self.name = name
        self.probability = probability
        self.entities = entities
        self.assessment = assessment
    }


}




public class Items: Codable {





    public var type: String?
    public var pattern: String?

    public init(type: String?, pattern: String?) {
        self.type = type
        self.pattern = pattern
    }


}




public class JourneyAction: Codable {





    /** The ID of an action from the Journey System (an action is spawned from an actionMap) */
    public var _id: String?
    /** Details about the action map from the Journey System which triggered this action */
    public var actionMap: JourneyActionMap?

    public init(_id: String?, actionMap: JourneyActionMap?) {
        self._id = _id
        self.actionMap = actionMap
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case actionMap
    }


}




public class JourneyAggregateQueryFilter: Codable {

    public enum ModelType: String, Codable { 
        case and = "and"
        case or = "or"
    }





    /** Boolean operation to apply to the provided predicates and clauses */
    public var type: ModelType?
    /** Boolean 'and/or' logic with up to two-levels of nesting */
    public var clauses: [JourneyAggregateQueryClause]?
    /** Like a three-word sentence: (attribute-name) (operator) (target-value). */
    public var predicates: [JourneyAggregateQueryPredicate]?

    public init(type: ModelType?, clauses: [JourneyAggregateQueryClause]?, predicates: [JourneyAggregateQueryPredicate]?) {
        self.type = type
        self.clauses = clauses
        self.predicates = predicates
    }


}




public class JourneyAppEventsNotificationAppEventsNotification: Codable {















    public enum EventType: String, Codable { 
        case appEvent = "AppEvent"
        case outcomeAchievedEvent = "OutcomeAchievedEvent"
        case segmentAssignmentEvent = "SegmentAssignmentEvent"
        case webActionEvent = "WebActionEvent"
    }









    public var _id: String?
    public var correlationId: String?
    public var externalContact: JourneyAppEventsNotificationExternalContact?
    public var createdDate: Date?
    public var customerId: String?
    public var customerIdType: String?
    public var session: JourneyAppEventsNotificationSession?
    public var eventType: EventType?
    public var appEvent: JourneyAppEventsNotificationAppMessage?
    public var outcomeAchievedEvent: JourneyAppEventsNotificationOutcomeAchievedMessage?
    public var segmentAssignmentEvent: JourneyAppEventsNotificationSegmentAssignmentMessage?
    public var webActionEvent: JourneyAppEventsNotificationWebActionMessage?

    public init(_id: String?, correlationId: String?, externalContact: JourneyAppEventsNotificationExternalContact?, createdDate: Date?, customerId: String?, customerIdType: String?, session: JourneyAppEventsNotificationSession?, eventType: EventType?, appEvent: JourneyAppEventsNotificationAppMessage?, outcomeAchievedEvent: JourneyAppEventsNotificationOutcomeAchievedMessage?, segmentAssignmentEvent: JourneyAppEventsNotificationSegmentAssignmentMessage?, webActionEvent: JourneyAppEventsNotificationWebActionMessage?) {
        self._id = _id
        self.correlationId = correlationId
        self.externalContact = externalContact
        self.createdDate = createdDate
        self.customerId = customerId
        self.customerIdType = customerIdType
        self.session = session
        self.eventType = eventType
        self.appEvent = appEvent
        self.outcomeAchievedEvent = outcomeAchievedEvent
        self.segmentAssignmentEvent = segmentAssignmentEvent
        self.webActionEvent = webActionEvent
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case correlationId
        case externalContact
        case createdDate
        case customerId
        case customerIdType
        case session
        case eventType
        case appEvent
        case outcomeAchievedEvent
        case segmentAssignmentEvent
        case webActionEvent
    }


}




public class JourneyAppEventsNotificationAppMessage: Codable {



























    public var eventName: String?
    public var screenName: String?
    public var app: JourneyAppEventsNotificationApp?
    public var device: JourneyAppEventsNotificationDevice?
    public var ipAddress: String?
    public var ipOrganization: String?
    public var geolocation: JourneyAppEventsNotificationGeoLocation?
    public var sdkLibrary: JourneyAppEventsNotificationSdkLibrary?
    public var networkConnectivity: JourneyAppEventsNotificationNetworkConnectivity?
    public var mktCampaign: JourneyAppEventsNotificationMktCampaign?
    public var searchQuery: String?
    public var attributes: [String:JourneyAppEventsNotificationCustomEventAttribute]?
    public var traits: [String:JourneyAppEventsNotificationCustomEventAttribute]?

    public init(eventName: String?, screenName: String?, app: JourneyAppEventsNotificationApp?, device: JourneyAppEventsNotificationDevice?, ipAddress: String?, ipOrganization: String?, geolocation: JourneyAppEventsNotificationGeoLocation?, sdkLibrary: JourneyAppEventsNotificationSdkLibrary?, networkConnectivity: JourneyAppEventsNotificationNetworkConnectivity?, mktCampaign: JourneyAppEventsNotificationMktCampaign?, searchQuery: String?, attributes: [String:JourneyAppEventsNotificationCustomEventAttribute]?, traits: [String:JourneyAppEventsNotificationCustomEventAttribute]?) {
        self.eventName = eventName
        self.screenName = screenName
        self.app = app
        self.device = device
        self.ipAddress = ipAddress
        self.ipOrganization = ipOrganization
        self.geolocation = geolocation
        self.sdkLibrary = sdkLibrary
        self.networkConnectivity = networkConnectivity
        self.mktCampaign = mktCampaign
        self.searchQuery = searchQuery
        self.attributes = attributes
        self.traits = traits
    }


}




public class JourneyAppEventsNotificationAssociatedValue: Codable {

    public enum DataType: String, Codable { 
        case number = "Number"
        case integer = "Integer"
    }



    public var dataType: DataType?
    public var value: Double?

    public init(dataType: DataType?, value: Double?) {
        self.dataType = dataType
        self.value = value
    }


}




public class JourneyAppEventsNotificationGeoLocation: Codable {





















    public var country: String?
    public var countryName: String?
    public var latitude: Double?
    public var longitude: Double?
    public var locality: String?
    public var postalCode: String?
    public var region: String?
    public var regionName: String?
    public var timezone: String?
    public var source: String?

    public init(country: String?, countryName: String?, latitude: Double?, longitude: Double?, locality: String?, postalCode: String?, region: String?, regionName: String?, timezone: String?, source: String?) {
        self.country = country
        self.countryName = countryName
        self.latitude = latitude
        self.longitude = longitude
        self.locality = locality
        self.postalCode = postalCode
        self.region = region
        self.regionName = regionName
        self.timezone = timezone
        self.source = source
    }


}




public class JourneyAppEventsNotificationSegment: Codable {





    public var _id: UUID?
    public var selfUri: String?

    public init(_id: UUID?, selfUri: String?) {
        self._id = _id
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
    }


}




public class JourneyContext: Codable {







    /** A subset of the Journey System's customer data at a point-in-time (for external linkage and internal usage/context) */
    public var customer: JourneyCustomer?
    /** A subset of the Journey System's tracked customer session data at a point-in-time (for external linkage and internal usage/context) */
    public var customerSession: JourneyCustomerSession?
    /** A subset of the Journey System's action data relevant to a part of a conversation (for external linkage and internal usage/context) */
    public var triggeringAction: JourneyAction?

    public init(customer: JourneyCustomer?, customerSession: JourneyCustomerSession?, triggeringAction: JourneyAction?) {
        self.customer = customer
        self.customerSession = customerSession
        self.triggeringAction = triggeringAction
    }


}




public class JourneyOutcomeEventsNotificationBrowser: Codable {





















    public var family: String?
    public var version: String?
    public var lang: String?
    public var fingerprint: String?
    public var viewHeight: Int64?
    public var viewWidth: Int64?
    public var featuresFlash: Bool?
    public var featuresJava: Bool?
    public var featuresPdf: Bool?
    public var featuresWebrtc: Bool?

    public init(family: String?, version: String?, lang: String?, fingerprint: String?, viewHeight: Int64?, viewWidth: Int64?, featuresFlash: Bool?, featuresJava: Bool?, featuresPdf: Bool?, featuresWebrtc: Bool?) {
        self.family = family
        self.version = version
        self.lang = lang
        self.fingerprint = fingerprint
        self.viewHeight = viewHeight
        self.viewWidth = viewWidth
        self.featuresFlash = featuresFlash
        self.featuresJava = featuresJava
        self.featuresPdf = featuresPdf
        self.featuresWebrtc = featuresWebrtc
    }


}




public class JourneyOutcomeEventsNotificationMktCampaign: Codable {















    public var content: String?
    public var medium: String?
    public var name: String?
    public var source: String?
    public var term: String?
    public var clickId: String?
    public var network: String?

    public init(content: String?, medium: String?, name: String?, source: String?, term: String?, clickId: String?, network: String?) {
        self.content = content
        self.medium = medium
        self.name = name
        self.source = source
        self.term = term
        self.clickId = clickId
        self.network = network
    }


}




public class JourneyOutcomeEventsNotificationSession: Codable {







    public var _id: String?
    public var selfUri: String?
    public var type: String?

    public init(_id: String?, selfUri: String?, type: String?) {
        self._id = _id
        self.selfUri = selfUri
        self.type = type
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
        case type
    }


}




public class JourneyPage: Codable {





















    /** The page URL. */
    public var url: String?
    /** Title of the page. */
    public var title: String?
    /** Domain of the page's URL. */
    public var domain: String?
    /** Fragment or hash of the page's URL. */
    public var fragment: String?
    /** Hostname of the page's URL. */
    public var hostname: String?
    /** Keywords from the HTML {@code <meta>} tag of the page. */
    public var keywords: String?
    /** ISO 639-1 language code for the page as defined in the {@code <html>} tag. */
    public var lang: String?
    /** Path name of the page for the event. */
    public var pathname: String?
    /** Query string that is passed to the page in the current event. */
    public var queryString: String?
    /** Hierarchy of the current page in relation to the website's structure. */
    public var breadcrumb: [String]?

    public init(url: String?, title: String?, domain: String?, fragment: String?, hostname: String?, keywords: String?, lang: String?, pathname: String?, queryString: String?, breadcrumb: [String]?) {
        self.url = url
        self.title = title
        self.domain = domain
        self.fragment = fragment
        self.hostname = hostname
        self.keywords = keywords
        self.lang = lang
        self.pathname = pathname
        self.queryString = queryString
        self.breadcrumb = breadcrumb
    }


}




public class JourneySegmentAssignmentEventsNotificationSession: Codable {







    public var _id: String?
    public var selfUri: String?
    public var type: String?

    public init(_id: String?, selfUri: String?, type: String?) {
        self._id = _id
        self.selfUri = selfUri
        self.type = type
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
        case type
    }


}




public class JourneySessionEventsNotificationConnectedQueue: Codable {





    public var _id: String?
    public var selfUri: String?

    public init(_id: String?, selfUri: String?) {
        self._id = _id
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
    }


}




public class JourneySessionEventsNotificationConversationChannel: Codable {

    public enum ModelType: String, Codable { 
        case unknown = "Unknown"
        case voice = "Voice"
        case chat = "Chat"
        case email = "Email"
        case callback = "Callback"
        case cobrowse = "Cobrowse"
        case video = "Video"
        case screenshare = "Screenshare"
        case message = "Message"
        case internalMessage = "InternalMessage"
    }

    public enum MessageType: String, Codable { 
        case unknown = "Unknown"
        case sms = "Sms"
        case twitter = "Twitter"
        case facebook = "Facebook"
        case line = "Line"
        case whatsApp = "WhatsApp"
        case webMessaging = "WebMessaging"
        case _open = "Open"
        case instagram = "Instagram"
        case apple = "Apple"
    }



    public var type: ModelType?
    public var messageType: MessageType?
    public var platform: String?

    public init(type: ModelType?, messageType: MessageType?, platform: String?) {
        self.type = type
        self.messageType = messageType
        self.platform = platform
    }


}




public class JourneySessionEventsNotificationDevice: Codable {

















    public enum Category: String, Codable { 
        case desktop = "desktop"
        case mobile = "mobile"
        case tablet = "tablet"
        case other = "other"
    }



    public var type: String?
    public var isMobile: Bool?
    public var screenHeight: Int64?
    public var screenWidth: Int64?
    public var screenDensity: Int64?
    public var fingerprint: String?
    public var osFamily: String?
    public var osVersion: String?
    public var category: Category?
    public var manufacturer: String?

    public init(type: String?, isMobile: Bool?, screenHeight: Int64?, screenWidth: Int64?, screenDensity: Int64?, fingerprint: String?, osFamily: String?, osVersion: String?, category: Category?, manufacturer: String?) {
        self.type = type
        self.isMobile = isMobile
        self.screenHeight = screenHeight
        self.screenWidth = screenWidth
        self.screenDensity = screenDensity
        self.fingerprint = fingerprint
        self.osFamily = osFamily
        self.osVersion = osVersion
        self.category = category
        self.manufacturer = manufacturer
    }


}




public class JourneySessionEventsNotificationOutcome: Codable {





    public var _id: UUID?
    public var selfUri: String?

    public init(_id: UUID?, selfUri: String?) {
        self._id = _id
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
    }


}




public class JourneySessionEventsNotificationSegmentAssignment: Codable {





    public var segment: JourneySessionEventsNotificationSegment?
    public var assignedDate: Date?

    public init(segment: JourneySessionEventsNotificationSegment?, assignedDate: Date?) {
        self.segment = segment
        self.assignedDate = assignedDate
    }


}



/** A journey view */

public class JourneyView: Codable {



























    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** A description of the journey view */
    public var _description: String?
    /** The version of the journey view */
    public var version: Int?
    /** User that has created the view. */
    public var createdBy: JourneyViewUser?
    /** User that has modified the view. */
    public var modifiedBy: JourneyViewUser?
    /** An absolute timeframe for the journey view, expressed as an ISO 8601 interval. Only one of interval or duration must be specified. Intervals are represented as an ISO-8601 string. For example: YYYY-MM-DDThh:mm:ss/YYYY-MM-DDThh:mm:ss */
    public var interval: String?
    /** A relative timeframe for the journey view, expressed as an ISO 8601 duration. Only one of interval or duration must be specified. Periods are represented as an ISO-8601 string. For example: P1D or P1DT12H */
    public var duration: String?
    /** The elements within the journey view */
    public var elements: [JourneyViewElement]?
    /** A list of charts to measure within context of the elements of the the journey view */
    public var charts: [JourneyViewChart]?
    /** The date when the journey view was created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** The date when this version of the journey view was modified. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, _description: String?, version: Int?, createdBy: JourneyViewUser?, modifiedBy: JourneyViewUser?, interval: String?, duration: String?, elements: [JourneyViewElement]?, charts: [JourneyViewChart]?, dateCreated: Date?, dateModified: Date?, selfUri: String?) {
        self._id = _id
        self.name = name
        self._description = _description
        self.version = version
        self.createdBy = createdBy
        self.modifiedBy = modifiedBy
        self.interval = interval
        self.duration = duration
        self.elements = elements
        self.charts = charts
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case _description = "description"
        case version
        case createdBy
        case modifiedBy
        case interval
        case duration
        case elements
        case charts
        case dateCreated
        case dateModified
        case selfUri
    }


}



/** A metric to measure within the chart */

public class JourneyViewChartMetric: Codable {





    public enum Aggregate: String, Codable { 
        case eventCount = "EventCount"
        case customerCount = "CustomerCount"
    }



    /** The unique identifier of the metric within the chart */
    public var _id: String?
    /** The element in the list of elements which the metric is measuring */
    public var elementId: String?
    /** How to aggregate the given element, defaults to CustomerCount */
    public var aggregate: Aggregate?
    /** A display label for the metric */
    public var displayLabel: String?

    public init(_id: String?, elementId: String?, aggregate: Aggregate?, displayLabel: String?) {
        self._id = _id
        self.elementId = elementId
        self.aggregate = aggregate
        self.displayLabel = displayLabel
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case elementId
        case aggregate
        case displayLabel
    }


}




public class JourneyViewListing: Codable {





















    public var entities: [JourneyView]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var previousUri: String?
    public var nextUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [JourneyView]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, previousUri: String?, nextUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.previousUri = previousUri
        self.nextUri = nextUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class JourneyViewUser: Codable {







    /** The globally unique identifier for the object. */
    public var _id: String?
    /** Email address of the user */
    public var emailAddress: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, emailAddress: String?, selfUri: String?) {
        self._id = _id
        self.emailAddress = emailAddress
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case emailAddress
        case selfUri
    }


}




public class JourneyWebActionEventsNotificationActionMapPageUrlCondition: Codable {



    public enum Operator: String, Codable { 
        case unknown = "unknown"
        case equal = "equal"
        case notequal = "notEqual"
        case like = "like"
        case notlike = "notLike"
        case greaterthan = "greaterThan"
        case greaterthanorequal = "greaterThanOrEqual"
        case lessthan = "lessThan"
        case lessthanorequal = "lessThanOrEqual"
        case startswith = "startsWith"
        case endswith = "endsWith"
        case containsany = "containsAny"
        case notcontainsany = "notContainsAny"
        case containsall = "containsAll"
        case notcontainsal = "notContainsAl"
    }

    public var values: [String]?
    public var _operator: Operator?

    public init(values: [String]?, _operator: Operator?) {
        self.values = values
        self._operator = _operator
    }

    public enum CodingKeys: String, CodingKey { 
        case values
        case _operator = "operator"
    }


}




public class JourneyWebActionEventsNotificationBrowser: Codable {





















    public var family: String?
    public var version: String?
    public var lang: String?
    public var fingerprint: String?
    public var viewHeight: Int64?
    public var viewWidth: Int64?
    public var featuresFlash: Bool?
    public var featuresJava: Bool?
    public var featuresPdf: Bool?
    public var featuresWebrtc: Bool?

    public init(family: String?, version: String?, lang: String?, fingerprint: String?, viewHeight: Int64?, viewWidth: Int64?, featuresFlash: Bool?, featuresJava: Bool?, featuresPdf: Bool?, featuresWebrtc: Bool?) {
        self.family = family
        self.version = version
        self.lang = lang
        self.fingerprint = fingerprint
        self.viewHeight = viewHeight
        self.viewWidth = viewWidth
        self.featuresFlash = featuresFlash
        self.featuresJava = featuresJava
        self.featuresPdf = featuresPdf
        self.featuresWebrtc = featuresWebrtc
    }


}




public class JourneyWebActionEventsNotificationEventAction: Codable {



    public var _id: String?

    public init(_id: String?) {
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
    }


}




public class JourneyWebActionEventsNotificationMktCampaign: Codable {















    public var content: String?
    public var medium: String?
    public var name: String?
    public var source: String?
    public var term: String?
    public var clickId: String?
    public var network: String?

    public init(content: String?, medium: String?, name: String?, source: String?, term: String?, clickId: String?, network: String?) {
        self.content = content
        self.medium = medium
        self.name = name
        self.source = source
        self.term = term
        self.clickId = clickId
        self.network = network
    }


}




public class JourneyWebActionEventsNotificationSession: Codable {







    public var _id: String?
    public var selfUri: String?
    public var type: String?

    public init(_id: String?, selfUri: String?, type: String?) {
        self._id = _id
        self.selfUri = selfUri
        self.type = type
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
        case type
    }


}




public class JourneyWebEventsNotificationActionTarget: Codable {





    public var _id: String?
    public var selfUri: String?

    public init(_id: String?, selfUri: String?) {
        self._id = _id
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
    }


}




public class JourneyWebEventsNotificationExternalContact: Codable {





    public var _id: String?
    public var selfUri: String?

    public init(_id: String?, selfUri: String?) {
        self._id = _id
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
    }


}




public class JourneyWebEventsNotificationPage: Codable {





















    public var url: String?
    public var title: String?
    public var domain: String?
    public var fragment: String?
    public var hostname: String?
    public var keywords: String?
    public var lang: String?
    public var pathname: String?
    public var queryString: String?
    public var breadcrumb: [String]?

    public init(url: String?, title: String?, domain: String?, fragment: String?, hostname: String?, keywords: String?, lang: String?, pathname: String?, queryString: String?, breadcrumb: [String]?) {
        self.url = url
        self.title = title
        self.domain = domain
        self.fragment = fragment
        self.hostname = hostname
        self.keywords = keywords
        self.lang = lang
        self.pathname = pathname
        self.queryString = queryString
        self.breadcrumb = breadcrumb
    }


}




public class JourneyWebEventsNotificationSegmentAssignmentMessage: Codable {



    public enum AssignmentState: String, Codable { 
        case unknown = "Unknown"
        case assigned = "Assigned"
        case unassigned = "Unassigned"
    }





    public var segment: JourneyWebEventsNotificationSegment?
    public var assignmentState: AssignmentState?
    public var dateAssigned: Date?
    public var dateForUnassignment: Date?

    public init(segment: JourneyWebEventsNotificationSegment?, assignmentState: AssignmentState?, dateAssigned: Date?, dateForUnassignment: Date?) {
        self.segment = segment
        self.assignmentState = assignmentState
        self.dateAssigned = dateAssigned
        self.dateForUnassignment = dateForUnassignment
    }


}




public class JourneyWebEventsNotificationWebActionMessage: Codable {





























    public var action: JourneyWebEventsNotificationEventAction?
    public var actionTarget: JourneyWebEventsNotificationActionTarget?
    public var actionMap: JourneyWebEventsNotificationActionMap?
    public var errorCode: String?
    public var errorMessage: String?
    public var userAgentString: String?
    public var ipAddress: String?
    public var ipOrganization: String?
    public var browser: JourneyWebEventsNotificationBrowser?
    public var device: JourneyWebEventsNotificationDevice?
    public var geolocation: JourneyWebEventsNotificationGeoLocation?
    public var mktCampaign: JourneyWebEventsNotificationMktCampaign?
    public var visitReferrer: JourneyWebEventsNotificationReferrer?
    public var timeToDisposition: Int64?

    public init(action: JourneyWebEventsNotificationEventAction?, actionTarget: JourneyWebEventsNotificationActionTarget?, actionMap: JourneyWebEventsNotificationActionMap?, errorCode: String?, errorMessage: String?, userAgentString: String?, ipAddress: String?, ipOrganization: String?, browser: JourneyWebEventsNotificationBrowser?, device: JourneyWebEventsNotificationDevice?, geolocation: JourneyWebEventsNotificationGeoLocation?, mktCampaign: JourneyWebEventsNotificationMktCampaign?, visitReferrer: JourneyWebEventsNotificationReferrer?, timeToDisposition: Int64?) {
        self.action = action
        self.actionTarget = actionTarget
        self.actionMap = actionMap
        self.errorCode = errorCode
        self.errorMessage = errorMessage
        self.userAgentString = userAgentString
        self.ipAddress = ipAddress
        self.ipOrganization = ipOrganization
        self.browser = browser
        self.device = device
        self.geolocation = geolocation
        self.mktCampaign = mktCampaign
        self.visitReferrer = visitReferrer
        self.timeToDisposition = timeToDisposition
    }


}



/** A JSON Schema document. */

public class JsonSchemaDocument: Codable {

















    public var _id: String?
    public var schema: String?
    public var title: String?
    public var _description: String?
    public var type: String?
    public var _required: [String]?
    public var properties: [String:JSON]?
    public var additionalProperties: JSON?

    public init(_id: String?, schema: String?, title: String?, _description: String?, type: String?, _required: [String]?, properties: [String:JSON]?, additionalProperties: JSON?) {
        self._id = _id
        self.schema = schema
        self.title = title
        self._description = _description
        self.type = type
        self._required = _required
        self.properties = properties
        self.additionalProperties = additionalProperties
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case schema = "$schema"
        case title
        case _description = "description"
        case type
        case _required = "required"
        case properties
        case additionalProperties
    }


}




public class KlaxonInteractionStatsRulesTopicNotificationUser: Codable {





    public var _id: String?
    public var displayName: String?

    public init(_id: String?, displayName: String?) {
        self._id = _id
        self.displayName = displayName
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case displayName
    }


}




public class KnowledgeAggregateQueryFilter: Codable {

    public enum ModelType: String, Codable { 
        case and = "and"
        case or = "or"
    }





    /** Boolean operation to apply to the provided predicates and clauses */
    public var type: ModelType?
    /** Boolean 'and/or' logic with up to two-levels of nesting */
    public var clauses: [KnowledgeAggregateQueryClause]?
    /** Like a three-word sentence: (attribute-name) (operator) (target-value). */
    public var predicates: [KnowledgeAggregateQueryPredicate]?

    public init(type: ModelType?, clauses: [KnowledgeAggregateQueryClause]?, predicates: [KnowledgeAggregateQueryPredicate]?) {
        self.type = type
        self.clauses = clauses
        self.predicates = predicates
    }


}




public class KnowledgeBaseWithDialectReference: Codable {



    public enum LanguageCode: String, Codable { 
        case enZa = "en-ZA"
        case enAu = "en-AU"
        case enGb = "en-GB"
        case enIe = "en-IE"
        case enIn = "en-IN"
        case enUs = "en-US"
        case esUs = "es-US"
        case esEs = "es-ES"
        case nlNl = "nl-NL"
        case frCa = "fr-CA"
        case frFr = "fr-FR"
        case deDe = "de-DE"
        case itIt = "it-IT"
        case ptPt = "pt-PT"
        case ptBr = "pt-BR"
        case arAe = "ar-AE"
        case jaJp = "ja-JP"
        case svSe = "sv-SE"
        case deAt = "de-AT"
        case deCh = "de-CH"
        case daDk = "da-DK"
        case frBe = "fr-BE"
        case frCh = "fr-CH"
        case esMx = "es-MX"
        case esCo = "es-CO"
        case koKr = "ko-KR"
        case hiIn = "hi-IN"
        case trTr = "tr-TR"
        case esAr = "es-AR"
        case fiFi = "fi-FI"
        case nbNo = "nb-NO"
        case csCz = "cs-CZ"
        case huHu = "hu-HU"
    }



    /** The globally unique identifier for the knowledge base. */
    public var _id: String?
    /** The dialect for the knowledge base. */
    public var languageCode: LanguageCode?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, languageCode: LanguageCode?, selfUri: String?) {
        self._id = _id
        self.languageCode = languageCode
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case languageCode
        case selfUri
    }


}




public class KnowledgeContextValueReference: Codable {





    /** The globally unique identifier for the knowledge context value. */
    public var _id: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, selfUri: String?) {
        self._id = _id
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
    }


}




public class KnowledgeConversationContext: Codable {



    public enum MediaType: String, Codable { 
        case unknown = "Unknown"
        case callback = "Callback"
        case chat = "Chat"
        case cobrowse = "Cobrowse"
        case email = "Email"
        case message = "Message"
        case screenshare = "Screenshare"
        case video = "Video"
        case voice = "Voice"
    }

    public enum MessageType: String, Codable { 
        case unknown = "Unknown"
        case phone = "Phone"
        case sms = "SMS"
        case genesysChatWidget = "GenesysChatWidget"
        case facebookMessenger = "FacebookMessenger"
        case weChat = "WeChat"
        case whatsapp = "Whatsapp"
        case appleBusinessChat = "AppleBusinessChat"
        case telegram = "Telegram"
        case slack = "Slack"
        case signal = "Signal"
        case line = "Line"
        case discord = "Discord"
        case twitterDirectMessage = "TwitterDirectMessage"
        case other = "Other"
        case _open = "Open"
        case instagram = "Instagram"
        case apple = "Apple"
    }





    /** The unique identifier of the conversation. */
    public var conversationId: String?
    /** The media type of the conversation. */
    public var mediaType: MediaType?
    /** The message type of the conversation. */
    public var messageType: MessageType?
    /** The unique identifier of the queue used to assign the interaction to the user. */
    public var queueId: String?
    /** The external contact identifier of the end-user participant. */
    public var externalContactId: String?

    public init(conversationId: String?, mediaType: MediaType?, messageType: MessageType?, queueId: String?, externalContactId: String?) {
        self.conversationId = conversationId
        self.mediaType = mediaType
        self.messageType = messageType
        self.queueId = queueId
        self.externalContactId = externalContactId
    }


}




public class KnowledgeDocumentBulkRemoveRequest: Codable {



    /** List of unique identifiers referencing documents that are to be deleted */
    public var entities: [WritableEntity]?

    public init(entities: [WritableEntity]?) {
        self.entities = entities
    }


}




public class KnowledgeDocumentBulkVersionAddRequest: Codable {



    /** List of unique identifiers referencing documents that are to be versioned */
    public var entities: [KnowledgeDocumentBulkVersionAddEntity]?

    public init(entities: [KnowledgeDocumentBulkVersionAddEntity]?) {
        self.entities = entities
    }


}




public class KnowledgeDocumentChunkRequest: Codable {









    public enum QueryType: String, Codable { 
        case autoSearch = "AutoSearch"
        case manualSearch = "ManualSearch"
        case suggestion = "Suggestion"
    }











    /** Query to search chunks in the knowledge base. */
    public var query: String?
    /** Page size of the returned results. */
    public var pageSize: Int?
    /** Page number of the returned results. */
    public var pageNumber: Int?
    /** Filter for the document chunks. */
    public var filter: DocumentQuery?
    /** The type of the query that initiates the chunks search. */
    public var queryType: QueryType?
    /** Indicates whether the chunks search query should be preprocessed. */
    public var preprocessQuery: Bool?
    /** Indicates whether the chunk results would also include draft documents. */
    public var includeDraftDocuments: Bool?
    /** The client application details from which chunks request was sent. */
    public var application: KnowledgeSearchClientApplication?
    /** Conversation context information if the chunks search is initiated in the context of a conversation. */
    public var conversationContext: KnowledgeConversationContext?
    /** The confidence threshold for the chunk results. If applied, the returned results will have an equal or higher confidence than the threshold. The value should be between 0 to 1. */
    public var confidenceThreshold: Float?

    public init(query: String?, pageSize: Int?, pageNumber: Int?, filter: DocumentQuery?, queryType: QueryType?, preprocessQuery: Bool?, includeDraftDocuments: Bool?, application: KnowledgeSearchClientApplication?, conversationContext: KnowledgeConversationContext?, confidenceThreshold: Float?) {
        self.query = query
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.filter = filter
        self.queryType = queryType
        self.preprocessQuery = preprocessQuery
        self.includeDraftDocuments = includeDraftDocuments
        self.application = application
        self.conversationContext = conversationContext
        self.confidenceThreshold = confidenceThreshold
    }


}




public class KnowledgeDocumentFeedbackResponse: Codable {





    public enum Rating: String, Codable { 
        case negative = "Negative"
        case positive = "Positive"
    }

    public enum Reason: String, Codable { 
        case documentContent = "DocumentContent"
        case searchResults = "SearchResults"
    }









    public enum QueryType: String, Codable { 
        case unknown = "Unknown"
        case article = "Article"
        case autoSearch = "AutoSearch"
        case category = "Category"
        case manualSearch = "ManualSearch"
        case recommendation = "Recommendation"
        case suggestion = "Suggestion"
        case expandedArticle = "ExpandedArticle"
    }

    public enum SurfacingMethod: String, Codable { 
        case unknown = "Unknown"
        case article = "Article"
        case snippet = "Snippet"
        case highlight = "Highlight"
        case generative = "Generative"
    }

    public enum State: String, Codable { 
        case draft = "Draft"
        case _final = "Final"
    }











    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The variation of the document on which feedback was given. */
    public var documentVariation: EntityReference?
    /** Feedback rating. */
    public var rating: Rating?
    /** Feedback reason. */
    public var reason: Reason?
    /** Free-text comment of the feedback. Maximum length: 2000 characters. */
    public var comment: String?
    /** The search that surfaced the document on which feedback was given. */
    public var search: EntityReference?
    /** Knowledge guest session ID. */
    public var sessionId: String?
    /** The date and time of the feedback. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** The type of the query that surfaced the document on which the feedback was given. */
    public var queryType: QueryType?
    /** The method how knowledge was surfaced. Article: Full article was shown. Snippet: A snippet from the article was shown. Highlight: A highlighted answer in a snippet was shown.Generative: A generated answer in a snippet was shown. */
    public var surfacingMethod: SurfacingMethod?
    /** The state of the feedback. */
    public var state: State?
    /** The document on which feedback was given. */
    public var document: KnowledgeDocumentVersionReference?
    /** The client application from which feedback was given. */
    public var application: KnowledgeSearchClientApplication?
    /** Conversation context information if the feedback is given in the context of a conversation. */
    public var conversationContext: KnowledgeConversationContextResponse?
    /** The user who created the feedback. */
    public var user: AddressableEntityRef?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, documentVariation: EntityReference?, rating: Rating?, reason: Reason?, comment: String?, search: EntityReference?, sessionId: String?, dateCreated: Date?, queryType: QueryType?, surfacingMethod: SurfacingMethod?, state: State?, document: KnowledgeDocumentVersionReference?, application: KnowledgeSearchClientApplication?, conversationContext: KnowledgeConversationContextResponse?, user: AddressableEntityRef?, selfUri: String?) {
        self._id = _id
        self.documentVariation = documentVariation
        self.rating = rating
        self.reason = reason
        self.comment = comment
        self.search = search
        self.sessionId = sessionId
        self.dateCreated = dateCreated
        self.queryType = queryType
        self.surfacingMethod = surfacingMethod
        self.state = state
        self.document = document
        self.application = application
        self.conversationContext = conversationContext
        self.user = user
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case documentVariation
        case rating
        case reason
        case comment
        case search
        case sessionId
        case dateCreated
        case queryType
        case surfacingMethod
        case state
        case document
        case application
        case conversationContext
        case user
        case selfUri
    }


}




public class KnowledgeDocumentFeedbackResponseListing: Codable {









    public var entities: [KnowledgeDocumentFeedbackResponse]?
    public var nextUri: String?
    public var selfUri: String?
    public var previousUri: String?

    public init(entities: [KnowledgeDocumentFeedbackResponse]?, nextUri: String?, selfUri: String?, previousUri: String?) {
        self.entities = entities
        self.nextUri = nextUri
        self.selfUri = selfUri
        self.previousUri = previousUri
    }


}




public class KnowledgeDocumentQueryVariation: Codable {























    /** The globally unique identifier for the variation. */
    public var _id: String?
    /** The creation date-time for the document variation. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** The last modification date-time for the document variation. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** The version of the document. */
    public var documentVersion: AddressableEntityRef?
    /** The context values associated with the variation. */
    public var contexts: [DocumentVariationContext]?
    /** The reference to document to which the variation is associated. */
    public var document: KnowledgeDocumentReference?
    /** The priority of the variation. */
    public var priority: Int?
    /** The name of the variation. */
    public var name: String?
    /** The content for the variation. */
    public var body: DocumentBodyResponse?
    /** The chunk blocks associated with the variation. */
    public var chunks: [DocumentVariationQueryChunkBlock]?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, dateCreated: Date?, dateModified: Date?, documentVersion: AddressableEntityRef?, contexts: [DocumentVariationContext]?, document: KnowledgeDocumentReference?, priority: Int?, name: String?, body: DocumentBodyResponse?, chunks: [DocumentVariationQueryChunkBlock]?, selfUri: String?) {
        self._id = _id
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.documentVersion = documentVersion
        self.contexts = contexts
        self.document = document
        self.priority = priority
        self.name = name
        self.body = body
        self.chunks = chunks
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case dateCreated
        case dateModified
        case documentVersion
        case contexts
        case document
        case priority
        case name
        case body
        case chunks
        case selfUri
    }


}




public class KnowledgeGuestDocumentVariationAnswer: Codable {

















    /** The globally unique identifier for the variation. */
    public var _id: String?
    /** The creation date-time for the document variation. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** The last modification date-time for the document variation. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** The version of the document. */
    public var documentVersion: AddressableEntityRef?
    /** The context values associated with the variation. */
    public var contexts: [KnowledgeGuestDocumentVariationContext]?
    /** The reference to document to which the variation is associated. */
    public var document: AddressableEntityRef?
    /** The content for the variation. */
    public var body: DocumentBodyWithHighlight?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, dateCreated: Date?, dateModified: Date?, documentVersion: AddressableEntityRef?, contexts: [KnowledgeGuestDocumentVariationContext]?, document: AddressableEntityRef?, body: DocumentBodyWithHighlight?, selfUri: String?) {
        self._id = _id
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.documentVersion = documentVersion
        self.contexts = contexts
        self.document = document
        self.body = body
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case dateCreated
        case dateModified
        case documentVersion
        case contexts
        case document
        case body
        case selfUri
    }


}




public class KnowledgeGuestSearchDocumentResponse: Codable {









    public enum State: String, Codable { 
        case draft = "Draft"
        case published = "Published"
        case archived = "Archived"
    }



























    /** The globally unique identifier for the object. */
    public var _id: String?
    /** Document title, having a limit of 500 words. */
    public var title: String?
    /** Indicates if the knowledge document should be included in search results. */
    public var visible: Bool?
    /** List of alternate phrases related to the title which improves search results. */
    public var alternatives: [KnowledgeDocumentAlternative]?
    /** State of the document. */
    public var state: State?
    /** Document creation date-time. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** Document last modification date-time. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** Document import date-time, or null if was not imported. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateImported: Date?
    /** The last published version number of the document. */
    public var lastPublishedVersionNumber: Int?
    /** The date on which the document was last published. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var datePublished: Date?
    /** The user who created the document. */
    public var createdBy: UserReference?
    /** The user who modified the document. */
    public var modifiedBy: UserReference?
    /** The version of the document. */
    public var documentVersion: AddressableEntityRef?
    /** ID of the guest session. */
    public var sessionId: String?
    /** The reference to category associated with the document. */
    public var category: GuestCategoryReference?
    /** Variations of the document. */
    public var variations: [KnowledgeGuestDocumentVariationAnswer]?
    /** The answer to the query. */
    public var answer: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, title: String?, visible: Bool?, alternatives: [KnowledgeDocumentAlternative]?, state: State?, dateCreated: Date?, dateModified: Date?, dateImported: Date?, lastPublishedVersionNumber: Int?, datePublished: Date?, createdBy: UserReference?, modifiedBy: UserReference?, documentVersion: AddressableEntityRef?, sessionId: String?, category: GuestCategoryReference?, variations: [KnowledgeGuestDocumentVariationAnswer]?, answer: String?, selfUri: String?) {
        self._id = _id
        self.title = title
        self.visible = visible
        self.alternatives = alternatives
        self.state = state
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.dateImported = dateImported
        self.lastPublishedVersionNumber = lastPublishedVersionNumber
        self.datePublished = datePublished
        self.createdBy = createdBy
        self.modifiedBy = modifiedBy
        self.documentVersion = documentVersion
        self.sessionId = sessionId
        self.category = category
        self.variations = variations
        self.answer = answer
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case title
        case visible
        case alternatives
        case state
        case dateCreated
        case dateModified
        case dateImported
        case lastPublishedVersionNumber
        case datePublished
        case createdBy
        case modifiedBy
        case documentVersion
        case sessionId
        case category
        case variations
        case answer
        case selfUri
    }


}




public class KnowledgeGuestSessionContext: Codable {





    /** The context id associated with the session. */
    public var _id: String?
    /** The list of knowledge context values associated with the session. */
    public var values: [Entity]?

    public init(_id: String?, values: [Entity]?) {
        self._id = _id
        self.values = values
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case values
    }


}




public class KnowledgeIntegrationOptionsResponse: Codable {



    /** Filter setting options available for a knowledge source. */
    public var filters: [KnowledgeIntegrationFilter]?

    public init(filters: [KnowledgeIntegrationFilter]?) {
        self.filters = filters
    }


}




public class KnowledgeParseImportResult: Codable {







    /** Number of imported articles. */
    public var success: Int?
    /** Number of articles failed to import. */
    public var failure: Int?
    /** Error information about the failures. */
    public var errors: [ErrorBody]?

    public init(success: Int?, failure: Int?, errors: [ErrorBody]?) {
        self.success = success
        self.failure = failure
        self.errors = errors
    }


}




public class KnowledgeParseJobRequestPatch: Codable {



    /** Hinted titles for the parser. */
    public var hints: [String]?

    public init(hints: [String]?) {
        self.hints = hints
    }


}




public class KnowledgeSearchDocumentResponse: Codable {









    public enum State: String, Codable { 
        case draft = "Draft"
        case published = "Published"
        case archived = "Archived"
    }





































    /** The globally unique identifier for the object. */
    public var _id: String?
    /** Document title, having a limit of 500 words. */
    public var title: String?
    /** Indicates if the knowledge document should be included in search results. */
    public var visible: Bool?
    /** List of alternate phrases related to the title which improves search results. */
    public var alternatives: [KnowledgeDocumentAlternative]?
    /** State of the document. */
    public var state: State?
    /** Document creation date-time. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** Document last modification date-time. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** Document import date-time, or null if was not imported. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateImported: Date?
    /** The last published version number of the document. */
    public var lastPublishedVersionNumber: Int?
    /** The date on which the document was last published. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var datePublished: Date?
    /** The user who created the document. */
    public var createdBy: UserReference?
    /** The user who modified the document. */
    public var modifiedBy: UserReference?
    /** The version of the document. */
    public var documentVersion: AddressableEntityRef?
    /** The reference to category associated with the document. */
    public var category: CategoryResponse?
    /** The references to labels associated with the document. */
    public var labels: [LabelResponse]?
    /** Knowledge base to which the document belongs to. */
    public var knowledgeBase: KnowledgeBaseReference?
    /** The reference to external id associated with the document. */
    public var externalId: String?
    /** The URL to external document. */
    public var externalUrl: String?
    /** The reference to source associated with the document. */
    public var source: AddressableEntityRef?
    /** Whether the document is read-only. */
    public var readonly: Bool?
    /** Variations of the document. */
    public var variations: [KnowledgeDocumentSearchVariation]?
    /** The answer to the query. */
    public var answer: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, title: String?, visible: Bool?, alternatives: [KnowledgeDocumentAlternative]?, state: State?, dateCreated: Date?, dateModified: Date?, dateImported: Date?, lastPublishedVersionNumber: Int?, datePublished: Date?, createdBy: UserReference?, modifiedBy: UserReference?, documentVersion: AddressableEntityRef?, category: CategoryResponse?, labels: [LabelResponse]?, knowledgeBase: KnowledgeBaseReference?, externalId: String?, externalUrl: String?, source: AddressableEntityRef?, readonly: Bool?, variations: [KnowledgeDocumentSearchVariation]?, answer: String?, selfUri: String?) {
        self._id = _id
        self.title = title
        self.visible = visible
        self.alternatives = alternatives
        self.state = state
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.dateImported = dateImported
        self.lastPublishedVersionNumber = lastPublishedVersionNumber
        self.datePublished = datePublished
        self.createdBy = createdBy
        self.modifiedBy = modifiedBy
        self.documentVersion = documentVersion
        self.category = category
        self.labels = labels
        self.knowledgeBase = knowledgeBase
        self.externalId = externalId
        self.externalUrl = externalUrl
        self.source = source
        self.readonly = readonly
        self.variations = variations
        self.answer = answer
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case title
        case visible
        case alternatives
        case state
        case dateCreated
        case dateModified
        case dateImported
        case lastPublishedVersionNumber
        case datePublished
        case createdBy
        case modifiedBy
        case documentVersion
        case category
        case labels
        case knowledgeBase
        case externalId
        case externalUrl
        case source
        case readonly
        case variations
        case answer
        case selfUri
    }


}




public class KnowledgeSyncJobRequest: Codable {





    /** Upload key */
    public var uploadKey: String?
    /** Knowledge integration source id. */
    public var sourceId: String?

    public init(uploadKey: String?, sourceId: String?) {
        self.uploadKey = uploadKey
        self.sourceId = sourceId
    }


}




public class LabelsFilter: Codable {



    /** A list of labels to filter by. Articles matching any of the specified labels can be accessed. */
    public var entities: [LabelEntity]?

    public init(entities: [LabelEntity]?) {
        self.entities = entities
    }


}




public class Language: Codable {







    public enum State: String, Codable { 
        case active = "active"
        case inactive = "inactive"
        case deleted = "deleted"
    }





    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The language name. */
    public var name: String?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    public var state: State?
    public var version: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, dateModified: Date?, state: State?, version: String?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.dateModified = dateModified
        self.state = state
        self.version = version
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case dateModified
        case state
        case version
        case selfUri
    }


}




public class Leaderboard: Codable {















    /** The targeted division for this leaderboard */
    public var division: Division?
    /** The metric id if the leaderboard is about a specific metric */
    public var metric: AddressableEntityRef?
    /** Start workday used as the date range. Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd */
    public var dateStartWorkday: Date?
    /** End workday used as the date range. Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd */
    public var dateEndWorkday: Date?
    /** The list of leaders generated. */
    public var leaders: [LeaderboardItem]?
    /** The requesting user's rank */
    public var userRank: LeaderboardItem?
    /** The targeted performance profile for the average points */
    public var performanceProfile: AddressableEntityRef?

    public init(division: Division?, metric: AddressableEntityRef?, dateStartWorkday: Date?, dateEndWorkday: Date?, leaders: [LeaderboardItem]?, userRank: LeaderboardItem?, performanceProfile: AddressableEntityRef?) {
        self.division = division
        self.metric = metric
        self.dateStartWorkday = dateStartWorkday
        self.dateEndWorkday = dateEndWorkday
        self.leaders = leaders
        self.userRank = userRank
        self.performanceProfile = performanceProfile
    }


}




public class LearningAssignmentItem: Codable {





    /** The Learning Module ID associated with this assignment */
    public var moduleId: String?
    /** The User ID associated with this assignment */
    public var userId: String?

    public init(moduleId: String?, userId: String?) {
        self.moduleId = moduleId
        self.userId = userId
    }


}




public class LearningAssignmentRuleRunTopicLearningAssignmentsCreated: Codable {



    public var module: LearningAssignmentRuleRunTopicLearningModuleReference?

    public init(module: LearningAssignmentRuleRunTopicLearningModuleReference?) {
        self.module = module
    }


}




public class LearningAssignmentRuleRunTopicLearningModuleReference: Codable {





    public var _id: String?
    public var name: String?

    public init(_id: String?, name: String?) {
        self._id = _id
        self.name = name
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
    }


}



/** Learning module users query request model */

public class LearningAssignmentUserQuery: Codable {





    /** Learning module rule object */
    public var rule: LearningModuleRule?
    /** The user name to be searched for */
    public var searchTerm: String?

    public init(rule: LearningModuleRule?, searchTerm: String?) {
        self.rule = rule
        self.searchTerm = searchTerm
    }


}




public class LearningCoverArtThumbnail: Codable {





    /** Resolution of thumbnail */
    public var resolution: String?
    /** The URL for the thumbnail */
    public var url: String?

    public init(resolution: String?, url: String?) {
        self.resolution = resolution
        self.url = url
    }


}



/** Auto assign response */

public class LearningModuleAutoAssignResponse: Codable {





    /** The rule reference */
    public var rule: UsersRulesRuleReference?
    /** Whether the rule is enabled for the module */
    public var enabled: Bool?

    public init(rule: UsersRulesRuleReference?, enabled: Bool?) {
        self.rule = rule
        self.enabled = enabled
    }


}



/** Learning module preview update request */

public class LearningModulePreviewUpdateRequest: Codable {

    public enum State: String, Codable { 
        case assigned = "Assigned"
        case inProgress = "InProgress"
        case completed = "Completed"
        case deleted = "Deleted"
        case notCompleted = "NotCompleted"
        case invalidSchedule = "InvalidSchedule"
    }









    /** The assignment State */
    public var state: State?
    /** The assignment current step */
    public var currentStep: LearningModulePreviewUpdateRequestCurrentStep?
    /** The assignment Steps */
    public var steps: [LearningModulePreviewUpdateStep]?
    /** The assessment for learning module */
    public var assessment: LearningAssessment?
    /** The assessment form for learning module */
    public var assessmentForm: AssessmentForm?

    public init(state: State?, currentStep: LearningModulePreviewUpdateRequestCurrentStep?, steps: [LearningModulePreviewUpdateStep]?, assessment: LearningAssessment?, assessmentForm: AssessmentForm?) {
        self.state = state
        self.currentStep = currentStep
        self.steps = steps
        self.assessment = assessment
        self.assessmentForm = assessmentForm
    }


}



/** Learning module preview update SCO structure */

public class LearningModulePreviewUpdateScoStructure: Codable {





    public enum SuccessStatus: String, Codable { 
        case passed = "Passed"
        case failed = "Failed"
        case unknown = "Unknown"
    }

    public enum CompletionStatus: String, Codable { 
        case completed = "Completed"
        case incomplete = "Incomplete"
        case notAttempted = "NotAttempted"
        case unknown = "Unknown"
    }





    /** The id of this SCO in the course manifest */
    public var _id: String?
    /** The name of this SCO in the course manifest */
    public var name: String?
    /** The success status of this SCO */
    public var successStatus: SuccessStatus?
    /** The completion status of this SCO */
    public var completionStatus: CompletionStatus?
    /** Percentage Score */
    public var percentageScore: Float?
    /** Child items belonging to this SCO in the course manifest */
    public var children: [LearningModulePreviewUpdateScoStructure]?

    public init(_id: String?, name: String?, successStatus: SuccessStatus?, completionStatus: CompletionStatus?, percentageScore: Float?, children: [LearningModulePreviewUpdateScoStructure]?) {
        self._id = _id
        self.name = name
        self.successStatus = successStatus
        self.completionStatus = completionStatus
        self.percentageScore = percentageScore
        self.children = children
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case successStatus
        case completionStatus
        case percentageScore
        case children
    }


}



/** Learning module publish response */

public class LearningModulePublishResponse: Codable {







    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The version of published learning module */
    public var version: Int?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, version: Int?, selfUri: String?) {
        self._id = _id
        self.version = version
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case version
        case selfUri
    }


}



/** Learning SCORM package */

public class LearningScormResponse: Codable {



    public enum Status: String, Codable { 
        case uploadPending = "UploadPending"
        case unpacking = "Unpacking"
        case error = "Error"
        case ready = "Ready"
    }









    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The status of the SCORM package */
    public var status: Status?
    /** The error code of the SCORM package (on failure) */
    public var errorCode: String?
    /** The error message associated with the error code */
    public var errorMessage: String?
    /** The percentage of the SCORM package that has been unpacked */
    public var percentageUnpacked: Float?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, status: Status?, errorCode: String?, errorMessage: String?, percentageUnpacked: Float?, selfUri: String?) {
        self._id = _id
        self.status = status
        self.errorCode = errorCode
        self.errorMessage = errorMessage
        self.percentageUnpacked = percentageUnpacked
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case status
        case errorCode
        case errorMessage
        case percentageUnpacked
        case selfUri
    }


}



/** Learning assignment SCO (Shareable Content Object) */

public class LearningShareableContentObject: Codable {



    public enum LessonStatus: String, Codable { 
        case passed = "Passed"
        case completed = "Completed"
        case failed = "Failed"
        case incomplete = "Incomplete"
        case browsed = "Browsed"
        case notAttempted = "NotAttempted"
    }

    public enum Exit: String, Codable { 
        case timeout = "Timeout"
        case suspend = "Suspend"
        case logout = "Logout"
        case empty = "Empty"
    }











    public enum Credit: String, Codable { 
        case credit = "Credit"
        case noCredit = "NoCredit"
    }

    public enum Entry: String, Codable { 
        case abInitio = "AbInitio"
        case resume = "Resume"
        case empty = "Empty"
    }

    public enum Mode: String, Codable { 
        case browse = "Browse"
        case normal = "Normal"
        case review = "Review"
    }











    /** The ID of the SCO from the course manifest. */
    public var _id: String?
    /** The status of the SCO. Maps to the SCORM 1.2 cmi.core.lesson_status property. */
    public var lessonStatus: LessonStatus?
    /** Indicates how or why the learner left the SCO. Maps to the SCORM 1.2 cmi.core.exit property. */
    public var exit: Exit?
    /** The learners current location in the SCO. Maps to the SCORM 1.2 cmi.core.lesson_location property. */
    public var location: String?
    /** The score of the most recent attempt on the SCO. Maps to the SCORM 1.2 cmi.core.score.raw property. */
    public var scoreRaw: Float?
    /** The maximum score that could be achieved on the SCO. Maps to the SCORM 1.2 cmi.core.score.max property. */
    public var scoreMax: Float?
    /** The minimum score that could be achieved on the SCO. Maps to the SCORM 1.2 cmi.core.score.min property. */
    public var scoreMin: Float?
    /** The unique information generated by the SCO from previous uses. Maps to the SCORM 1.2 cmi.suspend_data property. */
    public var suspendData: String?
    /** Whether completing this course counts towards the overall assignment. Maps to the SCORM 1.2 cmi.core.credit property. */
    public var credit: Credit?
    /** Whether the learner has previously accessed this SCO. Maps to the SCORM 1.2 cmi.core.entry property. */
    public var entry: Entry?
    /** Identifies the mode in which the SCO should be presented to the learner. Maps to the SCORM 1.2 cmi.core.lesson_mode property. */
    public var mode: Mode?
    /** The total amount of time the learner has spent in the SCO expressed as an ISO 8601 Duration, for example PT2H10M3.5S. Maps to the SCORM 1.2 cmi.core.total_time property. */
    public var totalTime: String?
    /** The amount of time spent in the SCO in this session expressed as an ISO-8601 Duration, for example PT2H10M3.5S. Maps to the SCORM 1.2 cmi.core.session_time property. */
    public var sessionTime: String?
    /** The href from the course manifest for this SCO. */
    public var href: String?
    /** The parameters from the course manifest for this SCO. */
    public var parameters: String?
    /** The launch data from the course manifest for this SCO. */
    public var launchData: String?

    public init(_id: String?, lessonStatus: LessonStatus?, exit: Exit?, location: String?, scoreRaw: Float?, scoreMax: Float?, scoreMin: Float?, suspendData: String?, credit: Credit?, entry: Entry?, mode: Mode?, totalTime: String?, sessionTime: String?, href: String?, parameters: String?, launchData: String?) {
        self._id = _id
        self.lessonStatus = lessonStatus
        self.exit = exit
        self.location = location
        self.scoreRaw = scoreRaw
        self.scoreMax = scoreMax
        self.scoreMin = scoreMin
        self.suspendData = suspendData
        self.credit = credit
        self.entry = entry
        self.mode = mode
        self.totalTime = totalTime
        self.sessionTime = sessionTime
        self.href = href
        self.parameters = parameters
        self.launchData = launchData
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case lessonStatus
        case exit
        case location
        case scoreRaw
        case scoreMax
        case scoreMin
        case suspendData
        case credit
        case entry
        case mode
        case totalTime
        case sessionTime
        case href
        case parameters
        case launchData
    }


}




public class LearningSlot: Codable {







    public enum DifferenceRating: String, Codable { 
        case poor = "Poor"
        case neutral = "Neutral"
        case good = "Good"
    }

    /** Start date and time of scheduled Learning activity slot. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateStart: Date?
    /** Length of Learning activity slot in minutes */
    public var lengthInMinutes: Int?
    /** Difference between scheduled and forecast headcount for this slot after scheduling the Learning activity */
    public var staffingDifference: Double?
    /** Rating based on the staffing difference for scheduled slot */
    public var differenceRating: DifferenceRating?

    public init(dateStart: Date?, lengthInMinutes: Int?, staffingDifference: Double?, differenceRating: DifferenceRating?) {
        self.dateStart = dateStart
        self.lengthInMinutes = lengthInMinutes
        self.staffingDifference = staffingDifference
        self.differenceRating = differenceRating
    }


}




public class LexV2Intent: Codable {









    /** The intent name */
    public var intentName: String?
    /** A description of the intent */
    public var _description: String?
    /** An object mapping slot names to Slot objects */
    public var slots: [String:LexV2Slot]?
    /** The intent id */
    public var intentId: String?

    public init(intentName: String?, _description: String?, slots: [String:LexV2Slot]?, intentId: String?) {
        self.intentName = intentName
        self._description = _description
        self.slots = slots
        self.intentId = intentId
    }

    public enum CodingKeys: String, CodingKey { 
        case intentName
        case _description = "description"
        case slots
        case intentId
    }


}




public class LimitDocs: Codable {













    public var key: String?
    public var defaultValue: Int64?
    public var _description: String?
    public var resource: String?
    public var configurable: Bool?
    public var trackable: Bool?

    public init(key: String?, defaultValue: Int64?, _description: String?, resource: String?, configurable: Bool?, trackable: Bool?) {
        self.key = key
        self.defaultValue = defaultValue
        self._description = _description
        self.resource = resource
        self.configurable = configurable
        self.trackable = trackable
    }

    public enum CodingKeys: String, CodingKey { 
        case key
        case defaultValue
        case _description = "description"
        case resource
        case configurable
        case trackable
    }


}




public class LineEntityListing: Codable {























    public var entities: [Line]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    /** The total organization-wide number of entities. */
    public var totalNumberOfEntities: Int64?
    public var firstUri: String?
    public var previousUri: String?
    public var nextUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [Line]?, pageSize: Int?, pageNumber: Int?, total: Int64?, totalNumberOfEntities: Int64?, firstUri: String?, previousUri: String?, nextUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.totalNumberOfEntities = totalNumberOfEntities
        self.firstUri = firstUri
        self.previousUri = previousUri
        self.nextUri = nextUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class ListWrapperBidGroupWorkPlanRequest: Codable {



    public var values: [BidGroupWorkPlanRequest]?

    public init(values: [BidGroupWorkPlanRequest]?) {
        self.values = values
    }


}




public class ListWrapperShiftStartVariance: Codable {



    public var values: [ShiftStartVariance]?

    public init(values: [ShiftStartVariance]?) {
        self.values = values
    }


}




public class ListedTopic: Codable {









    public enum Strictness: String, Codable { 
        case _1 = "1"
        case _55 = "55"
        case _65 = "65"
        case _72 = "72"
        case _85 = "85"
        case _90 = "90"
    }

    public enum MatchingType: String, Codable { 
        case lexical = "Lexical"
        case semantic = "Semantic"
    }







    public enum Participants: String, Codable { 
        case external = "External"
        case _internal = "Internal"
        case all = "All"
    }









    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    public var _description: String?
    public var published: Bool?
    public var strictness: Strictness?
    public var matchingType: MatchingType?
    public var programsCount: Int?
    public var tags: [String]?
    public var dialect: String?
    public var participants: Participants?
    public var phrasesCount: Int?
    public var modifiedBy: AddressableEntityRef?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, _description: String?, published: Bool?, strictness: Strictness?, matchingType: MatchingType?, programsCount: Int?, tags: [String]?, dialect: String?, participants: Participants?, phrasesCount: Int?, modifiedBy: AddressableEntityRef?, dateModified: Date?, selfUri: String?) {
        self._id = _id
        self.name = name
        self._description = _description
        self.published = published
        self.strictness = strictness
        self.matchingType = matchingType
        self.programsCount = programsCount
        self.tags = tags
        self.dialect = dialect
        self.participants = participants
        self.phrasesCount = phrasesCount
        self.modifiedBy = modifiedBy
        self.dateModified = dateModified
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case _description = "description"
        case published
        case strictness
        case matchingType
        case programsCount
        case tags
        case dialect
        case participants
        case phrasesCount
        case modifiedBy
        case dateModified
        case selfUri
    }


}



/** Contains localized labels used in messenger apps */

public class LocalizedLabels: Codable {

    public enum Key: String, Codable { 
        case messengerHomeHeaderTitle = "MessengerHomeHeaderTitle"
        case messengerHomeHeaderSubTitle = "MessengerHomeHeaderSubTitle"
        case pushNotificationTitle = "PushNotificationTitle"
        case pushNotificationBody = "PushNotificationBody"
    }



    /** Contains localized label key used in messenger homescreen and push notification. PushNotificationTitle and PushNotificationBody keys are required when notifications are enabled. */
    public var key: Key?
    /** Contains localized label value used in messenger homescreen and push notification */
    public var value: String?

    public init(key: Key?, value: String?) {
        self.key = key
        self.value = value
    }


}




public class LocationCreateDefinition: Codable {





    public enum State: String, Codable { 
        case active = "active"
        case deleted = "deleted"
    }











    /** The name of the Location. Required for creates, not required for updates */
    public var name: String?
    /** Current version of the location */
    public var version: Int?
    /** Current activity status of the location. */
    public var state: State?
    /** A list of ancestor ids */
    public var path: [String]?
    /** Notes for the location */
    public var notes: String?
    /** The user id of the location contact */
    public var contactUser: String?
    /** Emergency number for the location */
    public var emergencyNumber: LocationEmergencyNumber?
    /** Address of the location */
    public var address: LocationAddress?

    public init(name: String?, version: Int?, state: State?, path: [String]?, notes: String?, contactUser: String?, emergencyNumber: LocationEmergencyNumber?, address: LocationAddress?) {
        self.name = name
        self.version = version
        self.state = state
        self.path = path
        self.notes = notes
        self.contactUser = contactUser
        self.emergencyNumber = emergencyNumber
        self.address = address
    }


}




public class LocationEmergencyNumber: Codable {





    public enum ModelType: String, Codable { 
        case _default = "default"
        case elin = "elin"
    }

    public var e164: String?
    public var number: String?
    /** The type of emergency number. */
    public var type: ModelType?

    public init(e164: String?, number: String?, type: ModelType?) {
        self.e164 = e164
        self.number = number
        self.type = type
    }


}




public class LocationUpdateDefinition: Codable {





    public enum State: String, Codable { 
        case active = "active"
        case deleted = "deleted"
    }











    /** The name of the Location. Required for creates, not required for updates */
    public var name: String?
    /** Current version of the location */
    public var version: Int?
    /** Current activity status of the location. */
    public var state: State?
    /** A list of ancestor ids */
    public var path: [String]?
    /** Notes for the location */
    public var notes: String?
    /** The user id of the location contact */
    public var contactUser: String?
    /** Emergency number for the location */
    public var emergencyNumber: LocationEmergencyNumber?
    /** Address of the location */
    public var address: LocationAddress?

    public init(name: String?, version: Int?, state: State?, path: [String]?, notes: String?, contactUser: String?, emergencyNumber: LocationEmergencyNumber?, address: LocationAddress?) {
        self.name = name
        self.version = version
        self.state = state
        self.path = path
        self.notes = notes
        self.contactUser = contactUser
        self.emergencyNumber = emergencyNumber
        self.address = address
    }


}




public class LockInfo: Codable {







    public enum Action: String, Codable { 
        case update = "UPDATE"
        case delete = "DELETE"
        case copy = "COPY"
        case move = "MOVE"
        case replace = "REPLACE"
        case thumbnail = "THUMBNAIL"
        case textExtraction = "TEXT_EXTRACTION"
    }

    public var lockedBy: DomainEntityRef?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateExpires: Date?
    public var action: Action?

    public init(lockedBy: DomainEntityRef?, dateCreated: Date?, dateExpires: Date?, action: Action?) {
        self.lockedBy = lockedBy
        self.dateCreated = dateCreated
        self.dateExpires = dateExpires
        self.action = action
    }


}




public class LogCaptureUserConfigurationResponse: Codable {









    /** The globally unique identifier for the object. */
    public var _id: String?
    /** Indicates when log capture was enabled for the user. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateStarted: Date?
    /** Indicates when log capture will be turned off for the user. (Must be within 24 hours). Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateExpired: Date?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, dateStarted: Date?, dateExpired: Date?, selfUri: String?) {
        self._id = _id
        self.dateStarted = dateStarted
        self.dateExpired = dateExpired
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case dateStarted
        case dateExpired
        case selfUri
    }


}




public class LogicalInterfaceEntityListing: Codable {





















    public var entities: [DomainLogicalInterface]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var previousUri: String?
    public var nextUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [DomainLogicalInterface]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, previousUri: String?, nextUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.previousUri = previousUri
        self.nextUri = nextUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class LongTermRequirementsErrorDetail: Codable {

    public enum InternalErrorCode: String, Codable { 
        case timedOut = "TimedOut"
        case noData = "NoData"
        case clientDataInvalid = "ClientDataInvalid"
        case configurationInvalid = "ConfigurationInvalid"
        case requirementsFailed = "RequirementsFailed"
    }



    /** The error code */
    public var internalErrorCode: InternalErrorCode?
    /** The description of the error code */
    public var _description: String?

    public init(internalErrorCode: InternalErrorCode?, _description: String?) {
        self.internalErrorCode = internalErrorCode
        self._description = _description
    }

    public enum CodingKeys: String, CodingKey { 
        case internalErrorCode
        case _description = "description"
    }


}




public class LongTermRequirementsResponse: Codable {

    public enum Status: String, Codable { 
        case processing = "Processing"
        case complete = "Complete"
        case canceled = "Canceled"
        case error = "Error"
    }

    public enum ErrorCode: String, Codable { 
        case timedOut = "TimedOut"
        case noData = "NoData"
        case clientDataInvalid = "ClientDataInvalid"
        case configurationInvalid = "ConfigurationInvalid"
        case requirementsFailed = "RequirementsFailed"
    }





    /** Status of the long term forecast */
    public var status: Status?
    /** Error code when status is Failed */
    public var errorCode: ErrorCode?
    /** For schema documentation only, always null, schema for staffing forecast result at downloadUrl */
    public var longTermRequirements: LongTermRequirements?
    /** Download URL for the staffing forecast result */
    public var downloadUrl: String?

    public init(status: Status?, errorCode: ErrorCode?, longTermRequirements: LongTermRequirements?, downloadUrl: String?) {
        self.status = status
        self.errorCode = errorCode
        self.longTermRequirements = longTermRequirements
        self.downloadUrl = downloadUrl
    }


}



/** Defines a SCIM manager. */

public class Manager: Codable {





    /** The ID of the manager. */
    public var value: String?
    /** The reference URI of the manager's user record. */
    public var ref: String?

    public init(value: String?, ref: String?) {
        self.value = value
        self.ref = ref
    }

    public enum CodingKeys: String, CodingKey { 
        case value
        case ref = "$ref"
    }


}




public class MaskingRuleValidateResponse: Codable {







    /** is masking rule definition valid? */
    public var valid: Bool?
    /** Validation message. */
    public var validationMessage: String?
    /** Masked text. */
    public var maskedText: String?

    public init(valid: Bool?, validationMessage: String?, maskedText: String?) {
        self.valid = valid
        self.validationMessage = validationMessage
        self.maskedText = maskedText
    }


}




public class MatchShiftTradeRequest: Codable {







    /** The ID of the schedule with which the shift trade is associated */
    public var receivingScheduleId: String?
    /** The ID of the shift the receiving user is giving up in trade, if applicable */
    public var receivingShiftId: String?
    /** Version metadata for the shift trade */
    public var metadata: WfmVersionedEntityMetadata?

    public init(receivingScheduleId: String?, receivingShiftId: String?, metadata: WfmVersionedEntityMetadata?) {
        self.receivingScheduleId = receivingScheduleId
        self.receivingShiftId = receivingShiftId
        self.metadata = metadata
    }


}




public class MaxLength: Codable {





    /** A non-negative integer for a text-based schema field denoting the minimum largest length string the field can contain for a schema instance. */
    public var min: Int64?
    /** A non-negative integer for a text-based schema field denoting the maximum largest string the field can contain for a schema instance. */
    public var max: Int64?

    public init(min: Int64?, max: Int64?) {
        self.min = min
        self.max = max
    }


}




public class MediaPolicies: Codable {









    /** Conditions and actions for calls */
    public var callPolicy: CallMediaPolicy?
    /** Conditions and actions for chats */
    public var chatPolicy: ChatMediaPolicy?
    /** Conditions and actions for emails */
    public var emailPolicy: EmailMediaPolicy?
    /** Conditions and actions for messages */
    public var messagePolicy: MessageMediaPolicy?

    public init(callPolicy: CallMediaPolicy?, chatPolicy: ChatMediaPolicy?, emailPolicy: EmailMediaPolicy?, messagePolicy: MessageMediaPolicy?) {
        self.callPolicy = callPolicy
        self.chatPolicy = chatPolicy
        self.emailPolicy = emailPolicy
        self.messagePolicy = messagePolicy
    }


}




public class MediaResult: Codable {





    public var mediaUri: String?
    public var waveformData: [Float]?

    public init(mediaUri: String?, waveformData: [Float]?) {
        self.mediaUri = mediaUri
        self.waveformData = waveformData
    }


}




public class MediaSettings: Codable {











    /** Indicates if auto-answer is enabled for the given media type or subtype (default is false).  Subtype settings take precedence over media type settings. */
    public var enableAutoAnswer: Bool?
    /** The alerting timeout for the media type, in seconds */
    public var alertingTimeoutSeconds: Int?
    /** The targeted service level for the media type */
    public var serviceLevel: ServiceLevel?
    /** How long to play the alerting tone for an auto-answer interaction */
    public var autoAnswerAlertToneSeconds: Double?
    /** How long to play the alerting tone for a manual-answer interaction */
    public var manualAnswerAlertToneSeconds: Double?

    public init(enableAutoAnswer: Bool?, alertingTimeoutSeconds: Int?, serviceLevel: ServiceLevel?, autoAnswerAlertToneSeconds: Double?, manualAnswerAlertToneSeconds: Double?) {
        self.enableAutoAnswer = enableAutoAnswer
        self.alertingTimeoutSeconds = alertingTimeoutSeconds
        self.serviceLevel = serviceLevel
        self.autoAnswerAlertToneSeconds = autoAnswerAlertToneSeconds
        self.manualAnswerAlertToneSeconds = manualAnswerAlertToneSeconds
    }


}




public class Message: Codable {

    public enum State: String, Codable { 
        case alerting = "alerting"
        case connected = "connected"
        case parked = "parked"
        case disconnected = "disconnected"
    }

    public enum InitialState: String, Codable { 
        case alerting = "alerting"
        case connected = "connected"
        case parked = "parked"
        case disconnected = "disconnected"
    }







    public enum Direction: String, Codable { 
        case inbound = "inbound"
        case outbound = "outbound"
    }





    public enum DisconnectType: String, Codable { 
        case endpoint = "endpoint"
        case client = "client"
        case system = "system"
        case timeout = "timeout"
        case transfer = "transfer"
        case transferConference = "transfer.conference"
        case transferConsult = "transfer.consult"
        case transferForward = "transfer.forward"
        case transferNoanswer = "transfer.noanswer"
        case transferNotavailable = "transfer.notavailable"
        case transportFailure = "transport.failure"
        case error = "error"
        case peer = "peer"
        case other = "other"
        case spam = "spam"
        case uncallable = "uncallable"
        case inactivity = "inactivity"
        case sessionExpired = "session.expired"
    }













    public enum ModelType: String, Codable { 
        case apple = "apple"
        case facebook = "facebook"
        case instagram = "instagram"
        case kakao = "kakao"
        case line = "line"
        case _open = "open"
        case sms = "sms"
        case telegram = "telegram"
        case twitter = "twitter"
        case webmessaging = "webmessaging"
        case whatsapp = "whatsapp"
        case unknown = "unknown"
    }





























    public enum EngagementSource: String, Codable { 
        case appleMessagesForBusiness = "AppleMessagesForBusiness"
        case discord = "Discord"
        case email = "Email"
        case facebook = "Facebook"
        case facebookMessenger = "FacebookMessenger"
        case glassdoor = "Glassdoor"
        case googleBusinessProfile = "GoogleBusinessProfile"
        case instagram = "Instagram"
        case kakaoTalk = "KakaoTalk"
        case line = "Line"
        case linkedIn = "LinkedIn"
        case microsoftTeams = "MicrosoftTeams"
        case mobileChat = "MobileChat"
        case other = "Other"
        case qq = "QQ"
        case reddit = "Reddit"
        case serviceNow = "ServiceNow"
        case sfdc = "SFDC"
        case sms = "SMS"
        case snapchat = "Snapchat"
        case telegram = "Telegram"
        case threads = "Threads"
        case trustpilot = "Trustpilot"
        case unspecified = "Unspecified"
        case viber = "Viber"
        case webChat = "WebChat"
        case weChat = "WeChat"
        case weibo = "Weibo"
        case whatsApp = "WhatsApp"
        case x = "X"
        case yelp = "Yelp"
        case youTube = "YouTube"
        case zendesk = "Zendesk"
    }

    /** The connection state of this communication. */
    public var state: State?
    /** The initial connection state of this communication. */
    public var initialState: InitialState?
    /** A globally unique identifier for this communication. */
    public var _id: String?
    /** True if this call is held and the person on this side hears silence. */
    public var held: Bool?
    /** The time line of the participant's message, divided into activity segments. */
    public var segments: [Segment]?
    /** The direction of the message. */
    public var direction: Direction?
    /** A globally unique identifier for the recording associated with this message. */
    public var recordingId: String?
    public var errorInfo: ErrorBody?
    /** System defined string indicating what caused the communication to disconnect. Will be null until the communication disconnects. */
    public var disconnectType: DisconnectType?
    /** The timestamp the message was placed on hold in the cloud clock if the message is currently on hold. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var startHoldTime: Date?
    /** The timestamp the communication has when it is first put into an alerting state. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var startAlertingTime: Date?
    /** The timestamp when this communication was connected in the cloud clock. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var connectedTime: Date?
    /** The timestamp when this communication disconnected from the conversation in the provider clock. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var disconnectedTime: Date?
    /** The source provider for the message. */
    public var provider: String?
    /** If true, the participant member is authenticated. */
    public var authenticated: Bool?
    /** Indicates the type of message platform from which the message originated. */
    public var type: ModelType?
    /** Indicates the country where the recipient is associated in ISO 3166-1 alpha-2 format. */
    public var recipientCountry: String?
    /** The type of the recipient. Eg: Provisioned phoneNumber is the recipient for sms message type. */
    public var recipientType: String?
    /** The UUID of the script to use. */
    public var scriptId: String?
    /** The id of the peer communication corresponding to a matching leg for this communication. */
    public var peerId: String?
    /** Address and name data for a call endpoint. */
    public var toAddress: Address?
    /** Address and name data for a call endpoint. */
    public var fromAddress: Address?
    /** The messages sent on this communication channel. */
    public var messages: [MessageDetails]?
    /** A subset of the Journey System's data relevant to a part of a conversation (for external linkage and internal usage/context). */
    public var journeyContext: JourneyContext?
    /** Call wrap up or disposition data. */
    public var wrapup: Wrapup?
    /** After-call work for the communication. */
    public var afterCallWork: AfterCallWork?
    /** Indicates if after-call work is required for a communication. Only used when the ACW Setting is Agent Requested. */
    public var afterCallWorkRequired: Bool?
    /** UUID of virtual agent assistant that provide suggestions to the agent participant during the conversation. */
    public var agentAssistantId: String?
    /** The internal id representing the customer supplied sms integration message. */
    public var byoSmsIntegrationId: String?
    /** Represents the queue settings for this media type. */
    public var queueMediaSettings: ConversationQueueMediaSettings?
    public var engagementSource: EngagementSource?

    public init(state: State?, initialState: InitialState?, _id: String?, held: Bool?, segments: [Segment]?, direction: Direction?, recordingId: String?, errorInfo: ErrorBody?, disconnectType: DisconnectType?, startHoldTime: Date?, startAlertingTime: Date?, connectedTime: Date?, disconnectedTime: Date?, provider: String?, authenticated: Bool?, type: ModelType?, recipientCountry: String?, recipientType: String?, scriptId: String?, peerId: String?, toAddress: Address?, fromAddress: Address?, messages: [MessageDetails]?, journeyContext: JourneyContext?, wrapup: Wrapup?, afterCallWork: AfterCallWork?, afterCallWorkRequired: Bool?, agentAssistantId: String?, byoSmsIntegrationId: String?, queueMediaSettings: ConversationQueueMediaSettings?, engagementSource: EngagementSource?) {
        self.state = state
        self.initialState = initialState
        self._id = _id
        self.held = held
        self.segments = segments
        self.direction = direction
        self.recordingId = recordingId
        self.errorInfo = errorInfo
        self.disconnectType = disconnectType
        self.startHoldTime = startHoldTime
        self.startAlertingTime = startAlertingTime
        self.connectedTime = connectedTime
        self.disconnectedTime = disconnectedTime
        self.provider = provider
        self.authenticated = authenticated
        self.type = type
        self.recipientCountry = recipientCountry
        self.recipientType = recipientType
        self.scriptId = scriptId
        self.peerId = peerId
        self.toAddress = toAddress
        self.fromAddress = fromAddress
        self.messages = messages
        self.journeyContext = journeyContext
        self.wrapup = wrapup
        self.afterCallWork = afterCallWork
        self.afterCallWorkRequired = afterCallWorkRequired
        self.agentAssistantId = agentAssistantId
        self.byoSmsIntegrationId = byoSmsIntegrationId
        self.queueMediaSettings = queueMediaSettings
        self.engagementSource = engagementSource
    }

    public enum CodingKeys: String, CodingKey { 
        case state
        case initialState
        case _id = "id"
        case held
        case segments
        case direction
        case recordingId
        case errorInfo
        case disconnectType
        case startHoldTime
        case startAlertingTime
        case connectedTime
        case disconnectedTime
        case provider
        case authenticated
        case type
        case recipientCountry
        case recipientType
        case scriptId
        case peerId
        case toAddress
        case fromAddress
        case messages
        case journeyContext
        case wrapup
        case afterCallWork
        case afterCallWorkRequired
        case agentAssistantId
        case byoSmsIntegrationId
        case queueMediaSettings
        case engagementSource
    }


}




public class MessageConversation: Codable {



















    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** The list of participants involved in the conversation. */
    public var participants: [MessageMediaParticipant]?
    /** The list of other media channels involved in the conversation. */
    public var otherMediaUris: [String]?
    /** The list of the most recent 20 transfer commands applied to this conversation. */
    public var recentTransfers: [TransferResponse]?
    /** An optional label that categorizes the conversation.  Max-utilization settings can be configured at a per-label level */
    public var utilizationLabelId: String?
    /** The time in the future, after which this conversation would be considered inactive. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var inactivityTimeout: Date?
    /** Identifiers of divisions associated with this conversation. */
    public var divisions: [ConversationDivisionMembership]?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, participants: [MessageMediaParticipant]?, otherMediaUris: [String]?, recentTransfers: [TransferResponse]?, utilizationLabelId: String?, inactivityTimeout: Date?, divisions: [ConversationDivisionMembership]?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.participants = participants
        self.otherMediaUris = otherMediaUris
        self.recentTransfers = recentTransfers
        self.utilizationLabelId = utilizationLabelId
        self.inactivityTimeout = inactivityTimeout
        self.divisions = divisions
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case participants
        case otherMediaUris
        case recentTransfers
        case utilizationLabelId
        case inactivityTimeout
        case divisions
        case selfUri
    }


}




public class MessageDetails: Codable {





    public enum MessageStatus: String, Codable { 
        case queued = "queued"
        case sent = "sent"
        case failed = "failed"
        case received = "received"
        case deliverySuccess = "delivery-success"
        case deliveryFailed = "delivery-failed"
        case read = "read"
        case removed = "removed"
        case published = "published"
    }











    public enum SocialVisibility: String, Codable { 
        case _private = "private"
        case _public = "public"
    }



    /** UUID identifying the message media. */
    public var messageId: String?
    /** A URI for this message entity. */
    public var messageURI: String?
    /** Indicates the delivery status of the message. */
    public var messageStatus: MessageStatus?
    /** The message segment count, greater than 1 if the message content was split into multiple parts for this message type, e.g. SMS character limits. */
    public var messageSegmentCount: Int?
    /** The time when the message was sent or received. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var messageTime: Date?
    /** Deprecated: Use the API /api/v2/conversations/messages/{conversationId}/messages/{messageId} to get the associated media. */
    public var media: [MessageMedia]?
    /** Deprecated: This attribute is no longer used. Messages have not included associated stickers for a long time. */
    public var stickers: [MessageSticker]?
    /** Information that describes the content of the message, if any */
    public var messageMetadata: ConversationMessageMetadata?
    /** For social media messages, the visibility of the message in the originating social platform */
    public var socialVisibility: SocialVisibility?
    /** Provider specific error information for a communication. */
    public var errorInfo: ErrorBody?

    public init(messageId: String?, messageURI: String?, messageStatus: MessageStatus?, messageSegmentCount: Int?, messageTime: Date?, media: [MessageMedia]?, stickers: [MessageSticker]?, messageMetadata: ConversationMessageMetadata?, socialVisibility: SocialVisibility?, errorInfo: ErrorBody?) {
        self.messageId = messageId
        self.messageURI = messageURI
        self.messageStatus = messageStatus
        self.messageSegmentCount = messageSegmentCount
        self.messageTime = messageTime
        self.media = media
        self.stickers = stickers
        self.messageMetadata = messageMetadata
        self.socialVisibility = socialVisibility
        self.errorInfo = errorInfo
    }


}




public class MessageHeader: Codable {

    public enum ModelType: String, Codable { 
        case text = "Text"
        case image = "Image"
    }



    /** Defines the content type of the Header in message */
    public var type: ModelType?
    /** Content associated with the header in the message */
    public var content: String?

    public init(type: ModelType?, content: String?) {
        self.type = type
        self.content = content
    }


}




public class MessageMedia: Codable {











    /** The location of the media, useful for retrieving it */
    public var url: String?
    /** The optional internet media type of the the media object.  If null then the media type should be dictated by the url */
    public var mediaType: String?
    /** The optional content length of the the media object, in bytes. */
    public var contentLengthBytes: Int?
    /** The optional name of the the media object. */
    public var name: String?
    /** The optional id of the the media object. */
    public var _id: String?

    public init(url: String?, mediaType: String?, contentLengthBytes: Int?, name: String?, _id: String?) {
        self.url = url
        self.mediaType = mediaType
        self.contentLengthBytes = contentLengthBytes
        self.name = name
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case url
        case mediaType
        case contentLengthBytes
        case name
        case _id = "id"
    }


}




public class MessageSticker: Codable {





    /** The location of the sticker, useful for retrieving it */
    public var url: String?
    /** The unique id of the the sticker object. */
    public var _id: String?

    public init(url: String?, _id: String?) {
        self.url = url
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case url
        case _id = "id"
    }


}




public class MessagingCampaignDivisionView: Codable {









    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** The division to which this entity belongs. */
    public var division: Division?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, division: Division?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.division = division
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case division
        case selfUri
    }


}




public class MessagingCampaignSchedule: Codable {





















    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** Creation time of the entity. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** Last modified time of the entity. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** Required for updates, must match the version number of the most recent update */
    public var version: Int?
    /** A list of intervals during which to run the associated Campaign. */
    public var intervals: [ScheduleInterval]?
    /** Recurring schedules of the campaign */
    public var recurrences: [Reoccurrence]?
    /** The time zone for this messaging campaign schedule. Defaults to UTC if empty or not provided. See here for a list of valid time zones https://www.iana.org/time-zones */
    public var timeZone: String?
    /** The Campaign that this messaging campaign schedule is for. */
    public var messagingCampaign: DivisionedDomainEntityRef?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, dateCreated: Date?, dateModified: Date?, version: Int?, intervals: [ScheduleInterval]?, recurrences: [Reoccurrence]?, timeZone: String?, messagingCampaign: DivisionedDomainEntityRef?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.version = version
        self.intervals = intervals
        self.recurrences = recurrences
        self.timeZone = timeZone
        self.messagingCampaign = messagingCampaign
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case dateCreated
        case dateModified
        case version
        case intervals
        case recurrences
        case timeZone
        case messagingCampaign
        case selfUri
    }


}




public class MessagingConfigListing: Codable {





















    public var entities: [MessagingSetting]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var previousUri: String?
    public var nextUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [MessagingSetting]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, previousUri: String?, nextUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.previousUri = previousUri
        self.nextUri = nextUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class MessagingIntegrationEntityListing: Codable {





















    public var entities: [MessagingIntegration]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var previousUri: String?
    public var nextUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [MessagingIntegration]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, previousUri: String?, nextUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.previousUri = previousUri
        self.nextUri = nextUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class MessagingSettingDefaultRequest: Codable {



    /** Messaging Setting ID to be used as the default for this Organization. */
    public var settingId: String?

    public init(settingId: String?) {
        self.settingId = settingId
    }


}



/** The messaging template identifies a structured message templates supported by a messaging channel. */

public class MessagingTemplate: Codable {



    /** Defines a messaging template for a WhatsApp messaging channel */
    public var whatsApp: WhatsAppDefinition?

    public init(whatsApp: WhatsAppDefinition?) {
        self.whatsApp = whatsApp
    }


}




public class MetaData: Codable {







    public var pairingToken: String?
    public var pairingTrust: [String]?
    public var pairingUrl: String?

    public init(pairingToken: String?, pairingTrust: [String]?, pairingUrl: String?) {
        self.pairingToken = pairingToken
        self.pairingTrust = pairingTrust
        self.pairingUrl = pairingUrl
    }

    public enum CodingKeys: String, CodingKey { 
        case pairingToken = "pairing-token"
        case pairingTrust = "pairing-trust"
        case pairingUrl = "pairing-url"
    }


}




public class MetadataAttribute: Codable {



    /** The value of the metadata attribute. */
    public var value: String?

    public init(value: String?) {
        self.value = value
    }


}



/** A description of the contents of a data gathering interface for an accelerator */

public class MetadataSchema: Codable {











    /** title for the data gathering page */
    public var title: String?
    /** description of the data being gathered on this page */
    public var _description: String?
    /** type of data being gathered */
    public var type: String?
    /** list of properties for which input is to be gathered, bother required and optional */
    public var properties: [[String:JSON]]?
    /** list of required properties */
    public var _required: [String]?

    public init(title: String?, _description: String?, type: String?, properties: [[String:JSON]]?, _required: [String]?) {
        self.title = title
        self._description = _description
        self.type = type
        self.properties = properties
        self._required = _required
    }

    public enum CodingKeys: String, CodingKey { 
        case title
        case _description = "description"
        case type
        case properties
        case _required = "required"
    }


}




public class MetricValueTrendAverage: Codable {



















    /** The targeted start workday. Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd */
    public var dateStartWorkday: Date?
    /** The targeted end workday. Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd */
    public var dateEndWorkday: Date?
    /** The targeted reference workday. Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd */
    public var dateReferenceWorkday: Date?
    /** The targeted division for the metrics */
    public var division: Division?
    /** The targeted user for the metrics */
    public var user: UserReference?
    /** The time zone used for aggregating metric values */
    public var timezone: String?
    /** The metric value trend and average */
    public var result: WorkdayValuesMetricItem?
    /** The targeted performance profile for the average points */
    public var performanceProfile: AddressableEntityRef?
    /** The targeted performance profile for the average points */
    public var metric: AddressableEntityRef?

    public init(dateStartWorkday: Date?, dateEndWorkday: Date?, dateReferenceWorkday: Date?, division: Division?, user: UserReference?, timezone: String?, result: WorkdayValuesMetricItem?, performanceProfile: AddressableEntityRef?, metric: AddressableEntityRef?) {
        self.dateStartWorkday = dateStartWorkday
        self.dateEndWorkday = dateEndWorkday
        self.dateReferenceWorkday = dateReferenceWorkday
        self.division = division
        self.user = user
        self.timezone = timezone
        self.result = result
        self.performanceProfile = performanceProfile
        self.metric = metric
    }


}




public class MinedIntentsListing: Codable {









    public var entities: [MinerIntent]?
    public var nextUri: String?
    public var selfUri: String?
    public var previousUri: String?

    public init(entities: [MinerIntent]?, nextUri: String?, selfUri: String?, previousUri: String?) {
        self.entities = entities
        self.nextUri = nextUri
        self.selfUri = selfUri
        self.previousUri = previousUri
    }


}




public class MinerTopicPhrase: Codable {













    /** The globally unique identifier for the object. */
    public var _id: String?
    /** Phrase name. */
    public var name: String?
    /** Topic associated with a phrase. */
    public var topic: MinerTopic?
    /** List of utterances related to a phrase. */
    public var utterances: [Utterance]?
    /** Number of utterances belonging to a phrase */
    public var utteranceCount: Int?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, topic: MinerTopic?, utterances: [Utterance]?, utteranceCount: Int?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.topic = topic
        self.utterances = utterances
        self.utteranceCount = utteranceCount
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case topic
        case utterances
        case utteranceCount
        case selfUri
    }


}



/** Settings for a user's mobile notifications */

public class MobileNotificationSettings: Codable {

    public enum When: String, Codable { 
        case always = "Always"
        case onlyWhenInactive = "OnlyWhenInactive"
    }

    /** When the user should receive notifications */
    public var when: When?

    public init(when: When?) {
        self.when = when
    }


}



/** Settings for mobile devices */

public class MobileSettings: Codable {



    /** Settings for a user's mobile notifications */
    public var notifications: MobileNotificationSettings?

    public init(notifications: MobileNotificationSettings?) {
        self.notifications = notifications
    }


}



/** Contains information about a response. */

public class ModelResponse: Codable {















    public enum InteractionType: String, Codable { 
        case chat = "chat"
        case email = "email"
        case twitter = "twitter"
    }





    public enum ResponseType: String, Codable { 
        case messagingTemplate = "MessagingTemplate"
        case campaignSmsTemplate = "CampaignSmsTemplate"
        case campaignEmailTemplate = "CampaignEmailTemplate"
        case footer = "Footer"
        case form = "Form"
    }









    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** Version number required for updates. */
    public var version: Int?
    /** One or more libraries response is associated with. */
    public var libraries: [DomainEntityRef]?
    /** One or more texts associated with the response. */
    public var texts: [ResponseText]?
    /** User that created the response */
    public var createdBy: User?
    /** The date and time the response was created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** The interaction type for this response. */
    public var interactionType: InteractionType?
    /** Details about any text substitutions used in the texts for this response. */
    public var substitutions: [ResponseSubstitution]?
    /** Metadata about the text substitutions in json schema format. */
    public var substitutionsSchema: JsonSchemaDocument?
    /** The response type represented by the response. */
    public var responseType: ResponseType?
    /** An optional messaging template definition for responseType.MessagingTemplate. */
    public var messagingTemplate: MessagingTemplate?
    /** Assets used in the response */
    public var assets: [AddressableEntityRef]?
    /** Footer template definition for responseType.Footer. */
    public var footer: FooterTemplate?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, version: Int?, libraries: [DomainEntityRef]?, texts: [ResponseText]?, createdBy: User?, dateCreated: Date?, interactionType: InteractionType?, substitutions: [ResponseSubstitution]?, substitutionsSchema: JsonSchemaDocument?, responseType: ResponseType?, messagingTemplate: MessagingTemplate?, assets: [AddressableEntityRef]?, footer: FooterTemplate?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.version = version
        self.libraries = libraries
        self.texts = texts
        self.createdBy = createdBy
        self.dateCreated = dateCreated
        self.interactionType = interactionType
        self.substitutions = substitutions
        self.substitutionsSchema = substitutionsSchema
        self.responseType = responseType
        self.messagingTemplate = messagingTemplate
        self.assets = assets
        self.footer = footer
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case version
        case libraries
        case texts
        case createdBy
        case dateCreated
        case interactionType
        case substitutions
        case substitutionsSchema
        case responseType
        case messagingTemplate
        case assets
        case footer
        case selfUri
    }


}




public class MoveAgentResponse: Codable {



    public enum Result: String, Codable { 
        case alreadyMoved = "AlreadyMoved"
        case destinationBusinessUnitAgentLimitExceeded = "DestinationBusinessUnitAgentLimitExceeded"
        case destinationManagementUnitAgentLimitExceeded = "DestinationManagementUnitAgentLimitExceeded"
        case destinationManagementUnitDoesNotExist = "DestinationManagementUnitDoesNotExist"
        case moveSuccessful = "MoveSuccessful"
        case movingToDifferentManagementUnit = "MovingToDifferentManagementUnit"
        case nothingToDo = "NothingToDo"
        case sourceManagementUnitNotAuthorized = "SourceManagementUnitNotAuthorized"
    }

    /** The user associated with the move */
    public var user: UserReference?
    /** The result of the move */
    public var result: Result?

    public init(user: UserReference?, result: Result?) {
        self.user = user
        self.result = result
    }


}




public class MoveAgentsResponse: Codable {







    /** The user that made the request */
    public var requestingUser: UserReference?
    /** The management unit specified on the request */
    public var destinationManagementUnit: ManagementUnitReference?
    /** The list containing the agent and result of the move operation */
    public var results: [MoveAgentResponse]?

    public init(requestingUser: UserReference?, destinationManagementUnit: ManagementUnitReference?, results: [MoveAgentResponse]?) {
        self.requestingUser = requestingUser
        self.destinationManagementUnit = destinationManagementUnit
        self.results = results
    }


}




public class MoveManagementUnitRequest: Codable {



    /** The ID of the business unit to which to move the management unit */
    public var businessUnitId: String?

    public init(businessUnitId: String?) {
        self.businessUnitId = businessUnitId
    }


}




public class NamedEntityTypeBinding: Codable {





    /** The named entity type of the binding. It can be a built-in one such as builtin:number or a custom entity type such as BeverageType. */
    public var entityType: String?
    /** The name that this named entity type is bound to. */
    public var entityName: String?

    public init(entityType: String?, entityName: String?) {
        self.entityType = entityType
        self.entityName = entityName
    }


}




public class NamedEntityTypeItem: Codable {







    /** A value for an named entity type definition. */
    public var value: String?
    /** Synonyms for the given named entity value. */
    public var synonyms: [String]?
    /** Additional Language Synonyms for the given named entity value. */
    public var additionalLanguages: [String:AdditionalLanguagesSynonyms]?

    public init(value: String?, synonyms: [String]?, additionalLanguages: [String:AdditionalLanguagesSynonyms]?) {
        self.value = value
        self.synonyms = synonyms
        self.additionalLanguages = additionalLanguages
    }


}




public class NluInfo: Codable {











    public var domain: AddressableEntityRef?
    public var version: NluDomainVersion?
    public var intents: [Intent]?
    public var engineVersion: String?
    public var nluData: NluDomainVersion?

    public init(domain: AddressableEntityRef?, version: NluDomainVersion?, intents: [Intent]?, engineVersion: String?, nluData: NluDomainVersion?) {
        self.domain = domain
        self.version = version
        self.intents = intents
        self.engineVersion = engineVersion
        self.nluData = nluData
    }


}




public class NluQualityReportSummary: Codable {



    /** The list of metrics in the summary */
    public var metrics: [NluQualityReportSummaryMetric]?

    public init(metrics: [NluQualityReportSummaryMetric]?) {
        self.metrics = metrics
    }


}



/** Notification settings that handles messenger notifications */

public class NotificationsSettings: Codable {



    public enum NotificationContentType: String, Codable { 
        case includeMessagesContent = "IncludeMessagesContent"
        case excludeMessagesContent = "ExcludeMessagesContent"
    }

    /** The toggle to enable or disable notifications. When enabled, PushNotificationTitle and PushNotificationBody localization keys are required. */
    public var enabled: Bool?
    /** The notification content type settings for messenger */
    public var notificationContentType: NotificationContentType?

    public init(enabled: Bool?, notificationContentType: NotificationContentType?) {
        self.enabled = enabled
        self.notificationContentType = notificationContentType
    }


}



/** Model for a Nuance bot credentials */

public class NuanceBotCredentials: Codable {









    /** The application ID */
    public var appId: String?
    /** The credentials client ID */
    public var clientId: String?
    /** The credentials client secret */
    public var clientSecret: String?
    /** True if the credentials secret is set (but not returned due to security reasons) */
    public var clientSecretProvided: Bool?

    public init(appId: String?, clientId: String?, clientSecret: String?, clientSecretProvided: Bool?) {
        self.appId = appId
        self.clientId = clientId
        self.clientSecret = clientSecret
        self.clientSecretProvided = clientSecretProvided
    }


}



/** Model for a Nuance channel */

public class NuanceChannel: Codable {









    /** The channel ID */
    public var _id: String?
    /** The channel name */
    public var name: String?
    /** Supported Channel Modes */
    public var modes: [String]?
    /** The Channel Color */
    public var color: String?

    public init(_id: String?, name: String?, modes: [String]?, color: String?) {
        self._id = _id
        self.name = name
        self.modes = modes
        self.color = color
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case modes
        case color
    }


}




public class OAuthAppleAuthorizationResponse: Codable {





    /** The redirected url */
    public var redirectUrl: String?
    /** The error object */
    public var error: OAuthAppleAuthorizationResponseError?

    public init(redirectUrl: String?, error: OAuthAppleAuthorizationResponseError?) {
        self.redirectUrl = redirectUrl
        self.error = error
    }


}




public class OAuthAuthorization: Codable {



















    public enum State: String, Codable { 
        case unauthorized = "Unauthorized"
        case requested = "Requested"
        case authorized = "Authorized"
        case revoked = "Revoked"
    }



    public var client: OAuthClient?
    public var scope: [String]?
    public var roles: [String]?
    public var resourceOwner: DomainEntityRef?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    public var createdBy: DomainEntityRef?
    public var modifiedBy: DomainEntityRef?
    public var pending: Bool?
    public var state: State?
    /** The URI for this object */
    public var selfUri: String?

    public init(client: OAuthClient?, scope: [String]?, roles: [String]?, resourceOwner: DomainEntityRef?, dateCreated: Date?, dateModified: Date?, createdBy: DomainEntityRef?, modifiedBy: DomainEntityRef?, pending: Bool?, state: State?, selfUri: String?) {
        self.client = client
        self.scope = scope
        self.roles = roles
        self.resourceOwner = resourceOwner
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.createdBy = createdBy
        self.modifiedBy = modifiedBy
        self.pending = pending
        self.state = state
        self.selfUri = selfUri
    }


}




public class OAuthAuthorizationListing: Codable {







    public var total: Int64?
    public var entities: [OAuthAuthorization]?
    public var selfUri: String?

    public init(total: Int64?, entities: [OAuthAuthorization]?, selfUri: String?) {
        self.total = total
        self.entities = entities
        self.selfUri = selfUri
    }


}




public class OAuthLastTokenIssued: Codable {



    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateIssued: Date?

    public init(dateIssued: Date?) {
        self.dateIssued = dateIssued
    }


}




public class ObservationMetricData: Codable {











    public var metric: String?
    public var qualifier: String?
    public var stats: StatisticalSummary?
    /** Flag for a truncated list of observations. If truncated, the first half of the list of observations will contain the oldest observations and the second half the newest observations. */
    public var truncated: Bool?
    /** List of observations sorted by timestamp in ascending order. This list may be truncated. */
    public var observations: [ObservationValue]?

    public init(metric: String?, qualifier: String?, stats: StatisticalSummary?, truncated: Bool?, observations: [ObservationValue]?) {
        self.metric = metric
        self.qualifier = qualifier
        self.stats = stats
        self.truncated = truncated
        self.observations = observations
    }


}




public class Okta: Codable {























    public enum NameIdentifierFormat: String, Codable { 
        case urnOasisNamesTcSaml11NameidFormatUnspecified = "urn:oasis:names:tc:SAML:1.1:nameid-format:unspecified"
        case urnOasisNamesTcSaml11NameidFormatEmailaddress = "urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress"
        case urnOasisNamesTcSaml11NameidFormatX509subjectname = "urn:oasis:names:tc:SAML:1.1:nameid-format:X509SubjectName"
        case urnOasisNamesTcSaml11NameidFormatWindowsdomainqualifiedname = "urn:oasis:names:tc:SAML:1.1:nameid-format:WindowsDomainQualifiedName"
        case urnOasisNamesTcSaml20NameidFormatKerberos = "urn:oasis:names:tc:SAML:2.0:nameid-format:kerberos"
        case urnOasisNamesTcSaml20NameidFormatEntity = "urn:oasis:names:tc:SAML:2.0:nameid-format:entity"
        case urnOasisNamesTcSaml20NameidFormatPersistent = "urn:oasis:names:tc:SAML:2.0:nameid-format:persistent"
        case urnOasisNamesTcSaml20NameidFormatTransient = "urn:oasis:names:tc:SAML:2.0:nameid-format:transient"
    }

    public enum SsoBinding: String, Codable { 
        case urnOasisNamesTcSaml20BindingsHttpPost = "urn:oasis:names:tc:SAML:2.0:bindings:HTTP-POST"
        case urnOasisNamesTcSaml20BindingsHttpRedirect = "urn:oasis:names:tc:SAML:2.0:bindings:HTTP-Redirect"
    }











    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    public var disabled: Bool?
    public var issuerURI: String?
    public var ssoTargetURI: String?
    public var sloURI: String?
    public var sloBinding: String?
    public var relyingPartyIdentifier: String?
    public var certificate: String?
    public var certificates: [String]?
    public var logoImageData: String?
    public var nameIdentifierFormat: NameIdentifierFormat?
    public var ssoBinding: SsoBinding?
    public var signAuthnRequests: Bool?
    public var providerName: String?
    public var displayOnLogin: Bool?
    public var metadataURL: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, disabled: Bool?, issuerURI: String?, ssoTargetURI: String?, sloURI: String?, sloBinding: String?, relyingPartyIdentifier: String?, certificate: String?, certificates: [String]?, logoImageData: String?, nameIdentifierFormat: NameIdentifierFormat?, ssoBinding: SsoBinding?, signAuthnRequests: Bool?, providerName: String?, displayOnLogin: Bool?, metadataURL: String?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.disabled = disabled
        self.issuerURI = issuerURI
        self.ssoTargetURI = ssoTargetURI
        self.sloURI = sloURI
        self.sloBinding = sloBinding
        self.relyingPartyIdentifier = relyingPartyIdentifier
        self.certificate = certificate
        self.certificates = certificates
        self.logoImageData = logoImageData
        self.nameIdentifierFormat = nameIdentifierFormat
        self.ssoBinding = ssoBinding
        self.signAuthnRequests = signAuthnRequests
        self.providerName = providerName
        self.displayOnLogin = displayOnLogin
        self.metadataURL = metadataURL
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case disabled
        case issuerURI
        case ssoTargetURI
        case sloURI
        case sloBinding
        case relyingPartyIdentifier
        case certificate
        case certificates
        case logoImageData
        case nameIdentifierFormat
        case ssoBinding
        case signAuthnRequests
        case providerName
        case displayOnLogin
        case metadataURL
        case selfUri
    }


}




public class OneOnOne: Codable {



    /** Room's pinned messages */
    public var pinnedMessages: [AddressableEntityRef]?

    public init(pinnedMessages: [AddressableEntityRef]?) {
        self.pinnedMessages = pinnedMessages
    }


}




public class OpenDataIngestionRuleResponse: Codable {







    public enum Status: String, Codable { 
        case active = "Active"
        case deleted = "Deleted"
        case error = "Error"
        case paused = "Paused"
        case pending = "Pending"
        case systemPaused = "SystemPaused"
    }















    /** ID of the open data ingestion rule. */
    public var _id: String?
    /** The name of the data ingestion rule. */
    public var name: String?
    /** A description of the data ingestion rule. */
    public var _description: String?
    /** The status of the data ingestion rule. */
    public var status: Status?
    /** The version number of the data ingestion rule. */
    public var version: Int?
    /** Timestamp indicating when the data ingestion rule was created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** Timestamp indicating when the data ingestion rule was last updated. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** The platform of the data ingestion rule. */
    public var platform: String?
    /** The countries is available only on twitter data ingestion rule. ISO 3166-1 alpha-2 country codes where Data Ingestion Rules should apply. Defaults to worldwide. */
    public var countries: [String]?
    /** The external source associated with this open data ingestion rule, which is used when performing identity resolution */
    public var externalSource: DomainEntityRef?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, _description: String?, status: Status?, version: Int?, dateCreated: Date?, dateModified: Date?, platform: String?, countries: [String]?, externalSource: DomainEntityRef?, selfUri: String?) {
        self._id = _id
        self.name = name
        self._description = _description
        self.status = status
        self.version = version
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.platform = platform
        self.countries = countries
        self.externalSource = externalSource
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case _description = "description"
        case status
        case version
        case dateCreated
        case dateModified
        case platform
        case countries
        case externalSource
        case selfUri
    }


}



/** Open Channel-specific information that describes the message and the message channel/provider. */

public class OpenInboundMessagingChannel: Codable {





    /** Information about the recipient the message is received from. */
    public var from: OpenMessagingFromRecipient?
    /** Original time of the event. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var time: Date?

    public init(from: OpenMessagingFromRecipient?, time: Date?) {
        self.from = from
        self.time = time
    }


}




public class OpenInboundStructuredResponseMessage: Codable {







    /** Channel-specific information that describes the message and the message channel/provider. */
    public var channel: OpenInboundMessageMessagingChannel?
    /** Button response element. */
    public var buttonResponse: ContentButtonResponse?
    /** Id of original structured message that this messages responds to. */
    public var originatingMessageId: String?

    public init(channel: OpenInboundMessageMessagingChannel?, buttonResponse: ContentButtonResponse?, originatingMessageId: String?) {
        self.channel = channel
        self.buttonResponse = buttonResponse
        self.originatingMessageId = originatingMessageId
    }


}




public class OpenIntegrationUpdateRequest: Codable {

















    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The name of the Open messaging integration. */
    public var name: String?
    /** Defines the SupportedContent profile configured for an integration */
    public var supportedContent: SupportedContentReference?
    /** Defines the message settings to be applied for this integration */
    public var messagingSetting: MessagingSettingRequestReference?
    /** The outbound notification webhook URL for the Open messaging integration. */
    public var outboundNotificationWebhookUrl: String?
    /** The outbound notification webhook signature secret token. */
    public var outboundNotificationWebhookSignatureSecretToken: String?
    /** The user specified headers for the Open messaging integration. */
    public var webhookHeaders: [String:String]?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, supportedContent: SupportedContentReference?, messagingSetting: MessagingSettingRequestReference?, outboundNotificationWebhookUrl: String?, outboundNotificationWebhookSignatureSecretToken: String?, webhookHeaders: [String:String]?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.supportedContent = supportedContent
        self.messagingSetting = messagingSetting
        self.outboundNotificationWebhookUrl = outboundNotificationWebhookUrl
        self.outboundNotificationWebhookSignatureSecretToken = outboundNotificationWebhookSignatureSecretToken
        self.webhookHeaders = webhookHeaders
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case supportedContent
        case messagingSetting
        case outboundNotificationWebhookUrl
        case outboundNotificationWebhookSignatureSecretToken
        case webhookHeaders
        case selfUri
    }


}




public class OpenMessagingIdentityResolutionConfig: Codable {











    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The division to use when performing identity resolution. */
    public var division: WritableStarrableDivision?
    /** Whether the channel should resolve identities */
    public var resolveIdentities: Bool?
    /** The external source used for stitching this channel. */
    public var externalSource: IdentityResolutionExternalSource?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, division: WritableStarrableDivision?, resolveIdentities: Bool?, externalSource: IdentityResolutionExternalSource?, selfUri: String?) {
        self._id = _id
        self.division = division
        self.resolveIdentities = resolveIdentities
        self.externalSource = externalSource
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case division
        case resolveIdentities
        case externalSource
        case selfUri
    }


}



/** Information about the recipient the message is sent to. */

public class OpenMessagingToRecipient: Codable {





    public enum IdType: String, Codable { 
        case email = "Email"
        case phone = "Phone"
        case opaque = "Opaque"
    }









    /** Nickname or display name of the recipient. */
    public var nickname: String?
    /** The recipient ID specific to the provider. */
    public var _id: String?
    /** The recipient ID type. This is used to indicate the format used for the ID. */
    public var idType: IdType?
    /** First name of the recipient. */
    public var firstName: String?
    /** Last name of the recipient. */
    public var lastName: String?
    /** URL of an image that represents the recipient. */
    public var image: String?
    /** E-mail address of the recipient. */
    public var email: String?

    public init(nickname: String?, _id: String?, idType: IdType?, firstName: String?, lastName: String?, image: String?, email: String?) {
        self.nickname = nickname
        self._id = _id
        self.idType = idType
        self.firstName = firstName
        self.lastName = lastName
        self.image = image
        self.email = email
    }

    public enum CodingKeys: String, CodingKey { 
        case nickname
        case _id = "id"
        case idType
        case firstName
        case lastName
        case image
        case email
    }


}



/** Open Social Messaging rich media message structure */

public class OpenSocialMediaNormalizedMessage: Codable {







    public enum ModelType: String, Codable { 
        case text = "Text"
    }







    /** Unique ID of the message generated by Genesys Platform. */
    public var _id: String?
    /** Channel-specific information that describes the message and the message channel/provider. */
    public var channel: OpenSocialMediaChannel?
    /** Message text. */
    public var text: String?
    /** Message type. */
    public var type: ModelType?
    /** List of content elements. */
    public var content: [OpenSocialMediaMessageContent]?
    /** Additional metadata about this message. */
    public var metadata: [String:String]?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, channel: OpenSocialMediaChannel?, text: String?, type: ModelType?, content: [OpenSocialMediaMessageContent]?, metadata: [String:String]?, selfUri: String?) {
        self._id = _id
        self.channel = channel
        self.text = text
        self.type = type
        self.content = content
        self.metadata = metadata
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case channel
        case text
        case type
        case content
        case metadata
        case selfUri
    }


}




public class OperationalEvent: Codable {























    /** The event that occurred. */
    public var eventDefinition: AddressableEntityRef?
    /** The unique identifier for the entity */
    public var entityId: String?
    /** A token representing the entity */
    public var entityToken: String?
    /** The name for the entity */
    public var entityName: String?
    /** The value prior to the event */
    public var previousValue: String?
    /** The changed value following the event */
    public var currentValue: String?
    /** The error code of the entity in the providing service associated to the event */
    public var errorCode: String?
    /** The unique identifier for the parent of the entity */
    public var parentEntityId: String?
    /** The link to a conversation */
    public var conversation: AddressableEntityRef?
    /** The date when the event created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** The version of the entity in the providing service */
    public var entityVersion: String?

    public init(eventDefinition: AddressableEntityRef?, entityId: String?, entityToken: String?, entityName: String?, previousValue: String?, currentValue: String?, errorCode: String?, parentEntityId: String?, conversation: AddressableEntityRef?, dateCreated: Date?, entityVersion: String?) {
        self.eventDefinition = eventDefinition
        self.entityId = entityId
        self.entityToken = entityToken
        self.entityName = entityName
        self.previousValue = previousValue
        self.currentValue = currentValue
        self.errorCode = errorCode
        self.parentEntityId = parentEntityId
        self.conversation = conversation
        self.dateCreated = dateCreated
        self.entityVersion = entityVersion
    }


}




public class OperationalEventNotificationTopicOperationalEventNotification: Codable {

























    public var eventEntity: OperationalEventNotificationTopicEventEntity?
    public var entityId: UUID?
    public var entityName: String?
    public var previousValue: String?
    public var currentValue: String?
    public var errorCode: String?
    public var version: String?
    public var parentEntity: UUID?
    public var entityType: String?
    public var conversationId: UUID?
    public var entityToken: String?
    public var timestamp: Int64?

    public init(eventEntity: OperationalEventNotificationTopicEventEntity?, entityId: UUID?, entityName: String?, previousValue: String?, currentValue: String?, errorCode: String?, version: String?, parentEntity: UUID?, entityType: String?, conversationId: UUID?, entityToken: String?, timestamp: Int64?) {
        self.eventEntity = eventEntity
        self.entityId = entityId
        self.entityName = entityName
        self.previousValue = previousValue
        self.currentValue = currentValue
        self.errorCode = errorCode
        self.version = version
        self.parentEntity = parentEntity
        self.entityType = entityType
        self.conversationId = conversationId
        self.entityToken = entityToken
        self.timestamp = timestamp
    }


}




public class OptInSettings: Codable {





    /** List of keywords for compliance */
    public var keyword: [String]?
    /** The response configuration for the keywords */
    public var response: ComplianceResponse?

    public init(keyword: [String]?, response: ComplianceResponse?) {
        self.keyword = keyword
        self.response = response
    }


}




public class OrgOAuthClient: Codable {













    public enum AuthorizedGrantType: String, Codable { 
        case code = "CODE"
        case token = "TOKEN"
        case saml2Bearer = "SAML2-BEARER"
        case password = "PASSWORD"
        case clientCredentials = "CLIENT-CREDENTIALS"
    }





    public enum State: String, Codable { 
        case active = "active"
        case disabled = "disabled"
        case inactive = "inactive"
    }





    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The name of the OAuth client. */
    public var name: String?
    /** Date this client was created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** Date this client was last modified. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** User that created this client */
    public var createdBy: DomainEntityRef?
    /** User that last modified this client */
    public var modifiedBy: DomainEntityRef?
    /** The OAuth Grant/Client type supported by this client. Code Authorization Grant/Client type - Preferred client type where the Client ID and Secret are required to create tokens. Used where the secret can be secured. PKCE-Enabled Code Authorization grant type - Code grant type which requires PKCE challenge and verifier to create tokens. Used in public clients for increased security. Implicit grant type - Client ID only is required to create tokens. Used in browser and mobile apps where the secret can not be secured. SAML2-Bearer extension grant type - SAML2 assertion provider for user authentication at the token endpoint. Client Credential grant type - Used to created access tokens that are tied only to the client.  */
    public var authorizedGrantType: AuthorizedGrantType?
    /** The scope requested by this client. Scopes only apply to clients not using the client_credential grant */
    public var scope: [String]?
    /** Set of roles and their corresponding divisions associated with this client. Roles and divisions only apply to clients using the client_credential grant */
    public var roleDivisions: [RoleDivision]?
    /** The state of the OAuth client. Active: The OAuth client can be used to create access tokens. This is the default state. Disabled: Access tokens created by the client are invalid and new ones cannot be created. Inactive: Access tokens cannot be created with this OAuth client and it will be deleted. */
    public var state: State?
    /** The time at which this client will be deleted. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateToDelete: Date?
    /** The  oauth client's organization. */
    public var organization: NamedEntity?

    public init(_id: String?, name: String?, dateCreated: Date?, dateModified: Date?, createdBy: DomainEntityRef?, modifiedBy: DomainEntityRef?, authorizedGrantType: AuthorizedGrantType?, scope: [String]?, roleDivisions: [RoleDivision]?, state: State?, dateToDelete: Date?, organization: NamedEntity?) {
        self._id = _id
        self.name = name
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.createdBy = createdBy
        self.modifiedBy = modifiedBy
        self.authorizedGrantType = authorizedGrantType
        self.scope = scope
        self.roleDivisions = roleDivisions
        self.state = state
        self.dateToDelete = dateToDelete
        self.organization = organization
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case dateCreated
        case dateModified
        case createdBy
        case modifiedBy
        case authorizedGrantType
        case scope
        case roleDivisions
        case state
        case dateToDelete
        case organization
    }


}




public class Organization: Codable {

















    public enum State: String, Codable { 
        case active = "active"
        case inactive = "inactive"
        case deleted = "deleted"
    }







    public enum ProductPlatform: String, Codable { 
        case genesysCloud = "GenesysCloud"
        case pureCloud = "PureCloud"
        case pureEngage = "PureEngage"
        case pureEngageCloud = "PureEngageCloud"
        case pureConnect = "PureConnect"
        case pureConnectCloud = "PureConnectCloud"
        case unknown = "Unknown"
    }





    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** The default language for this organization. Example: 'en' */
    public var defaultLanguage: String?
    /** The default country code for this organization. Example: 'US' */
    public var defaultCountryCode: String?
    /** The short name for the organization. This field is globally unique and cannot be changed. */
    public var thirdPartyOrgName: String?
    public var thirdPartyURI: String?
    public var domain: String?
    /** The current version of the organization. */
    public var version: Int?
    /** The current state. Examples are active, inactive, deleted. */
    public var state: State?
    public var defaultSiteId: String?
    /** Email address where support tickets are sent to. */
    public var supportURI: String?
    public var voicemailEnabled: Bool?
    /** Organizations Originating Platform. */
    public var productPlatform: ProductPlatform?
    /** The URI for this object */
    public var selfUri: String?
    /** The state of features available for the organization. */
    public var features: [String:Bool]?

    public init(_id: String?, name: String?, defaultLanguage: String?, defaultCountryCode: String?, thirdPartyOrgName: String?, thirdPartyURI: String?, domain: String?, version: Int?, state: State?, defaultSiteId: String?, supportURI: String?, voicemailEnabled: Bool?, productPlatform: ProductPlatform?, selfUri: String?, features: [String:Bool]?) {
        self._id = _id
        self.name = name
        self.defaultLanguage = defaultLanguage
        self.defaultCountryCode = defaultCountryCode
        self.thirdPartyOrgName = thirdPartyOrgName
        self.thirdPartyURI = thirdPartyURI
        self.domain = domain
        self.version = version
        self.state = state
        self.defaultSiteId = defaultSiteId
        self.supportURI = supportURI
        self.voicemailEnabled = voicemailEnabled
        self.productPlatform = productPlatform
        self.selfUri = selfUri
        self.features = features
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case defaultLanguage
        case defaultCountryCode
        case thirdPartyOrgName
        case thirdPartyURI
        case domain
        case version
        case state
        case defaultSiteId
        case supportURI
        case voicemailEnabled
        case productPlatform
        case selfUri
        case features
    }


}




public class OrganizationPublicApiUsage: Codable {





    public enum HttpMethod: String, Codable { 
        case _get = "GET"
        case post = "POST"
        case put = "PUT"
        case patch = "PATCH"
        case delete = "DELETE"
        case head = "HEAD"
    }



















    /** The date of the usage. Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd */
    public var date: Date?
    /** The platform the request(s) is/were made on. */
    public var platform: String?
    /** The http method of the request(s) */
    public var httpMethod: HttpMethod?
    /** The templateUri of the request(s). */
    public var templateUri: String?
    /** The total number of requests. */
    public var requestCount: Int64?
    /** The number of requests resulting in a 2xx HTTP status code. */
    public var status200: Int64?
    /** The number of requests resulting in a 3xx HTTP status code. */
    public var status300: Int64?
    /** The number of requests resulting in a 4xx HTTP status code. */
    public var status400: Int64?
    /** The number of requests resulting in a 429 HTTP status code. */
    public var status429: Int64?
    /** The number of requests resulting in a 5xx HTTP status code. */
    public var status500: Int64?
    /** The id of the oauthClient that made the request(s). */
    public var oauthClient: DomainEntityRef?
    /** The id of the user who made the request(s). */
    public var user: UserReference?

    public init(date: Date?, platform: String?, httpMethod: HttpMethod?, templateUri: String?, requestCount: Int64?, status200: Int64?, status300: Int64?, status400: Int64?, status429: Int64?, status500: Int64?, oauthClient: DomainEntityRef?, user: UserReference?) {
        self.date = date
        self.platform = platform
        self.httpMethod = httpMethod
        self.templateUri = templateUri
        self.requestCount = requestCount
        self.status200 = status200
        self.status300 = status300
        self.status400 = status400
        self.status429 = status429
        self.status500 = status500
        self.oauthClient = oauthClient
        self.user = user
    }


}




public class OtherProfileAssignment: Codable {







    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The current performance profile that this user belongs to */
    public var currentProfile: DomainEntityRef?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, currentProfile: DomainEntityRef?, selfUri: String?) {
        self._id = _id
        self.currentProfile = currentProfile
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case currentProfile
        case selfUri
    }


}




public class OutboundDetailEventTopicOutboundInitEvent: Codable {









    public enum MediaType: String, Codable { 
        case unknown = "UNKNOWN"
        case voice = "VOICE"
        case chat = "CHAT"
        case email = "EMAIL"
        case callback = "CALLBACK"
        case cobrowse = "COBROWSE"
        case video = "VIDEO"
        case screenshare = "SCREENSHARE"
        case message = "MESSAGE"
        case internalmessage = "INTERNALMESSAGE"
    }



    public enum Direction: String, Codable { 
        case unknown = "UNKNOWN"
        case inbound = "INBOUND"
        case outbound = "OUTBOUND"
    }











    public enum MessageType: String, Codable { 
        case unknown = "UNKNOWN"
        case sms = "SMS"
        case twitter = "TWITTER"
        case facebook = "FACEBOOK"
        case line = "LINE"
        case whatsapp = "WHATSAPP"
        case webmessaging = "WEBMESSAGING"
        case _open = "OPEN"
        case instagram = "INSTAGRAM"
        case apple = "APPLE"
    }













    public var eventTime: Int64?
    public var conversationId: String?
    public var participantId: String?
    public var sessionId: String?
    public var mediaType: MediaType?
    public var provider: String?
    public var direction: Direction?
    public var ani: String?
    public var dnis: String?
    public var addressTo: String?
    public var addressFrom: String?
    public var subject: String?
    public var messageType: MessageType?
    public var outboundCampaignId: String?
    public var divisionId: String?
    public var outboundContactListId: String?
    public var outboundContactId: String?
    public var conversationExternalContactIds: [String]?
    public var conversationExternalOrganizationIds: [String]?

    public init(eventTime: Int64?, conversationId: String?, participantId: String?, sessionId: String?, mediaType: MediaType?, provider: String?, direction: Direction?, ani: String?, dnis: String?, addressTo: String?, addressFrom: String?, subject: String?, messageType: MessageType?, outboundCampaignId: String?, divisionId: String?, outboundContactListId: String?, outboundContactId: String?, conversationExternalContactIds: [String]?, conversationExternalOrganizationIds: [String]?) {
        self.eventTime = eventTime
        self.conversationId = conversationId
        self.participantId = participantId
        self.sessionId = sessionId
        self.mediaType = mediaType
        self.provider = provider
        self.direction = direction
        self.ani = ani
        self.dnis = dnis
        self.addressTo = addressTo
        self.addressFrom = addressFrom
        self.subject = subject
        self.messageType = messageType
        self.outboundCampaignId = outboundCampaignId
        self.divisionId = divisionId
        self.outboundContactListId = outboundContactListId
        self.outboundContactId = outboundContactId
        self.conversationExternalContactIds = conversationExternalContactIds
        self.conversationExternalOrganizationIds = conversationExternalOrganizationIds
    }


}




public class OutboundDomainCreateRequest: Codable {



    public enum SenderType: String, Codable { 
        case unknown = "Unknown"
        case emailDomain = "EmailDomain"
        case mockEmailDomain = "MockEmailDomain"
        case emailSmtpDomain = "EmailSmtpDomain"
    }





    /** Unique Id of the domain such as: example.com */
    public var _id: String?
    /** Sender Type */
    public var senderType: SenderType?
    /** The email settings to associate with this domain. */
    public var emailSetting: EmailSettingReference?
    /** The domain such as: example.com */
    public var name: String?

    public init(_id: String?, senderType: SenderType?, emailSetting: EmailSettingReference?, name: String?) {
        self._id = _id
        self.senderType = senderType
        self.emailSetting = emailSetting
        self.name = name
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case senderType
        case emailSetting
        case name
    }


}




public class OutboundMessagingCampaignPostContactEmailEventTopicOutboundMessagingCampaignPostContactEmailEvent: Codable {





    public enum OutboundCampaignType: String, Codable { 
        case unknown = "UNKNOWN"
        case email = "EMAIL"
        case sms = "SMS"
        case whatsapp = "WHATSAPP"
    }



    public enum WrapupCode: String, Codable { 
        case unknown = "UNKNOWN"
        case outboundMessageSent = "OUTBOUND_MESSAGE_SENT"
        case outboundMessageFailed = "OUTBOUND_MESSAGE_FAILED"
        case outboundMessageThrottled = "OUTBOUND_MESSAGE_THROTTLED"
        case outboundMessageAmbiguous = "OUTBOUND_MESSAGE_AMBIGUOUS"
    }













    public var eventTime: Int64?
    public var conversationId: UUID?
    public var outboundCampaignType: OutboundCampaignType?
    public var emailAttributes: OutboundMessagingCampaignPostContactEmailEventTopicEmailAttributes?
    public var wrapupCode: WrapupCode?
    public var outboundCampaignId: UUID?
    public var divisionId: UUID?
    public var contentTemplateId: UUID?
    public var outboundContactListId: UUID?
    public var outboundContactId: String?
    public var isCampaignAlwaysRunning: Bool?

    public init(eventTime: Int64?, conversationId: UUID?, outboundCampaignType: OutboundCampaignType?, emailAttributes: OutboundMessagingCampaignPostContactEmailEventTopicEmailAttributes?, wrapupCode: WrapupCode?, outboundCampaignId: UUID?, divisionId: UUID?, contentTemplateId: UUID?, outboundContactListId: UUID?, outboundContactId: String?, isCampaignAlwaysRunning: Bool?) {
        self.eventTime = eventTime
        self.conversationId = conversationId
        self.outboundCampaignType = outboundCampaignType
        self.emailAttributes = emailAttributes
        self.wrapupCode = wrapupCode
        self.outboundCampaignId = outboundCampaignId
        self.divisionId = divisionId
        self.contentTemplateId = contentTemplateId
        self.outboundContactListId = outboundContactListId
        self.outboundContactId = outboundContactId
        self.isCampaignAlwaysRunning = isCampaignAlwaysRunning
    }


}




public class OutboundMessagingCampaignPreContactEmailEventTopicEmailAttributes: Codable {











    public var emailSubject: String?
    public var configuredEmailAddress: String?
    public var contactEmailAddress: String?
    public var replyToAddress: String?
    public var contactEmailColumnName: String?

    public init(emailSubject: String?, configuredEmailAddress: String?, contactEmailAddress: String?, replyToAddress: String?, contactEmailColumnName: String?) {
        self.emailSubject = emailSubject
        self.configuredEmailAddress = configuredEmailAddress
        self.contactEmailAddress = contactEmailAddress
        self.replyToAddress = replyToAddress
        self.contactEmailColumnName = contactEmailColumnName
    }


}




public class OutboundMessagingCampaignPreContactSmsEventTopicOutboundMessagingCampaignPreContactSMSEvent: Codable {



    public enum OutboundCampaignType: String, Codable { 
        case unknown = "UNKNOWN"
        case email = "EMAIL"
        case sms = "SMS"
        case whatsapp = "WHATSAPP"
    }



    public enum WrapupCode: String, Codable { 
        case unknown = "UNKNOWN"
        case ininOutboundNumbersInvalid = "ININ_OUTBOUND_NUMBERS_INVALID"
        case ininOutboundContactAttemptLimitSkipped = "ININ_OUTBOUND_CONTACT_ATTEMPT_LIMIT_SKIPPED"
        case ininOutboundInternalErrorSkipped = "ININ_OUTBOUND_INTERNAL_ERROR_SKIPPED"
        case ininOutboundDncSkipped = "ININ_OUTBOUND_DNC_SKIPPED"
        case ininOutboundZoneBlockedSkipped = "ININ_OUTBOUND_ZONE_BLOCKED_SKIPPED"
        case outboundMessageBlank = "OUTBOUND_MESSAGE_BLANK"
        case outboundRuleErrorSkipped = "OUTBOUND_RULE_ERROR_SKIPPED"
        case outboundRuleSkipped = "OUTBOUND_RULE_SKIPPED"
        case outboundContactUncontactableSkipped = "OUTBOUND_CONTACT_UNCONTACTABLE_SKIPPED"
        case outboundNumberUncontactableSkipped = "OUTBOUND_NUMBER_UNCONTACTABLE_SKIPPED"
        case outboundContactAddressUncontactableSkipped = "OUTBOUND_CONTACT_ADDRESS_UNCONTACTABLE_SKIPPED"
        case outboundInvalidPhoneNumber = "OUTBOUND_INVALID_PHONE_NUMBER"
        case ininOutboundDncAuthenticationFailed = "ININ_OUTBOUND_DNC_AUTHENTICATION_FAILED"
        case ininOutboundDncInvalidPhoneNumber = "ININ_OUTBOUND_DNC_INVALID_PHONE_NUMBER"
        case ininOutboundAutomaticTimezoneBlocked = "ININ_OUTBOUND_AUTOMATIC_TIMEZONE_BLOCKED"
        case ininOutboundNumberAttemptLimitSkipped = "ININ_OUTBOUND_NUMBER_ATTEMPT_LIMIT_SKIPPED"
        case ininOutboundOnDoNotCallList = "ININ_OUTBOUND_ON_DO_NOT_CALL_LIST"
        case ininOutboundNotCallableTime = "ININ_OUTBOUND_NOT_CALLABLE_TIME"
        case outboundMaxMessageLengthExceeded = "OUTBOUND_MAX_MESSAGE_LENGTH_EXCEEDED"
        case outboundStuckContact = "OUTBOUND_STUCK_CONTACT"
    }













    public var eventTime: Int64?
    public var outboundCampaignType: OutboundCampaignType?
    public var smsAttributes: OutboundMessagingCampaignPreContactSmsEventTopicSMSAttributes?
    public var wrapupCode: WrapupCode?
    public var outboundCampaignId: UUID?
    public var divisionId: UUID?
    public var contentTemplateId: UUID?
    public var outboundContactListId: UUID?
    public var outboundContactId: String?
    public var isCampaignAlwaysRunning: Bool?

    public init(eventTime: Int64?, outboundCampaignType: OutboundCampaignType?, smsAttributes: OutboundMessagingCampaignPreContactSmsEventTopicSMSAttributes?, wrapupCode: WrapupCode?, outboundCampaignId: UUID?, divisionId: UUID?, contentTemplateId: UUID?, outboundContactListId: UUID?, outboundContactId: String?, isCampaignAlwaysRunning: Bool?) {
        self.eventTime = eventTime
        self.outboundCampaignType = outboundCampaignType
        self.smsAttributes = smsAttributes
        self.wrapupCode = wrapupCode
        self.outboundCampaignId = outboundCampaignId
        self.divisionId = divisionId
        self.contentTemplateId = contentTemplateId
        self.outboundContactListId = outboundContactListId
        self.outboundContactId = outboundContactId
        self.isCampaignAlwaysRunning = isCampaignAlwaysRunning
    }


}




public class OutboundMessagingEmailCampaignConfigChangeErrorDetail: Codable {





    /** The name of the error code. */
    public var error: String?
    /** The additional information regarding the error message. */
    public var details: String?

    public init(error: String?, details: String?) {
        self.error = error
        self.details = details
    }


}



/** An outbound-messaging messaging campaign email address */

public class OutboundMessagingEmailCampaignConfigChangeFromEmailAddress: Codable {







    /** The friendly name of the email address. */
    public var friendlyName: String?
    /** The local part of the email address. */
    public var localPart: String?
    /** A UriReference for a resource */
    public var domain: OutboundMessagingEmailCampaignConfigChangeUriReference?

    public init(friendlyName: String?, localPart: String?, domain: OutboundMessagingEmailCampaignConfigChangeUriReference?) {
        self.friendlyName = friendlyName
        self.localPart = localPart
        self.domain = domain
    }


}



/** An outbound-messaging messaging campaign email address */

public class OutboundMessagingEmailCampaignConfigChangeReplyToEmailAddress: Codable {





    /** A UriReference for a resource */
    public var domain: OutboundMessagingEmailCampaignConfigChangeUriReference?
    /** A UriReference for a resource */
    public var route: OutboundMessagingEmailCampaignConfigChangeUriReference?

    public init(domain: OutboundMessagingEmailCampaignConfigChangeUriReference?, route: OutboundMessagingEmailCampaignConfigChangeUriReference?) {
        self.domain = domain
        self.route = route
    }


}



/** A reference for a Response */

public class OutboundMessagingEmailCampaignConfigChangeResponseRef: Codable {



    /** The unique response id */
    public var _id: String?

    public init(_id: String?) {
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
    }


}



/** A UriReference for a resource */

public class OutboundMessagingEmailCampaignProgressEventUriReference: Codable {





    /** The ID of the resource */
    public var _id: String?
    /** The name of the resource */
    public var name: String?

    public init(_id: String?, name: String?) {
        self._id = _id
        self.name = name
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
    }


}




public class OutboundMessagingWhatsappCampaignConfigChangeContactSort: Codable {



    public enum Direction: String, Codable { 
        case asc = "ASC"
        case desc = "DESC"
    }







    public var fieldName: String?
    public var direction: Direction?
    /** Whether that column contains numeric data */
    public var numeric: Bool?
    public var additionalProperties: [String:JSON]?
    public var getAdditionalProperties: [String:JSON]?

    public init(fieldName: String?, direction: Direction?, numeric: Bool?, additionalProperties: [String:JSON]?, getAdditionalProperties: [String:JSON]?) {
        self.fieldName = fieldName
        self.direction = direction
        self.numeric = numeric
        self.additionalProperties = additionalProperties
        self.getAdditionalProperties = getAdditionalProperties
    }


}



/** An outbound-messaging messaging campaign SMS Config */

public class OutboundMessagingWhatsappCampaignConfigChangeSmsConfig: Codable {









    /** The Contact List column specifying the message to send to the contact. */
    public var messageColumn: String?
    /** The Contact List column specifying the phone number to send a message to. */
    public var phoneColumn: String?
    public var senderSmsPhoneNumber: OutboundMessagingWhatsappCampaignConfigChangeSmsPhoneNumberRef?
    public var contentTemplate: OutboundMessagingWhatsappCampaignConfigChangeResponseRef?

    public init(messageColumn: String?, phoneColumn: String?, senderSmsPhoneNumber: OutboundMessagingWhatsappCampaignConfigChangeSmsPhoneNumberRef?, contentTemplate: OutboundMessagingWhatsappCampaignConfigChangeResponseRef?) {
        self.messageColumn = messageColumn
        self.phoneColumn = phoneColumn
        self.senderSmsPhoneNumber = senderSmsPhoneNumber
        self.contentTemplate = contentTemplate
    }


}



/** A reference for an SmsPhoneNumber */

public class OutboundMessagingWhatsappCampaignConfigChangeSmsPhoneNumberRef: Codable {



    /** The unique phone number */
    public var phoneNumber: String?

    public init(phoneNumber: String?) {
        self.phoneNumber = phoneNumber
    }


}



/** A UriReference for a resource */

public class OutboundMessagingWhatsappCampaignConfigChangeUriReference: Codable {





    /** The ID of the resource */
    public var _id: String?
    /** The name of the resource */
    public var name: String?

    public init(_id: String?, name: String?) {
        self._id = _id
        self.name = name
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
    }


}




public class OutboundMessagingWhatsappCampaignProgressEventCampaignProgress: Codable {

















    public var campaign: OutboundMessagingWhatsappCampaignProgressEventUriReference?
    /** The number of contacts that have been called so far */
    public var numberOfContactsCalled: Double?
    /** The number of contacts that have been messaged so far */
    public var numberOfContactsMessaged: Double?
    /** The total number of contacts in the contact list */
    public var totalNumberOfContacts: Double?
    /** numberOfContactsContacted/totalNumberOfContacts*100 */
    public var percentage: Int64?
    /** A map of skipped reasons and the number of contacts associated with each. */
    public var numberOfContactsSkipped: [String:Int64]?
    public var additionalProperties: [String:JSON]?
    public var getAdditionalProperties: [String:JSON]?

    public init(campaign: OutboundMessagingWhatsappCampaignProgressEventUriReference?, numberOfContactsCalled: Double?, numberOfContactsMessaged: Double?, totalNumberOfContacts: Double?, percentage: Int64?, numberOfContactsSkipped: [String:Int64]?, additionalProperties: [String:JSON]?, getAdditionalProperties: [String:JSON]?) {
        self.campaign = campaign
        self.numberOfContactsCalled = numberOfContactsCalled
        self.numberOfContactsMessaged = numberOfContactsMessaged
        self.totalNumberOfContacts = totalNumberOfContacts
        self.percentage = percentage
        self.numberOfContactsSkipped = numberOfContactsSkipped
        self.additionalProperties = additionalProperties
        self.getAdditionalProperties = getAdditionalProperties
    }


}




public class OutboundPreviewCampaignPostContactVoiceAttributes: Codable {



    public enum ContactPhoneType: String, Codable { 
        case unknown = "UNKNOWN"
        case cell = "CELL"
        case daytime = "DAYTIME"
        case evening = "EVENING"
        case home = "HOME"
        case work = "WORK"
    }











    public var contactPhoneNumber: String?
    public var contactPhoneType: ContactPhoneType?
    public var callerIdPhoneNumber: String?
    public var callerIdName: String?
    public var agentOwnedColumnName: String?
    public var previewModeColumnName: String?
    public var isDeliveredAsPreview: Bool?

    public init(contactPhoneNumber: String?, contactPhoneType: ContactPhoneType?, callerIdPhoneNumber: String?, callerIdName: String?, agentOwnedColumnName: String?, previewModeColumnName: String?, isDeliveredAsPreview: Bool?) {
        self.contactPhoneNumber = contactPhoneNumber
        self.contactPhoneType = contactPhoneType
        self.callerIdPhoneNumber = callerIdPhoneNumber
        self.callerIdName = callerIdName
        self.agentOwnedColumnName = agentOwnedColumnName
        self.previewModeColumnName = previewModeColumnName
        self.isDeliveredAsPreview = isDeliveredAsPreview
    }


}




public class OutboundRouteBase: Codable {



















    public enum State: String, Codable { 
        case active = "active"
        case inactive = "inactive"
        case deleted = "deleted"
    }









    public enum Distribution: String, Codable { 
        case sequential = "SEQUENTIAL"
        case random = "RANDOM"
    }





    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The name of the entity. */
    public var name: String?
    /** The division to which this entity belongs. */
    public var division: Division?
    /** The resource's description. */
    public var _description: String?
    /** The current version of the resource. */
    public var version: Int?
    /** The date the resource was created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** The date of the last modification to the resource. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** The ID of the user that last modified the resource. */
    public var modifiedBy: String?
    /** The ID of the user that created the resource. */
    public var createdBy: String?
    /** Indicates if the resource is active, inactive, or deleted. */
    public var state: State?
    /** The application that last modified the resource. */
    public var modifiedByApp: String?
    /** The application that created the resource. */
    public var createdByApp: String?
    /** The site associated to the outbound route. */
    public var classificationTypes: [String]?
    public var enabled: Bool?
    public var distribution: Distribution?
    /** Trunk base settings of trunkType \"EXTERNAL\".  This base must also be set on an edge logical interface for correct routing. */
    public var externalTrunkBases: [DomainEntityRef]?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, division: Division?, _description: String?, version: Int?, dateCreated: Date?, dateModified: Date?, modifiedBy: String?, createdBy: String?, state: State?, modifiedByApp: String?, createdByApp: String?, classificationTypes: [String]?, enabled: Bool?, distribution: Distribution?, externalTrunkBases: [DomainEntityRef]?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.division = division
        self._description = _description
        self.version = version
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.modifiedBy = modifiedBy
        self.createdBy = createdBy
        self.state = state
        self.modifiedByApp = modifiedByApp
        self.createdByApp = createdByApp
        self.classificationTypes = classificationTypes
        self.enabled = enabled
        self.distribution = distribution
        self.externalTrunkBases = externalTrunkBases
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case division
        case _description = "description"
        case version
        case dateCreated
        case dateModified
        case modifiedBy
        case createdBy
        case state
        case modifiedByApp
        case createdByApp
        case classificationTypes
        case enabled
        case distribution
        case externalTrunkBases
        case selfUri
    }


}




public class OutcomeAchievedEvent: Codable {





















    /** The outcome achieved. */
    public var outcome: OutcomeAchievedEventOutcome?
    /** HTTP User-Agent string (see https://tools.ietf.org/html/rfc1945#section-10.15). */
    public var userAgentString: String?
    /** Customer's browser. */
    public var browser: Browser?
    /** Customer's device. */
    public var device: Device?
    /** Customer's geolocation. */
    public var geolocation: JourneyGeolocation?
    /** Visitor's IP address. */
    public var ipAddress: String?
    /** Visitor's IP-based organization or ISP name. */
    public var ipOrganization: String?
    /** Marketing / traffic source information. */
    public var mktCampaign: JourneyCampaign?
    /** Visit's referrer. */
    public var visitReferrer: Referrer?
    /** When visit was created (e.g. timestamp of the first event in visit). Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var visitCreatedDate: Date?

    public init(outcome: OutcomeAchievedEventOutcome?, userAgentString: String?, browser: Browser?, device: Device?, geolocation: JourneyGeolocation?, ipAddress: String?, ipOrganization: String?, mktCampaign: JourneyCampaign?, visitReferrer: Referrer?, visitCreatedDate: Date?) {
        self.outcome = outcome
        self.userAgentString = userAgentString
        self.browser = browser
        self.device = device
        self.geolocation = geolocation
        self.ipAddress = ipAddress
        self.ipOrganization = ipOrganization
        self.mktCampaign = mktCampaign
        self.visitReferrer = visitReferrer
        self.visitCreatedDate = visitCreatedDate
    }


}




public class OutcomeScoresResult: Codable {





    /** List of scored outcomes in the session. */
    public var outcomeScores: [OutcomeScore]?
    /** Timestamp indicating the last time that the event was scored. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var modifiedDate: Date?

    public init(outcomeScores: [OutcomeScore]?, modifiedDate: Date?) {
        self.outcomeScores = outcomeScores
        self.modifiedDate = modifiedDate
    }


}




public class OverallBestPointsItem: Codable {

    public enum GranularityType: String, Codable { 
        case daily = "Daily"
        case weekly = "Weekly"
        case monthly = "Monthly"
    }











    /** Best points aggregation interval granularity */
    public var granularityType: GranularityType?
    /** List of associated users with the equal points. */
    public var users: [UserReference]?
    /** The count of the user IDs in the list */
    public var count: Int?
    /** Gamification points */
    public var points: Int?
    /** Start workday of the best points aggregation interval. Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd */
    public var dateStartWorkday: Date?
    /** End workday of the best points aggregation interval. Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd */
    public var dateEndWorkday: Date?

    public init(granularityType: GranularityType?, users: [UserReference]?, count: Int?, points: Int?, dateStartWorkday: Date?, dateEndWorkday: Date?) {
        self.granularityType = granularityType
        self.users = users
        self.count = count
        self.points = points
        self.dateStartWorkday = dateStartWorkday
        self.dateEndWorkday = dateEndWorkday
    }


}




public class OverrideDate: Codable {



    public enum ModelType: String, Codable { 
        case blocked = "Blocked"
        case manualReview = "ManualReview"
    }

    /** The date in yyyy-MM-dd format, interpreted in the business units time zone. Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd */
    public var date: Date?
    /** The type of override date */
    public var type: ModelType?

    public init(date: Date?, type: ModelType?) {
        self.date = date
        self.type = type
    }


}




public class OverrideEscalationTarget: Codable {



    /** The ID of the integration. */
    public var integrationId: String?

    public init(integrationId: String?) {
        self.integrationId = integrationId
    }


}




public class PINConfiguration: Codable {





    public var minimumLength: Int?
    public var maximumLength: Int?

    public init(minimumLength: Int?, maximumLength: Int?) {
        self.minimumLength = minimumLength
        self.maximumLength = maximumLength
    }


}




public class ParkingStateRequest: Codable {

    public enum State: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case converting = "converting"
        case uploading = "uploading"
        case transmitting = "transmitting"
        case parked = "parked"
        case _none = "none"
    }

    /** State to set the participant. */
    public var state: State?

    public init(state: State?) {
        self.state = state
    }


}




public class ParticipantAttributes: Codable {



    /** The map of attribute keys to values. */
    public var attributes: [String:String]?

    public init(attributes: [String:String]?) {
        self.attributes = attributes
    }


}




public class PatchBuReschedulingOptionsManagementUnitRequest: Codable {





    /** The management unit portion of the rescheduling run to update */
    public var managementUnitId: String?
    /** Whether to mark the run as applied.  Only applies to reschedule runs.  Once applied, a run cannot be un-marked as applied */
    public var applied: Bool?

    public init(managementUnitId: String?, applied: Bool?) {
        self.managementUnitId = managementUnitId
        self.applied = applied
    }


}




public class PatchCallbackResponse: Codable {





    /** The conversation associated with the callback */
    public var conversation: DomainEntityRef?
    /** The list of communication identifiers for the callback participants */
    public var callbackIdentifiers: [CallbackIdentifier]?

    public init(conversation: DomainEntityRef?, callbackIdentifiers: [CallbackIdentifier]?) {
        self.conversation = conversation
        self.callbackIdentifiers = callbackIdentifiers
    }


}




public class PatchContentOfferStylingConfiguration: Codable {















    /** Properties for customizing the positioning of the content offer. */
    public var position: PatchContentPositionProperties?
    /** Properties for customizing the appearance of the content offer. */
    public var offer: PatchContentOfferStyleProperties?
    /** Properties for customizing the appearance of the close button. */
    public var closeButton: PatchCloseButtonStyleProperties?
    /** Properties for customizing the appearance of the CTA button. */
    public var ctaButton: PatchCtaButtonStyleProperties?
    /** Properties for customizing the appearance of the title text. */
    public var title: PatchTextStyleProperties?
    /** Properties for customizing the appearance of the headline text. */
    public var headline: PatchTextStyleProperties?
    /** Properties for customizing the appearance of the body text. */
    public var body: PatchTextStyleProperties?

    public init(position: PatchContentPositionProperties?, offer: PatchContentOfferStyleProperties?, closeButton: PatchCloseButtonStyleProperties?, ctaButton: PatchCtaButtonStyleProperties?, title: PatchTextStyleProperties?, headline: PatchTextStyleProperties?, body: PatchTextStyleProperties?) {
        self.position = position
        self.offer = offer
        self.closeButton = closeButton
        self.ctaButton = ctaButton
        self.title = title
        self.headline = headline
        self.body = body
    }


}




public class PatchContentPositionProperties: Codable {









    /** Top positioning offset. */
    public var top: String?
    /** Bottom positioning offset. */
    public var bottom: String?
    /** Left positioning offset. */
    public var _left: String?
    /** Right positioning offset. */
    public var _right: String?

    public init(top: String?, bottom: String?, _left: String?, _right: String?) {
        self.top = top
        self.bottom = bottom
        self._left = _left
        self._right = _right
    }

    public enum CodingKeys: String, CodingKey { 
        case top
        case bottom
        case _left = "left"
        case _right = "right"
    }


}




public class PatchExternalSegment: Codable {



    /** Name for the external segment in the system where it originates from. */
    public var name: String?

    public init(name: String?) {
        self.name = name
    }


}




public class PatchJourney: Codable {



    /** A list of zero or more patterns to match. */
    public var patterns: [PatchJourneyPattern]?

    public init(patterns: [PatchJourneyPattern]?) {
        self.patterns = patterns
    }


}




public class PatchSegment: Codable {





















    /** Whether or not the segment is active. */
    public var isActive: Bool?
    /** The display name of the segment. */
    public var displayName: String?
    /** The version of the segment. */
    public var version: Int?
    /** A description of the segment. */
    public var _description: String?
    /** The hexadecimal color value of the segment. */
    public var color: String?
    /** Whether or not the segment should be displayed to agent/supervisor users. */
    public var shouldDisplayToAgent: Bool?
    /** The context of the segment. */
    public var context: PatchContext?
    /** The pattern of rules defining the segment. */
    public var journey: PatchJourney?
    /** Details of an entity corresponding to this segment in an external system. */
    public var externalSegment: PatchExternalSegment?
    /** Time, in days, from when the segment is assigned until it is automatically unassigned. */
    public var assignmentExpirationDays: Int?

    public init(isActive: Bool?, displayName: String?, version: Int?, _description: String?, color: String?, shouldDisplayToAgent: Bool?, context: PatchContext?, journey: PatchJourney?, externalSegment: PatchExternalSegment?, assignmentExpirationDays: Int?) {
        self.isActive = isActive
        self.displayName = displayName
        self.version = version
        self._description = _description
        self.color = color
        self.shouldDisplayToAgent = shouldDisplayToAgent
        self.context = context
        self.journey = journey
        self.externalSegment = externalSegment
        self.assignmentExpirationDays = assignmentExpirationDays
    }

    public enum CodingKeys: String, CodingKey { 
        case isActive
        case displayName
        case version
        case _description = "description"
        case color
        case shouldDisplayToAgent
        case context
        case journey
        case externalSegment
        case assignmentExpirationDays
    }


}




public class Pattern: Codable {

    public enum ModelType: String, Codable { 
        case daily = "Daily"
        case weekly = "Weekly"
    }



    public enum DaysOfWeek: String, Codable { 
        case sunday = "Sunday"
        case monday = "Monday"
        case tuesday = "Tuesday"
        case wednesday = "Wednesday"
        case thursday = "Thursday"
        case friday = "Friday"
        case saturday = "Saturday"
    }

    /** Pattern type (Daily/Weekly) */
    public var type: ModelType?
    /** The interval of days between the occurrences for Daily pattern type, and weeks between the occurrences for Weekly */
    public var interval: Int?
    /** The day(s) of week the occurrence should be repeated. Required to set for Weekly pattern type. E.g. [\"Monday\", \"Wednesday\"] */
    public var daysOfWeek: [DaysOfWeek]?

    public init(type: ModelType?, interval: Int?, daysOfWeek: [DaysOfWeek]?) {
        self.type = type
        self.interval = interval
        self.daysOfWeek = daysOfWeek
    }


}




public class PauseCriteria: Codable {



    public enum Condition: String, Codable { 
        case includes = "Includes"
        case doesNotInclude = "DoesNotInclude"
        case startsWith = "StartsWith"
        case endsWith = "EndsWith"
        case equals = "Equals"
    }

    public var urlFragment: String?
    public var condition: Condition?

    public init(urlFragment: String?, condition: Condition?) {
        self.urlFragment = urlFragment
        self.condition = condition
    }


}




public class PaymentRequest: Codable {

    public enum PaymentPlatform: String, Codable { 
        case applePay = "ApplePay"
    }











    /** The payment platform being used (e.g. Apple Pay) */
    public var paymentPlatform: PaymentPlatform?
    /** The merchant's two-letter ISO 3166 country code. */
    public var countryCode: String?
    /** The three-letter ISO 4217 currency code for the payment. */
    public var currencyCode: String?
    /** The total price of the order. */
    public var orderTotal: Double?
    /** The items that make up the order. */
    public var lineItems: [PaymentLineItem]?
    /** The available shipping options. */
    public var shippingOptions: [PaymentLineItem]?

    public init(paymentPlatform: PaymentPlatform?, countryCode: String?, currencyCode: String?, orderTotal: Double?, lineItems: [PaymentLineItem]?, shippingOptions: [PaymentLineItem]?) {
        self.paymentPlatform = paymentPlatform
        self.countryCode = countryCode
        self.currencyCode = currencyCode
        self.orderTotal = orderTotal
        self.lineItems = lineItems
        self.shippingOptions = shippingOptions
    }


}




public class PerformancePredictionCompleteEventTopicErrorBody: Codable {









    public var status: Int64?
    public var code: String?
    public var message: String?
    public var messageParams: [String:String]?

    public init(status: Int64?, code: String?, message: String?, messageParams: [String:String]?) {
        self.status = status
        self.code = code
        self.message = message
        self.messageParams = messageParams
    }


}




public class PerformancePredictionRecalculationCompleteEventTopicErrorBody: Codable {









    public var status: Int64?
    public var code: String?
    public var message: String?
    public var messageParams: [String:String]?

    public init(status: Int64?, code: String?, message: String?, messageParams: [String:String]?) {
        self.status = status
        self.code = code
        self.message = message
        self.messageParams = messageParams
    }


}




public class PerformancePredictionRecalculationUploadResponse: Codable {









    /** The key to pass to the secondary request to start processing of the upload */
    public var uploadKey: String?
    /** The url to which to PUT the upload body */
    public var url: String?
    /** Required headers for the PUT request to the url */
    public var headers: [String:String]?
    /** Always null. Defines the schema of the json body to be PUT to the url. The json body should be gzip encoded before uploading */
    public var uploadBodySchema: PerformancePredictionUploadSchema?

    public init(uploadKey: String?, url: String?, headers: [String:String]?, uploadBodySchema: PerformancePredictionUploadSchema?) {
        self.uploadKey = uploadKey
        self.url = url
        self.headers = headers
        self.uploadBodySchema = uploadBodySchema
    }


}




public class PerformanceProfile: Codable {























    /** The globally unique identifier for the object. */
    public var _id: String?
    /** A name for this performance profile */
    public var name: String?
    /** The division for this performance profile associate to */
    public var division: Division?
    /** A description about this performance profile */
    public var _description: String?
    /** Order of the associated metrics. The list should contain valid ids for metrics */
    public var metricOrders: [String]?
    /** Creation date for this performance profile. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** The reporting interval periods for this performance profile */
    public var reportingIntervals: [ReportingInterval]?
    /** The flag for active profiles */
    public var active: Bool?
    /** The number of members in this performance profile */
    public var memberCount: Int?
    /** The maximum rank size for the leaderboard. This counts the number of ranks can be retrieved in a leaderboard queries */
    public var maxLeaderboardRankSize: Int?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, division: Division?, _description: String?, metricOrders: [String]?, dateCreated: Date?, reportingIntervals: [ReportingInterval]?, active: Bool?, memberCount: Int?, maxLeaderboardRankSize: Int?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.division = division
        self._description = _description
        self.metricOrders = metricOrders
        self.dateCreated = dateCreated
        self.reportingIntervals = reportingIntervals
        self.active = active
        self.memberCount = memberCount
        self.maxLeaderboardRankSize = maxLeaderboardRankSize
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case division
        case _description = "description"
        case metricOrders
        case dateCreated
        case reportingIntervals
        case active
        case memberCount
        case maxLeaderboardRankSize
        case selfUri
    }


}




public class PersistentConnectionChangeTopicErrorInfo: Codable {











    public var text: String?
    public var code: String?
    public var userMessage: String?
    public var userParams: [String:String]?
    public var nestedErrorDetails: [PersistentConnectionChangeTopicErrorInfoDetails]?

    public init(text: String?, code: String?, userMessage: String?, userParams: [String:String]?, nestedErrorDetails: [PersistentConnectionChangeTopicErrorInfoDetails]?) {
        self.text = text
        self.code = code
        self.userMessage = userMessage
        self.userParams = userParams
        self.nestedErrorDetails = nestedErrorDetails
    }


}




public class PersistentConnectionChangeTopicErrorInfoDetails: Codable {











    public var code: String?
    public var userMessage: String?
    public var userParams: [String:String]?
    public var hostname: String?
    public var location: PersistentConnectionChangeTopicErrorLocation?

    public init(code: String?, userMessage: String?, userParams: [String:String]?, hostname: String?, location: PersistentConnectionChangeTopicErrorLocation?) {
        self.code = code
        self.userMessage = userMessage
        self.userParams = userParams
        self.hostname = hostname
        self.location = location
    }


}




public class PhoneBaseSettings: Codable {







    /** The globally unique identifier for this phone base settings */
    public var _id: String?
    public var name: String?
    public var selfUri: String?

    public init(_id: String?, name: String?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case selfUri
    }


}




public class PhoneChangeTopicPhoneStatus: Codable {



    public enum OperationalStatus: String, Codable { 
        case operational = "OPERATIONAL"
        case degraded = "DEGRADED"
        case offline = "OFFLINE"
    }









    public var _id: String?
    public var operationalStatus: OperationalStatus?
    public var edge: PhoneChangeTopicEdgeReference?
    public var provision: PhoneChangeTopicProvisionInfo?
    public var lineStatuses: [PhoneChangeTopicLineStatus]?
    public var eventCreationTime: Date?

    public init(_id: String?, operationalStatus: OperationalStatus?, edge: PhoneChangeTopicEdgeReference?, provision: PhoneChangeTopicProvisionInfo?, lineStatuses: [PhoneChangeTopicLineStatus]?, eventCreationTime: Date?) {
        self._id = _id
        self.operationalStatus = operationalStatus
        self.edge = edge
        self.provision = provision
        self.lineStatuses = lineStatuses
        self.eventCreationTime = eventCreationTime
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case operationalStatus
        case edge
        case provision
        case lineStatuses
        case eventCreationTime
    }


}




public class PhoneChangeTopicProvisionInfo: Codable {







    public var time: Date?
    public var source: String?
    public var errorInfo: String?

    public init(time: Date?, source: String?, errorInfo: String?) {
        self.time = time
        self.source = source
        self.errorInfo = errorInfo
    }


}




public class PhysicalInterfaceEntityListing: Codable {





















    public var entities: [DomainPhysicalInterface]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var previousUri: String?
    public var nextUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [DomainPhysicalInterface]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, previousUri: String?, nextUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.previousUri = previousUri
        self.nextUri = nextUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class PlanningGroupReference: Codable {





    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, selfUri: String?) {
        self._id = _id
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
    }


}




public class PlanningGroupRequirementOutput: Codable {









    /** The ID of the planning group to which this output applies */
    public var _id: String?
    /** List of interval values that correspond with the requirements granularity that was requested */
    public var intervals: [Int]?
    /** Error details if the intervals cannot be provided for this planning group because of missing data or internal error */
    public var errorDetails: [LongTermRequirementsErrorDetail]?
    /** The service goal details used to generate the requirements */
    public var serviceGoalDetails: LongTermRequirementsServiceGoalDetail?

    public init(_id: String?, intervals: [Int]?, errorDetails: [LongTermRequirementsErrorDetail]?, serviceGoalDetails: LongTermRequirementsServiceGoalDetail?) {
        self._id = _id
        self.intervals = intervals
        self.errorDetails = errorDetails
        self.serviceGoalDetails = serviceGoalDetails
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case intervals
        case errorDetails
        case serviceGoalDetails
    }


}




public class Policy: Codable {

























    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var modifiedDate: Date?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var createdDate: Date?
    public var order: Int?
    public var _description: String?
    public var enabled: Bool?
    /** Conditions and actions per media type */
    public var mediaPolicies: MediaPolicies?
    /** Conditions */
    public var conditions: PolicyConditions?
    /** Actions */
    public var actions: PolicyActions?
    public var policyErrors: PolicyErrors?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, modifiedDate: Date?, createdDate: Date?, order: Int?, _description: String?, enabled: Bool?, mediaPolicies: MediaPolicies?, conditions: PolicyConditions?, actions: PolicyActions?, policyErrors: PolicyErrors?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.modifiedDate = modifiedDate
        self.createdDate = createdDate
        self.order = order
        self._description = _description
        self.enabled = enabled
        self.mediaPolicies = mediaPolicies
        self.conditions = conditions
        self.actions = actions
        self.policyErrors = policyErrors
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case modifiedDate
        case createdDate
        case order
        case _description = "description"
        case enabled
        case mediaPolicies
        case conditions
        case actions
        case policyErrors
        case selfUri
    }


}




public class PolicyConditions: Codable {



    public enum Directions: String, Codable { 
        case inbound = "INBOUND"
        case outbound = "OUTBOUND"
    }



    public enum MediaTypes: String, Codable { 
        case call = "CALL"
        case chat = "CHAT"
    }











    public enum CustomerParticipation: String, Codable { 
        case yes = "YES"
        case no = "NO"
    }

    /** List of users to apply this policy to. Each user object can include the 'id' field containing the user's unique identifier. Example: [{\"id\":\"<userId>\"}]. */
    public var forUsers: [PolicyUser]?
    public var directions: [Directions]?
    public var dateRanges: [String]?
    public var mediaTypes: [MediaTypes]?
    public var forQueues: [Queue]?
    public var duration: DurationCondition?
    public var wrapupCodes: [WrapupCode]?
    public var timeAllowed: TimeAllowed?
    /** Teams to match conversations against */
    public var teams: [Team]?
    /** This condition is to filter out conversation with and without customer participation. */
    public var customerParticipation: CustomerParticipation?

    public init(forUsers: [PolicyUser]?, directions: [Directions]?, dateRanges: [String]?, mediaTypes: [MediaTypes]?, forQueues: [Queue]?, duration: DurationCondition?, wrapupCodes: [WrapupCode]?, timeAllowed: TimeAllowed?, teams: [Team]?, customerParticipation: CustomerParticipation?) {
        self.forUsers = forUsers
        self.directions = directions
        self.dateRanges = dateRanges
        self.mediaTypes = mediaTypes
        self.forQueues = forQueues
        self.duration = duration
        self.wrapupCodes = wrapupCodes
        self.timeAllowed = timeAllowed
        self.teams = teams
        self.customerParticipation = customerParticipation
    }


}




public class PolicyUser: Codable {

















    public enum State: String, Codable { 
        case active = "active"
        case inactive = "inactive"
        case deleted = "deleted"
    }





























































    /** User ID */
    public var _id: String?
    public var name: String?
    /** The division to which this entity belongs. */
    public var division: Division?
    public var chat: Chat?
    public var department: String?
    public var email: String?
    /** Auto populated from addresses. */
    public var primaryContactInfo: [Contact]?
    /** Email addresses and phone numbers for this user */
    public var addresses: [Contact]?
    /** The current state for this user. */
    public var state: State?
    public var title: String?
    public var username: String?
    public var manager: User?
    public var images: [Image]?
    /** Required when updating a user, this value should be the current version of the user.  The current version can be obtained with a GET on the user before doing a PATCH. */
    public var version: Int?
    public var certifications: [String]?
    public var biography: Biography?
    public var employerInfo: EmployerInfo?
    /** Preferred full name of the agent */
    public var preferredName: String?
    /** ACD routing status */
    public var routingStatus: RoutingStatus?
    /** Active presence */
    public var presence: UserPresence?
    /** Integration presence */
    public var integrationPresence: UserPresence?
    /** Summary of conversion statistics for conversation types. */
    public var conversationSummary: UserConversationSummary?
    /** Determine if out of office is enabled */
    public var outOfOffice: OutOfOffice?
    /** Current geolocation position */
    public var geolocation: Geolocation?
    /** Effective, default, and last station information */
    public var station: UserStations?
    /** Roles and permissions assigned to the user */
    public var authorization: UserAuthorization?
    /** Profile skills possessed by the user */
    public var profileSkills: [String]?
    /** The user placement at each site location. */
    public var locations: [Location]?
    /** The groups the user is a member of */
    public var groups: [Group]?
    /** The team the user is a member of */
    public var team: Team?
    /** The WFM work plan bid rank settings for the user */
    public var workPlanBidRanks: WorkPlanBidRanks?
    /** Routing (ACD) skills possessed by the user */
    public var skills: [UserRoutingSkill]?
    /** Routing (ACD) languages possessed by the user */
    public var languages: [UserRoutingLanguage]?
    /** acd auto answer */
    public var acdAutoAnswer: Bool?
    /** preferred language by the user */
    public var languagePreference: String?
    public var lastTokenIssued: OAuthLastTokenIssued?
    /** The last time the user logged in using username and password. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateLastLogin: Date?
    /** The date & time the user was sent their welcome email. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateWelcomeSent: Date?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, division: Division?, chat: Chat?, department: String?, email: String?, primaryContactInfo: [Contact]?, addresses: [Contact]?, state: State?, title: String?, username: String?, manager: User?, images: [Image]?, version: Int?, certifications: [String]?, biography: Biography?, employerInfo: EmployerInfo?, preferredName: String?, routingStatus: RoutingStatus?, presence: UserPresence?, integrationPresence: UserPresence?, conversationSummary: UserConversationSummary?, outOfOffice: OutOfOffice?, geolocation: Geolocation?, station: UserStations?, authorization: UserAuthorization?, profileSkills: [String]?, locations: [Location]?, groups: [Group]?, team: Team?, workPlanBidRanks: WorkPlanBidRanks?, skills: [UserRoutingSkill]?, languages: [UserRoutingLanguage]?, acdAutoAnswer: Bool?, languagePreference: String?, lastTokenIssued: OAuthLastTokenIssued?, dateLastLogin: Date?, dateWelcomeSent: Date?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.division = division
        self.chat = chat
        self.department = department
        self.email = email
        self.primaryContactInfo = primaryContactInfo
        self.addresses = addresses
        self.state = state
        self.title = title
        self.username = username
        self.manager = manager
        self.images = images
        self.version = version
        self.certifications = certifications
        self.biography = biography
        self.employerInfo = employerInfo
        self.preferredName = preferredName
        self.routingStatus = routingStatus
        self.presence = presence
        self.integrationPresence = integrationPresence
        self.conversationSummary = conversationSummary
        self.outOfOffice = outOfOffice
        self.geolocation = geolocation
        self.station = station
        self.authorization = authorization
        self.profileSkills = profileSkills
        self.locations = locations
        self.groups = groups
        self.team = team
        self.workPlanBidRanks = workPlanBidRanks
        self.skills = skills
        self.languages = languages
        self.acdAutoAnswer = acdAutoAnswer
        self.languagePreference = languagePreference
        self.lastTokenIssued = lastTokenIssued
        self.dateLastLogin = dateLastLogin
        self.dateWelcomeSent = dateWelcomeSent
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case division
        case chat
        case department
        case email
        case primaryContactInfo
        case addresses
        case state
        case title
        case username
        case manager
        case images
        case version
        case certifications
        case biography
        case employerInfo
        case preferredName
        case routingStatus
        case presence
        case integrationPresence
        case conversationSummary
        case outOfOffice
        case geolocation
        case station
        case authorization
        case profileSkills
        case locations
        case groups
        case team
        case workPlanBidRanks
        case skills
        case languages
        case acdAutoAnswer
        case languagePreference
        case lastTokenIssued
        case dateLastLogin
        case dateWelcomeSent
        case selfUri
    }


}



/** The schemas defining all of the expected responses/outputs. */

public class PostOutputContract: Codable {



    /** JSON schema that defines the transformed, successful result that will be sent back to the caller. */
    public var successSchema: JsonSchemaDocument?

    public init(successSchema: JsonSchemaDocument?) {
        self.successSchema = successSchema
    }


}




public class PresenceDefinition: Codable {







    /** description */
    public var _id: String?
    public var systemPresence: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, systemPresence: String?, selfUri: String?) {
        self._id = _id
        self.systemPresence = systemPresence
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case systemPresence
        case selfUri
    }


}




public class PresenceDetailQueryFilter: Codable {

    public enum ModelType: String, Codable { 
        case and = "and"
        case or = "or"
    }





    /** Boolean operation to apply to the provided predicates and clauses */
    public var type: ModelType?
    /** Boolean 'and/or' logic with up to two-levels of nesting */
    public var clauses: [PresenceDetailQueryClause]?
    /** Like a three-word sentence: (attribute-name) (operator) (target-value). */
    public var predicates: [PresenceDetailQueryPredicate]?

    public init(type: ModelType?, clauses: [PresenceDetailQueryClause]?, predicates: [PresenceDetailQueryPredicate]?) {
        self.type = type
        self.clauses = clauses
        self.predicates = predicates
    }


}




public class ProgramMappings: Codable {











    public var program: BaseProgramEntity?
    public var queues: [AddressableEntityRef]?
    public var flows: [AddressableEntityRef]?
    public var modifiedBy: AddressableEntityRef?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?

    public init(program: BaseProgramEntity?, queues: [AddressableEntityRef]?, flows: [AddressableEntityRef]?, modifiedBy: AddressableEntityRef?, dateModified: Date?) {
        self.program = program
        self.queues = queues
        self.flows = flows
        self.modifiedBy = modifiedBy
        self.dateModified = dateModified
    }


}




public class ProgramMappingsRequest: Codable {





    /** The program queues */
    public var queueIds: [String]?
    /** The program flows */
    public var flowIds: [String]?

    public init(queueIds: [String]?, flowIds: [String]?) {
        self.queueIds = queueIds
        self.flowIds = flowIds
    }


}




public class ProgramTopicLinksTestPhraseMatchedTranscript: Codable {









    public enum MediaType: String, Codable { 
        case unknown = "unknown"
        case call = "call"
        case message = "message"
        case email = "email"
        case chat = "chat"
        case callback = "callback"
        case all = "all"
    }



    public var timestamp: Int64?
    public var transcriptId: String?
    public var communicationId: String?
    public var conversationId: String?
    public var mediaType: MediaType?
    public var detectedPhrases: [ProgramTopicLinksTestPhraseDetectedPhrase]?

    public init(timestamp: Int64?, transcriptId: String?, communicationId: String?, conversationId: String?, mediaType: MediaType?, detectedPhrases: [ProgramTopicLinksTestPhraseDetectedPhrase]?) {
        self.timestamp = timestamp
        self.transcriptId = transcriptId
        self.communicationId = communicationId
        self.conversationId = conversationId
        self.mediaType = mediaType
        self.detectedPhrases = detectedPhrases
    }


}




public class ProgramTopicLinksTestTopicPhraseResults: Codable {







    public var processedTranscriptsCount: Int64?
    public var matchedTranscriptsCount: Int64?
    public var matchedTranscripts: [ProgramTopicLinksTestPhraseMatchedTranscript]?

    public init(processedTranscriptsCount: Int64?, matchedTranscriptsCount: Int64?, matchedTranscripts: [ProgramTopicLinksTestPhraseMatchedTranscript]?) {
        self.processedTranscriptsCount = processedTranscriptsCount
        self.matchedTranscriptsCount = matchedTranscriptsCount
        self.matchedTranscripts = matchedTranscripts
    }


}




public class ProgramTopicLinksTopicsDefinitionsJob: Codable {



    public enum State: String, Codable { 
        case completed = "Completed"
        case running = "Running"
        case failed = "Failed"
    }



    public var _id: String?
    public var state: State?
    public var testTopicPhraseResults: [ProgramTopicLinksTestTopicPhraseResults]?

    public init(_id: String?, state: State?, testTopicPhraseResults: [ProgramTopicLinksTestTopicPhraseResults]?) {
        self._id = _id
        self.state = state
        self.testTopicPhraseResults = testTopicPhraseResults
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case state
        case testTopicPhraseResults
    }


}




public class ProgressTransferEvent: Codable {













    /** A unique (V4 UUID) eventId for this event */
    public var eventId: String?
    /** A Date Time representing the time this event occurred. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var eventDateTime: Date?
    /** A unique Id (V4 UUID) identifying this conversation */
    public var conversationId: String?
    /** The id (V4 UUID) used to identify the transfer already started by the external platform. */
    public var commandId: String?
    /** The id (V4 UUID) of the communication that is being transferred. */
    public var objectCommunicationId: String?
    /** The id (V4 UUID) of the communication that is being transferred to. */
    public var destinationCommunicationId: String?

    public init(eventId: String?, eventDateTime: Date?, conversationId: String?, commandId: String?, objectCommunicationId: String?, destinationCommunicationId: String?) {
        self.eventId = eventId
        self.eventDateTime = eventDateTime
        self.conversationId = conversationId
        self.commandId = commandId
        self.objectCommunicationId = objectCommunicationId
        self.destinationCommunicationId = destinationCommunicationId
    }


}




public class PromptAsset: Codable {















    public enum UploadStatus: String, Codable { 
        case created = "created"
        case uploaded = "uploaded"
        case transcoded = "transcoded"
        case transcodefailed = "transcodeFailed"
    }











    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** Associated prompt ID */
    public var promptId: String?
    /** Prompt resource language */
    public var language: String?
    /** URI of the resource audio */
    public var mediaUri: String?
    /** Text to speech of the resource */
    public var ttsString: String?
    /** Text of the resource */
    public var text: String?
    /** Audio upload status */
    public var uploadStatus: UploadStatus?
    /** Deprecated. This was use for uploading the resource audio. */
    public var uploadUri: String?
    /** Whether or not this resource locale is the default for the language */
    public var languageDefault: Bool?
    public var tags: [String:[String]]?
    public var durationSeconds: Double?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, promptId: String?, language: String?, mediaUri: String?, ttsString: String?, text: String?, uploadStatus: UploadStatus?, uploadUri: String?, languageDefault: Bool?, tags: [String:[String]]?, durationSeconds: Double?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.promptId = promptId
        self.language = language
        self.mediaUri = mediaUri
        self.ttsString = ttsString
        self.text = text
        self.uploadStatus = uploadStatus
        self.uploadUri = uploadUri
        self.languageDefault = languageDefault
        self.tags = tags
        self.durationSeconds = durationSeconds
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case promptId
        case language
        case mediaUri
        case ttsString
        case text
        case uploadStatus
        case uploadUri
        case languageDefault
        case tags
        case durationSeconds
        case selfUri
    }


}




public class PromptEntityListing: Codable {





















    public var entities: [Prompt]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var previousUri: String?
    public var nextUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [Prompt]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, previousUri: String?, nextUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.previousUri = previousUri
        self.nextUri = nextUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class PublishScriptRequestData: Codable {





    /** The id of the script to publish */
    public var scriptId: String?
    public var versionId: String?

    public init(scriptId: String?, versionId: String?) {
        self.scriptId = scriptId
        self.versionId = versionId
    }


}




public class PushDeviceUpdateRequest: Codable {





    /** The preferred language of the user (eg. en-us, de, fr) */
    public var language: String?
    /** The device token generated by the network providers */
    public var deviceToken: String?

    public init(language: String?, deviceToken: String?) {
        self.language = language
        self.deviceToken = deviceToken
    }


}




public class QueryCapacityPlanStaffingGroupMetricChangeHistory: Codable {





    /** The IDs of the staffing groups for which to fetch the metric change history */
    public var staffingGroupIds: [String]?
    /** Fetch the history of metric changes on or before this date, in IS0-8601 format. If not specified, sets to current date */
    public var queryEndDate: Date?

    public init(staffingGroupIds: [String]?, queryEndDate: Date?) {
        self.staffingGroupIds = staffingGroupIds
        self.queryEndDate = queryEndDate
    }


}




public class QueryRequest: Codable {

















    public var queryPhrase: String?
    public var pageNumber: Int?
    public var pageSize: Int?
    public var facetNameRequests: [String]?
    public var sort: [SortItem]?
    public var filters: [ContentFilterItem]?
    public var attributeFilters: [AttributeFilterItem]?
    public var includeShares: Bool?

    public init(queryPhrase: String?, pageNumber: Int?, pageSize: Int?, facetNameRequests: [String]?, sort: [SortItem]?, filters: [ContentFilterItem]?, attributeFilters: [AttributeFilterItem]?, includeShares: Bool?) {
        self.queryPhrase = queryPhrase
        self.pageNumber = pageNumber
        self.pageSize = pageSize
        self.facetNameRequests = facetNameRequests
        self.sort = sort
        self.filters = filters
        self.attributeFilters = attributeFilters
        self.includeShares = includeShares
    }


}




public class QueryRequestClause: Codable {

    public enum ModelType: String, Codable { 
        case and = "And"
        case or = "Or"
    }



    /** The logic used to combine the predicates */
    public var type: ModelType?
    /** The list of predicates used to filter the data */
    public var predicates: [QueryRequestPredicate]?

    public init(type: ModelType?, predicates: [QueryRequestPredicate]?) {
        self.type = type
        self.predicates = predicates
    }


}




public class QueryResponseData: Codable {





    /** Interval with start and end represented as ISO-8601 string. i.e: yyyy-MM-dd'T'HH:mm:ss.SSS'Z'/yyyy-MM-dd'T'HH:mm:ss.SSS'Z' */
    public var interval: String?
    /** A list of aggregated metrics */
    public var metrics: [QueryResponseMetric]?

    public init(interval: String?, metrics: [QueryResponseMetric]?) {
        self.interval = interval
        self.metrics = metrics
    }


}




public class QueryUserStaffingGroupListRequest: Codable {



    /** The set of user IDs to fetch associated staffing groups */
    public var userIds: [String]?

    public init(userIds: [String]?) {
        self.userIds = userIds
    }


}




public class QueueConversationCallEventTopicConversationRoutingData: Codable {











    /** A UriReference for a resource */
    public var queue: QueueConversationCallEventTopicUriReference?
    /** A UriReference for a resource */
    public var language: QueueConversationCallEventTopicUriReference?
    /** The priority of the conversation to use for routing decisions */
    public var priority: Int64?
    /** The skills to use for routing decisions */
    public var skills: [QueueConversationCallEventTopicUriReference]?
    /** A collection of agents and their assigned scores for this conversation (0 - 100, higher being better), for use in routing to preferred agents */
    public var scoredAgents: [QueueConversationCallEventTopicScoredAgent]?

    public init(queue: QueueConversationCallEventTopicUriReference?, language: QueueConversationCallEventTopicUriReference?, priority: Int64?, skills: [QueueConversationCallEventTopicUriReference]?, scoredAgents: [QueueConversationCallEventTopicScoredAgent]?) {
        self.queue = queue
        self.language = language
        self.priority = priority
        self.skills = skills
        self.scoredAgents = scoredAgents
    }


}



/** A reference to another domain entity. */

public class QueueConversationCallEventTopicDomainEntityRef: Codable {





    public var _id: String?
    public var selfUri: String?

    public init(_id: String?, selfUri: String?) {
        self._id = _id
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
    }


}




public class QueueConversationCallbackEventTopicCallbackConversation: Codable {

















    public var _id: String?
    public var name: String?
    public var participants: [QueueConversationCallbackEventTopicCallbackMediaParticipant]?
    public var otherMediaUris: [String]?
    public var address: String?
    public var utilizationLabelId: String?
    public var inactivityTimeout: Date?
    public var divisions: [QueueConversationCallbackEventTopicConversationDivisionMembership]?

    public init(_id: String?, name: String?, participants: [QueueConversationCallbackEventTopicCallbackMediaParticipant]?, otherMediaUris: [String]?, address: String?, utilizationLabelId: String?, inactivityTimeout: Date?, divisions: [QueueConversationCallbackEventTopicConversationDivisionMembership]?) {
        self._id = _id
        self.name = name
        self.participants = participants
        self.otherMediaUris = otherMediaUris
        self.address = address
        self.utilizationLabelId = utilizationLabelId
        self.inactivityTimeout = inactivityTimeout
        self.divisions = divisions
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case participants
        case otherMediaUris
        case address
        case utilizationLabelId
        case inactivityTimeout
        case divisions
    }


}




public class QueueConversationCallbackEventTopicDialerPreview: Codable {











    public var _id: String?
    /** The contact associated with this preview data pop */
    public var contactId: String?
    /** The contactList associated with this preview data pop. */
    public var contactListId: String?
    /** The campaignId associated with this preview data pop. */
    public var campaignId: String?
    /** The phone number columns associated with this campaign */
    public var phoneNumberColumns: [QueueConversationCallbackEventTopicPhoneNumberColumn]?

    public init(_id: String?, contactId: String?, contactListId: String?, campaignId: String?, phoneNumberColumns: [QueueConversationCallbackEventTopicPhoneNumberColumn]?) {
        self._id = _id
        self.contactId = contactId
        self.contactListId = contactListId
        self.campaignId = campaignId
        self.phoneNumberColumns = phoneNumberColumns
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case contactId
        case contactListId
        case campaignId
        case phoneNumberColumns
    }


}




public class QueueConversationCallbackEventTopicLimit: Codable {



    public enum Namespace: String, Codable { 
        case agentAssistant = "agent.assistant"
        case analyticsAlerting = "analytics.alerting"
        case analytics = "analytics"
        case analyticsRealtime = "analytics.realtime"
        case analyticsReportingSettings = "analytics.reporting.settings"
        case architect = "architect"
        case audiohook = "audiohook"
        case audit = "audit"
        case authApi = "auth.api"
        case authorization = "authorization"
        case automationTesting = "automation.testing"
        case bots = "bots"
        case botsVoice = "bots.voice"
        case callback = "callback"
        case cobrowse = "cobrowse"
        case contentManagement = "content.management"
        case conversation = "conversation"
        case dataactions = "dataactions"
        case datatables = "datatables"
        case directory = "directory"
        case email = "email"
        case eventOrchestration = "event.orchestration"
        case externalContacts = "external.contacts"
        case gcv = "gcv"
        case gdpr = "gdpr"
        case groups = "groups"
        case historicalAdherence = "historical.adherence"
        case infrastructureascode = "infrastructureascode"
        case integrations = "integrations"
        case intentMiner = "intent.miner"
        case journey = "journey"
        case knowledge = "knowledge"
        case languageUnderstanding = "language.understanding"
        case learning = "learning"
        case limitRegistry = "limit.registry"
        case marketplace = "marketplace"
        case mediaCommunications = "media.communications"
        case messaging = "messaging"
        case notifications = "notifications"
        case onboarding = "onboarding"
        case outbound = "outbound"
        case platformApi = "platform.api"
        case predictiveRouting = "predictive.routing"
        case presence = "presence"
        case quality = "quality"
        case recording = "recording"
        case responseManagement = "response.management"
        case routing = "routing"
        case scim = "scim"
        case search = "search"
        case secondaryAutomationTesting = "secondary.automation.testing"
        case skills = "skills"
        case speechAndTextAnalytics = "speech.and.text.analytics"
        case speechIntegration = "speech.integration"
        case supportability = "supportability"
        case taskManagement = "task.management"
        case telephonyConfiguration = "telephony.configuration"
        case usage = "usage"
        case users = "users"
        case webDeployments = "web.deployments"
        case webMessaging = "web.messaging"
        case webchat = "webchat"
        case webhooks = "webhooks"
        case workforceManagement = "workforce.management"
    }





    public var key: String?
    public var namespace: Namespace?
    public var value: Int64?
    public var documented: Bool?

    public init(key: String?, namespace: Namespace?, value: Int64?, documented: Bool?) {
        self.key = key
        self.namespace = namespace
        self.value = value
        self.documented = documented
    }


}




public class QueueConversationCallbackEventTopicQueueMediaSettings: Codable {









    /** Specifies how long the agent has to answer an interaction before being marked as not responding. */
    public var alertingTimeoutSeconds: Int64?
    /** Specifies the duration of the alerting sound to be played for auto answered interactions. */
    public var autoAnswerAlertToneSeconds: Double?
    /** Specifies the duration of the alerting sound to be played for manually answered interactions */
    public var manualAnswerAlertToneSeconds: Double?
    /** Flag to indicate if auto answer is enabled for the given media type or media subtype. */
    public var enableAutoAnswer: Bool?

    public init(alertingTimeoutSeconds: Int64?, autoAnswerAlertToneSeconds: Double?, manualAnswerAlertToneSeconds: Double?, enableAutoAnswer: Bool?) {
        self.alertingTimeoutSeconds = alertingTimeoutSeconds
        self.autoAnswerAlertToneSeconds = autoAnswerAlertToneSeconds
        self.manualAnswerAlertToneSeconds = manualAnswerAlertToneSeconds
        self.enableAutoAnswer = enableAutoAnswer
    }


}




public class QueueConversationCallbackEventTopicVoicemail: Codable {



    public enum UploadStatus: String, Codable { 
        case pending = "pending"
        case complete = "complete"
        case failed = "failed"
        case timeout = "timeout"
        case _none = "none"
    }

    /** The voicemail id */
    public var _id: String?
    /** current state of the voicemail upload */
    public var uploadStatus: UploadStatus?

    public init(_id: String?, uploadStatus: UploadStatus?) {
        self._id = _id
        self.uploadStatus = uploadStatus
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case uploadStatus
    }


}




public class QueueConversationChatEventTopicConversationDivisionMembership: Codable {





    public var division: QueueConversationChatEventTopicDomainEntityRef?
    public var entities: [QueueConversationChatEventTopicDivisionEntityRef]?

    public init(division: QueueConversationChatEventTopicDomainEntityRef?, entities: [QueueConversationChatEventTopicDivisionEntityRef]?) {
        self.division = division
        self.entities = entities
    }


}



/** A subset of the Journey System's customer data at a point-in-time (for external linkage and internal usage/context) */

public class QueueConversationChatEventTopicJourneyCustomer: Codable {





    /** An ID of a customer within the Journey System at a point-in-time.  Note that a customer entity can have multiple customerIds based on the stitching process.  Depending on the context within the PureCloud conversation, this may or may not be mutable. */
    public var _id: String?
    /** The type of the customerId within the Journey System (e.g. cookie). */
    public var idType: String?

    public init(_id: String?, idType: String?) {
        self._id = _id
        self.idType = idType
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case idType
    }


}



/** A subset of the Journey System's tracked customer session data at a point-in-time (for external linkage and internal usage/context) */

public class QueueConversationChatEventTopicJourneyCustomerSession: Codable {





    /** An ID of a Customer/User's session within the Journey System at a point-in-time */
    public var _id: String?
    /** The type of the Customer/User's session within the Journey System (e.g. web, app) */
    public var type: String?

    public init(_id: String?, type: String?) {
        self._id = _id
        self.type = type
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case type
    }


}




public class QueueConversationChatEventTopicScoredAgent: Codable {





    /** A UriReference for a resource */
    public var agent: QueueConversationChatEventTopicUriReference?
    /** Agent's score for the current conversation, from 0 - 100, higher being better */
    public var score: Int64?

    public init(agent: QueueConversationChatEventTopicUriReference?, score: Int64?) {
        self.agent = agent
        self.score = score
    }


}




public class QueueConversationCobrowseEventTopicCobrowseConversation: Codable {

















    public var _id: String?
    public var name: String?
    public var participants: [QueueConversationCobrowseEventTopicCobrowseMediaParticipant]?
    public var otherMediaUris: [String]?
    public var address: String?
    public var utilizationLabelId: String?
    public var inactivityTimeout: Date?
    public var divisions: [QueueConversationCobrowseEventTopicConversationDivisionMembership]?

    public init(_id: String?, name: String?, participants: [QueueConversationCobrowseEventTopicCobrowseMediaParticipant]?, otherMediaUris: [String]?, address: String?, utilizationLabelId: String?, inactivityTimeout: Date?, divisions: [QueueConversationCobrowseEventTopicConversationDivisionMembership]?) {
        self._id = _id
        self.name = name
        self.participants = participants
        self.otherMediaUris = otherMediaUris
        self.address = address
        self.utilizationLabelId = utilizationLabelId
        self.inactivityTimeout = inactivityTimeout
        self.divisions = divisions
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case participants
        case otherMediaUris
        case address
        case utilizationLabelId
        case inactivityTimeout
        case divisions
    }


}




public class QueueConversationCobrowseEventTopicLimit: Codable {



    public enum Namespace: String, Codable { 
        case agentAssistant = "agent.assistant"
        case analyticsAlerting = "analytics.alerting"
        case analytics = "analytics"
        case analyticsRealtime = "analytics.realtime"
        case analyticsReportingSettings = "analytics.reporting.settings"
        case architect = "architect"
        case audiohook = "audiohook"
        case audit = "audit"
        case authApi = "auth.api"
        case authorization = "authorization"
        case automationTesting = "automation.testing"
        case bots = "bots"
        case botsVoice = "bots.voice"
        case callback = "callback"
        case cobrowse = "cobrowse"
        case contentManagement = "content.management"
        case conversation = "conversation"
        case dataactions = "dataactions"
        case datatables = "datatables"
        case directory = "directory"
        case email = "email"
        case eventOrchestration = "event.orchestration"
        case externalContacts = "external.contacts"
        case gcv = "gcv"
        case gdpr = "gdpr"
        case groups = "groups"
        case historicalAdherence = "historical.adherence"
        case infrastructureascode = "infrastructureascode"
        case integrations = "integrations"
        case intentMiner = "intent.miner"
        case journey = "journey"
        case knowledge = "knowledge"
        case languageUnderstanding = "language.understanding"
        case learning = "learning"
        case limitRegistry = "limit.registry"
        case marketplace = "marketplace"
        case mediaCommunications = "media.communications"
        case messaging = "messaging"
        case notifications = "notifications"
        case onboarding = "onboarding"
        case outbound = "outbound"
        case platformApi = "platform.api"
        case predictiveRouting = "predictive.routing"
        case presence = "presence"
        case quality = "quality"
        case recording = "recording"
        case responseManagement = "response.management"
        case routing = "routing"
        case scim = "scim"
        case search = "search"
        case secondaryAutomationTesting = "secondary.automation.testing"
        case skills = "skills"
        case speechAndTextAnalytics = "speech.and.text.analytics"
        case speechIntegration = "speech.integration"
        case supportability = "supportability"
        case taskManagement = "task.management"
        case telephonyConfiguration = "telephony.configuration"
        case usage = "usage"
        case users = "users"
        case webDeployments = "web.deployments"
        case webMessaging = "web.messaging"
        case webchat = "webchat"
        case webhooks = "webhooks"
        case workforceManagement = "workforce.management"
    }





    public var key: String?
    public var namespace: Namespace?
    public var value: Int64?
    public var documented: Bool?

    public init(key: String?, namespace: Namespace?, value: Int64?, documented: Bool?) {
        self.key = key
        self.namespace = namespace
        self.value = value
        self.documented = documented
    }


}




public class QueueConversationCobrowseEventTopicQueueMediaSettings: Codable {









    /** Specifies how long the agent has to answer an interaction before being marked as not responding. */
    public var alertingTimeoutSeconds: Int64?
    /** Specifies the duration of the alerting sound to be played for auto answered interactions. */
    public var autoAnswerAlertToneSeconds: Double?
    /** Specifies the duration of the alerting sound to be played for manually answered interactions */
    public var manualAnswerAlertToneSeconds: Double?
    /** Flag to indicate if auto answer is enabled for the given media type or media subtype. */
    public var enableAutoAnswer: Bool?

    public init(alertingTimeoutSeconds: Int64?, autoAnswerAlertToneSeconds: Double?, manualAnswerAlertToneSeconds: Double?, enableAutoAnswer: Bool?) {
        self.alertingTimeoutSeconds = alertingTimeoutSeconds
        self.autoAnswerAlertToneSeconds = autoAnswerAlertToneSeconds
        self.manualAnswerAlertToneSeconds = manualAnswerAlertToneSeconds
        self.enableAutoAnswer = enableAutoAnswer
    }


}




public class QueueConversationEmailEventTopicDivisionEntityRef: Codable {







    public var _id: String?
    public var selfUri: String?
    /** The time the entity division was last updated. */
    public var dateDivisionUpdated: Date?

    public init(_id: String?, selfUri: String?, dateDivisionUpdated: Date?) {
        self._id = _id
        self.selfUri = selfUri
        self.dateDivisionUpdated = dateDivisionUpdated
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
        case dateDivisionUpdated
    }


}




public class QueueConversationEmailEventTopicEmailMediaParticipant: Codable {

















    public enum State: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case converting = "converting"
        case uploading = "uploading"
        case transmitting = "transmitting"
        case scheduled = "scheduled"
        case parked = "parked"
        case _none = "none"
    }

    public enum InitialState: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case converting = "converting"
        case uploading = "uploading"
        case transmitting = "transmitting"
        case scheduled = "scheduled"
        case parked = "parked"
        case _none = "none"
    }

    public enum Direction: String, Codable { 
        case inbound = "inbound"
        case outbound = "outbound"
    }

    public enum DisconnectType: String, Codable { 
        case endpoint = "endpoint"
        case endpointDnd = "endpoint.dnd"
        case client = "client"
        case system = "system"
        case transfer = "transfer"
        case timeout = "timeout"
        case transferConference = "transfer.conference"
        case transferConsult = "transfer.consult"
        case transferForward = "transfer.forward"
        case transferNoanswer = "transfer.noanswer"
        case transferNotavailable = "transfer.notavailable"
        case transferDnd = "transfer.dnd"
        case transportFailure = "transport.failure"
        case error = "error"
        case peer = "peer"
        case other = "other"
        case spam = "spam"
        case uncallable = "uncallable"
        case inactivity = "inactivity"
        case sessionExpired = "session.expired"
    }









































    public enum FlaggedReason: String, Codable { 
        case general = "general"
    }



























    public var _id: String?
    public var name: String?
    public var address: String?
    public var startTime: Date?
    public var connectedTime: Date?
    public var endTime: Date?
    public var startHoldTime: Date?
    public var purpose: String?
    public var state: State?
    public var initialState: InitialState?
    public var direction: Direction?
    public var disconnectType: DisconnectType?
    public var held: Bool?
    public var wrapupRequired: Bool?
    public var wrapupPrompt: String?
    public var user: QueueConversationEmailEventTopicUriReference?
    public var queue: QueueConversationEmailEventTopicUriReference?
    public var team: QueueConversationEmailEventTopicUriReference?
    public var attributes: [String:String]?
    public var errorInfo: QueueConversationEmailEventTopicErrorBody?
    public var script: QueueConversationEmailEventTopicUriReference?
    public var wrapupTimeoutMs: Int64?
    public var wrapupSkipped: Bool?
    public var alertingTimeoutMs: Int64?
    public var provider: String?
    public var externalContact: QueueConversationEmailEventTopicUriReference?
    public var externalContactInitialDivisionId: String?
    public var externalOrganization: QueueConversationEmailEventTopicUriReference?
    public var wrapup: QueueConversationEmailEventTopicWrapup?
    public var conversationRoutingData: QueueConversationEmailEventTopicConversationRoutingData?
    public var peer: String?
    public var screenRecordingState: String?
    public var flaggedReason: FlaggedReason?
    public var journeyContext: QueueConversationEmailEventTopicJourneyContext?
    public var startAcwTime: Date?
    public var endAcwTime: Date?
    public var resumeTime: Date?
    public var parkTime: Date?
    public var mediaRoles: [String]?
    public var queueMediaSettings: QueueConversationEmailEventTopicQueueMediaSettings?
    public var subject: String?
    public var messagesSent: Int64?
    public var autoGenerated: Bool?
    public var messageId: String?
    public var draftAttachments: [QueueConversationEmailEventTopicAttachment]?
    public var spam: Bool?

    public init(_id: String?, name: String?, address: String?, startTime: Date?, connectedTime: Date?, endTime: Date?, startHoldTime: Date?, purpose: String?, state: State?, initialState: InitialState?, direction: Direction?, disconnectType: DisconnectType?, held: Bool?, wrapupRequired: Bool?, wrapupPrompt: String?, user: QueueConversationEmailEventTopicUriReference?, queue: QueueConversationEmailEventTopicUriReference?, team: QueueConversationEmailEventTopicUriReference?, attributes: [String:String]?, errorInfo: QueueConversationEmailEventTopicErrorBody?, script: QueueConversationEmailEventTopicUriReference?, wrapupTimeoutMs: Int64?, wrapupSkipped: Bool?, alertingTimeoutMs: Int64?, provider: String?, externalContact: QueueConversationEmailEventTopicUriReference?, externalContactInitialDivisionId: String?, externalOrganization: QueueConversationEmailEventTopicUriReference?, wrapup: QueueConversationEmailEventTopicWrapup?, conversationRoutingData: QueueConversationEmailEventTopicConversationRoutingData?, peer: String?, screenRecordingState: String?, flaggedReason: FlaggedReason?, journeyContext: QueueConversationEmailEventTopicJourneyContext?, startAcwTime: Date?, endAcwTime: Date?, resumeTime: Date?, parkTime: Date?, mediaRoles: [String]?, queueMediaSettings: QueueConversationEmailEventTopicQueueMediaSettings?, subject: String?, messagesSent: Int64?, autoGenerated: Bool?, messageId: String?, draftAttachments: [QueueConversationEmailEventTopicAttachment]?, spam: Bool?) {
        self._id = _id
        self.name = name
        self.address = address
        self.startTime = startTime
        self.connectedTime = connectedTime
        self.endTime = endTime
        self.startHoldTime = startHoldTime
        self.purpose = purpose
        self.state = state
        self.initialState = initialState
        self.direction = direction
        self.disconnectType = disconnectType
        self.held = held
        self.wrapupRequired = wrapupRequired
        self.wrapupPrompt = wrapupPrompt
        self.user = user
        self.queue = queue
        self.team = team
        self.attributes = attributes
        self.errorInfo = errorInfo
        self.script = script
        self.wrapupTimeoutMs = wrapupTimeoutMs
        self.wrapupSkipped = wrapupSkipped
        self.alertingTimeoutMs = alertingTimeoutMs
        self.provider = provider
        self.externalContact = externalContact
        self.externalContactInitialDivisionId = externalContactInitialDivisionId
        self.externalOrganization = externalOrganization
        self.wrapup = wrapup
        self.conversationRoutingData = conversationRoutingData
        self.peer = peer
        self.screenRecordingState = screenRecordingState
        self.flaggedReason = flaggedReason
        self.journeyContext = journeyContext
        self.startAcwTime = startAcwTime
        self.endAcwTime = endAcwTime
        self.resumeTime = resumeTime
        self.parkTime = parkTime
        self.mediaRoles = mediaRoles
        self.queueMediaSettings = queueMediaSettings
        self.subject = subject
        self.messagesSent = messagesSent
        self.autoGenerated = autoGenerated
        self.messageId = messageId
        self.draftAttachments = draftAttachments
        self.spam = spam
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case address
        case startTime
        case connectedTime
        case endTime
        case startHoldTime
        case purpose
        case state
        case initialState
        case direction
        case disconnectType
        case held
        case wrapupRequired
        case wrapupPrompt
        case user
        case queue
        case team
        case attributes
        case errorInfo
        case script
        case wrapupTimeoutMs
        case wrapupSkipped
        case alertingTimeoutMs
        case provider
        case externalContact
        case externalContactInitialDivisionId
        case externalOrganization
        case wrapup
        case conversationRoutingData
        case peer
        case screenRecordingState
        case flaggedReason
        case journeyContext
        case startAcwTime
        case endAcwTime
        case resumeTime
        case parkTime
        case mediaRoles
        case queueMediaSettings
        case subject
        case messagesSent
        case autoGenerated
        case messageId
        case draftAttachments
        case spam
    }


}



/** A subset of the Journey System's action data relevant to a part of a conversation (for external linkage and internal usage/context) */

public class QueueConversationEmailEventTopicJourneyAction: Codable {





    /** The ID of an action from the Journey System (an action is spawned from an actionMap) */
    public var _id: String?
    public var actionMap: QueueConversationEmailEventTopicJourneyActionMap?

    public init(_id: String?, actionMap: QueueConversationEmailEventTopicJourneyActionMap?) {
        self._id = _id
        self.actionMap = actionMap
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case actionMap
    }


}




public class QueueConversationEmailEventTopicJourneyContext: Codable {







    public var customer: QueueConversationEmailEventTopicJourneyCustomer?
    public var customerSession: QueueConversationEmailEventTopicJourneyCustomerSession?
    public var triggeringAction: QueueConversationEmailEventTopicJourneyAction?

    public init(customer: QueueConversationEmailEventTopicJourneyCustomer?, customerSession: QueueConversationEmailEventTopicJourneyCustomerSession?, triggeringAction: QueueConversationEmailEventTopicJourneyAction?) {
        self.customer = customer
        self.customerSession = customerSession
        self.triggeringAction = triggeringAction
    }


}




public class QueueConversationEmailEventTopicWrapup: Codable {











    /** The user configured wrap up code name. */
    public var code: String?
    /** Text entered by the agent to describe the call or disposition. */
    public var notes: String?
    /** List of tags selected by the agent to describe the call or disposition. */
    public var tags: [String]?
    /** The length of time in seconds that the agent spent doing after call work., Note, the format of utc-millisec should be ignored, our code generator needs it to generate a Long for us internally */
    public var durationSeconds: Int64?
    /** The timestamp when the wrapup was finished. */
    public var endTime: Date?

    public init(code: String?, notes: String?, tags: [String]?, durationSeconds: Int64?, endTime: Date?) {
        self.code = code
        self.notes = notes
        self.tags = tags
        self.durationSeconds = durationSeconds
        self.endTime = endTime
    }


}



/** A communication's after-call work data. */

public class QueueConversationEventTopicAfterCallWork: Codable {

    public enum State: String, Codable { 
        case unknown = "unknown"
        case skipped = "skipped"
        case pending = "pending"
        case complete = "complete"
        case notapplicable = "notApplicable"
    }





    /** The communication's after-call work state. */
    public var state: State?
    /** The timestamp when this communication started after-call work in the cloud clock. */
    public var startTime: Date?
    /** The timestamp when this communication ended after-call work in the cloud clock. */
    public var endTime: Date?

    public init(state: State?, startTime: Date?, endTime: Date?) {
        self.state = state
        self.startTime = startTime
        self.endTime = endTime
    }


}



/** Information on how a communication should be routed to an agent. */

public class QueueConversationEventTopicConversationRoutingData: Codable {











    public var queue: QueueConversationEventTopicUriReference?
    /** A UriReference for a resource */
    public var language: QueueConversationEventTopicUriReference?
    /** The priority of the conversation to use for routing decisions */
    public var priority: Int64?
    /** The skills to use for routing decisions */
    public var skills: [QueueConversationEventTopicUriReference]?
    /** A collection of agents and their assigned scores for this conversation (0 - 100, higher being better), for use in routing to preferred agents */
    public var scoredAgents: [QueueConversationEventTopicScoredAgent]?

    public init(queue: QueueConversationEventTopicUriReference?, language: QueueConversationEventTopicUriReference?, priority: Int64?, skills: [QueueConversationEventTopicUriReference]?, scoredAgents: [QueueConversationEventTopicScoredAgent]?) {
        self.queue = queue
        self.language = language
        self.priority = priority
        self.skills = skills
        self.scoredAgents = scoredAgents
    }


}



/** A reference to another domain entity. */

public class QueueConversationEventTopicDomainEntityRef: Codable {





    public var _id: String?
    public var selfUri: String?

    public init(_id: String?, selfUri: String?) {
        self._id = _id
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
    }


}



/** Detailed information about an error response. */

public class QueueConversationEventTopicErrorDetails: Codable {















    /** The HTTP status code for this message (400, 401, 403, 404, 500, etc. */
    public var status: Int64?
    /** A code unique to this error. */
    public var code: String?
    /** Friendly description of this error. */
    public var message: String?
    /** This is the same as message except it uses template fields for variable replacement. For instance: 'User {username} was not found' */
    public var messageWithParams: String?
    /** Used in conjunction with messageWithParams. These are the template parameters. For instance: UserParam.key = 'username', UserParam.value = 'john.doe' */
    public var messageParams: [String:String]?
    /** The correlation Id or context Id for this message. If left blank the Public API will look at the HTTP response header 'ININ-Correlation-Id' instead. */
    public var contextId: String?
    public var uri: String?

    public init(status: Int64?, code: String?, message: String?, messageWithParams: String?, messageParams: [String:String]?, contextId: String?, uri: String?) {
        self.status = status
        self.code = code
        self.message = message
        self.messageWithParams = messageWithParams
        self.messageParams = messageParams
        self.contextId = contextId
        self.uri = uri
    }


}




public class QueueConversationEventTopicScreenShare: Codable {

    public enum State: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case _none = "none"
    }

    public enum InitialState: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case _none = "none"
    }

















    public enum DisconnectType: String, Codable { 
        case endpoint = "endpoint"
        case endpointDnd = "endpoint.dnd"
        case client = "client"
        case system = "system"
        case timeout = "timeout"
        case transfer = "transfer"
        case transferConference = "transfer.conference"
        case transferConsult = "transfer.consult"
        case transferForward = "transfer.forward"
        case transferNoanswer = "transfer.noanswer"
        case transferNotavailable = "transfer.notavailable"
        case transferDnd = "transfer.dnd"
        case transportFailure = "transport.failure"
        case error = "error"
        case peer = "peer"
        case other = "other"
        case spam = "spam"
        case uncallable = "uncallable"
    }













    public var state: State?
    public var initialState: InitialState?
    /** Address and name data for a call endpoint. */
    public var _self: QueueConversationEventTopicAddress?
    /** A globally unique identifier for this communication. */
    public var _id: String?
    /** The room id context (xmpp jid) for the conference session. */
    public var context: String?
    /** Indicates whether this participant is sharing their screen to the session. */
    public var sharing: Bool?
    /** The source provider of the screen share. */
    public var provider: String?
    /** The UUID of the script to use. */
    public var scriptId: String?
    /** The id of the peer communication corresponding to a matching leg for this communication. */
    public var peerId: String?
    /** The number of peer participants from the perspective of the participant in the conference. */
    public var peerCount: Int64?
    /** System defined string indicating what caused the communication to disconnect. Will be null until the communication disconnects. */
    public var disconnectType: DisconnectType?
    /** The timestamp when this communication was connected in the cloud clock. */
    public var connectedTime: Date?
    /** The timestamp when this communication disconnected from the conversation in the provider clock. */
    public var disconnectedTime: Date?
    /** Call wrap up or disposition data. */
    public var wrapup: QueueConversationEventTopicWrapup?
    /** A communication's after-call work data. */
    public var afterCallWork: QueueConversationEventTopicAfterCallWork?
    /** Indicates if after-call is required for a communication. Only used when the ACW Setting is Agent Requested. */
    public var afterCallWorkRequired: Bool?
    /** Represents the queue setting for this media. */
    public var queueMediaSettings: QueueConversationEventTopicQueueMediaSettings?

    public init(state: State?, initialState: InitialState?, _self: QueueConversationEventTopicAddress?, _id: String?, context: String?, sharing: Bool?, provider: String?, scriptId: String?, peerId: String?, peerCount: Int64?, disconnectType: DisconnectType?, connectedTime: Date?, disconnectedTime: Date?, wrapup: QueueConversationEventTopicWrapup?, afterCallWork: QueueConversationEventTopicAfterCallWork?, afterCallWorkRequired: Bool?, queueMediaSettings: QueueConversationEventTopicQueueMediaSettings?) {
        self.state = state
        self.initialState = initialState
        self._self = _self
        self._id = _id
        self.context = context
        self.sharing = sharing
        self.provider = provider
        self.scriptId = scriptId
        self.peerId = peerId
        self.peerCount = peerCount
        self.disconnectType = disconnectType
        self.connectedTime = connectedTime
        self.disconnectedTime = disconnectedTime
        self.wrapup = wrapup
        self.afterCallWork = afterCallWork
        self.afterCallWorkRequired = afterCallWorkRequired
        self.queueMediaSettings = queueMediaSettings
    }

    public enum CodingKeys: String, CodingKey { 
        case state
        case initialState
        case _self = "self"
        case _id = "id"
        case context
        case sharing
        case provider
        case scriptId
        case peerId
        case peerCount
        case disconnectType
        case connectedTime
        case disconnectedTime
        case wrapup
        case afterCallWork
        case afterCallWorkRequired
        case queueMediaSettings
    }


}




public class QueueConversationMessageEventTopicConversationDivisionMembership: Codable {





    public var division: QueueConversationMessageEventTopicDomainEntityRef?
    public var entities: [QueueConversationMessageEventTopicDivisionEntityRef]?

    public init(division: QueueConversationMessageEventTopicDomainEntityRef?, entities: [QueueConversationMessageEventTopicDivisionEntityRef]?) {
        self.division = division
        self.entities = entities
    }


}



/** A subset of the Journey System's customer data at a point-in-time (for external linkage and internal usage/context) */

public class QueueConversationMessageEventTopicJourneyCustomer: Codable {





    /** An ID of a customer within the Journey System at a point-in-time.  Note that a customer entity can have multiple customerIds based on the stitching process.  Depending on the context within the PureCloud conversation, this may or may not be mutable. */
    public var _id: String?
    /** The type of the customerId within the Journey System (e.g. cookie). */
    public var idType: String?

    public init(_id: String?, idType: String?) {
        self._id = _id
        self.idType = idType
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case idType
    }


}



/** A subset of the Journey System's tracked customer session data at a point-in-time (for external linkage and internal usage/context) */

public class QueueConversationMessageEventTopicJourneyCustomerSession: Codable {





    /** An ID of a Customer/User's session within the Journey System at a point-in-time */
    public var _id: String?
    /** The type of the Customer/User's session within the Journey System (e.g. web, app) */
    public var type: String?

    public init(_id: String?, type: String?) {
        self._id = _id
        self.type = type
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case type
    }


}




public class QueueConversationMessageEventTopicScoredAgent: Codable {





    /** A UriReference for a resource */
    public var agent: QueueConversationMessageEventTopicUriReference?
    /** Agent's score for the current conversation, from 0 - 100, higher being better */
    public var score: Int64?

    public init(agent: QueueConversationMessageEventTopicUriReference?, score: Int64?) {
        self.agent = agent
        self.score = score
    }


}




public class QueueConversationScreenShareEventTopicDetail: Codable {









    public var errorCode: String?
    public var fieldName: String?
    public var entityId: String?
    public var entityName: String?

    public init(errorCode: String?, fieldName: String?, entityId: String?, entityName: String?) {
        self.errorCode = errorCode
        self.fieldName = fieldName
        self.entityId = entityId
        self.entityName = entityName
    }


}




public class QueueConversationScreenShareEventTopicErrorBody: Codable {























    public var message: String?
    public var code: String?
    public var status: Int64?
    public var entityId: String?
    public var entityName: String?
    public var messageWithParams: String?
    public var messageParams: [String:String]?
    public var contextId: String?
    public var details: [QueueConversationScreenShareEventTopicDetail]?
    public var errors: [QueueConversationScreenShareEventTopicErrorBody]?
    public var limit: QueueConversationScreenShareEventTopicLimit?

    public init(message: String?, code: String?, status: Int64?, entityId: String?, entityName: String?, messageWithParams: String?, messageParams: [String:String]?, contextId: String?, details: [QueueConversationScreenShareEventTopicDetail]?, errors: [QueueConversationScreenShareEventTopicErrorBody]?, limit: QueueConversationScreenShareEventTopicLimit?) {
        self.message = message
        self.code = code
        self.status = status
        self.entityId = entityId
        self.entityName = entityName
        self.messageWithParams = messageWithParams
        self.messageParams = messageParams
        self.contextId = contextId
        self.details = details
        self.errors = errors
        self.limit = limit
    }


}



/** Details about the action map from the Journey System which triggered this action */

public class QueueConversationScreenShareEventTopicJourneyActionMap: Codable {





    /** The ID of the actionMap in the Journey System which triggered this action */
    public var _id: String?
    /** The version number of the actionMap in the Journey System at the time this action was triggered */
    public var version: Int64?

    public init(_id: String?, version: Int64?) {
        self._id = _id
        self.version = version
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case version
    }


}




public class QueueConversationScreenShareEventTopicUriReference: Codable {





    /** The ID of the resource */
    public var _id: String?
    /** The name of the resource */
    public var name: String?

    public init(_id: String?, name: String?) {
        self._id = _id
        self.name = name
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
    }


}



/** A communication's after-call work data. */

public class QueueConversationSocialExpressionEventTopicAfterCallWork: Codable {

    public enum State: String, Codable { 
        case unknown = "unknown"
        case skipped = "skipped"
        case pending = "pending"
        case complete = "complete"
        case notapplicable = "notApplicable"
    }





    /** The communication's after-call work state. */
    public var state: State?
    /** The timestamp when this communication started after-call work in the cloud clock. */
    public var startTime: Date?
    /** The timestamp when this communication ended after-call work in the cloud clock. */
    public var endTime: Date?

    public init(state: State?, startTime: Date?, endTime: Date?) {
        self.state = state
        self.startTime = startTime
        self.endTime = endTime
    }


}



/** Information on how a communication should be routed to an agent. */

public class QueueConversationSocialExpressionEventTopicConversationRoutingData: Codable {











    public var queue: QueueConversationSocialExpressionEventTopicUriReference?
    /** A UriReference for a resource */
    public var language: QueueConversationSocialExpressionEventTopicUriReference?
    /** The priority of the conversation to use for routing decisions */
    public var priority: Int64?
    /** The skills to use for routing decisions */
    public var skills: [QueueConversationSocialExpressionEventTopicUriReference]?
    /** A collection of agents and their assigned scores for this conversation (0 - 100, higher being better), for use in routing to preferred agents */
    public var scoredAgents: [QueueConversationSocialExpressionEventTopicScoredAgent]?

    public init(queue: QueueConversationSocialExpressionEventTopicUriReference?, language: QueueConversationSocialExpressionEventTopicUriReference?, priority: Int64?, skills: [QueueConversationSocialExpressionEventTopicUriReference]?, scoredAgents: [QueueConversationSocialExpressionEventTopicScoredAgent]?) {
        self.queue = queue
        self.language = language
        self.priority = priority
        self.skills = skills
        self.scoredAgents = scoredAgents
    }


}



/** A reference to another domain entity. */

public class QueueConversationSocialExpressionEventTopicDomainEntityRef: Codable {





    public var _id: String?
    public var selfUri: String?

    public init(_id: String?, selfUri: String?) {
        self._id = _id
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
    }


}



/** Detailed information about an error response. */

public class QueueConversationSocialExpressionEventTopicErrorDetails: Codable {















    /** The HTTP status code for this message (400, 401, 403, 404, 500, etc. */
    public var status: Int64?
    /** A code unique to this error. */
    public var code: String?
    /** Friendly description of this error. */
    public var message: String?
    /** This is the same as message except it uses template fields for variable replacement. For instance: 'User {username} was not found' */
    public var messageWithParams: String?
    /** Used in conjunction with messageWithParams. These are the template parameters. For instance: UserParam.key = 'username', UserParam.value = 'john.doe' */
    public var messageParams: [String:String]?
    /** The correlation Id or context Id for this message. If left blank the Public API will look at the HTTP response header 'ININ-Correlation-Id' instead. */
    public var contextId: String?
    public var uri: String?

    public init(status: Int64?, code: String?, message: String?, messageWithParams: String?, messageParams: [String:String]?, contextId: String?, uri: String?) {
        self.status = status
        self.code = code
        self.message = message
        self.messageWithParams = messageWithParams
        self.messageParams = messageParams
        self.contextId = contextId
        self.uri = uri
    }


}




public class QueueConversationSocialExpressionEventTopicScreenShare: Codable {

    public enum State: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case _none = "none"
    }

    public enum InitialState: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case _none = "none"
    }

















    public enum DisconnectType: String, Codable { 
        case endpoint = "endpoint"
        case endpointDnd = "endpoint.dnd"
        case client = "client"
        case system = "system"
        case timeout = "timeout"
        case transfer = "transfer"
        case transferConference = "transfer.conference"
        case transferConsult = "transfer.consult"
        case transferForward = "transfer.forward"
        case transferNoanswer = "transfer.noanswer"
        case transferNotavailable = "transfer.notavailable"
        case transferDnd = "transfer.dnd"
        case transportFailure = "transport.failure"
        case error = "error"
        case peer = "peer"
        case other = "other"
        case spam = "spam"
        case uncallable = "uncallable"
    }













    public var state: State?
    public var initialState: InitialState?
    /** Address and name data for a call endpoint. */
    public var _self: QueueConversationSocialExpressionEventTopicAddress?
    /** A globally unique identifier for this communication. */
    public var _id: String?
    /** The room id context (xmpp jid) for the conference session. */
    public var context: String?
    /** Indicates whether this participant is sharing their screen to the session. */
    public var sharing: Bool?
    /** The source provider of the screen share. */
    public var provider: String?
    /** The UUID of the script to use. */
    public var scriptId: String?
    /** The id of the peer communication corresponding to a matching leg for this communication. */
    public var peerId: String?
    /** The number of peer participants from the perspective of the participant in the conference. */
    public var peerCount: Int64?
    /** System defined string indicating what caused the communication to disconnect. Will be null until the communication disconnects. */
    public var disconnectType: DisconnectType?
    /** The timestamp when this communication was connected in the cloud clock. */
    public var connectedTime: Date?
    /** The timestamp when this communication disconnected from the conversation in the provider clock. */
    public var disconnectedTime: Date?
    /** Call wrap up or disposition data. */
    public var wrapup: QueueConversationSocialExpressionEventTopicWrapup?
    /** A communication's after-call work data. */
    public var afterCallWork: QueueConversationSocialExpressionEventTopicAfterCallWork?
    /** Indicates if after-call is required for a communication. Only used when the ACW Setting is Agent Requested. */
    public var afterCallWorkRequired: Bool?
    /** Represents the queue setting for this media. */
    public var queueMediaSettings: QueueConversationSocialExpressionEventTopicQueueMediaSettings?

    public init(state: State?, initialState: InitialState?, _self: QueueConversationSocialExpressionEventTopicAddress?, _id: String?, context: String?, sharing: Bool?, provider: String?, scriptId: String?, peerId: String?, peerCount: Int64?, disconnectType: DisconnectType?, connectedTime: Date?, disconnectedTime: Date?, wrapup: QueueConversationSocialExpressionEventTopicWrapup?, afterCallWork: QueueConversationSocialExpressionEventTopicAfterCallWork?, afterCallWorkRequired: Bool?, queueMediaSettings: QueueConversationSocialExpressionEventTopicQueueMediaSettings?) {
        self.state = state
        self.initialState = initialState
        self._self = _self
        self._id = _id
        self.context = context
        self.sharing = sharing
        self.provider = provider
        self.scriptId = scriptId
        self.peerId = peerId
        self.peerCount = peerCount
        self.disconnectType = disconnectType
        self.connectedTime = connectedTime
        self.disconnectedTime = disconnectedTime
        self.wrapup = wrapup
        self.afterCallWork = afterCallWork
        self.afterCallWorkRequired = afterCallWorkRequired
        self.queueMediaSettings = queueMediaSettings
    }

    public enum CodingKeys: String, CodingKey { 
        case state
        case initialState
        case _self = "self"
        case _id = "id"
        case context
        case sharing
        case provider
        case scriptId
        case peerId
        case peerCount
        case disconnectType
        case connectedTime
        case disconnectedTime
        case wrapup
        case afterCallWork
        case afterCallWorkRequired
        case queueMediaSettings
    }


}




public class QueueConversationVideoEventTopicChat: Codable {

    public enum State: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case _none = "none"
    }

    public enum InitialState: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case _none = "none"
    }















    public enum DisconnectType: String, Codable { 
        case endpoint = "endpoint"
        case endpointDnd = "endpoint.dnd"
        case client = "client"
        case system = "system"
        case timeout = "timeout"
        case transfer = "transfer"
        case transferConference = "transfer.conference"
        case transferConsult = "transfer.consult"
        case transferForward = "transfer.forward"
        case transferNoanswer = "transfer.noanswer"
        case transferNotavailable = "transfer.notavailable"
        case transferDnd = "transfer.dnd"
        case transportFailure = "transport.failure"
        case error = "error"
        case peer = "peer"
        case other = "other"
        case spam = "spam"
        case uncallable = "uncallable"
    }

















    public var state: State?
    public var initialState: InitialState?
    /** A globally unique identifier for this communication. */
    public var _id: String?
    /** The source provider of the chat. */
    public var provider: String?
    /** The UUID of the script to use. */
    public var scriptId: String?
    /** The id of the peer communication corresponding to a matching leg for this communication. */
    public var peerId: String?
    /** The room id for the chat. */
    public var roomId: String?
    /** The avatar for the chat (if available). */
    public var avatarImageUrl: String?
    /** True if this call is held and the person on this side hears silence. */
    public var held: Bool?
    /** System defined string indicating what caused the communication to disconnect. Will be null until the communication disconnects. */
    public var disconnectType: DisconnectType?
    /** The timestamp the chat was placed on hold in the cloud clock if the chat is currently on hold. */
    public var startHoldTime: Date?
    /** The timestamp when this communication was connected in the cloud clock. */
    public var connectedTime: Date?
    /** The timestamp when this communication disconnected from the conversation in the provider clock. */
    public var disconnectedTime: Date?
    public var journeyContext: QueueConversationVideoEventTopicJourneyContext?
    /** Call wrap up or disposition data. */
    public var wrapup: QueueConversationVideoEventTopicWrapup?
    /** A communication's after-call work data. */
    public var afterCallWork: QueueConversationVideoEventTopicAfterCallWork?
    /** Indicates if after-call is required for a communication. Only used when the ACW Setting is Agent Requested. */
    public var afterCallWorkRequired: Bool?
    /** Represents the queue setting for this media. */
    public var queueMediaSettings: QueueConversationVideoEventTopicQueueMediaSettings?

    public init(state: State?, initialState: InitialState?, _id: String?, provider: String?, scriptId: String?, peerId: String?, roomId: String?, avatarImageUrl: String?, held: Bool?, disconnectType: DisconnectType?, startHoldTime: Date?, connectedTime: Date?, disconnectedTime: Date?, journeyContext: QueueConversationVideoEventTopicJourneyContext?, wrapup: QueueConversationVideoEventTopicWrapup?, afterCallWork: QueueConversationVideoEventTopicAfterCallWork?, afterCallWorkRequired: Bool?, queueMediaSettings: QueueConversationVideoEventTopicQueueMediaSettings?) {
        self.state = state
        self.initialState = initialState
        self._id = _id
        self.provider = provider
        self.scriptId = scriptId
        self.peerId = peerId
        self.roomId = roomId
        self.avatarImageUrl = avatarImageUrl
        self.held = held
        self.disconnectType = disconnectType
        self.startHoldTime = startHoldTime
        self.connectedTime = connectedTime
        self.disconnectedTime = disconnectedTime
        self.journeyContext = journeyContext
        self.wrapup = wrapup
        self.afterCallWork = afterCallWork
        self.afterCallWorkRequired = afterCallWorkRequired
        self.queueMediaSettings = queueMediaSettings
    }

    public enum CodingKeys: String, CodingKey { 
        case state
        case initialState
        case _id = "id"
        case provider
        case scriptId
        case peerId
        case roomId
        case avatarImageUrl
        case held
        case disconnectType
        case startHoldTime
        case connectedTime
        case disconnectedTime
        case journeyContext
        case wrapup
        case afterCallWork
        case afterCallWorkRequired
        case queueMediaSettings
    }


}



/** Silent Call timeout configuration. */

public class QueueConversationVideoEventTopicDispositionSilentCallTimeout: Codable {







    /** Configured Silent Call timeout value. */
    public var timeoutMs: Int64?
    /** Timer start time, measured in epoch milliseconds. */
    public var timerStartTime: Double?
    /** Timer end time, measured in epoch milliseconds. */
    public var timerEndTime: Double?

    public init(timeoutMs: Int64?, timerStartTime: Double?, timerEndTime: Double?) {
        self.timeoutMs = timeoutMs
        self.timerStartTime = timerStartTime
        self.timerEndTime = timerEndTime
    }


}




public class QueueConversationVideoEventTopicDivisionEntityRef: Codable {







    public var _id: String?
    public var selfUri: String?
    /** The time the entity division was last updated. */
    public var dateDivisionUpdated: Date?

    public init(_id: String?, selfUri: String?, dateDivisionUpdated: Date?) {
        self._id = _id
        self.selfUri = selfUri
        self.dateDivisionUpdated = dateDivisionUpdated
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
        case dateDivisionUpdated
    }


}



/** A subset of the Journey System's action data relevant to a part of a conversation (for external linkage and internal usage/context) */

public class QueueConversationVideoEventTopicJourneyAction: Codable {





    /** The ID of an action from the Journey System (an action is spawned from an actionMap) */
    public var _id: String?
    public var actionMap: QueueConversationVideoEventTopicJourneyActionMap?

    public init(_id: String?, actionMap: QueueConversationVideoEventTopicJourneyActionMap?) {
        self._id = _id
        self.actionMap = actionMap
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case actionMap
    }


}



/** A subset of the Journey System's data relevant to a part of a conversation (for external linkage and internal usage/context). */

public class QueueConversationVideoEventTopicJourneyContext: Codable {







    public var customer: QueueConversationVideoEventTopicJourneyCustomer?
    public var customerSession: QueueConversationVideoEventTopicJourneyCustomerSession?
    public var triggeringAction: QueueConversationVideoEventTopicJourneyAction?

    public init(customer: QueueConversationVideoEventTopicJourneyCustomer?, customerSession: QueueConversationVideoEventTopicJourneyCustomerSession?, triggeringAction: QueueConversationVideoEventTopicJourneyAction?) {
        self.customer = customer
        self.customerSession = customerSession
        self.triggeringAction = triggeringAction
    }


}




public class QueueConversationVideoEventTopicMessage: Codable {



    public enum State: String, Codable { 
        case alerting = "alerting"
        case connected = "connected"
        case disconnected = "disconnected"
    }

    public enum InitialState: String, Codable { 
        case alerting = "alerting"
        case connected = "connected"
        case disconnected = "disconnected"
    }

    public enum Direction: String, Codable { 
        case outbound = "outbound"
        case inbound = "inbound"
    }











    public enum DisconnectType: String, Codable { 
        case endpoint = "endpoint"
        case endpointDnd = "endpoint.dnd"
        case client = "client"
        case system = "system"
        case timeout = "timeout"
        case transfer = "transfer"
        case transferConference = "transfer.conference"
        case transferConsult = "transfer.consult"
        case transferForward = "transfer.forward"
        case transferNoanswer = "transfer.noanswer"
        case transferNotavailable = "transfer.notavailable"
        case transferDnd = "transfer.dnd"
        case transportFailure = "transport.failure"
        case error = "error"
        case peer = "peer"
        case other = "other"
        case spam = "spam"
        case uncallable = "uncallable"
        case inactivity = "inactivity"
        case sessionExpired = "session.expired"
    }















    public enum ModelType: String, Codable { 
        case unknown = "unknown"
        case sms = "sms"
        case twitter = "twitter"
        case facebook = "facebook"
        case line = "line"
        case viber = "viber"
        case wechat = "wechat"
        case whatsapp = "whatsapp"
        case telegram = "telegram"
        case kakao = "kakao"
        case webmessaging = "webmessaging"
        case _open = "open"
        case instagram = "instagram"
        case apple = "apple"
    }





















    /** A globally unique identifier for this communication. */
    public var _id: String?
    public var state: State?
    public var initialState: InitialState?
    /** Whether a message is inbound or outbound. */
    public var direction: Direction?
    /** True if this call is held and the person on this side hears silence. */
    public var held: Bool?
    /** Detailed information about an error response. */
    public var errorInfo: QueueConversationVideoEventTopicErrorDetails?
    /** The source provider of the email. */
    public var provider: String?
    /** The UUID of the script to use. */
    public var scriptId: String?
    /** The id of the peer communication corresponding to a matching leg for this communication. */
    public var peerId: String?
    /** System defined string indicating what caused the communication to disconnect. Will be null until the communication disconnects. */
    public var disconnectType: DisconnectType?
    /** The timestamp the email was placed on hold in the cloud clock if the email is currently on hold. */
    public var startHoldTime: Date?
    /** The timestamp when this communication was connected in the cloud clock. */
    public var connectedTime: Date?
    /** The timestamp when this communication disconnected from the conversation in the provider clock. */
    public var disconnectedTime: Date?
    /** Address and name data for a call endpoint. */
    public var toAddress: QueueConversationVideoEventTopicAddress?
    /** Address and name data for a call endpoint. */
    public var fromAddress: QueueConversationVideoEventTopicAddress?
    /** The messages sent on this communication channel. */
    public var messages: [QueueConversationVideoEventTopicMessageDetails]?
    /** the messages transcript file uri. */
    public var messagesTranscriptUri: String?
    /** Indicates the type of message platform from which the message originated. */
    public var type: ModelType?
    /** Indicates the country where the recipient is associated in ISO 3166-1 alpha-2 format. */
    public var recipientCountry: String?
    /** The type of the recipient. Eg: Provisioned phoneNumber is the recipient for sms message type. */
    public var recipientType: String?
    /** A subset of the Journey System's data relevant to a part of a conversation (for external linkage and internal usage/context). */
    public var journeyContext: QueueConversationVideoEventTopicJourneyContext?
    /** Call wrap up or disposition data. */
    public var wrapup: QueueConversationVideoEventTopicWrapup?
    /** A communication's after-call work data. */
    public var afterCallWork: QueueConversationVideoEventTopicAfterCallWork?
    /** Indicates if after-call is required for a communication. Only used when the ACW Setting is Agent Requested. */
    public var afterCallWorkRequired: Bool?
    /** UUID of virtual agent assistant that provide suggestions to the agent participant during the conversation. */
    public var agentAssistantId: String?
    /** Provide more visibility into what integrations customers are creating with Open Messaging. String values are defined in the Constants.java named ENGAGEMENT_SOURCE_* */
    public var engagementSource: String?
    public var byoSmsIntegrationId: String?
    /** Represents the queue setting for this media. */
    public var queueMediaSettings: QueueConversationVideoEventTopicQueueMediaSettings?

    public init(_id: String?, state: State?, initialState: InitialState?, direction: Direction?, held: Bool?, errorInfo: QueueConversationVideoEventTopicErrorDetails?, provider: String?, scriptId: String?, peerId: String?, disconnectType: DisconnectType?, startHoldTime: Date?, connectedTime: Date?, disconnectedTime: Date?, toAddress: QueueConversationVideoEventTopicAddress?, fromAddress: QueueConversationVideoEventTopicAddress?, messages: [QueueConversationVideoEventTopicMessageDetails]?, messagesTranscriptUri: String?, type: ModelType?, recipientCountry: String?, recipientType: String?, journeyContext: QueueConversationVideoEventTopicJourneyContext?, wrapup: QueueConversationVideoEventTopicWrapup?, afterCallWork: QueueConversationVideoEventTopicAfterCallWork?, afterCallWorkRequired: Bool?, agentAssistantId: String?, engagementSource: String?, byoSmsIntegrationId: String?, queueMediaSettings: QueueConversationVideoEventTopicQueueMediaSettings?) {
        self._id = _id
        self.state = state
        self.initialState = initialState
        self.direction = direction
        self.held = held
        self.errorInfo = errorInfo
        self.provider = provider
        self.scriptId = scriptId
        self.peerId = peerId
        self.disconnectType = disconnectType
        self.startHoldTime = startHoldTime
        self.connectedTime = connectedTime
        self.disconnectedTime = disconnectedTime
        self.toAddress = toAddress
        self.fromAddress = fromAddress
        self.messages = messages
        self.messagesTranscriptUri = messagesTranscriptUri
        self.type = type
        self.recipientCountry = recipientCountry
        self.recipientType = recipientType
        self.journeyContext = journeyContext
        self.wrapup = wrapup
        self.afterCallWork = afterCallWork
        self.afterCallWorkRequired = afterCallWorkRequired
        self.agentAssistantId = agentAssistantId
        self.engagementSource = engagementSource
        self.byoSmsIntegrationId = byoSmsIntegrationId
        self.queueMediaSettings = queueMediaSettings
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case state
        case initialState
        case direction
        case held
        case errorInfo
        case provider
        case scriptId
        case peerId
        case disconnectType
        case startHoldTime
        case connectedTime
        case disconnectedTime
        case toAddress
        case fromAddress
        case messages
        case messagesTranscriptUri
        case type
        case recipientCountry
        case recipientType
        case journeyContext
        case wrapup
        case afterCallWork
        case afterCallWorkRequired
        case agentAssistantId
        case engagementSource
        case byoSmsIntegrationId
        case queueMediaSettings
    }


}




public class QueueConversationVideoEventTopicMessageDetails: Codable {





    public enum MessageStatus: String, Codable { 
        case queued = "queued"
        case sent = "sent"
        case failed = "failed"
        case received = "received"
        case deliverySuccess = "delivery-success"
        case deliveryFailed = "delivery-failed"
        case read = "read"
        case removed = "removed"
        case published = "published"
    }











    public enum SocialVisibility: String, Codable { 
        case _private = "private"
        case _public = "public"
    }

    /** UUID identifying the message media. */
    public var messageId: String?
    /** The time when the message was sent or received. */
    public var messageTime: Date?
    /** Indicates the delivery status of the message. */
    public var messageStatus: MessageStatus?
    /** The message segment count, greater than 1 if the message content was split into multiple parts for this message type, e.g. SMS character limits. */
    public var messageSegmentCount: Int64?
    /** The media (images, files, etc) associated with this message, if any */
    public var media: [QueueConversationVideoEventTopicMessageMedia]?
    /** Detailed information about an error response. */
    public var errorInfo: QueueConversationVideoEventTopicErrorDetails?
    /** A list of stickers included in the message */
    public var stickers: [QueueConversationVideoEventTopicMessageSticker]?
    public var messageMetadata: QueueConversationVideoEventTopicMessageMetadata?
    /** For social media messages, the visibility of the message in the originating social platform */
    public var socialVisibility: SocialVisibility?

    public init(messageId: String?, messageTime: Date?, messageStatus: MessageStatus?, messageSegmentCount: Int64?, media: [QueueConversationVideoEventTopicMessageMedia]?, errorInfo: QueueConversationVideoEventTopicErrorDetails?, stickers: [QueueConversationVideoEventTopicMessageSticker]?, messageMetadata: QueueConversationVideoEventTopicMessageMetadata?, socialVisibility: SocialVisibility?) {
        self.messageId = messageId
        self.messageTime = messageTime
        self.messageStatus = messageStatus
        self.messageSegmentCount = messageSegmentCount
        self.media = media
        self.errorInfo = errorInfo
        self.stickers = stickers
        self.messageMetadata = messageMetadata
        self.socialVisibility = socialVisibility
    }


}




public class QueueConversationVideoEventTopicMessageMedia: Codable {











    /** The location of the media, useful for retrieving it */
    public var url: String?
    /** The optional internet media type of the the media object.  If null then the media type should be dictated by the url */
    public var mediaType: String?
    /** The optional content length of the the media object, in bytes. */
    public var contentLengthBytes: Int64?
    /** The optional name of the the media object. */
    public var name: String?
    /** The optional id of the the media object. */
    public var _id: String?

    public init(url: String?, mediaType: String?, contentLengthBytes: Int64?, name: String?, _id: String?) {
        self.url = url
        self.mediaType = mediaType
        self.contentLengthBytes = contentLengthBytes
        self.name = name
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case url
        case mediaType
        case contentLengthBytes
        case name
        case _id = "id"
    }


}




public class QueueConversationVideoEventTopicMessageMetadataEvent: Codable {





    /** Type of this event element. */
    public var eventType: String?
    /** Event subtype, if any */
    public var subType: String?

    public init(eventType: String?, subType: String?) {
        self.eventType = eventType
        self.subType = subType
    }


}




public class QueueConversationVideoEventTopicMessageSticker: Codable {





    /** The location of the sticker, useful for retrieving it */
    public var url: String?
    /** The unique id of the the sticker object. */
    public var _id: String?

    public init(url: String?, _id: String?) {
        self.url = url
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case url
        case _id = "id"
    }


}



/** Fields identifying the initiator of a given conversation command. */

public class QueueConversationVideoEventTopicTransferInitiator: Codable {



    /** The id of the user who initiated the command if it was initiated by a user. */
    public var userId: String?

    public init(userId: String?) {
        self.userId = userId
    }


}




public class QueueConversationVideoEventTopicTransferResponse: Codable {



    public enum State: String, Codable { 
        case pending = "pending"
        case active = "active"
        case complete = "complete"
        case canceled = "canceled"
        case failed = "failed"
        case timeout = "timeout"
        case unknown = "unknown"
    }









    public enum TransferType: String, Codable { 
        case attended = "attended"
        case unattended = "unattended"
    }

    /** The id of the command. */
    public var _id: String?
    public var state: State?
    /** The date/time that this command was issued. */
    public var dateIssued: Date?
    public var initiator: QueueConversationVideoEventTopicTransferInitiator?
    public var modifiedBy: QueueConversationVideoEventTopicTransferModifedBy?
    public var destination: QueueConversationVideoEventTopicTransferDestination?
    /** The type of transfer to perform. */
    public var transferType: TransferType?

    public init(_id: String?, state: State?, dateIssued: Date?, initiator: QueueConversationVideoEventTopicTransferInitiator?, modifiedBy: QueueConversationVideoEventTopicTransferModifedBy?, destination: QueueConversationVideoEventTopicTransferDestination?, transferType: TransferType?) {
        self._id = _id
        self.state = state
        self.dateIssued = dateIssued
        self.initiator = initiator
        self.modifiedBy = modifiedBy
        self.destination = destination
        self.transferType = transferType
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case state
        case dateIssued
        case initiator
        case modifiedBy
        case destination
        case transferType
    }


}



/** Information about the workflow. */

public class QueueConversationVideoEventTopicWorkflow: Codable {



    /** The id of the workflow */
    public var workflowId: String?

    public init(workflowId: String?) {
        self.workflowId = workflowId
    }


}



/** Call wrap up or disposition data. */

public class QueueConversationVideoEventTopicWrapup: Codable {











    /** The user configured wrap up code name. */
    public var code: String?
    /** Text entered by the agent to describe the call or disposition. */
    public var notes: String?
    /** List of tags selected by the agent to describe the call or disposition. */
    public var tags: [String]?
    /** The length of time in seconds that the agent spent doing after call work., Note, the format of utc-millisec should be ignored, our code generator needs it to generate a Long for us internally */
    public var durationSeconds: Int64?
    /** The timestamp when the wrapup was finished. */
    public var endTime: Date?

    public init(code: String?, notes: String?, tags: [String]?, durationSeconds: Int64?, endTime: Date?) {
        self.code = code
        self.notes = notes
        self.tags = tags
        self.durationSeconds = durationSeconds
        self.endTime = endTime
    }


}




public class QueueEntityListing: Codable {





















    public var entities: [Queue]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var previousUri: String?
    public var nextUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [Queue]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, previousUri: String?, nextUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.previousUri = previousUri
        self.nextUri = nextUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class QueueMemberEntityListing: Codable {















    public var entities: [QueueMember]?
    public var pageNumber: Int?
    public var pageSize: Int?
    public var firstUri: String?
    public var previousUri: String?
    public var nextUri: String?
    public var selfUri: String?

    public init(entities: [QueueMember]?, pageNumber: Int?, pageSize: Int?, firstUri: String?, previousUri: String?, nextUri: String?, selfUri: String?) {
        self.entities = entities
        self.pageNumber = pageNumber
        self.pageSize = pageSize
        self.firstUri = firstUri
        self.previousUri = previousUri
        self.nextUri = nextUri
        self.selfUri = selfUri
    }


}




public class QueueMemberEntityListingV1: Codable {





















    public var entities: [QueueMember]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var previousUri: String?
    public var nextUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [QueueMember]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, previousUri: String?, nextUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.previousUri = previousUri
        self.nextUri = nextUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class QueueMessagingAddresses: Codable {







    public var smsAddress: DomainEntityRef?
    public var openMessagingRecipient: DomainEntityRef?
    public var whatsAppRecipient: DomainEntityRef?

    public init(smsAddress: DomainEntityRef?, openMessagingRecipient: DomainEntityRef?, whatsAppRecipient: DomainEntityRef?) {
        self.smsAddress = smsAddress
        self.openMessagingRecipient = openMessagingRecipient
        self.whatsAppRecipient = whatsAppRecipient
    }


}




public class QueueObservationQueryFilter: Codable {

    public enum ModelType: String, Codable { 
        case and = "and"
        case or = "or"
    }





    /** Boolean operation to apply to the provided predicates and clauses */
    public var type: ModelType?
    /** Boolean 'and/or' logic with up to two-levels of nesting */
    public var clauses: [QueueObservationQueryClause]?
    /** Like a three-word sentence: (attribute-name) (operator) (target-value). */
    public var predicates: [QueueObservationQueryPredicate]?

    public init(type: ModelType?, clauses: [QueueObservationQueryClause]?, predicates: [QueueObservationQueryPredicate]?) {
        self.type = type
        self.clauses = clauses
        self.predicates = predicates
    }


}




public class QueueUserEventTopicQueueMember: Codable {











    public var _id: String?
    public var user: QueueUserEventTopicUserReference?
    public var queueId: String?
    public var joined: Bool?
    public var additionalProperties: [String:JSON]?

    public init(_id: String?, user: QueueUserEventTopicUserReference?, queueId: String?, joined: Bool?, additionalProperties: [String:JSON]?) {
        self._id = _id
        self.user = user
        self.queueId = queueId
        self.joined = joined
        self.additionalProperties = additionalProperties
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case user
        case queueId
        case joined
        case additionalProperties
    }


}




public class RateLimitAggregateDataContainer: Codable {





    /** A mapping from dimension to value */
    public var group: [String:String]?
    public var data: [StatisticalResponse]?

    public init(group: [String:String]?, data: [StatisticalResponse]?) {
        self.group = group
        self.data = data
    }


}




public class RateLimitAggregateQueryClause: Codable {

    public enum ModelType: String, Codable { 
        case and = "and"
        case or = "or"
    }



    /** Boolean operation to apply to the provided predicates */
    public var type: ModelType?
    /** Like a three-word sentence: (attribute-name) (operator) (target-value). */
    public var predicates: [RateLimitAggregateQueryPredicate]?

    public init(type: ModelType?, predicates: [RateLimitAggregateQueryPredicate]?) {
        self.type = type
        self.predicates = predicates
    }


}




public class RateLimitAggregationQuery: Codable {







    public enum GroupBy: String, Codable { 
        case correlationid = "correlationId"
        case entityid = "entityId"
        case limitname = "limitName"
        case max = "max"
        case namespace = "namespace"
        case timeunit = "timeUnit"
        case userid = "userId"
    }



    public enum Metrics: String, Codable { 
        case oratelimitrecorded = "oRateLimitRecorded"
    }





    public enum AlternateTimeDimension: String, Codable { 
        case eventtime = "eventTime"
    }

    /** Behaves like one clause in a SQL WHERE. Specifies the date and time range of data being queried. Intervals are represented as an ISO-8601 string. For example: YYYY-MM-DDThh:mm:ss/YYYY-MM-DDThh:mm:ss */
    public var interval: String?
    /** Granularity aggregates metrics into subpartitions within the time interval specified. The default granularity is the same duration as the interval. Periods are represented as an ISO-8601 string. For example: P1D or P1DT12H */
    public var granularity: String?
    /** Time zone context used to calculate response intervals (this allows resolving DST changes). The interval offset is used even when timeZone is specified. Default is UTC. Time zones are represented as a string of the zone name as found in the IANA time zone database. For example: UTC, Etc/UTC, or Europe/London */
    public var timeZone: String?
    /** Behaves like a SQL GROUPBY. Allows for multiple levels of grouping as a list of dimensions. Partitions resulting aggregate computations into distinct named subgroups rather than across the entire result set as if it were one group. */
    public var groupBy: [GroupBy]?
    /** Behaves like a SQL WHERE clause. This is ANDed with the interval parameter. Expresses boolean logical predicates as well as dimensional filters */
    public var filter: RateLimitAggregateQueryFilter?
    /** Behaves like a SQL SELECT clause. Only named metrics will be retrieved. */
    public var metrics: [Metrics]?
    /** Flattens any multivalued dimensions used in response groups (e.g. ['a','b','c']->'a,b,c') */
    public var flattenMultivaluedDimensions: Bool?
    /** Custom derived metric views */
    public var views: [RateLimitAggregationView]?
    /** Dimension to use as the alternative timestamp for data in the aggregate.  Choosing \"eventTime\" uses the actual time of the data event. */
    public var alternateTimeDimension: AlternateTimeDimension?

    public init(interval: String?, granularity: String?, timeZone: String?, groupBy: [GroupBy]?, filter: RateLimitAggregateQueryFilter?, metrics: [Metrics]?, flattenMultivaluedDimensions: Bool?, views: [RateLimitAggregationView]?, alternateTimeDimension: AlternateTimeDimension?) {
        self.interval = interval
        self.granularity = granularity
        self.timeZone = timeZone
        self.groupBy = groupBy
        self.filter = filter
        self.metrics = metrics
        self.flattenMultivaluedDimensions = flattenMultivaluedDimensions
        self.views = views
        self.alternateTimeDimension = alternateTimeDimension
    }


}




public class RateLimitAggregationSort: Codable {

    public enum Name: String, Codable { 
        case oratelimitrecorded = "oRateLimitRecorded"
    }

    public enum Function: String, Codable { 
        case count = "count"
        case max = "max"
        case min = "min"
        case sum = "sum"
    }

    /** Name of the metric used for sorting values. */
    public var name: Name?
    /** Aggregation function used for the sort metric. */
    public var function: Function?

    public init(name: Name?, function: Function?) {
        self.name = name
        self.function = function
    }


}




public class RecipientFlow: Codable {



    /** The flow identifier */
    public var _id: String?

    public init(_id: String?) {
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
    }


}




public class RecordingAnnotationFlow: Codable {





    /** The flow name */
    public var name: String?
    /** The flow Id */
    public var _id: String?

    public init(name: String?, _id: String?) {
        self.name = name
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case name
        case _id = "id"
    }


}




public class RecordingEventRecording: Codable {













    public var _id: String?
    public var conversationId: String?
    public var fileState: String?
    public var mediaUris: [RecordingEventMediaResult]?
    public var estimatedTranscodeTimeMs: Int64?
    public var actualTranscodeTimeMs: Int64?

    public init(_id: String?, conversationId: String?, fileState: String?, mediaUris: [RecordingEventMediaResult]?, estimatedTranscodeTimeMs: Int64?, actualTranscodeTimeMs: Int64?) {
        self._id = _id
        self.conversationId = conversationId
        self.fileState = fileState
        self.mediaUris = mediaUris
        self.estimatedTranscodeTimeMs = estimatedTranscodeTimeMs
        self.actualTranscodeTimeMs = actualTranscodeTimeMs
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case conversationId
        case fileState
        case mediaUris
        case estimatedTranscodeTimeMs
        case actualTranscodeTimeMs
    }


}




public class RecordingForm: Codable {















    /** The introduction component, used to give an intro into what the form entails. */
    public var introduction: RecordingIntroduction?
    /** Form pages. */
    public var formPages: [RecordingFormPage]?
    /** Defines the initial prompt message structure containing title and subtitle fields that are displayed to the end user when a form requires completion. */
    public var receivedMessage: ReceivedReplyMessage?
    /** The reply message after the user has filled out the form received. */
    public var replyMessage: ReceivedReplyMessage?
    /** Content of the payload included in the Form response. */
    public var response: [RecordingFormResponseComponent]?
    /** Reference to the id of the original message. */
    public var originatingMessageId: String?
    /** The id of the canned response which was used to create the form. */
    public var cannedResponseId: String?

    public init(introduction: RecordingIntroduction?, formPages: [RecordingFormPage]?, receivedMessage: ReceivedReplyMessage?, replyMessage: ReceivedReplyMessage?, response: [RecordingFormResponseComponent]?, originatingMessageId: String?, cannedResponseId: String?) {
        self.introduction = introduction
        self.formPages = formPages
        self.receivedMessage = receivedMessage
        self.replyMessage = replyMessage
        self.response = response
        self.originatingMessageId = originatingMessageId
        self.cannedResponseId = cannedResponseId
    }


}




public class RecordingJobFailedRecording: Codable {





    /** Conversation */
    public var conversation: AddressableEntityRef?
    /** Recording */
    public var recording: AddressableEntityRef?

    public init(conversation: AddressableEntityRef?, recording: AddressableEntityRef?) {
        self.conversation = conversation
        self.recording = recording
    }


}




public class RecordingRoadsideAssistance: Codable {











    /** The Roadside Assistance message text. */
    public var text: String?
    /** Phone number the user provided. */
    public var phoneNumber: String?
    /** If the user provided their own phone number. */
    public var isDevicePhoneNumber: Bool?
    /** User Location object. */
    public var location: RecordingLocation?
    /** The counter of the message. */
    public var messageNumber: Int64?

    public init(text: String?, phoneNumber: String?, isDevicePhoneNumber: Bool?, location: RecordingLocation?, messageNumber: Int64?) {
        self.text = text
        self.phoneNumber = phoneNumber
        self.isDevicePhoneNumber = isDevicePhoneNumber
        self.location = location
        self.messageNumber = messageNumber
    }


}




public class RecordingSettings: Codable {











    /** Maximum number of simultaneous screen recording streams */
    public var maxSimultaneousStreams: Int?
    /** Upper limit that maxSimultaneousStreams can be configured */
    public var maxConfigurableScreenRecordingStreams: Int?
    /** Store call recordings in the region where they are intended to be recorded, otherwise in the organization's home region */
    public var regionalRecordingStorageEnabled: Bool?
    /** The duration in minutes for which the generated URL for recording playback remains valid.The default duration is set to 60 minutes, with a minimum allowable duration of 2 minutes and a maximum of 60 minutes. */
    public var recordingPlaybackUrlTtl: Int?
    /** The duration in minutes for which the generated URL for recording batch download remains valid.The default duration is set to 60 minutes, with a minimum allowable duration of 2 minutes and a maximum of 60 minutes. */
    public var recordingBatchDownloadUrlTtl: Int?

    public init(maxSimultaneousStreams: Int?, maxConfigurableScreenRecordingStreams: Int?, regionalRecordingStorageEnabled: Bool?, recordingPlaybackUrlTtl: Int?, recordingBatchDownloadUrlTtl: Int?) {
        self.maxSimultaneousStreams = maxSimultaneousStreams
        self.maxConfigurableScreenRecordingStreams = maxConfigurableScreenRecordingStreams
        self.regionalRecordingStorageEnabled = regionalRecordingStorageEnabled
        self.recordingPlaybackUrlTtl = recordingPlaybackUrlTtl
        self.recordingBatchDownloadUrlTtl = recordingBatchDownloadUrlTtl
    }


}




public class RecordingTemplateButton: Codable {

    public enum ModelType: String, Codable { 
        case quickReply = "QuickReply"
        case phoneNumber = "PhoneNumber"
        case url = "Url"
    }











    /** Specifies the type of the button. */
    public var type: ModelType?
    /** Button text message. */
    public var text: String?
    /** Index of the button in the list. */
    public var index: Int64?
    /** Button phone number. */
    public var phoneNumber: String?
    /** Button URL link. */
    public var url: String?
    /** Indicates if the button is selected by end customer. */
    public var isSelected: Bool?

    public init(type: ModelType?, text: String?, index: Int64?, phoneNumber: String?, url: String?, isSelected: Bool?) {
        self.type = type
        self.text = text
        self.index = index
        self.phoneNumber = phoneNumber
        self.url = url
        self.isSelected = isSelected
    }


}




public class RecordingUploadReport: Codable {





    public enum State: String, Codable { 
        case inProgress = "InProgress"
        case completed = "Completed"
        case failed = "Failed"
    }





    /** The report id. */
    public var _id: String?
    public var name: String?
    /** The current status of the upload report. */
    public var state: State?
    /** For COMPLETED tasks, the signed url to download the report. */
    public var signedUrl: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, state: State?, signedUrl: String?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.state = state
        self.signedUrl = signedUrl
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case state
        case signedUrl
        case selfUri
    }


}




public class RecordingUploadReportRequest: Codable {



    public enum UploadStatus: String, Codable { 
        case pending = "Pending"
        case success = "Success"
        case failure = "Failure"
        case waitForConversation = "WaitForConversation"
    }

    /** Report will include uploads since this date. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateSince: Date?
    /** Report will include uploads with this status */
    public var uploadStatus: UploadStatus?

    public init(dateSince: Date?, uploadStatus: UploadStatus?) {
        self.dateSince = dateSince
        self.uploadStatus = uploadStatus
    }


}




public class RecurrencePeriod: Codable {



    public enum Granularity: String, Codable { 
        case days = "Days"
        case weeks = "Weeks"
    }

    /** The period of the activity plan in granularity units */
    public var magnitude: Int?
    /** The granularity unit to interpret the period of this activity plan */
    public var granularity: Granularity?

    public init(magnitude: Int?, granularity: Granularity?) {
        self.magnitude = magnitude
        self.granularity = granularity
    }


}




public class Referrer: Codable {

















    public enum Medium: String, Codable { 
        case _internal = "internal"
        case search = "search"
        case social = "social"
        case email = "email"
        case unknown = "unknown"
        case paid = "paid"
    }

    /** Referrer URL. */
    public var url: String?
    /** Referrer URL domain. */
    public var domain: String?
    /** Referrer URL hostname. */
    public var hostname: String?
    /** Referrer keywords. */
    public var keywords: String?
    /** Referrer URL pathname. */
    public var pathname: String?
    /** Referrer URL querystring. */
    public var queryString: String?
    /** Referrer URL fragment. */
    public var fragment: String?
    /** Name of referrer (e.g. Yahoo!, Google, InfoSpace). */
    public var name: String?
    /** Type of referrer (e.g. search, social). */
    public var medium: Medium?

    public init(url: String?, domain: String?, hostname: String?, keywords: String?, pathname: String?, queryString: String?, fragment: String?, name: String?, medium: Medium?) {
        self.url = url
        self.domain = domain
        self.hostname = hostname
        self.keywords = keywords
        self.pathname = pathname
        self.queryString = queryString
        self.fragment = fragment
        self.name = name
        self.medium = medium
    }


}




public class RemoveEntitiesRequest: Codable {



    /** List of entities to be removed */
    public var entities: [RemoveEntity]?

    public init(entities: [RemoveEntity]?) {
        self.entities = entities
    }


}




public class RemoveEntity: Codable {



    /** Unique identifier of the entity to be removed */
    public var _id: String?

    public init(_id: String?) {
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
    }


}




public class ReplacementTerm: Codable {

    public enum ModelType: String, Codable { 
        case name = "NAME"
        case address = "ADDRESS"
        case phone = "PHONE"
        case email = "EMAIL"
        case twitter = "TWITTER"
        case instagram = "INSTAGRAM"
        case facebook = "FACEBOOK"
    }





    /** Replacement term type */
    public var type: ModelType?
    public var existingValue: String?
    public var updatedValue: String?

    public init(type: ModelType?, existingValue: String?, updatedValue: String?) {
        self.type = type
        self.existingValue = existingValue
        self.updatedValue = updatedValue
    }


}




public class ReportingExportJobListing: Codable {





















    public var entities: [ReportingExportJobResponse]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var previousUri: String?
    public var nextUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [ReportingExportJobResponse]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, previousUri: String?, nextUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.previousUri = previousUri
        self.nextUri = nextUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class ReportingExportJobRequest: Codable {





    public enum ExportFormat: String, Codable { 
        case csv = "CSV"
        case pdf = "PDF"
    }





    public enum ViewType: String, Codable { 
        case queuePerformanceSummaryView = "QUEUE_PERFORMANCE_SUMMARY_VIEW"
        case queuePerformanceDetailView = "QUEUE_PERFORMANCE_DETAIL_VIEW"
        case interactionSearchView = "INTERACTION_SEARCH_VIEW"
        case agentPerformanceSummaryView = "AGENT_PERFORMANCE_SUMMARY_VIEW"
        case agentPerformanceDetailView = "AGENT_PERFORMANCE_DETAIL_VIEW"
        case agentStatusSummaryView = "AGENT_STATUS_SUMMARY_VIEW"
        case agentStatusDetailView = "AGENT_STATUS_DETAIL_VIEW"
        case agentEvaluationSummaryView = "AGENT_EVALUATION_SUMMARY_VIEW"
        case agentEvaluationDetailView = "AGENT_EVALUATION_DETAIL_VIEW"
        case agentQueueDetailView = "AGENT_QUEUE_DETAIL_VIEW"
        case agentInteractionDetailView = "AGENT_INTERACTION_DETAIL_VIEW"
        case abandonInsightsView = "ABANDON_INSIGHTS_VIEW"
        case skillsPerformanceView = "SKILLS_PERFORMANCE_VIEW"
        case surveyFormPerformanceSummaryView = "SURVEY_FORM_PERFORMANCE_SUMMARY_VIEW"
        case surveyFormPerformanceDetailView = "SURVEY_FORM_PERFORMANCE_DETAIL_VIEW"
        case dnisPerformanceSummaryView = "DNIS_PERFORMANCE_SUMMARY_VIEW"
        case dnisPerformanceDetailView = "DNIS_PERFORMANCE_DETAIL_VIEW"
        case wrapUpPerformanceSummaryView = "WRAP_UP_PERFORMANCE_SUMMARY_VIEW"
        case agentWrapUpPerformanceDetailView = "AGENT_WRAP_UP_PERFORMANCE_DETAIL_VIEW"
        case queueActivitySummaryView = "QUEUE_ACTIVITY_SUMMARY_VIEW"
        case queueActivityDetailView = "QUEUE_ACTIVITY_DETAIL_VIEW"
        case agentQueueActivitySummaryView = "AGENT_QUEUE_ACTIVITY_SUMMARY_VIEW"
        case queueAgentDetailView = "QUEUE_AGENT_DETAIL_VIEW"
        case queueInteractionDetailView = "QUEUE_INTERACTION_DETAIL_VIEW"
        case agentScheduleDetailView = "AGENT_SCHEDULE_DETAIL_VIEW"
        case ivrPerformanceSummaryView = "IVR_PERFORMANCE_SUMMARY_VIEW"
        case ivrPerformanceDetailView = "IVR_PERFORMANCE_DETAIL_VIEW"
        case answerInsightsView = "ANSWER_INSIGHTS_VIEW"
        case handleInsightsView = "HANDLE_INSIGHTS_VIEW"
        case talkInsightsView = "TALK_INSIGHTS_VIEW"
        case holdInsightsView = "HOLD_INSIGHTS_VIEW"
        case acwInsightsView = "ACW_INSIGHTS_VIEW"
        case waitInsightsView = "WAIT_INSIGHTS_VIEW"
        case agentWrapUpPerformanceIntervalDetailView = "AGENT_WRAP_UP_PERFORMANCE_INTERVAL_DETAIL_VIEW"
        case flowOutcomeSummaryView = "FLOW_OUTCOME_SUMMARY_VIEW"
        case flowOutcomePerformanceDetailView = "FLOW_OUTCOME_PERFORMANCE_DETAIL_VIEW"
        case flowOutcomePerformanceIntervalDetailView = "FLOW_OUTCOME_PERFORMANCE_INTERVAL_DETAIL_VIEW"
        case flowDestinationSummaryView = "FLOW_DESTINATION_SUMMARY_VIEW"
        case flowDestinationDetailView = "FLOW_DESTINATION_DETAIL_VIEW"
        case apiUsageView = "API_USAGE_VIEW"
        case scheduledCallbacksView = "SCHEDULED_CALLBACKS_VIEW"
        case contentSearchView = "CONTENT_SEARCH_VIEW"
        case landingPage = "LANDING_PAGE"
        case dashboardSummary = "DASHBOARD_SUMMARY"
        case dashboardDetail = "DASHBOARD_DETAIL"
        case dashboardUsers = "DASHBOARD_USERS"
        case dashboardUsersDetail = "DASHBOARD_USERS_DETAIL"
        case journeyActionMapSummaryView = "JOURNEY_ACTION_MAP_SUMMARY_VIEW"
        case journeyOutcomeSummaryView = "JOURNEY_OUTCOME_SUMMARY_VIEW"
        case journeySegmentSummaryView = "JOURNEY_SEGMENT_SUMMARY_VIEW"
        case agentDevelopmentDetailView = "AGENT_DEVELOPMENT_DETAIL_VIEW"
        case agentDevelopmentDetailMeView = "AGENT_DEVELOPMENT_DETAIL_ME_VIEW"
        case agentDevelopmentSummaryView = "AGENT_DEVELOPMENT_SUMMARY_VIEW"
        case agentPerformanceMeView = "AGENT_PERFORMANCE_ME_VIEW"
        case agentStatusMeView = "AGENT_STATUS_ME_VIEW"
        case agentEvaluationMeView = "AGENT_EVALUATION_ME_VIEW"
        case agentScorecardView = "AGENT_SCORECARD_VIEW"
        case agentScorecardMeView = "AGENT_SCORECARD_ME_VIEW"
        case agentGamificationLeadershipView = "AGENT_GAMIFICATION_LEADERSHIP_VIEW"
        case agentScheduleMeView = "AGENT_SCHEDULE_ME_VIEW"
        case botPerformanceSummaryView = "BOT_PERFORMANCE_SUMMARY_VIEW"
        case botPerformanceDetailView = "BOT_PERFORMANCE_DETAIL_VIEW"
        case scheduledExportsView = "SCHEDULED_EXPORTS_VIEW"
        case topicTrendSummaryView = "TOPIC_TREND_SUMMARY_VIEW"
        case topicTrendDetailView = "TOPIC_TREND_DETAIL_VIEW"
        case actionMapBlockedConstraintsDetailView = "ACTION_MAP_BLOCKED_CONSTRAINTS_DETAIL_VIEW"
        case actionMapBlockedConstraintsIntervalDetailView = "ACTION_MAP_BLOCKED_CONSTRAINTS_INTERVAL_DETAIL_VIEW"
        case flowMilestonePerformanceDetailView = "FLOW_MILESTONE_PERFORMANCE_DETAIL_VIEW"
        case flowMilestonePerformanceIntervalDetailView = "FLOW_MILESTONE_PERFORMANCE_INTERVAL_DETAIL_VIEW"
        case agentTopicSummaryView = "AGENT_TOPIC_SUMMARY_VIEW"
        case agentTopicDetailView = "AGENT_TOPIC_DETAIL_VIEW"
        case queueTopicSummaryView = "QUEUE_TOPIC_SUMMARY_VIEW"
        case queueTopicDetailView = "QUEUE_TOPIC_DETAIL_VIEW"
        case flowTopicSummaryView = "FLOW_TOPIC_SUMMARY_VIEW"
        case flowTopicDetailView = "FLOW_TOPIC_DETAIL_VIEW"
        case agentInteractionsMeView = "AGENT_INTERACTIONS_ME_VIEW"
        case alertRulesView = "ALERT_RULES_VIEW"
        case configureAlertRuleView = "CONFIGURE_ALERT_RULE_VIEW"
        case predictiveRoutingView = "PREDICTIVE_ROUTING_VIEW"
        case predictiveRoutingQueueOverview = "PREDICTIVE_ROUTING_QUEUE_OVERVIEW"
        case predictiveRoutingModelView = "PREDICTIVE_ROUTING_MODEL_VIEW"
        case predictiveRoutingImpactView = "PREDICTIVE_ROUTING_IMPACT_VIEW"
        case dataActionsPerformanceSummaryView = "DATA_ACTIONS_PERFORMANCE_SUMMARY_VIEW"
        case dataActionsPerformanceDetailView = "DATA_ACTIONS_PERFORMANCE_DETAIL_VIEW"
        case agentTimelineSummaryView = "AGENT_TIMELINE_SUMMARY_VIEW"
        case agentTimelineDetailView = "AGENT_TIMELINE_DETAIL_VIEW"
        case agentLoginLogoutSummaryView = "AGENT_LOGIN_LOGOUT_SUMMARY_VIEW"
        case agentLoginLogoutDetailView = "AGENT_LOGIN_LOGOUT_DETAIL_VIEW"
        case campaignPerformanceSummaryView = "CAMPAIGN_PERFORMANCE_SUMMARY_VIEW"
        case campaignPerformanceDetailView = "CAMPAIGN_PERFORMANCE_DETAIL_VIEW"
        case knowledgePerformanceView = "KNOWLEDGE_PERFORMANCE_VIEW"
        case agentScorecardInsightsSummaryView = "AGENT_SCORECARD_INSIGHTS_SUMMARY_VIEW"
        case agentScorecardInsightsDetailView = "AGENT_SCORECARD_INSIGHTS_DETAIL_VIEW"
        case queueWrapupDetailView = "QUEUE_WRAPUP_DETAIL_VIEW"
        case interactionDetailView = "INTERACTION_DETAIL_VIEW"
        case campaignInteractionDetailView = "CAMPAIGN_INTERACTION_DETAIL_VIEW"
        case campaignAttemptDetailView = "CAMPAIGN_ATTEMPT_DETAIL_VIEW"
        case workitemPerformanceSummaryView = "WORKITEM_PERFORMANCE_SUMMARY_VIEW"
        case agentAssistPerformanceView = "AGENT_ASSIST_PERFORMANCE_VIEW"
        case contactCenterPerformanceView = "CONTACT_CENTER_PERFORMANCE_VIEW"
        case queueRoutingPerformanceView = "QUEUE_ROUTING_PERFORMANCE_VIEW"
        case agentWorkitemPerformanceSummaryView = "AGENT_WORKITEM_PERFORMANCE_SUMMARY_VIEW"
        case agentWorkitemPerformanceDetailView = "AGENT_WORKITEM_PERFORMANCE_DETAIL_VIEW"
        case queueWorkitemPerformanceSummaryView = "QUEUE_WORKITEM_PERFORMANCE_SUMMARY_VIEW"
        case queueWorkitemPerformanceDetailView = "QUEUE_WORKITEM_PERFORMANCE_DETAIL_VIEW"
        case emailAgentPerformanceSummaryView = "EMAIL_AGENT_PERFORMANCE_SUMMARY_VIEW"
        case emailAgentPerformanceDetailView = "EMAIL_AGENT_PERFORMANCE_DETAIL_VIEW"
        case messagingAgentPerformanceSummaryView = "MESSAGING_AGENT_PERFORMANCE_SUMMARY_VIEW"
        case messagingAgentPerformanceDetailView = "MESSAGING_AGENT_PERFORMANCE_DETAIL_VIEW"
        case emailQueuePerformanceSummaryView = "EMAIL_QUEUE_PERFORMANCE_SUMMARY_VIEW"
        case emailQueuePerformanceDetailView = "EMAIL_QUEUE_PERFORMANCE_DETAIL_VIEW"
        case messagingQueuePerformanceSummaryView = "MESSAGING_QUEUE_PERFORMANCE_SUMMARY_VIEW"
        case messagingQueuePerformanceDetailView = "MESSAGING_QUEUE_PERFORMANCE_DETAIL_VIEW"
        case socialListeningView = "SOCIAL_LISTENING_VIEW"
        case socialListeningPostsView = "SOCIAL_LISTENING_POSTS_VIEW"
        case agentPerformanceTimelineDetailView = "AGENT_PERFORMANCE_TIMELINE_DETAIL_VIEW"
        case dashboardSlideshows = "DASHBOARD_SLIDESHOWS"
        case dashboardSlideshowsDetail = "DASHBOARD_SLIDESHOWS_DETAIL"
        case agentCopilotPerformanceView = "AGENT_COPILOT_PERFORMANCE_VIEW"
        case agentAssignedEvaluationMeView = "AGENT_ASSIGNED_EVALUATION_ME_VIEW"
        case virtualAgentPerformanceView = "VIRTUAL_AGENT_PERFORMANCE_VIEW"
        case contentExplorationView = "CONTENT_EXPLORATION_VIEW"
        case evaluationPerformanceSummaryView = "EVALUATION_PERFORMANCE_SUMMARY_VIEW"
        case evaluationPerformanceDetailView = "EVALUATION_PERFORMANCE_DETAIL_VIEW"
        case evaluationPerformanceQuestionGroupDetailView = "EVALUATION_PERFORMANCE_QUESTION_GROUP_DETAIL_VIEW"
        case evaluationPerformanceQuestionDetailView = "EVALUATION_PERFORMANCE_QUESTION_DETAIL_VIEW"
        case queueWorkitemActivitySummaryView = "QUEUE_WORKITEM_ACTIVITY_SUMMARY_VIEW"
        case queueWorkitemActivityDetailView = "QUEUE_WORKITEM_ACTIVITY_DETAIL_VIEW"
        case digitalAdoptionView = "DIGITAL_ADOPTION_VIEW"
        case digitalIntentView = "DIGITAL_INTENT_VIEW"
        case digitalPerformanceView = "DIGITAL_PERFORMANCE_VIEW"
        case copilotUsageView = "COPILOT_USAGE_VIEW"
    }

















    public enum CsvDelimiter: String, Codable { 
        case semicolon = "SEMICOLON"
        case comma = "COMMA"
    }









    public enum DurationFormat: String, Codable { 
        case seconds = "Seconds"
        case milliseconds = "Milliseconds"
        case hhmmss = "Hhmmss"
        case hms = "Hms"
    }



    /** The user supplied name of the export request */
    public var name: String?
    /** The requested timezone of the exported data. Time zones are represented as a string of the zone name as found in the IANA time zone database. For example: UTC, Etc/UTC, or Europe/London */
    public var timeZone: String?
    /** The requested format of the exported data */
    public var exportFormat: ExportFormat?
    /** The time period used to limit the the exported data. Intervals are represented as an ISO-8601 string. For example: YYYY-MM-DDThh:mm:ss/YYYY-MM-DDThh:mm:ss */
    public var interval: String?
    /** The Period of the request in which to break down the intervals. Periods are represented as an ISO-8601 string. For example: P1D or P1DT12H */
    public var period: String?
    /** The type of view export job to be created */
    public var viewType: ViewType?
    /** Filters to apply to create the view */
    public var filter: ViewFilter?
    /** Indicates if the request has been marked as read */
    public var read: Bool?
    /** The locale used for localization of the exported data, i.e. en-US, es */
    public var locale: String?
    /** Indicates if durations are formatted in hh:mm:ss format instead of ms */
    public var hasFormatDurations: Bool?
    /** Indicates if filters will be split in aggregate detail exports */
    public var hasSplitFilters: Bool?
    /** Excludes empty rows from the exports */
    public var excludeEmptyRows: Bool?
    /** Indicates if media type will be split in aggregate detail exports */
    public var hasSplitByMedia: Bool?
    /** Indicates if summary row needs to be present in exports */
    public var hasSummaryRow: Bool?
    /** The user supplied csv delimiter string value either of type 'comma' or 'semicolon' permitted for the export request */
    public var csvDelimiter: CsvDelimiter?
    /** The list of ordered selected columns from the export view by the user */
    public var selectedColumns: [SelectedColumns]?
    /** Indicates if custom participant attributes will be exported */
    public var hasCustomParticipantAttributes: Bool?
    /** The list of email recipients for the exports */
    public var recipientEmails: [String]?
    /** Indicates whether to include selected duration format to the column headers */
    public var includeDurationFormatInHeader: Bool?
    /** Indicates the duration format for the exports */
    public var durationFormat: DurationFormat?
    /** The list of columns for which chart is going to be displayed in export */
    public var chartColumns: [ChartColumn]?

    public init(name: String?, timeZone: String?, exportFormat: ExportFormat?, interval: String?, period: String?, viewType: ViewType?, filter: ViewFilter?, read: Bool?, locale: String?, hasFormatDurations: Bool?, hasSplitFilters: Bool?, excludeEmptyRows: Bool?, hasSplitByMedia: Bool?, hasSummaryRow: Bool?, csvDelimiter: CsvDelimiter?, selectedColumns: [SelectedColumns]?, hasCustomParticipantAttributes: Bool?, recipientEmails: [String]?, includeDurationFormatInHeader: Bool?, durationFormat: DurationFormat?, chartColumns: [ChartColumn]?) {
        self.name = name
        self.timeZone = timeZone
        self.exportFormat = exportFormat
        self.interval = interval
        self.period = period
        self.viewType = viewType
        self.filter = filter
        self.read = read
        self.locale = locale
        self.hasFormatDurations = hasFormatDurations
        self.hasSplitFilters = hasSplitFilters
        self.excludeEmptyRows = excludeEmptyRows
        self.hasSplitByMedia = hasSplitByMedia
        self.hasSummaryRow = hasSummaryRow
        self.csvDelimiter = csvDelimiter
        self.selectedColumns = selectedColumns
        self.hasCustomParticipantAttributes = hasCustomParticipantAttributes
        self.recipientEmails = recipientEmails
        self.includeDurationFormatInHeader = includeDurationFormatInHeader
        self.durationFormat = durationFormat
        self.chartColumns = chartColumns
    }


}




public class ReportingTurn: Codable {



















    public enum AskActionResult: String, Codable { 
        case successCollection = "SuccessCollection"
        case successConfirmationYes = "SuccessConfirmationYes"
        case successConfirmationNo = "SuccessConfirmationNo"
        case skippedCollection = "SkippedCollection"
        case partialCollection = "PartialCollection"
        case noMatchCollection = "NoMatchCollection"
        case noMatchConfirmation = "NoMatchConfirmation"
        case agentRequestedByUser = "AgentRequestedByUser"
        case confirmationRequired = "ConfirmationRequired"
        case error = "Error"
        case expressionError = "ExpressionError"
        case noInputCollection = "NoInputCollection"
        case noInputConfirmation = "NoInputConfirmation"
        case disambiguationRequired = "DisambiguationRequired"
        case successDisambiguation = "SuccessDisambiguation"
        case successDisambiguationNone = "SuccessDisambiguationNone"
        case noMatchDisambiguation = "NoMatchDisambiguation"
        case noInputDisambiguation = "NoInputDisambiguation"
    }





    /** The chosen user input associated with this reporting turn. */
    public var userInput: String?
    /** The bot prompts associated with this reporting turn. */
    public var botPrompts: [String]?
    /** The bot session ID that this reporting turn is grouped under. */
    public var sessionId: String?
    /** The bot flow 'ask' action associated with this reporting turn (e.g. AskForIntent). */
    public var askAction: ReportingTurnAction?
    /** The intent and associated slots detected during this reporting turn. */
    public var intent: ReportingTurnIntent?
    /** The knowledge data captured during this reporting turn. */
    public var knowledge: ReportingTurnKnowledge?
    /** The knowledge data captured during this reporting turn. */
    public var knowledgeBaseEvents: ReportingTurnKnowledgeEvents?
    /** Timestamp indicating when the original turn was created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** Timestamp indicating when the original turn was completed. Note: The 'interval' query param uses this timestamp to filter the output. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCompleted: Date?
    /** Result of the bot flow 'ask' action. */
    public var askActionResult: AskActionResult?
    /** The details related to end of bot flow session. */
    public var sessionEndDetails: SessionEndDetails?
    /** The conversation details, across potentially multiple Bot Flow sessions. */
    public var conversation: AddressableEntityRef?

    public init(userInput: String?, botPrompts: [String]?, sessionId: String?, askAction: ReportingTurnAction?, intent: ReportingTurnIntent?, knowledge: ReportingTurnKnowledge?, knowledgeBaseEvents: ReportingTurnKnowledgeEvents?, dateCreated: Date?, dateCompleted: Date?, askActionResult: AskActionResult?, sessionEndDetails: SessionEndDetails?, conversation: AddressableEntityRef?) {
        self.userInput = userInput
        self.botPrompts = botPrompts
        self.sessionId = sessionId
        self.askAction = askAction
        self.intent = intent
        self.knowledge = knowledge
        self.knowledgeBaseEvents = knowledgeBaseEvents
        self.dateCreated = dateCreated
        self.dateCompleted = dateCompleted
        self.askActionResult = askActionResult
        self.sessionEndDetails = sessionEndDetails
        self.conversation = conversation
    }


}




public class ReportingTurnKnowledgeFeedbackEvent: Codable {













    /** The ID of this knowledge search. */
    public var searchId: String?
    /** The Knowledge Base ID that the captured knowledge data relates to. */
    public var knowledgeBaseId: String?
    /** The list of search documents that the feedback applies to. */
    public var documents: [ReportingTurnKnowledgeDocument]?
    /** The feedback rating for the search (1.0 - 5.0). 1 = Negative, 5 = Positive. */
    public var feedbackRating: Int?
    /** The variation of the document. */
    public var documentVariationId: String?
    /** The version of the document. */
    public var documentVersionId: String?

    public init(searchId: String?, knowledgeBaseId: String?, documents: [ReportingTurnKnowledgeDocument]?, feedbackRating: Int?, documentVariationId: String?, documentVersionId: String?) {
        self.searchId = searchId
        self.knowledgeBaseId = knowledgeBaseId
        self.documents = documents
        self.feedbackRating = feedbackRating
        self.documentVariationId = documentVariationId
        self.documentVersionId = documentVersionId
    }


}




public class ReportingTurnKnowledgeSearchEvent: Codable {











    /** The ID of this knowledge search. */
    public var searchId: String?
    /** The Knowledge Base ID that the captured knowledge data relates to. */
    public var knowledgeBaseId: String?
    /** The list of search documents that the feedback applies to. */
    public var documents: [ReportingTurnKnowledgeDocument]?
    /** The search query that was used to search the Knowledge Base documents for a matching question. */
    public var searchQuery: String?
    /** The document ID of the search answer. */
    public var answerDocumentId: String?

    public init(searchId: String?, knowledgeBaseId: String?, documents: [ReportingTurnKnowledgeDocument]?, searchQuery: String?, answerDocumentId: String?) {
        self.searchId = searchId
        self.knowledgeBaseId = knowledgeBaseId
        self.documents = documents
        self.searchQuery = searchQuery
        self.answerDocumentId = answerDocumentId
    }


}




public class RequestCriteria: Codable {







    public enum Operator: String, Codable { 
        case containsall = "containsAll"
        case containsany = "containsAny"
        case notcontainsall = "notContainsAll"
        case notcontainsany = "notContainsAny"
        case equal = "equal"
        case notequal = "notEqual"
        case greaterthan = "greaterThan"
        case greaterthanorequal = "greaterThanOrEqual"
        case lessthan = "lessThan"
        case lessthanorequal = "lessThanOrEqual"
        case startswith = "startsWith"
        case endswith = "endsWith"
    }

    /** The criteria key. */
    public var key: String?
    /** The criteria values. */
    public var values: [String]?
    /** Should criteria be case insensitive. */
    public var shouldIgnoreCase: Bool?
    /** The comparison operator. */
    public var _operator: Operator?

    public init(key: String?, values: [String]?, shouldIgnoreCase: Bool?, _operator: Operator?) {
        self.key = key
        self.values = values
        self.shouldIgnoreCase = shouldIgnoreCase
        self._operator = _operator
    }

    public enum CodingKeys: String, CodingKey { 
        case key
        case values
        case shouldIgnoreCase
        case _operator = "operator"
    }


}




public class RequestEntityTypeCriteria: Codable {







    public enum Operator: String, Codable { 
        case containsall = "containsAll"
        case containsany = "containsAny"
        case notcontainsall = "notContainsAll"
        case notcontainsany = "notContainsAny"
        case equal = "equal"
        case notequal = "notEqual"
        case greaterthan = "greaterThan"
        case greaterthanorequal = "greaterThanOrEqual"
        case lessthan = "lessThan"
        case lessthanorequal = "lessThanOrEqual"
        case startswith = "startsWith"
        case endswith = "endsWith"
    }

    public enum EntityType: String, Codable { 
        case visit = "visit"
    }

    /** The criteria key. */
    public var key: String?
    /** The criteria values. */
    public var values: [String]?
    /** Should criteria be case insensitive. */
    public var shouldIgnoreCase: Bool?
    /** The comparison operator. */
    public var _operator: Operator?
    /** The entity to match the pattern against. */
    public var entityType: EntityType?

    public init(key: String?, values: [String]?, shouldIgnoreCase: Bool?, _operator: Operator?, entityType: EntityType?) {
        self.key = key
        self.values = values
        self.shouldIgnoreCase = shouldIgnoreCase
        self._operator = _operator
        self.entityType = entityType
    }

    public enum CodingKeys: String, CodingKey { 
        case key
        case values
        case shouldIgnoreCase
        case _operator = "operator"
        case entityType
    }


}




public class RequiredLocalDateRange: Codable {





    /** The inclusive start of a date range in yyyy-MM-dd format. Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd */
    public var startDate: Date?
    /** The inclusive end of a date range in yyyy-MM-dd format. Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd */
    public var endDate: Date?

    public init(startDate: Date?, endDate: Date?) {
        self.startDate = startDate
        self.endDate = endDate
    }


}




public class ReschedulingManagementUnitResponse: Codable {





    /** The management unit */
    public var managementUnit: ManagementUnitReference?
    /** Whether the rescheduling run is applied for the given management unit */
    public var applied: Bool?

    public init(managementUnit: ManagementUnitReference?, applied: Bool?) {
        self.managementUnit = managementUnit
        self.applied = applied
    }


}




public class ReschedulingOptionsRunResponse: Codable {





















    /** The existing schedule to which this reschedule run applies */
    public var existingSchedule: BuScheduleReference?
    /** The start date of the period to reschedule. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var startDate: Date?
    /** The end date of the period to reschedule. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var endDate: Date?
    /** Per-management unit rescheduling options */
    public var managementUnits: [ReschedulingManagementUnitResponse]?
    /** The number of agents to be considered in the reschedule */
    public var agentCount: Int?
    /** The IDs of the activity codes being considered for reschedule */
    public var activityCodeIds: [String]?
    /** Whether weekly paid time is allowed to be changed */
    public var doNotChangeWeeklyPaidTime: Bool?
    /** Whether daily paid time is allowed to be changed */
    public var doNotChangeDailyPaidTime: Bool?
    /** Whether shift start times are allowed to be changed */
    public var doNotChangeShiftStartTimes: Bool?
    /** Whether manually edited shifts are allowed to be changed */
    public var doNotChangeManuallyEditedShifts: Bool?

    public init(existingSchedule: BuScheduleReference?, startDate: Date?, endDate: Date?, managementUnits: [ReschedulingManagementUnitResponse]?, agentCount: Int?, activityCodeIds: [String]?, doNotChangeWeeklyPaidTime: Bool?, doNotChangeDailyPaidTime: Bool?, doNotChangeShiftStartTimes: Bool?, doNotChangeManuallyEditedShifts: Bool?) {
        self.existingSchedule = existingSchedule
        self.startDate = startDate
        self.endDate = endDate
        self.managementUnits = managementUnits
        self.agentCount = agentCount
        self.activityCodeIds = activityCodeIds
        self.doNotChangeWeeklyPaidTime = doNotChangeWeeklyPaidTime
        self.doNotChangeDailyPaidTime = doNotChangeDailyPaidTime
        self.doNotChangeShiftStartTimes = doNotChangeShiftStartTimes
        self.doNotChangeManuallyEditedShifts = doNotChangeManuallyEditedShifts
    }


}




public class ResolutionDetailQueryFilter: Codable {

    public enum ModelType: String, Codable { 
        case and = "and"
        case or = "or"
    }





    /** Boolean operation to apply to the provided predicates and clauses */
    public var type: ModelType?
    /** Boolean 'and/or' logic with up to two-levels of nesting */
    public var clauses: [ResolutionDetailQueryClause]?
    /** Like a three-word sentence: (attribute-name) (operator) (target-value). */
    public var predicates: [ResolutionDetailQueryPredicate]?

    public init(type: ModelType?, clauses: [ResolutionDetailQueryClause]?, predicates: [ResolutionDetailQueryPredicate]?) {
        self.type = type
        self.clauses = clauses
        self.predicates = predicates
    }


}




public class ResourceConditionValue: Codable {

    public enum ModelType: String, Codable { 
        case scalar = "SCALAR"
        case variable = "VARIABLE"
        case user = "USER"
        case queue = "QUEUE"
        case team = "TEAM"
    }



    public var type: ModelType?
    public var value: String?

    public init(type: ModelType?, value: String?) {
        self.type = type
        self.value = value
    }


}




public class ResourcePermissionPolicy: Codable {























    public var _id: String?
    public var domain: String?
    public var entityName: String?
    public var policyName: String?
    public var policyDescription: String?
    public var actionSetKey: String?
    public var allowConditions: Bool?
    public var resourceConditionNode: ResourceConditionNode?
    public var namedResources: [String]?
    public var resourceCondition: String?
    public var actionSet: [String]?

    public init(_id: String?, domain: String?, entityName: String?, policyName: String?, policyDescription: String?, actionSetKey: String?, allowConditions: Bool?, resourceConditionNode: ResourceConditionNode?, namedResources: [String]?, resourceCondition: String?, actionSet: [String]?) {
        self._id = _id
        self.domain = domain
        self.entityName = entityName
        self.policyName = policyName
        self.policyDescription = policyDescription
        self.actionSetKey = actionSetKey
        self.allowConditions = allowConditions
        self.resourceConditionNode = resourceConditionNode
        self.namedResources = namedResources
        self.resourceCondition = resourceCondition
        self.actionSet = actionSet
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case domain
        case entityName
        case policyName
        case policyDescription
        case actionSetKey
        case allowConditions
        case resourceConditionNode
        case namedResources
        case resourceCondition
        case actionSet
    }


}




public class ResponseAsset: Codable {

























    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** The division to which this entity belongs. */
    public var division: Division?
    /** response asset size in bytes */
    public var contentLength: Int64?
    /** response asset location. */
    public var contentLocation: String?
    /** MIME type of response asset */
    public var contentType: String?
    /** Created date of the response asset. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** User who created the response asset */
    public var createdBy: DomainEntityRef?
    /** Last modified date of the response asset. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** User who last modified the response asset */
    public var modifiedBy: DomainEntityRef?
    /** Canned responses actively using this asset */
    public var responses: [DomainEntityRef]?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, division: Division?, contentLength: Int64?, contentLocation: String?, contentType: String?, dateCreated: Date?, createdBy: DomainEntityRef?, dateModified: Date?, modifiedBy: DomainEntityRef?, responses: [DomainEntityRef]?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.division = division
        self.contentLength = contentLength
        self.contentLocation = contentLocation
        self.contentType = contentType
        self.dateCreated = dateCreated
        self.createdBy = createdBy
        self.dateModified = dateModified
        self.modifiedBy = modifiedBy
        self.responses = responses
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case division
        case contentLength
        case contentLocation
        case contentType
        case dateCreated
        case createdBy
        case dateModified
        case modifiedBy
        case responses
        case selfUri
    }


}




public class ResponseAssetRequest: Codable {





    /** Name of the file to upload. It must not start with a dot and not end with a forward slash. Whitespace and the following characters are not allowed: \\{^}%`]\">[~<#| */
    public var name: String?
    /** Division to associate to this asset. Can only be used with this division. */
    public var divisionId: String?

    public init(name: String?, divisionId: String?) {
        self.name = name
        self.divisionId = divisionId
    }


}




public class ResponseEntityListing: Codable {





















    public var entities: [ModelResponse]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var previousUri: String?
    public var nextUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [ModelResponse]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, previousUri: String?, nextUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.previousUri = previousUri
        self.nextUri = nextUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class ResponseSetEntityListing: Codable {





















    public var entities: [ResponseSet]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var previousUri: String?
    public var nextUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [ResponseSet]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, previousUri: String?, nextUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.previousUri = previousUri
        self.nextUri = nextUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class RoleDivision: Codable {





    /** Role to be associated with the given division which forms a grant */
    public var roleId: String?
    /** Division associated with the given role which forms a grant */
    public var divisionId: String?

    public init(roleId: String?, divisionId: String?) {
        self.roleId = roleId
        self.divisionId = divisionId
    }


}




public class RoomParticipant: Codable {



    /** participantJid */
    public var participantJid: String?

    public init(participantJid: String?) {
        self.participantJid = participantJid
    }


}




public class RoomUpdateRequest: Codable {









    /** Room's description */
    public var _description: String?
    /** Room's subject */
    public var subject: String?
    /** Room's pinned messages */
    public var pinnedMessageIds: [String]?
    /** Room's owners */
    public var ownerIds: [String]?

    public init(_description: String?, subject: String?, pinnedMessageIds: [String]?, ownerIds: [String]?) {
        self._description = _description
        self.subject = subject
        self.pinnedMessageIds = pinnedMessageIds
        self.ownerIds = ownerIds
    }

    public enum CodingKeys: String, CodingKey { 
        case _description = "description"
        case subject
        case pinnedMessageIds
        case ownerIds
    }


}




public class RoutePathRequest: Codable {



    public enum MediaType: String, Codable { 
        case voice = "Voice"
        case chat = "Chat"
        case email = "Email"
        case callback = "Callback"
        case message = "Message"
        case workitem = "Workitem"
    }







    /** The ID of the queue to associate with the route path */
    public var queueId: String?
    /** The media type of the given queue to associate with the route path */
    public var mediaType: MediaType?
    /** The ID of the language to associate with the route path */
    public var languageId: String?
    /** The set of skill IDs to associate with the route path */
    public var skillIds: [String]?
    /** The planning group from which to take route paths. This property is only needed if a route path already exists in another planning group.Note that taking a route path from another planning group will modify the other planning group */
    public var sourcePlanningGroup: SourcePlanningGroupRequest?

    public init(queueId: String?, mediaType: MediaType?, languageId: String?, skillIds: [String]?, sourcePlanningGroup: SourcePlanningGroupRequest?) {
        self.queueId = queueId
        self.mediaType = mediaType
        self.languageId = languageId
        self.skillIds = skillIds
        self.sourcePlanningGroup = sourcePlanningGroup
    }


}




public class RoutingActivityEntityData: Codable {





















    /** The time at which the activity was observed. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var activityDate: Date?
    /** Organization presence identifier */
    public var organizationPresenceId: String?
    /** Date of the latest presence change. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var presenceDate: Date?
    /** Queue identifier */
    public var queueId: String?
    /** Queue membership status (e.g. active or inactive) */
    public var queueMembershipStatus: String?
    /** Agent routing status */
    public var routingStatus: String?
    /** Date of the latest routing status change. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var routingStatusDate: Date?
    /** System presence */
    public var systemPresence: String?
    /** The team ID the user is a member of */
    public var teamId: String?
    /** Unique identifier for the user */
    public var userId: String?

    public init(activityDate: Date?, organizationPresenceId: String?, presenceDate: Date?, queueId: String?, queueMembershipStatus: String?, routingStatus: String?, routingStatusDate: Date?, systemPresence: String?, teamId: String?, userId: String?) {
        self.activityDate = activityDate
        self.organizationPresenceId = organizationPresenceId
        self.presenceDate = presenceDate
        self.queueId = queueId
        self.queueMembershipStatus = queueMembershipStatus
        self.routingStatus = routingStatus
        self.routingStatusDate = routingStatusDate
        self.systemPresence = systemPresence
        self.teamId = teamId
        self.userId = userId
    }


}




public class RoutingConversationAttributesResponse: Codable {











    /** Current priority value on in-queue conversation. Range:[-25000000, 25000000] */
    public var priority: Int?
    /** Current routing skills on in-queue conversation */
    public var skills: [RoutingSkill]?
    /** Current language on in-queue conversation */
    public var language: Language?
    /** Current label on in-queue conversation */
    public var label: UtilizationLabel?
    /** Current scored agents on in-queue conversation */
    public var scoredAgents: [ScoredAgent]?

    public init(priority: Int?, skills: [RoutingSkill]?, language: Language?, label: UtilizationLabel?, scoredAgents: [ScoredAgent]?) {
        self.priority = priority
        self.skills = skills
        self.language = language
        self.label = label
        self.scoredAgents = scoredAgents
    }


}




public class RowSearchFilter: Codable {



    /** The predicates that each row matches in the search results must match */
    public var predicates: [RowSearchPredicate]?

    public init(predicates: [RowSearchPredicate]?) {
        self.predicates = predicates
    }


}




public class RuleEngineConfig: Codable {





    /** List of rules to evaluate by the engine. */
    public var rules: [RuleConfig]?
    /** Fallback configuration. */
    public var fallback: Fallback?

    public init(rules: [RuleConfig]?, fallback: Fallback?) {
        self.rules = rules
        self.fallback = fallback
    }


}




public class SAMLProvider: Codable {























    public enum NameIdentifierFormat: String, Codable { 
        case urnOasisNamesTcSaml11NameidFormatUnspecified = "urn:oasis:names:tc:SAML:1.1:nameid-format:unspecified"
        case urnOasisNamesTcSaml11NameidFormatEmailaddress = "urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress"
        case urnOasisNamesTcSaml11NameidFormatX509subjectname = "urn:oasis:names:tc:SAML:1.1:nameid-format:X509SubjectName"
        case urnOasisNamesTcSaml11NameidFormatWindowsdomainqualifiedname = "urn:oasis:names:tc:SAML:1.1:nameid-format:WindowsDomainQualifiedName"
        case urnOasisNamesTcSaml20NameidFormatKerberos = "urn:oasis:names:tc:SAML:2.0:nameid-format:kerberos"
        case urnOasisNamesTcSaml20NameidFormatEntity = "urn:oasis:names:tc:SAML:2.0:nameid-format:entity"
        case urnOasisNamesTcSaml20NameidFormatPersistent = "urn:oasis:names:tc:SAML:2.0:nameid-format:persistent"
        case urnOasisNamesTcSaml20NameidFormatTransient = "urn:oasis:names:tc:SAML:2.0:nameid-format:transient"
    }

    public enum SsoBinding: String, Codable { 
        case urnOasisNamesTcSaml20BindingsHttpPost = "urn:oasis:names:tc:SAML:2.0:bindings:HTTP-POST"
        case urnOasisNamesTcSaml20BindingsHttpRedirect = "urn:oasis:names:tc:SAML:2.0:bindings:HTTP-Redirect"
    }











    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    public var disabled: Bool?
    public var issuerURI: String?
    public var ssoTargetURI: String?
    public var sloURI: String?
    public var sloBinding: String?
    public var relyingPartyIdentifier: String?
    public var certificate: String?
    public var certificates: [String]?
    public var logoImageData: String?
    public var nameIdentifierFormat: NameIdentifierFormat?
    public var ssoBinding: SsoBinding?
    public var signAuthnRequests: Bool?
    public var providerName: String?
    public var displayOnLogin: Bool?
    public var metadataURL: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, disabled: Bool?, issuerURI: String?, ssoTargetURI: String?, sloURI: String?, sloBinding: String?, relyingPartyIdentifier: String?, certificate: String?, certificates: [String]?, logoImageData: String?, nameIdentifierFormat: NameIdentifierFormat?, ssoBinding: SsoBinding?, signAuthnRequests: Bool?, providerName: String?, displayOnLogin: Bool?, metadataURL: String?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.disabled = disabled
        self.issuerURI = issuerURI
        self.ssoTargetURI = ssoTargetURI
        self.sloURI = sloURI
        self.sloBinding = sloBinding
        self.relyingPartyIdentifier = relyingPartyIdentifier
        self.certificate = certificate
        self.certificates = certificates
        self.logoImageData = logoImageData
        self.nameIdentifierFormat = nameIdentifierFormat
        self.ssoBinding = ssoBinding
        self.signAuthnRequests = signAuthnRequests
        self.providerName = providerName
        self.displayOnLogin = displayOnLogin
        self.metadataURL = metadataURL
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case disabled
        case issuerURI
        case ssoTargetURI
        case sloURI
        case sloBinding
        case relyingPartyIdentifier
        case certificate
        case certificates
        case logoImageData
        case nameIdentifierFormat
        case ssoBinding
        case signAuthnRequests
        case providerName
        case displayOnLogin
        case metadataURL
        case selfUri
    }


}




public class SchedulingSettingsRequest: Codable {











    public enum StartDayOfWeekend: String, Codable { 
        case sunday = "Sunday"
        case monday = "Monday"
        case tuesday = "Tuesday"
        case wednesday = "Wednesday"
        case thursday = "Thursday"
        case friday = "Friday"
        case saturday = "Saturday"
    }

    /** Max occupancy percent for deferred work */
    public var maxOccupancyPercentForDeferredWork: Int?
    /** Default shrinkage percent for scheduling */
    public var defaultShrinkagePercent: Double?
    /** Shrinkage overrides for scheduling */
    public var shrinkageOverrides: ShrinkageOverrides?
    /** Planning period settings for scheduling. Only one of planningPeriod or monthlyPlanningPeriod may be defined */
    public var planningPeriod: ValueWrapperPlanningPeriodSettings?
    /** Monthly planning period setting for scheduling. Only one of planningPeriod or monthlyPlanningPeriod may be defined */
    public var monthlyPlanningPeriod: ValueWrapperMonthlyPlanningPeriodSettings?
    /** Start day of weekend for scheduling */
    public var startDayOfWeekend: StartDayOfWeekend?

    public init(maxOccupancyPercentForDeferredWork: Int?, defaultShrinkagePercent: Double?, shrinkageOverrides: ShrinkageOverrides?, planningPeriod: ValueWrapperPlanningPeriodSettings?, monthlyPlanningPeriod: ValueWrapperMonthlyPlanningPeriodSettings?, startDayOfWeekend: StartDayOfWeekend?) {
        self.maxOccupancyPercentForDeferredWork = maxOccupancyPercentForDeferredWork
        self.defaultShrinkagePercent = defaultShrinkagePercent
        self.shrinkageOverrides = shrinkageOverrides
        self.planningPeriod = planningPeriod
        self.monthlyPlanningPeriod = monthlyPlanningPeriod
        self.startDayOfWeekend = startDayOfWeekend
    }


}



/** Defines a SCIM email address. */

public class ScimEmail: Codable {



    public enum ModelType: String, Codable { 
        case work = "work"
        case other = "other"
    }



    /** The email address. Is immutable if \"type\" is set to \"other\". */
    public var value: String?
    /** The type of email address. \"value\" is immutable if \"type\" is set to \"other\". */
    public var type: ModelType?
    /** Indicates whether the email address is the primary email address. */
    public var primary: Bool?

    public init(value: String?, type: ModelType?, primary: Bool?) {
        self.value = value
        self.type = type
        self.primary = primary
    }


}



/** Defines a SCIM phone number. */

public class ScimPhoneNumber: Codable {



    public enum ModelType: String, Codable { 
        case work = "work"
        case work2 = "work2"
        case work3 = "work3"
        case work4 = "work4"
        case home = "home"
        case mobile = "mobile"
        case other = "other"
        case microsoftteams = "microsoftteams"
        case zoomphone = "zoomphone"
        case eightbyeight = "eightbyeight"
        case ringcentral = "ringcentral"
    }



    /** The phone number in E.164 or tel URI format, for example, tel:+nnnnnnnn; ext=xxxxx. */
    public var value: String?
    /** The type of phone number. */
    public var type: ModelType?
    /** Indicates whether the phone number is the primary phone number. */
    public var primary: Bool?

    public init(value: String?, type: ModelType?, primary: Bool?) {
        self.value = value
        self.type = type
        self.primary = primary
    }


}



/** The routing language assigned to a user. */

public class ScimUserRoutingLanguage: Codable {





    /** The case-sensitive name of a routing language configured in Genesys Cloud. */
    public var name: String?
    /** A rating from 0.0 to 5.0 that indicates how fluent an agent is in a particular language. ACD interactions are routed to agents with higher proficiency ratings. */
    public var proficiency: Double?

    public init(name: String?, proficiency: Double?) {
        self.name = name
        self.proficiency = proficiency
    }


}



/** Defines a SCIM enterprise user. */

public class ScimV2EnterpriseUser: Codable {











    /** The division that the user belongs to. */
    public var division: String?
    /** The department that the user belongs to. */
    public var department: String?
    /** The user's manager. */
    public var manager: Manager?
    /** The user's employee number. */
    public var employeeNumber: String?
    /** The user's hire date. Format in JSON will be YYYY-MM-DD. */
    public var dateHire: String?

    public init(division: String?, department: String?, manager: Manager?, employeeNumber: String?, dateHire: String?) {
        self.division = division
        self.department = department
        self.manager = manager
        self.employeeNumber = employeeNumber
        self.dateHire = dateHire
    }


}



/** Defines the list response for SCIM resource types. */

public class ScimV2SchemaListResponse: Codable {











    /** The list of supported schemas. */
    public var schemas: [String]?
    /** The total number of results. */
    public var totalResults: Int64?
    /** The 1-based index of the first result returned by this request. Add this to \"itemsPerPage\" when requesting the next page of results. */
    public var startIndex: Int64?
    /** The number of resources returned per page. */
    public var itemsPerPage: Int64?
    /** The list of requested resources. */
    public var resources: [ScimV2SchemaDefinition]?

    public init(schemas: [String]?, totalResults: Int64?, startIndex: Int64?, itemsPerPage: Int64?, resources: [ScimV2SchemaDefinition]?) {
        self.schemas = schemas
        self.totalResults = totalResults
        self.startIndex = startIndex
        self.itemsPerPage = itemsPerPage
        self.resources = resources
    }

    public enum CodingKeys: String, CodingKey { 
        case schemas
        case totalResults
        case startIndex
        case itemsPerPage
        case resources = "Resources"
    }


}




public class Screenshare: Codable {

    public enum State: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case _none = "none"
    }

    public enum InitialState: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case _none = "none"
    }









    public enum DisconnectType: String, Codable { 
        case endpoint = "endpoint"
        case client = "client"
        case system = "system"
        case timeout = "timeout"
        case transfer = "transfer"
        case transferConference = "transfer.conference"
        case transferConsult = "transfer.consult"
        case transferForward = "transfer.forward"
        case transferNoanswer = "transfer.noanswer"
        case transferNotavailable = "transfer.notavailable"
        case transportFailure = "transport.failure"
        case error = "error"
        case peer = "peer"
        case other = "other"
        case spam = "spam"
        case uncallable = "uncallable"
    }



















    /** The connection state of this communication. */
    public var state: State?
    /** The initial connection state of this communication. */
    public var initialState: InitialState?
    /** A globally unique identifier for this communication. */
    public var _id: String?
    /** The room id context (xmpp jid) for the conference session. */
    public var context: String?
    /** Indicates whether this participant is sharing their screen. */
    public var sharing: Bool?
    /** The number of peer participants from the perspective of the participant in the conference. */
    public var peerCount: Int?
    /** System defined string indicating what caused the communication to disconnect. Will be null until the communication disconnects. */
    public var disconnectType: DisconnectType?
    /** The timestamp the communication has when it is first put into an alerting state. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var startAlertingTime: Date?
    /** The timestamp when this communication was connected in the cloud clock. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var connectedTime: Date?
    /** The timestamp when this communication disconnected from the conversation in the provider clock. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var disconnectedTime: Date?
    /** The source provider for the screen share. */
    public var provider: String?
    /** The id of the peer communication corresponding to a matching leg for this communication. */
    public var peerId: String?
    /** The time line of the participant's call, divided into activity segments. */
    public var segments: [Segment]?
    /** Call wrap up or disposition data. */
    public var wrapup: Wrapup?
    /** After-call work for the communication. */
    public var afterCallWork: AfterCallWork?
    /** Indicates if after-call work is required for a communication. Only used when the ACW Setting is Agent Requested. */
    public var afterCallWorkRequired: Bool?

    public init(state: State?, initialState: InitialState?, _id: String?, context: String?, sharing: Bool?, peerCount: Int?, disconnectType: DisconnectType?, startAlertingTime: Date?, connectedTime: Date?, disconnectedTime: Date?, provider: String?, peerId: String?, segments: [Segment]?, wrapup: Wrapup?, afterCallWork: AfterCallWork?, afterCallWorkRequired: Bool?) {
        self.state = state
        self.initialState = initialState
        self._id = _id
        self.context = context
        self.sharing = sharing
        self.peerCount = peerCount
        self.disconnectType = disconnectType
        self.startAlertingTime = startAlertingTime
        self.connectedTime = connectedTime
        self.disconnectedTime = disconnectedTime
        self.provider = provider
        self.peerId = peerId
        self.segments = segments
        self.wrapup = wrapup
        self.afterCallWork = afterCallWork
        self.afterCallWorkRequired = afterCallWorkRequired
    }

    public enum CodingKeys: String, CodingKey { 
        case state
        case initialState
        case _id = "id"
        case context
        case sharing
        case peerCount
        case disconnectType
        case startAlertingTime
        case connectedTime
        case disconnectedTime
        case provider
        case peerId
        case segments
        case wrapup
        case afterCallWork
        case afterCallWorkRequired
    }


}




public class Script: Codable {































    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** The division to which this entity belongs. */
    public var division: Division?
    public var versionId: String?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var createdDate: Date?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var modifiedDate: Date?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var publishedDate: Date?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var versionDate: Date?
    public var startPageId: String?
    public var startPageName: String?
    public var features: JSON?
    public var variables: JSON?
    public var customActions: JSON?
    public var pages: [Page]?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, division: Division?, versionId: String?, createdDate: Date?, modifiedDate: Date?, publishedDate: Date?, versionDate: Date?, startPageId: String?, startPageName: String?, features: JSON?, variables: JSON?, customActions: JSON?, pages: [Page]?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.division = division
        self.versionId = versionId
        self.createdDate = createdDate
        self.modifiedDate = modifiedDate
        self.publishedDate = publishedDate
        self.versionDate = versionDate
        self.startPageId = startPageId
        self.startPageName = startPageName
        self.features = features
        self.variables = variables
        self.customActions = customActions
        self.pages = pages
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case division
        case versionId
        case createdDate
        case modifiedDate
        case publishedDate
        case versionDate
        case startPageId
        case startPageName
        case features
        case variables
        case customActions
        case pages
        case selfUri
    }


}




public class SearchShiftTradesRequest: Codable {





    /** The ID of the schedule for which to search for available shift trades */
    public var receivingScheduleId: String?
    /** The IDs of shifts that the receiving user would potentially be willing to trade. If empty, only returns one sided trades (pick up a shift) */
    public var receivingShiftIds: [String]?

    public init(receivingScheduleId: String?, receivingShiftIds: [String]?) {
        self.receivingScheduleId = receivingScheduleId
        self.receivingShiftIds = receivingShiftIds
    }


}




public class SearchUpdateRequest: Codable {









    /** The unique identifier of this session */
    public var sessionId: String?
    /** Mark the search as answered/unanswered */
    public var answered: Bool?
    /** The selected search result chosen as the answer. */
    public var selectedAnswer: SelectedAnswer?
    /** The search results selected as answers */
    public var selectedAnswers: [SelectedAnswer]?

    public init(sessionId: String?, answered: Bool?, selectedAnswer: SelectedAnswer?, selectedAnswers: [SelectedAnswer]?) {
        self.sessionId = sessionId
        self.answered = answered
        self.selectedAnswer = selectedAnswer
        self.selectedAnswers = selectedAnswers
    }


}




public class SecurityProfileEntityListing: Codable {





















    public var entities: [SecurityProfile]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var previousUri: String?
    public var nextUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [SecurityProfile]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, previousUri: String?, nextUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.previousUri = previousUri
        self.nextUri = nextUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class SegmentForUnassignment: Codable {



    /** The ID of the segment to be unassigned. */
    public var _id: String?

    public init(_id: String?) {
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
    }


}




public class SegmentUnassignments: Codable {



    /** The segments to be unassigned. */
    public var segments: [SegmentForUnassignment]?

    public init(segments: [SegmentForUnassignment]?) {
        self.segments = segments
    }


}




public class SentimentData: Codable {



    /** The sentiment insights extracted from the conversation */
    public var insights: SentimentInsights?

    public init(insights: SentimentInsights?) {
        self.insights = insights
    }


}




public class SentimentFeedback: Codable {







    public enum FeedbackValue: String, Codable { 
        case neutral = "Neutral"
        case positive = "Positive"
        case negative = "Negative"
    }





    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The phrase for which sentiment feedback is provided */
    public var phrase: String?
    /** The dialect for the given phrase, dialect format is {language}-{country} where language follows ISO 639-1 standard and country follows ISO 3166-1 alpha 2 standard */
    public var dialect: String?
    /** The sentiment feedback value for the given phrase */
    public var feedbackValue: FeedbackValue?
    /** The Timestamp when sentiment feedback created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** The Id of user who created the sentiment feedback */
    public var createdBy: AddressableEntityRef?

    public init(_id: String?, phrase: String?, dialect: String?, feedbackValue: FeedbackValue?, dateCreated: Date?, createdBy: AddressableEntityRef?) {
        self._id = _id
        self.phrase = phrase
        self.dialect = dialect
        self.feedbackValue = feedbackValue
        self.dateCreated = dateCreated
        self.createdBy = createdBy
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case phrase
        case dialect
        case feedbackValue
        case dateCreated
        case createdBy
    }


}




public class ServiceGoalTemplateImpactOverride: Codable {





    /** Whether service goal overrides are enabled for this service goal template */
    public var enabled: Bool?
    /** Settings controlling max percent increase and decrease of service goals for this service goal template */
    public var impact: WfmServiceGoalImpactSettings?

    public init(enabled: Bool?, impact: WfmServiceGoalImpactSettings?) {
        self.enabled = enabled
        self.impact = impact
    }


}




public class Share: Codable {





    public enum SharedEntityType: String, Codable { 
        case document = "DOCUMENT"
    }



    public enum MemberType: String, Codable { 
        case user = "USER"
        case group = "GROUP"
        case _public = "PUBLIC"
    }













    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    public var sharedEntityType: SharedEntityType?
    public var sharedEntity: DomainEntityRef?
    public var memberType: MemberType?
    public var member: DomainEntityRef?
    public var sharedBy: DomainEntityRef?
    public var workspace: DomainEntityRef?
    public var user: User?
    public var group: Group?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, sharedEntityType: SharedEntityType?, sharedEntity: DomainEntityRef?, memberType: MemberType?, member: DomainEntityRef?, sharedBy: DomainEntityRef?, workspace: DomainEntityRef?, user: User?, group: Group?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.sharedEntityType = sharedEntityType
        self.sharedEntity = sharedEntity
        self.memberType = memberType
        self.member = member
        self.sharedBy = sharedBy
        self.workspace = workspace
        self.user = user
        self.group = group
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case sharedEntityType
        case sharedEntity
        case memberType
        case member
        case sharedBy
        case workspace
        case user
        case group
        case selfUri
    }


}




public class ServiceNowSourceRequest: Codable {













    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The name of the integration source. */
    public var name: String?
    /** The integration associated with the source. */
    public var integrationId: String?
    /** The schedule period of the source in hours. Must be at least 6 and at most 48 hours. */
    public var schedulePeriod: Int?
    /** The settings of the source. */
    public var settings: ServiceNowSettings?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, integrationId: String?, schedulePeriod: Int?, settings: ServiceNowSettings?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.integrationId = integrationId
        self.schedulePeriod = schedulePeriod
        self.settings = settings
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case integrationId
        case schedulePeriod
        case settings
        case selfUri
    }


}




public class SessionEndDetails: Codable {

    public enum ModelType: String, Codable { 
        case disconnect = "Disconnect"
        case exit = "Exit"
    }



    /** The type of termination handling that resulted in the session end. It can be either Exit or Disconnect */
    public var type: ModelType?
    /** The reason for termination action. It can be due to an error or normal flow execution */
    public var reason: String?

    public init(type: ModelType?, reason: String?) {
        self.type = type
        self.reason = reason
    }


}




public class SetContentTemplateActionSettings: Codable {





    /** A string of sms contentTemplateId. */
    public var smsContentTemplateId: String?
    /** A string of email contentTemplateId. */
    public var emailContentTemplateId: String?

    public init(smsContentTemplateId: String?, emailContentTemplateId: String?) {
        self.smsContentTemplateId = smsContentTemplateId
        self.emailContentTemplateId = emailContentTemplateId
    }


}




public class Settings: Codable {













    /** Communication Based ACW */
    public var communicationBasedACW: Bool?
    /** Display communication summary */
    public var includeNonAgentConversationSummary: Bool?
    /** Allow Callback Queue Selection */
    public var allowCallbackQueueSelection: Bool?
    /** Inherit callback routing data from inbound calls */
    public var callbacksInheritRoutingFromInboundCall: Bool?
    /** Complete ACW When Agent Transitions Offline */
    public var completeAcwWhenAgentTransitionsOffline: Bool?
    /** Exclude the 'interacting' duration from the handle calculations of callbacks */
    public var totalActiveCallback: Bool?

    public init(communicationBasedACW: Bool?, includeNonAgentConversationSummary: Bool?, allowCallbackQueueSelection: Bool?, callbacksInheritRoutingFromInboundCall: Bool?, completeAcwWhenAgentTransitionsOffline: Bool?, totalActiveCallback: Bool?) {
        self.communicationBasedACW = communicationBasedACW
        self.includeNonAgentConversationSummary = includeNonAgentConversationSummary
        self.allowCallbackQueueSelection = allowCallbackQueueSelection
        self.callbacksInheritRoutingFromInboundCall = callbacksInheritRoutingFromInboundCall
        self.completeAcwWhenAgentTransitionsOffline = completeAcwWhenAgentTransitionsOffline
        self.totalActiveCallback = totalActiveCallback
    }


}




public class ShiftTradeActivityRule: Codable {

    public enum ActivityCategory: String, Codable { 
        case onQueueWork = "OnQueueWork"
        case _break = "Break"
        case meal = "Meal"
        case meeting = "Meeting"
        case offQueueWork = "OffQueueWork"
        case timeOff = "TimeOff"
        case training = "Training"
        case unavailable = "Unavailable"
    }

    public enum Action: String, Codable { 
        case replace = "Replace"
        case doNotAllowTrade = "DoNotAllowTrade"
        case keepWithSchedule = "KeepWithSchedule"
    }



    /** The activity category to which to apply this rule */
    public var activityCategory: ActivityCategory?
    /** The action this rule invokes */
    public var action: Action?
    /** The ID of the activity code with which to replace activities belonging to the original category if applicable (required if action == Replace, must be a default activity code ID) */
    public var activityCodeIdReplacement: String?

    public init(activityCategory: ActivityCategory?, action: Action?, activityCodeIdReplacement: String?) {
        self.activityCategory = activityCategory
        self.action = action
        self.activityCodeIdReplacement = activityCodeIdReplacement
    }


}




public class ShiftTradeExternalActivityRule: Codable {

    public enum ExternalActivityType: String, Codable { 
        case activityPlan = "ActivityPlan"
        case coaching = "Coaching"
        case learning = "Learning"
    }

    public enum Action: String, Codable { 
        case doNotAllowTrade = "DoNotAllowTrade"
        case keepWithAgent = "KeepWithAgent"
    }



    /** The external activity type to which to apply this rule */
    public var externalActivityType: ExternalActivityType?
    /** The action this rule invokes */
    public var action: Action?
    /** The ID of the activity code with which to replace to replace external activities (required if action == KeepWithAgent, must be a default activity code ID) */
    public var activityCodeIdReplacement: String?

    public init(externalActivityType: ExternalActivityType?, action: Action?, activityCodeIdReplacement: String?) {
        self.externalActivityType = externalActivityType
        self.action = action
        self.activityCodeIdReplacement = activityCodeIdReplacement
    }


}




public class SkillGroupDefinition: Codable {

















    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The group name. */
    public var name: String?
    /** The division to which this entity belongs. */
    public var division: WritableDivision?
    /** Group description */
    public var _description: String?
    /** Estimated number of members in this group. It can take some time for the count to be updated after expressions are changed. */
    public var memberCount: Int64?
    /** Last modified date/time of the skill group. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** Created date/time of the skill group. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, division: WritableDivision?, _description: String?, memberCount: Int64?, dateModified: Date?, dateCreated: Date?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.division = division
        self._description = _description
        self.memberCount = memberCount
        self.dateModified = dateModified
        self.dateCreated = dateCreated
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case division
        case _description = "description"
        case memberCount
        case dateModified
        case dateCreated
        case selfUri
    }


}




public class SmsAddressEntityListing: Codable {





















    public var entities: [SmsAddress]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var previousUri: String?
    public var nextUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [SmsAddress]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, previousUri: String?, nextUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.previousUri = previousUri
        self.nextUri = nextUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class SmsPhoneNumberProvision: Codable {





    public enum PhoneNumberType: String, Codable { 
        case local = "local"
        case mobile = "mobile"
        case tollfree = "tollfree"
        case shortcode = "shortcode"
    }











    /** The globally unique identifier for the object. */
    public var _id: String?
    /** A phone number to be used for SMS communications. E.g. +13175555555 or +34234234234 */
    public var phoneNumber: String?
    /** Type of the phone number provisioned. */
    public var phoneNumberType: PhoneNumberType?
    /** The ISO 3166-1 alpha-2 country code of the country this phone number is associated with. */
    public var countryCode: String?
    public var name: String?
    /** The id of an address added on your account. Due to regulatory requirements in some countries, an address may be required when provisioning a sms number. In those cases you should provide the provisioned sms address id here */
    public var addressId: String?
    /** Defines the media SupportedContent profile configured for an MMS capable phone number. */
    public var supportedContent: SupportedContentReference?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, phoneNumber: String?, phoneNumberType: PhoneNumberType?, countryCode: String?, name: String?, addressId: String?, supportedContent: SupportedContentReference?, selfUri: String?) {
        self._id = _id
        self.phoneNumber = phoneNumber
        self.phoneNumberType = phoneNumberType
        self.countryCode = countryCode
        self.name = name
        self.addressId = addressId
        self.supportedContent = supportedContent
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case phoneNumber
        case phoneNumberType
        case countryCode
        case name
        case addressId
        case supportedContent
        case selfUri
    }


}




public class SocialEscalationResponseEntityListing: Codable {





















    public var entities: [EscalationRuleResponse]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var previousUri: String?
    public var nextUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [EscalationRuleResponse]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, previousUri: String?, nextUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.previousUri = previousUri
        self.nextUri = nextUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class SocialKeyword: Codable {





    /** List of keywords that must be included */
    public var includes: [String]?
    /** List of keywords that must be excluded */
    public var excludes: [String]?

    public init(includes: [String]?, excludes: [String]?) {
        self.includes = includes
        self.excludes = excludes
    }


}




public class SocialMediaAsyncDetailQueryResponse: Codable {





    public var results: [SocialMediaDetailDataContainer]?
    /** Cursor token to retrieve next or previous page */
    public var cursor: String?

    public init(results: [SocialMediaDetailDataContainer]?, cursor: String?) {
        self.results = results
        self.cursor = cursor
    }


}




public class SocialTopicRequest: Codable {







    /** Name of the social topic. */
    public var name: String?
    /** A description of the social topic. */
    public var _description: String?
    /** The ID of the division the social topic belongs to. */
    public var divisionId: String?

    public init(name: String?, _description: String?, divisionId: String?) {
        self.name = name
        self._description = _description
        self.divisionId = divisionId
    }

    public enum CodingKeys: String, CodingKey { 
        case name
        case _description = "description"
        case divisionId
    }


}




public class StaffingGroupMetricChangeResponse: Codable {







    public enum Metric: String, Codable { 
        case startingWeeklyFullTimeEquivalentCount = "StartingWeeklyFullTimeEquivalentCount"
        case newHiresFullTimeEquivalentCount = "NewHiresFullTimeEquivalentCount"
        case attritionPercentage = "AttritionPercentage"
        case shrinkagePercentage = "ShrinkagePercentage"
    }









    /** The number of weeks to which the metric change applies */
    public var numberOfWeeks: Int?
    /** The start number of the week (starting from 1) to which the metric change applies, related to numberOfWeeks */
    public var weekStartNumber: Int?
    /** The value of the metric */
    public var value: Double?
    /** The metric which is going to be modified for the selected staffing groups */
    public var metric: Metric?
    /** Notes about the staffing groups metric changes */
    public var notes: String?
    /** The staffing groups affected by the metric change */
    public var staffingGroups: [StaffingGroupReference]?
    /** The user who created the metric change */
    public var createdBy: UserReference?
    /** The date the entity was created, in ISO-8601 format */
    public var createdDate: Date?

    public init(numberOfWeeks: Int?, weekStartNumber: Int?, value: Double?, metric: Metric?, notes: String?, staffingGroups: [StaffingGroupReference]?, createdBy: UserReference?, createdDate: Date?) {
        self.numberOfWeeks = numberOfWeeks
        self.weekStartNumber = weekStartNumber
        self.value = value
        self.metric = metric
        self.notes = notes
        self.staffingGroups = staffingGroups
        self.createdBy = createdBy
        self.createdDate = createdDate
    }


}




public class StaffingGroupReference: Codable {





    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, selfUri: String?) {
        self._id = _id
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
    }


}




public class StatEventCampaignTopicStatsNotification: Codable {





    public var group: [String:String]?
    public var data: [StatEventCampaignTopicIntervalMetrics]?

    public init(group: [String:String]?, data: [StatEventCampaignTopicIntervalMetrics]?) {
        self.group = group
        self.data = data
    }


}




public class StatEventFlowOutcomeTopicStatsNotification: Codable {





    public var group: [String:String]?
    public var data: [StatEventFlowOutcomeTopicIntervalMetrics]?

    public init(group: [String:String]?, data: [StatEventFlowOutcomeTopicIntervalMetrics]?) {
        self.group = group
        self.data = data
    }


}




public class StatEventFlowTopicIntervalMetrics: Codable {





    public var interval: String?
    public var metrics: [StatEventFlowTopicMetricStats]?

    public init(interval: String?, metrics: [StatEventFlowTopicMetricStats]?) {
        self.interval = interval
        self.metrics = metrics
    }


}




public class StatEventFlowTopicMetricStats: Codable {







    public var metric: String?
    public var qualifier: String?
    public var stats: [String:Double]?

    public init(metric: String?, qualifier: String?, stats: [String:Double]?) {
        self.metric = metric
        self.qualifier = qualifier
        self.stats = stats
    }


}




public class StatEventUserTopicStatsNotification: Codable {





    public var group: [String:String]?
    public var data: [StatEventUserTopicIntervalMetrics]?

    public init(group: [String:String]?, data: [StatEventUserTopicIntervalMetrics]?) {
        self.group = group
        self.data = data
    }


}




public class StatisticalResponse: Codable {







    public var interval: String?
    public var metrics: [AggregateMetricData]?
    public var views: [AggregateViewData]?

    public init(interval: String?, metrics: [AggregateMetricData]?, views: [AggregateViewData]?) {
        self.interval = interval
        self.metrics = metrics
        self.views = views
    }


}




public class StorySetting: Codable {





    /** Setting relating to Story Mentions */
    public var mention: InboundOnlySetting?
    /** Setting relating to Story Replies */
    public var reply: InboundOnlySetting?

    public init(mention: InboundOnlySetting?, reply: InboundOnlySetting?) {
        self.mention = mention
        self.reply = reply
    }


}




public class Suggestion: Codable {



    public enum ModelType: String, Codable { 
        case faq = "Faq"
        case article = "Article"
        case knowledgeArticle = "KnowledgeArticle"
        case knowledgeSearch = "KnowledgeSearch"
        case cannedResponse = "CannedResponse"
        case script = "Script"
    }









    public enum TriggerType: String, Codable { 
        case unknown = "Unknown"
        case fallback = "Fallback"
        case conversationStart = "ConversationStart"
        case conversationTransfer = "ConversationTransfer"
        case conversationEnd = "ConversationEnd"
        case intent = "Intent"
    }



    public enum State: String, Codable { 
        case suggested = "Suggested"
        case accepted = "Accepted"
        case dismissed = "Dismissed"
        case failed = "Failed"
        case rated = "Rated"
    }















    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The type of the documents for which the suggestion is. */
    public var type: ModelType?
    /** The Faq from the knowledgebase that was provided as the suggestion. */
    public var faq: Faq?
    /** The article from the knowledgebase that was provided as the suggestion. */
    public var article: Article?
    /** Date when the suggestion was created. For example: yyyy-MM-ddTHH:mm:ss.SSZ. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** The ID of the knowledge search that provided the suggestion. */
    public var answerRecordId: String?
    /** The trigger type of the suggestion. */
    public var triggerType: TriggerType?
    /** The conversation context in which the suggestion was raised. */
    public var context: SuggestionContext?
    /** The state of the suggestion. */
    public var state: State?
    /** The suggested knowledge search result that was provided as the suggestion. */
    public var knowledgeSearch: SuggestionKnowledgeSearch?
    /** The suggested knowledge article that was provided as the suggestion. */
    public var knowledgeArticle: SuggestionKnowledgeArticle?
    /** The suggested canned response that was provided as the suggestion. */
    public var cannedResponse: SuggestionCannedResponse?
    /** The suggested script that was provided as the suggestion. */
    public var script: SuggestionScript?
    /** The URI for this object */
    public var selfUri: String?
    /** The conversation that the suggestions correspond to. */
    public var conversation: AddressableEntityRef?
    /** The assistant that was used to provide the suggestions. */
    public var assistant: AddressableEntityRef?

    public init(_id: String?, type: ModelType?, faq: Faq?, article: Article?, dateCreated: Date?, answerRecordId: String?, triggerType: TriggerType?, context: SuggestionContext?, state: State?, knowledgeSearch: SuggestionKnowledgeSearch?, knowledgeArticle: SuggestionKnowledgeArticle?, cannedResponse: SuggestionCannedResponse?, script: SuggestionScript?, selfUri: String?, conversation: AddressableEntityRef?, assistant: AddressableEntityRef?) {
        self._id = _id
        self.type = type
        self.faq = faq
        self.article = article
        self.dateCreated = dateCreated
        self.answerRecordId = answerRecordId
        self.triggerType = triggerType
        self.context = context
        self.state = state
        self.knowledgeSearch = knowledgeSearch
        self.knowledgeArticle = knowledgeArticle
        self.cannedResponse = cannedResponse
        self.script = script
        self.selfUri = selfUri
        self.conversation = conversation
        self.assistant = assistant
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case type
        case faq
        case article
        case dateCreated
        case answerRecordId
        case triggerType
        case context
        case state
        case knowledgeSearch
        case knowledgeArticle
        case cannedResponse
        case script
        case selfUri
        case conversation
        case assistant
    }


}




public class SuggestionListing: Codable {









    public var entities: [Suggestion]?
    public var nextUri: String?
    public var selfUri: String?
    public var previousUri: String?

    public init(entities: [Suggestion]?, nextUri: String?, selfUri: String?, previousUri: String?) {
        self.entities = entities
        self.nextUri = nextUri
        self.selfUri = selfUri
        self.previousUri = previousUri
    }


}




public class SummaryAggregateQueryResponse: Codable {



    public var results: [SummaryAggregateDataContainer]?

    public init(results: [SummaryAggregateDataContainer]?) {
        self.results = results
    }


}




public class SummaryAggregationView: Codable {

    public enum Target: String, Codable { 
        case nconversationsummaries = "nConversationSummaries"
        case nconversationsummaryengagements = "nConversationSummaryEngagements"
        case tconversationsummary = "tConversationSummary"
    }



    public enum Function: String, Codable { 
        case rangebound = "rangeBound"
    }



    /** Target metric name */
    public var target: Target?
    /** A unique name for this view. Must be distinct from other views and built-in metric names. */
    public var name: String?
    /** Type of view you wish to create */
    public var function: Function?
    /** Range of numbers for slicing up data */
    public var range: AggregationRange?

    public init(target: Target?, name: String?, function: Function?, range: AggregationRange?) {
        self.target = target
        self.name = name
        self.function = function
        self.range = range
    }


}




public class SummaryGenerationConfig: Codable {





    /** Copilot generated summary is enabled. */
    public var enabled: Bool?
    /** Configured summary setting object. */
    public var summarySetting: SummarySettingEntity?

    public init(enabled: Bool?, summarySetting: SummarySettingEntity?) {
        self.enabled = enabled
        self.summarySetting = summarySetting
    }


}




public class SummarySetting: Codable {







    public enum SummaryType: String, Codable { 
        case concise = "Concise"
        case detailed = "Detailed"
    }

    public enum Format: String, Codable { 
        case textBlock = "TextBlock"
        case bulletPoints = "BulletPoints"
        case groupedTextBlocks = "GroupedTextBlocks"
        case groupedBulletPoints = "GroupedBulletPoints"
    }





    public enum PredefinedInsights: String, Codable { 
        case reasonForCall = "ReasonForCall"
        case resolution = "Resolution"
        case actionItems = "ActionItems"
    }



    public enum SettingType: String, Codable { 
        case basic = "Basic"
        case prompt = "Prompt"
    }









    /** The globally unique identifier for the object. */
    public var _id: String?
    /** Name of the summary setting. */
    public var name: String?
    /** Language of the generated summary, e.g. en-US, it-IT. */
    public var language: String?
    /** Level of detail of the generated summary. */
    public var summaryType: SummaryType?
    /** Format of the generated summary. */
    public var format: Format?
    /** Displaying PII in the generated summary. */
    public var maskPII: SummarySettingPII?
    /** How to refer to interaction participants in the generated summary. */
    public var participantLabels: SummarySettingParticipantLabels?
    /** Set which insights to include in the generated summary by default. */
    public var predefinedInsights: [PredefinedInsights]?
    /** Custom entity definition. */
    public var customEntities: [SummarySettingCustomEntity]?
    /** Type of the summary setting. */
    public var settingType: SettingType?
    /** Custom prompt of summary setting. */
    public var prompt: String?
    /** The date and time the setting was created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** The date and time the setting was last modified. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, language: String?, summaryType: SummaryType?, format: Format?, maskPII: SummarySettingPII?, participantLabels: SummarySettingParticipantLabels?, predefinedInsights: [PredefinedInsights]?, customEntities: [SummarySettingCustomEntity]?, settingType: SettingType?, prompt: String?, dateCreated: Date?, dateModified: Date?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.language = language
        self.summaryType = summaryType
        self.format = format
        self.maskPII = maskPII
        self.participantLabels = participantLabels
        self.predefinedInsights = predefinedInsights
        self.customEntities = customEntities
        self.settingType = settingType
        self.prompt = prompt
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case language
        case summaryType
        case format
        case maskPII
        case participantLabels
        case predefinedInsights
        case customEntities
        case settingType
        case prompt
        case dateCreated
        case dateModified
        case selfUri
    }


}




public class SupportCenterCategory: Codable {







    public var _id: String?
    public var selfUri: String?
    /** Image attributes for a featured category */
    public var image: SupportCenterImage?

    public init(_id: String?, selfUri: String?, image: SupportCenterImage?) {
        self._id = _id
        self.selfUri = selfUri
        self.image = image
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
        case image
    }


}




public class SupportedLanguagesInfoDefinition: Codable {





    public enum Status: String, Codable { 
        case earlyPreview = "EARLY_PREVIEW"
        case preview = "PREVIEW"
        case ga = "GA"
    }





    /** The given supported Language */
    public var language: String?
    /** The boolean status of if intent classification is supported in this language */
    public var intentClassification: Bool?
    /** The language release status */
    public var status: Status?
    /** The supported entity types for this language */
    public var supportedEntityTypes: [String]?
    /** The configuration for the supported entity types */
    public var supportedEntityTypeConfiguration: SupportedEntityTypeStatus?

    public init(language: String?, intentClassification: Bool?, status: Status?, supportedEntityTypes: [String]?, supportedEntityTypeConfiguration: SupportedEntityTypeStatus?) {
        self.language = language
        self.intentClassification = intentClassification
        self.status = status
        self.supportedEntityTypes = supportedEntityTypes
        self.supportedEntityTypeConfiguration = supportedEntityTypeConfiguration
    }


}




public class Survey: Codable {











    public enum Status: String, Codable { 
        case pending = "Pending"
        case sent = "Sent"
        case inProgress = "InProgress"
        case finished = "Finished"
        case optOut = "OptOut"
        case error = "Error"
        case expired = "Expired"
    }











    public enum SurveyType: String, Codable { 
        case web = "Web"
        case voice = "Voice"
    }







    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    public var conversation: ConversationReference?
    /** Survey form used for this survey. */
    public var surveyForm: SurveyForm?
    public var agent: DomainEntityRef?
    public var status: Status?
    public var queue: QueueReference?
    public var answers: SurveyScoringSet?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var completedDate: Date?
    /** Additional information about what happened when the survey is in Error status. */
    public var surveyErrorDetails: SurveyErrorDetails?
    /** The team that the agent belongs to */
    public var agentTeam: Team?
    /** Type of the survey */
    public var surveyType: SurveyType?
    /** True if any of the required questions for the survey form have not been answered. Null if survey is not finished. */
    public var missingRequiredAnswer: Bool?
    /** An Architect flow that executed in order to collect the answers for this survey. */
    public var flow: AddressableEntityRef?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, conversation: ConversationReference?, surveyForm: SurveyForm?, agent: DomainEntityRef?, status: Status?, queue: QueueReference?, answers: SurveyScoringSet?, completedDate: Date?, surveyErrorDetails: SurveyErrorDetails?, agentTeam: Team?, surveyType: SurveyType?, missingRequiredAnswer: Bool?, flow: AddressableEntityRef?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.conversation = conversation
        self.surveyForm = surveyForm
        self.agent = agent
        self.status = status
        self.queue = queue
        self.answers = answers
        self.completedDate = completedDate
        self.surveyErrorDetails = surveyErrorDetails
        self.agentTeam = agentTeam
        self.surveyType = surveyType
        self.missingRequiredAnswer = missingRequiredAnswer
        self.flow = flow
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case conversation
        case surveyForm
        case agent
        case status
        case queue
        case answers
        case completedDate
        case surveyErrorDetails
        case agentTeam
        case surveyType
        case missingRequiredAnswer
        case flow
        case selfUri
    }


}




public class SurveyAggregateQueryPredicate: Codable {

    public enum ModelType: String, Codable { 
        case dimension = "dimension"
        case property = "property"
        case metric = "metric"
    }

    public enum Dimension: String, Codable { 
        case conversationid = "conversationId"
        case divisionid = "divisionId"
        case externalcontactid = "externalContactId"
        case mediatype = "mediaType"
        case queueid = "queueId"
        case requestedlanguageid = "requestedLanguageId"
        case requestedroutingskillid = "requestedRoutingSkillId"
        case surveyanswerid = "surveyAnswerId"
        case surveycreateddate = "surveyCreatedDate"
        case surveyerrorreason = "surveyErrorReason"
        case surveyformcontextid = "surveyFormContextId"
        case surveyformid = "surveyFormId"
        case surveyformname = "surveyFormName"
        case surveyid = "surveyId"
        case surveypartialresponse = "surveyPartialResponse"
        case surveypreviousstatus = "surveyPreviousStatus"
        case surveypromoterscore = "surveyPromoterScore"
        case surveyquestiongroupid = "surveyQuestionGroupId"
        case surveyquestionid = "surveyQuestionId"
        case surveystatus = "surveyStatus"
        case surveytype = "surveyType"
        case teamid = "teamId"
        case userid = "userId"
        case wrapupcode = "wrapUpCode"
    }

    public enum Operator: String, Codable { 
        case matches = "matches"
        case exists = "exists"
        case notexists = "notExists"
    }





    /** Optional type, can usually be inferred */
    public var type: ModelType?
    /** Left hand side for dimension predicates */
    public var dimension: Dimension?
    /** Optional operator, default is matches */
    public var _operator: Operator?
    /** Right hand side for dimension predicates */
    public var value: String?
    /** Right hand side for dimension predicates */
    public var range: NumericRange?

    public init(type: ModelType?, dimension: Dimension?, _operator: Operator?, value: String?, range: NumericRange?) {
        self.type = type
        self.dimension = dimension
        self._operator = _operator
        self.value = value
        self.range = range
    }

    public enum CodingKeys: String, CodingKey { 
        case type
        case dimension
        case _operator = "operator"
        case value
        case range
    }


}




public class SurveyScoringSet: Codable {







    public var totalScore: Float?
    public var npsScore: Int?
    public var questionGroupScores: [SurveyQuestionGroupScore]?

    public init(totalScore: Float?, npsScore: Int?, questionGroupScores: [SurveyQuestionGroupScore]?) {
        self.totalScore = totalScore
        self.npsScore = npsScore
        self.questionGroupScores = questionGroupScores
    }


}




public class SystemPromptAsset: Codable {



















    public enum UploadStatus: String, Codable { 
        case created = "created"
        case uploaded = "uploaded"
        case transcoded = "transcoded"
        case transcodefailed = "transcodeFailed"
    }









    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    public var promptId: String?
    /** The asset resource language */
    public var language: String?
    public var durationSeconds: Double?
    public var mediaUri: String?
    public var ttsString: String?
    public var text: String?
    /** Deprecated. This was use for uploading the resource audio. */
    public var uploadUri: String?
    public var uploadStatus: UploadStatus?
    public var hasDefault: Bool?
    public var languageDefault: Bool?
    public var tags: [String:[String]]?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, promptId: String?, language: String?, durationSeconds: Double?, mediaUri: String?, ttsString: String?, text: String?, uploadUri: String?, uploadStatus: UploadStatus?, hasDefault: Bool?, languageDefault: Bool?, tags: [String:[String]]?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.promptId = promptId
        self.language = language
        self.durationSeconds = durationSeconds
        self.mediaUri = mediaUri
        self.ttsString = ttsString
        self.text = text
        self.uploadUri = uploadUri
        self.uploadStatus = uploadStatus
        self.hasDefault = hasDefault
        self.languageDefault = languageDefault
        self.tags = tags
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case promptId
        case language
        case durationSeconds
        case mediaUri
        case ttsString
        case text
        case uploadUri
        case uploadStatus
        case hasDefault
        case languageDefault
        case tags
        case selfUri
    }


}




public class SystemPromptEntityListing: Codable {





















    public var entities: [SystemPrompt]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var previousUri: String?
    public var nextUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [SystemPrompt]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, previousUri: String?, nextUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.previousUri = previousUri
        self.nextUri = nextUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class TargetPerformanceProfile: Codable {



    /** The target destination performanceProfileId for the linked metric. */
    public var targetPerformanceProfileId: String?

    public init(targetPerformanceProfileId: String?) {
        self.targetPerformanceProfileId = targetPerformanceProfileId
    }


}




public class TaskManagementAggregateQueryPredicate: Codable {

    public enum ModelType: String, Codable { 
        case dimension = "dimension"
        case property = "property"
        case metric = "metric"
    }

    public enum Dimension: String, Codable { 
        case assigneeid = "assigneeId"
        case divisionid = "divisionId"
        case externaltag = "externalTag"
        case queueid = "queueId"
        case reporterid = "reporterId"
        case requestedlanguageid = "requestedLanguageId"
        case requestedrouting = "requestedRouting"
        case requestedroutingskillid = "requestedRoutingSkillId"
        case statuscategory = "statusCategory"
        case statusid = "statusId"
        case typeid = "typeId"
        case usedrouting = "usedRouting"
        case userid = "userId"
        case workbinid = "workbinId"
        case workitemid = "workitemId"
        case wrapupcode = "wrapUpCode"
    }

    public enum Operator: String, Codable { 
        case matches = "matches"
        case exists = "exists"
        case notexists = "notExists"
    }





    /** Optional type, can usually be inferred */
    public var type: ModelType?
    /** Left hand side for dimension predicates */
    public var dimension: Dimension?
    /** Optional operator, default is matches */
    public var _operator: Operator?
    /** Right hand side for dimension predicates */
    public var value: String?
    /** Right hand side for dimension predicates */
    public var range: NumericRange?

    public init(type: ModelType?, dimension: Dimension?, _operator: Operator?, value: String?, range: NumericRange?) {
        self.type = type
        self.dimension = dimension
        self._operator = _operator
        self.value = value
        self.range = range
    }

    public enum CodingKeys: String, CodingKey { 
        case type
        case dimension
        case _operator = "operator"
        case value
        case range
    }


}




public class TeamActivityData: Codable {









    /** A mapping from grouping dimension to value */
    public var group: [String:String]?
    /** Data for metrics */
    public var data: [TeamActivityMetricValue]?
    /** Flag for a truncated list of entities. If truncated, the first half of the list of entities will contain the oldest entities and the second half the newest entities. */
    public var truncated: Bool?
    /** Details for active entities */
    public var entities: [TeamActivityEntityData]?

    public init(group: [String:String]?, data: [TeamActivityMetricValue]?, truncated: Bool?, entities: [TeamActivityEntityData]?) {
        self.group = group
        self.data = data
        self.truncated = truncated
        self.entities = entities
    }


}




public class TeamActivityQueryFilter: Codable {

    public enum ModelType: String, Codable { 
        case and = "and"
        case or = "or"
    }





    /** Boolean operation to apply to the provided predicates and clauses */
    public var type: ModelType?
    /** Boolean 'and/or' logic with up to two-levels of nesting */
    public var clauses: [TeamActivityQueryClause]?
    /** Like a three-word sentence: (attribute-name) (operator) (target-value). */
    public var predicates: [TeamActivityQueryPredicate]?

    public init(type: ModelType?, clauses: [TeamActivityQueryClause]?, predicates: [TeamActivityQueryPredicate]?) {
        self.type = type
        self.clauses = clauses
        self.predicates = predicates
    }


}




public class TeamSearchRequest: Codable {

    public enum SortOrder: String, Codable { 
        case asc = "ASC"
        case desc = "DESC"
        case score = "SCORE"
    }











    /** The sort order for results */
    public var sortOrder: SortOrder?
    /** The field in the resource that you want to sort the results by */
    public var sortBy: String?
    /** The number of results per page */
    public var pageSize: Int?
    /** The page of resources you want to retrieve */
    public var pageNumber: Int?
    /** Multi-value sort order, list of multiple sort values */
    public var sort: [SearchSort]?
    /** Team Search Criteria */
    public var query: [TeamSearchCriteria]?

    public init(sortOrder: SortOrder?, sortBy: String?, pageSize: Int?, pageNumber: Int?, sort: [SearchSort]?, query: [TeamSearchCriteria]?) {
        self.sortOrder = sortOrder
        self.sortBy = sortBy
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.sort = sort
        self.query = query
    }


}



/** Results from evaluating matching criteria against test input */

public class TestMatchesEventOperation: Codable {









    /** The name of the processing step */
    public var name: String?
    /** The number of the processing step */
    public var step: Int?
    /** Triggers that matched */
    public var matchedTriggers: [TestModeTrigger]?
    /** Triggers that did not match */
    public var unmatchedTriggers: [TestModeTrigger]?

    public init(name: String?, step: Int?, matchedTriggers: [TestModeTrigger]?, unmatchedTriggers: [TestModeTrigger]?) {
        self.name = name
        self.step = step
        self.matchedTriggers = matchedTriggers
        self.unmatchedTriggers = unmatchedTriggers
    }


}



/** Information about trigger test mode execution */

public class TestModeResults: Codable {









    /** Information about the validation of the schema of the event body passed in to test mode */
    public var schemaValidation: TestSchemaOperation?
    /** Information about the validation of the trigger target */
    public var targetValidation: TestTargetOperation?
    /** Information about the json path matching criteria */
    public var jsonPathValidation: TestMatchesOperation?
    /** Whether the trigger would have matched on the provided event body */
    public var triggerMatches: Bool?

    public init(schemaValidation: TestSchemaOperation?, targetValidation: TestTargetOperation?, jsonPathValidation: TestMatchesOperation?, triggerMatches: Bool?) {
        self.schemaValidation = schemaValidation
        self.targetValidation = targetValidation
        self.jsonPathValidation = jsonPathValidation
        self.triggerMatches = triggerMatches
    }


}



/** Basic identifying information about a trigger */

public class TestModeTrigger: Codable {









    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The name of the trigger */
    public var name: String?
    /** Whether or not the trigger is enabled */
    public var enabled: Bool?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, enabled: Bool?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.enabled = enabled
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case enabled
        case selfUri
    }


}



/** Information about the Trigger test mode schema validation step */

public class TestSchemaOperation: Codable {









    /** The name of the processing step */
    public var name: String?
    /** The number of the processing step */
    public var step: Int?
    /** Whether or not the operation matches expectations */
    public var matches: Bool?
    /** Details about why the operation did or did not succeed */
    public var details: [String]?

    public init(name: String?, step: Int?, matches: Bool?, details: [String]?) {
        self.name = name
        self.step = step
        self.matches = matches
        self.details = details
    }


}




public class TestTopicPhrasePhrase: Codable {



    public enum Strictness: String, Codable { 
        case _1 = "1"
        case _55 = "55"
        case _65 = "65"
        case _72 = "72"
        case _85 = "85"
        case _90 = "90"
    }

    /** The phrase text */
    public var text: String?
    /** The phrase strictness, default value is null */
    public var strictness: Strictness?

    public init(text: String?, strictness: Strictness?) {
        self.text = text
        self.strictness = strictness
    }


}




public class TestTopicPhraseTopic: Codable {



    public enum Strictness: String, Codable { 
        case _1 = "1"
        case _55 = "55"
        case _65 = "65"
        case _72 = "72"
        case _85 = "85"
        case _90 = "90"
    }



    public enum Participants: String, Codable { 
        case external = "External"
        case _internal = "Internal"
        case all = "All"
    }

    /** The topic phrase to test */
    public var phrase: TestTopicPhrasePhrase?
    /** The topic strictness, default value is 72 */
    public var strictness: Strictness?
    /** The topic dialect, default value is en-US */
    public var dialect: String?
    /** The topic participants, default value is both */
    public var participants: Participants?

    public init(phrase: TestTopicPhrasePhrase?, strictness: Strictness?, dialect: String?, participants: Participants?) {
        self.phrase = phrase
        self.strictness = strictness
        self.dialect = dialect
        self.participants = participants
    }


}



/** Settings for a next-action of disconnecting, including the reason code for the disconnect. */

public class TextBotDisconnectAction: Codable {

    public enum Reason: String, Codable { 
        case triggeredByUser = "TriggeredByUser"
        case triggeredByFlow = "TriggeredByFlow"
        case sessionExpired = "SessionExpired"
        case error = "Error"
        case recognitionFailure = "RecognitionFailure"
    }







    /** The reason for the disconnect. */
    public var reason: Reason?
    /** Extended information related to the reason, if available. */
    public var reasonExtendedInfo: String?
    /** Describes where in the Bot Flow the user was when the disconnect occurred. */
    public var flowLocation: TextBotFlowLocation?
    /** The list of Flow Outcomes for the bot flow and their details. */
    public var flowOutcomes: [TextBotFlowOutcome]?

    public init(reason: Reason?, reasonExtendedInfo: String?, flowLocation: TextBotFlowLocation?, flowOutcomes: [TextBotFlowOutcome]?) {
        self.reason = reason
        self.reasonExtendedInfo = reasonExtendedInfo
        self.flowLocation = flowLocation
        self.flowOutcomes = flowOutcomes
    }


}



/** Flow Outcome data related to a bot flow which is exiting gracefully. */

public class TextBotFlowOutcome: Codable {



    public enum OutcomeValue: String, Codable { 
        case success = "SUCCESS"
        case failure = "FAILURE"
    }







    /** The Flow Outcome ID. */
    public var outcomeId: String?
    /** The value of the FlowOutcome. */
    public var outcomeValue: OutcomeValue?
    /** The timestamp for when the Flow Outcome began. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateStart: Date?
    /** The timestamp for when the Flow Outcome finished. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateEnd: Date?
    /** The Flow Milestones for the Flow Outcome. */
    public var milestones: [TextBotFlowMilestone]?

    public init(outcomeId: String?, outcomeValue: OutcomeValue?, dateStart: Date?, dateEnd: Date?, milestones: [TextBotFlowMilestone]?) {
        self.outcomeId = outcomeId
        self.outcomeValue = outcomeValue
        self.dateStart = dateStart
        self.dateEnd = dateEnd
        self.milestones = milestones
    }


}



/** Information related to a success bot flow turn request. */

public class TextBotFlowTurnResponse: Codable {







    public enum NextActionType: String, Codable { 
        case noOp = "NoOp"
        case disconnect = "Disconnect"
        case waitForInput = "WaitForInput"
        case exit = "Exit"
    }







    /** The ID of the bot flow turn. If additional turns are needed, supply this ID as the previous turn in your next turn request. */
    public var _id: String?
    /** The reference to a previous turn, if applicable. */
    public var previousTurn: TextBotTurnReference?
    /** The output prompts for this turn. */
    public var prompts: TextBotOutputPrompts?
    /** Indicates the suggested next action. If appropriate, the matching output event object includes additional information. */
    public var nextActionType: NextActionType?
    /** The next action directive for this turn if it is a Disconnect type. */
    public var nextActionDisconnect: TextBotDisconnectAction?
    /** The next action directive for this turn if it is a WaitForInput type. */
    public var nextActionWaitForInput: TextBotWaitForInputAction?
    /** The next action directive for this turn if it is an Exit type. */
    public var nextActionExit: TextBotExitAction?

    public init(_id: String?, previousTurn: TextBotTurnReference?, prompts: TextBotOutputPrompts?, nextActionType: NextActionType?, nextActionDisconnect: TextBotDisconnectAction?, nextActionWaitForInput: TextBotWaitForInputAction?, nextActionExit: TextBotExitAction?) {
        self._id = _id
        self.previousTurn = previousTurn
        self.prompts = prompts
        self.nextActionType = nextActionType
        self.nextActionDisconnect = nextActionDisconnect
        self.nextActionWaitForInput = nextActionWaitForInput
        self.nextActionExit = nextActionExit
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case previousTurn
        case prompts
        case nextActionType
        case nextActionDisconnect
        case nextActionWaitForInput
        case nextActionExit
    }


}



/** Mode constraints to observe when operating on a bot flow. */

public class TextBotModeConstraints: Codable {



    /** Mode constraints that apply to text scenarios. */
    public var text: TextBotTextModeConstraints?

    public init(text: TextBotTextModeConstraints?) {
        self.text = text
    }


}



/** Data for a single bot flow prompt segment. */

public class TextBotPromptSegment: Codable {



    public enum ModelType: String, Codable { 
        case text = "Text"
        case richMedia = "RichMedia"
        case messageEvent = "MessageEvent"
    }





    /** The text of this prompt segment. */
    public var text: String?
    /** The segment type which describes any semantics about the 'text' and also indicates which other field might include additional relevant info. */
    public var type: ModelType?
    /** Additional details describing the segments contents, which the client should honour where possible. */
    public var format: Format?
    /** Details to display Rich Media content. This is only populated when the segment 'type' is 'Rich Media'. */
    public var content: [ConversationMessageContent]?

    public init(text: String?, type: ModelType?, format: Format?, content: [ConversationMessageContent]?) {
        self.text = text
        self.type = type
        self.format = format
        self.content = content
    }


}



/** Information about the caller executing a bot flow. */

public class TextBotUserAgent: Codable {

    public enum Name: String, Codable { 
        case phone = "Phone"
        case sms = "SMS"
        case genesysWebWidget = "GenesysWebWidget"
        case facebookMessenger = "FacebookMessenger"
        case weChat = "WeChat"
        case whatsapp = "Whatsapp"
        case appleBusinessChat = "AppleBusinessChat"
        case apple = "Apple"
        case telegram = "Telegram"
        case slack = "Slack"
        case signal = "Signal"
        case line = "Line"
        case discord = "Discord"
        case twitterDirectMessage = "TwitterDirectMessage"
        case _open = "Open"
        case instagram = "Instagram"
        case other = "Other"
        case unknown = "Unknown"
    }

    /** The name of the user agent. */
    public var name: Name?

    public init(name: Name?) {
        self.name = name
    }


}




public class TextStyleProperties: Codable {







    public enum TextAlign: String, Codable { 
        case _left = "Left"
        case _right = "Right"
        case center = "Center"
    }

    /** Color of the text. (eg. #FFFFFF) */
    public var color: String?
    /** Font of the text. (eg. Helvetica) */
    public var font: String?
    /** Font size of the text. (eg. '12') */
    public var fontSize: String?
    /** Text alignment. */
    public var textAlign: TextAlign?

    public init(color: String?, font: String?, fontSize: String?, textAlign: TextAlign?) {
        self.color = color
        self.font = font
        self.fontSize = fontSize
        self.textAlign = textAlign
    }


}




public class TimeAndDateSubCondition: Codable {

    public enum ModelType: String, Codable { 
        case timeofday = "timeOfDay"
        case dayofweek = "dayOfWeek"
        case dayofmonth = "dayOfMonth"
        case specificdate = "specificDate"
    }

    public enum Operator: String, Codable { 
        case equals = "EQUALS"
        case lessThan = "LESS_THAN"
        case lessThanEquals = "LESS_THAN_EQUALS"
        case greaterThan = "GREATER_THAN"
        case greaterThanEquals = "GREATER_THAN_EQUALS"
        case contains = "CONTAINS"
        case beginsWith = "BEGINS_WITH"
        case endsWith = "ENDS_WITH"
        case before = "BEFORE"
        case after = "AFTER"
        case _in = "IN"
        case between = "BETWEEN"
    }









    /** The type of time/date sub-condition. */
    public var type: ModelType?
    /** The operator to use for comparison. */
    public var _operator: Operator?
    /** If true, inverts the result of evaluating this sub-condition. Default is false. */
    public var inverted: Bool?
    /** If true, includes year in date comparison for specificDate type. When false, only month and day are compared. Default is true. Only applicable for specificDate type. */
    public var includeYear: Bool?
    /** Threshold value for BEFORE or AFTER operators. Format depends on type: timeOfDay: HH:mm, dayOfWeek: 1-7 (Monday-Sunday), dayOfMonth: 1-31 and/ or LAST_DAY, ODD_DAY, EVEN_DAY, specificDate: yyyy-MM-dd (if includeYear=true) or MM-dd (if includeYear=false). For single-value comparison, use a list with one element. */
    public var thresholdValue: String?
    /** A range of values for BETWEEN and IN operators. Format follows the same rules as 'thresholdValue'. */
    public var range: TimeAndDateSubConditionRange?

    public init(type: ModelType?, _operator: Operator?, inverted: Bool?, includeYear: Bool?, thresholdValue: String?, range: TimeAndDateSubConditionRange?) {
        self.type = type
        self._operator = _operator
        self.inverted = inverted
        self.includeYear = includeYear
        self.thresholdValue = thresholdValue
        self.range = range
    }

    public enum CodingKeys: String, CodingKey { 
        case type
        case _operator = "operator"
        case inverted
        case includeYear
        case thresholdValue
        case range
    }


}




public class TimeOffBalanceJobReference: Codable {



    public enum Status: String, Codable { 
        case processing = "Processing"
        case complete = "Complete"
        case error = "Error"
    }



    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The status of the job */
    public var status: Status?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, status: Status?, selfUri: String?) {
        self._id = _id
        self.status = status
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case status
        case selfUri
    }


}




public class TimeOffIntegrationStatusResponse: Codable {



    public enum IntegrationStatus: String, Codable { 
        case processing = "Processing"
        case error = "Error"
        case automaticallyComplete = "AutomaticallyComplete"
        case manuallyComplete = "ManuallyComplete"
    }

    /** The time off request associated with this integration status */
    public var timeOffRequest: TimeOffRequestReference?
    /** The value of integration status for the time off request */
    public var integrationStatus: IntegrationStatus?

    public init(timeOffRequest: TimeOffRequestReference?, integrationStatus: IntegrationStatus?) {
        self.timeOffRequest = timeOffRequest
        self.integrationStatus = integrationStatus
    }


}




public class TimeOffIntegrationStatusResponseListing: Codable {



    public var entities: [TimeOffIntegrationStatusResponse]?

    public init(entities: [TimeOffIntegrationStatusResponse]?) {
        self.entities = entities
    }


}




public class TimeOffLimitReference: Codable {





    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, selfUri: String?) {
        self._id = _id
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
    }


}




public class TimeOffRequestList: Codable {









    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    public var timeOffRequests: [TimeOffRequestResponse]?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, timeOffRequests: [TimeOffRequestResponse]?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.timeOffRequests = timeOffRequests
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case timeOffRequests
        case selfUri
    }


}




public class TimeOffRequestQueryBody: Codable {






    public enum Statuses: String, Codable { 
        case pending = "PENDING"
    }

    public enum Substatuses: String, Codable { 
        case advanceTimeElapsed = "AdvanceTimeElapsed"
        case autoApproved = "AutoApproved"
        case blockedDate = "BlockedDate"
        case insufficientBalance = "InsufficientBalance"
        case invalidDailyDuration = "InvalidDailyDuration"
        case manualApproval = "ManualApproval"
        case outsideShift = "OutsideShift"
        case overlapsRestrictedActivityCode = "OverlapsRestrictedActivityCode"
        case removedFromWaitlist = "RemovedFromWaitlist"
        case reviewDate = "ReviewDate"
        case waitlisted = "Waitlisted"
    }


    /** The set of ids to filter time off requests */
    public var ids: [String]?
    /** The set of user ids to filter time off requests */
    public var userIds: [String]?
    /** The set of statuses to filter time off requests */
    public var statuses: [Statuses]?
    /** The set of substatuses to filter time off requests */
    public var substatuses: [Substatuses]?
    /** The inclusive range of dates to filter time off requests */
    public var dateRange: DateRange?

    public init(ids: [String]?, userIds: [String]?, statuses: [Statuses]?, substatuses: [Substatuses]?, dateRange: DateRange?) {
        self.ids = ids
        self.userIds = userIds
        self.statuses = statuses
        self.substatuses = substatuses
        self.dateRange = dateRange
    }


}




public class TimeOffRequestResponse: Codable {













    public enum Status: String, Codable { 
        case pending = "PENDING"
        case approved = "APPROVED"
        case denied = "DENIED"
        case canceled = "CANCELED"
    }

    public enum Substatus: String, Codable { 
        case advanceTimeElapsed = "AdvanceTimeElapsed"
        case autoApproved = "AutoApproved"
        case blockedDate = "BlockedDate"
        case insufficientBalance = "InsufficientBalance"
        case invalidDailyDuration = "InvalidDailyDuration"
        case manualApproval = "ManualApproval"
        case outsideShift = "OutsideShift"
        case overlapsRestrictedActivityCode = "OverlapsRestrictedActivityCode"
        case removedFromWaitlist = "RemovedFromWaitlist"
        case reviewDate = "ReviewDate"
        case waitlisted = "Waitlisted"
    }































    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The user associated with this time off request */
    public var user: UserReference?
    /** Whether this is a full day request (false means partial day) */
    public var isFullDayRequest: Bool?
    /** Whether this request has been marked as read by the agent */
    public var markedAsRead: Bool?
    /** The ID of the activity code associated with this time off request. Activity code must be of the TimeOff category */
    public var activityCodeId: String?
    /** Whether this is a paid time off request */
    public var paid: Bool?
    /** The status of this time off request */
    public var status: Status?
    /** The substatus of this time off request */
    public var substatus: Substatus?
    /** A set of start date-times in ISO-8601 format for partial day requests. Will be not empty if isFullDayRequest == false */
    public var partialDayStartDateTimes: [Date]?
    /** A set of dates in yyyy-MM-dd format.  Should be interpreted in the management unit's configured time zone. Will be not empty if isFullDayRequest == true */
    public var fullDayManagementUnitDates: [String]?
    /** The daily duration of this time off request in minutes */
    public var dailyDurationMinutes: Int?
    /** Daily durations for each day of this time off request in minutes */
    public var durationMinutes: [Int]?
    /** Payable minutes for each day of this time off request */
    public var payableMinutes: [Int]?
    /** Notes about the time off request */
    public var notes: String?
    /** The user who submitted this time off request. The id may be 'System' if it was an automated process */
    public var submittedBy: UserReference?
    /** The timestamp when this request was submitted. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var submittedDate: Date?
    /** The user who reviewed this time off request. The id may be 'System' if it was an automated process */
    public var reviewedBy: UserReference?
    /** The timestamp when this request was reviewed. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var reviewedDate: Date?
    /** The user who last modified this TimeOffRequestResponse */
    public var modifiedBy: UserReference?
    /** The timestamp when this request was last modified. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var modifiedDate: Date?
    /** The sync version of this time off request for which the scheduled activity is associated */
    public var syncVersion: Int?
    /** The version metadata of the time off request */
    public var metadata: WfmVersionedEntityMetadata?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, user: UserReference?, isFullDayRequest: Bool?, markedAsRead: Bool?, activityCodeId: String?, paid: Bool?, status: Status?, substatus: Substatus?, partialDayStartDateTimes: [Date]?, fullDayManagementUnitDates: [String]?, dailyDurationMinutes: Int?, durationMinutes: [Int]?, payableMinutes: [Int]?, notes: String?, submittedBy: UserReference?, submittedDate: Date?, reviewedBy: UserReference?, reviewedDate: Date?, modifiedBy: UserReference?, modifiedDate: Date?, syncVersion: Int?, metadata: WfmVersionedEntityMetadata?, selfUri: String?) {
        self._id = _id
        self.user = user
        self.isFullDayRequest = isFullDayRequest
        self.markedAsRead = markedAsRead
        self.activityCodeId = activityCodeId
        self.paid = paid
        self.status = status
        self.substatus = substatus
        self.partialDayStartDateTimes = partialDayStartDateTimes
        self.fullDayManagementUnitDates = fullDayManagementUnitDates
        self.dailyDurationMinutes = dailyDurationMinutes
        self.durationMinutes = durationMinutes
        self.payableMinutes = payableMinutes
        self.notes = notes
        self.submittedBy = submittedBy
        self.submittedDate = submittedDate
        self.reviewedBy = reviewedBy
        self.reviewedDate = reviewedDate
        self.modifiedBy = modifiedBy
        self.modifiedDate = modifiedDate
        self.syncVersion = syncVersion
        self.metadata = metadata
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case user
        case isFullDayRequest
        case markedAsRead
        case activityCodeId
        case paid
        case status
        case substatus
        case partialDayStartDateTimes
        case fullDayManagementUnitDates
        case dailyDurationMinutes
        case durationMinutes
        case payableMinutes
        case notes
        case submittedBy
        case submittedDate
        case reviewedBy
        case reviewedDate
        case modifiedBy
        case modifiedDate
        case syncVersion
        case metadata
        case selfUri
    }


}




public class TokenInfo: Codable {













    /** The current organization */
    public var organization: NamedEntity?
    /** The token's home organization */
    public var homeOrganization: NamedEntity?
    /** The list of scopes authorized for the OAuth client */
    public var authorizedScope: [String]?
    /** Only present when a user is a clone of trustee user in the trustor org. */
    public var clonedUser: TokenInfoClonedUser?
    /** Date/Time when token is due to expire. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateTokenIdles: Date?
    public var oAuthClient: OrgOAuthClient?

    public init(organization: NamedEntity?, homeOrganization: NamedEntity?, authorizedScope: [String]?, clonedUser: TokenInfoClonedUser?, dateTokenIdles: Date?, oAuthClient: OrgOAuthClient?) {
        self.organization = organization
        self.homeOrganization = homeOrganization
        self.authorizedScope = authorizedScope
        self.clonedUser = clonedUser
        self.dateTokenIdles = dateTokenIdles
        self.oAuthClient = oAuthClient
    }

    public enum CodingKeys: String, CodingKey { 
        case organization
        case homeOrganization
        case authorizedScope
        case clonedUser
        case dateTokenIdles
        case oAuthClient = "OAuthClient"
    }


}




public class TopicDuration: Codable {



    /** The total duration of the topic phrase within the conversation */
    public var totalMilliseconds: Int64?

    public init(totalMilliseconds: Int64?) {
        self.totalMilliseconds = totalMilliseconds
    }


}




public class TopicJob: Codable {



    public enum State: String, Codable { 
        case running = "Running"
        case completed = "Completed"
        case failed = "Failed"
    }











    /** The globally unique identifier for the object. */
    public var _id: String?
    public var state: State?
    public var topics: [BaseTopicEntitiy]?
    public var createdBy: AddressableEntityRef?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, state: State?, topics: [BaseTopicEntitiy]?, createdBy: AddressableEntityRef?, dateCreated: Date?, dateModified: Date?, selfUri: String?) {
        self._id = _id
        self.state = state
        self.topics = topics
        self.createdBy = createdBy
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case state
        case topics
        case createdBy
        case dateCreated
        case dateModified
        case selfUri
    }


}




public class TopicJobRequest: Codable {



    /** The ids of the topics used for this job */
    public var topicIds: [String]?

    public init(topicIds: [String]?) {
        self.topicIds = topicIds
    }


}




public class TranscriptSearchRequest: Codable {

    public enum SortOrder: String, Codable { 
        case asc = "ASC"
        case desc = "DESC"
        case score = "SCORE"
    }















    /** The sort order for results */
    public var sortOrder: SortOrder?
    /** The field in the resource that you want to sort the results by */
    public var sortBy: String?
    /** The number of results per page */
    public var pageSize: Int?
    /** The page of resources you want to retrieve */
    public var pageNumber: Int?
    /** Multi-value sort order, list of multiple sort values */
    public var sort: [SearchSort]?
    public var returnFields: [String]?
    /** Resource domain type to search */
    public var types: [String]?
    /** The search criteria */
    public var query: [TranscriptSearchCriteria]?

    public init(sortOrder: SortOrder?, sortBy: String?, pageSize: Int?, pageNumber: Int?, sort: [SearchSort]?, returnFields: [String]?, types: [String]?, query: [TranscriptSearchCriteria]?) {
        self.sortOrder = sortOrder
        self.sortBy = sortBy
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.sort = sort
        self.returnFields = returnFields
        self.types = types
        self.query = query
    }


}




public class TranscriptionTopicTranscriptionMessage: Codable {

















    public var eventTime: Date?
    public var organizationId: String?
    public var conversationId: String?
    public var communicationId: String?
    public var sessionStartTimeMs: Int64?
    public var transcriptionStartTimeMs: Int64?
    public var transcripts: [TranscriptionTopicTranscriptResult]?
    public var status: TranscriptionTopicTranscriptionRequestStatus?

    public init(eventTime: Date?, organizationId: String?, conversationId: String?, communicationId: String?, sessionStartTimeMs: Int64?, transcriptionStartTimeMs: Int64?, transcripts: [TranscriptionTopicTranscriptResult]?, status: TranscriptionTopicTranscriptionRequestStatus?) {
        self.eventTime = eventTime
        self.organizationId = organizationId
        self.conversationId = conversationId
        self.communicationId = communicationId
        self.sessionStartTimeMs = sessionStartTimeMs
        self.transcriptionStartTimeMs = transcriptionStartTimeMs
        self.transcripts = transcripts
        self.status = status
    }


}




public class TranscriptionTopicTranscriptionRequestStatus: Codable {



    public enum Status: String, Codable { 
        case unknown = "UNKNOWN"
        case sessionOngoing = "SESSION_ONGOING"
        case sessionEnded = "SESSION_ENDED"
    }

    public var offsetMs: Int64?
    public var status: Status?

    public init(offsetMs: Int64?, status: Status?) {
        self.offsetMs = offsetMs
        self.status = status
    }


}




public class TransferInitiator: Codable {



    /** The id of the user who initiated the command if it was initiated by a user. */
    public var userId: String?

    public init(userId: String?) {
        self.userId = userId
    }


}




public class TransferResponse: Codable {



    public enum State: String, Codable { 
        case pending = "Pending"
        case active = "Active"
        case complete = "Complete"
        case canceled = "Canceled"
        case failed = "Failed"
        case timeout = "Timeout"
        case unknown = "Unknown"
    }









    public enum TransferType: String, Codable { 
        case attended = "Attended"
        case unattended = "Unattended"
    }

    /** The id of the command. */
    public var _id: String?
    /** The state of the command. */
    public var state: State?
    /** The date/time that this command was issued. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateIssued: Date?
    /** The initiator of the command. */
    public var initiator: TransferInitiator?
    /** The user or entity that modified the command. */
    public var modifiedBy: TransferResponseModifiedBy?
    /** The destination of the command. */
    public var destination: TransferDestination?
    /** The type of transfer to perform. */
    public var transferType: TransferType?

    public init(_id: String?, state: State?, dateIssued: Date?, initiator: TransferInitiator?, modifiedBy: TransferResponseModifiedBy?, destination: TransferDestination?, transferType: TransferType?) {
        self._id = _id
        self.state = state
        self.dateIssued = dateIssued
        self.initiator = initiator
        self.modifiedBy = modifiedBy
        self.destination = destination
        self.transferType = transferType
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case state
        case dateIssued
        case initiator
        case modifiedBy
        case destination
        case transferType
    }


}




public class TransferToQueueRequest: Codable {

    public enum TransferType: String, Codable { 
        case attended = "Attended"
        case unattended = "Unattended"
    }







    /** The type of transfer to perform. Attended, where the initiating agent maintains ownership of the conversation until the intended recipient accepts the transfer, or Unattended, where the initiating agent immediately disconnects. Default is Unattended. */
    public var transferType: TransferType?
    /** If true, the digital internal message will NOT be terminated. */
    public var keepInternalMessageAlive: Bool?
    /** The id of the queue. */
    public var queueId: String?
    /** The name of the queue. */
    public var queueName: String?

    public init(transferType: TransferType?, keepInternalMessageAlive: Bool?, queueId: String?, queueName: String?) {
        self.transferType = transferType
        self.keepInternalMessageAlive = keepInternalMessageAlive
        self.queueId = queueId
        self.queueName = queueName
    }


}




public class TranslateSupportedLanguageList: Codable {



    public var entities: [TranslateSupportedLanguage]?

    public init(entities: [TranslateSupportedLanguage]?) {
        self.entities = entities
    }


}



/** Defines a process automation trigger. */

public class Trigger: Codable {























    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The name of the trigger */
    public var name: String?
    /** The topic that will cause the trigger to be invoked */
    public var topicName: String?
    /** The target to invoke when a matching event is received */
    public var target: TriggerTarget?
    /** Version of this trigger */
    public var version: Int64?
    /** Whether or not the trigger is enabled */
    public var enabled: Bool?
    /** The configuration for when a trigger is considered to be a match for an event */
    public var matchCriteria: [MatchCriteria]?
    /** Optional length of time that events are meaningful after origination. Events older than this threshold may be dropped if the platform is delayed in processing events. Unset means events are valid indefinitely, otherwise must be set to at least 10 seconds. Only one of eventTTLSeconds or delayBySeconds can be set. */
    public var eventTTLSeconds: Int?
    /** Optional delay invoking target after trigger fires. Must be in the range of 60 to 900 seconds. Only one of eventTTLSeconds or delayBySeconds can be set. */
    public var delayBySeconds: Int?
    /** Description of the trigger. Can be up to 512 characters in length. */
    public var _description: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, topicName: String?, target: TriggerTarget?, version: Int64?, enabled: Bool?, matchCriteria: [MatchCriteria]?, eventTTLSeconds: Int?, delayBySeconds: Int?, _description: String?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.topicName = topicName
        self.target = target
        self.version = version
        self.enabled = enabled
        self.matchCriteria = matchCriteria
        self.eventTTLSeconds = eventTTLSeconds
        self.delayBySeconds = delayBySeconds
        self._description = _description
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case topicName
        case target
        case version
        case enabled
        case matchCriteria
        case eventTTLSeconds
        case delayBySeconds
        case _description = "description"
        case selfUri
    }


}



/** The target of a trigger invocation */

public class TriggerTarget: Codable {

    public enum ModelType: String, Codable { 
        case workflow = "Workflow"
    }





    /** The entity type to target */
    public var type: ModelType?
    /** The ID of the entity to target */
    public var _id: String?
    /** Optional config for the target. */
    public var workflowTargetSettings: WorkflowTargetSettings?

    public init(type: ModelType?, _id: String?, workflowTargetSettings: WorkflowTargetSettings?) {
        self.type = type
        self._id = _id
        self.workflowTargetSettings = workflowTargetSettings
    }

    public enum CodingKeys: String, CodingKey { 
        case type
        case _id = "id"
        case workflowTargetSettings
    }


}




public class TrunkEntityListing: Codable {























    public var entities: [Trunk]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    /** The total organization-wide number of entities. */
    public var totalNumberOfEntities: Int64?
    public var firstUri: String?
    public var previousUri: String?
    public var nextUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [Trunk]?, pageSize: Int?, pageNumber: Int?, total: Int64?, totalNumberOfEntities: Int64?, firstUri: String?, previousUri: String?, nextUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.totalNumberOfEntities = totalNumberOfEntities
        self.firstUri = firstUri
        self.previousUri = previousUri
        self.nextUri = nextUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class TrunkInstanceTopicTrunkErrorInfo: Codable {







    public var text: String?
    public var code: String?
    public var details: TrunkInstanceTopicTrunkErrorInfoDetails?

    public init(text: String?, code: String?, details: TrunkInstanceTopicTrunkErrorInfoDetails?) {
        self.text = text
        self.code = code
        self.details = details
    }


}




public class TrunkInstanceTopicTrunkErrorInfoDetails: Codable {







    public var code: String?
    public var message: String?
    public var hostname: String?

    public init(code: String?, message: String?, hostname: String?) {
        self.code = code
        self.message = message
        self.hostname = hostname
    }


}




public class TrunkMetrics: Codable {











    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var eventTime: Date?
    public var logicalInterface: DomainEntityRef?
    public var trunk: DomainEntityRef?
    public var calls: TrunkMetricsCalls?
    public var qos: TrunkMetricsQoS?

    public init(eventTime: Date?, logicalInterface: DomainEntityRef?, trunk: DomainEntityRef?, calls: TrunkMetricsCalls?, qos: TrunkMetricsQoS?) {
        self.eventTime = eventTime
        self.logicalInterface = logicalInterface
        self.trunk = trunk
        self.calls = calls
        self.qos = qos
    }


}




public class TrunkMetricsCalls: Codable {





    public var inboundCallCount: Int?
    public var outboundCallCount: Int?

    public init(inboundCallCount: Int?, outboundCallCount: Int?) {
        self.inboundCallCount = inboundCallCount
        self.outboundCallCount = outboundCallCount
    }


}




public class TrunkMetricsQoS: Codable {



    /** Total number of QoS mismatches over the course of the last 24-hour period (sliding window). */
    public var mismatchCount: Int?

    public init(mismatchCount: Int?) {
        self.mismatchCount = mismatchCount
    }


}




public class TrunkMetricsTopicTrunkMetrics: Codable {









    public var calls: TrunkMetricsTopicTrunkMetricsCalls?
    public var eventTime: Date?
    public var qos: TrunkMetricsTopicTrunkMetricsQoS?
    public var trunk: TrunkMetricsTopicUriReference?

    public init(calls: TrunkMetricsTopicTrunkMetricsCalls?, eventTime: Date?, qos: TrunkMetricsTopicTrunkMetricsQoS?, trunk: TrunkMetricsTopicUriReference?) {
        self.calls = calls
        self.eventTime = eventTime
        self.qos = qos
        self.trunk = trunk
    }


}




public class TrunkMetricsTopicTrunkMetricsCalls: Codable {





    public var inboundCallCount: Int64?
    public var outboundCallCount: Int64?

    public init(inboundCallCount: Int64?, outboundCallCount: Int64?) {
        self.inboundCallCount = inboundCallCount
        self.outboundCallCount = outboundCallCount
    }


}




public class TrunkMetricsTopicTrunkMetricsQoS: Codable {



    public var mismatchCount: Int64?

    public init(mismatchCount: Int64?) {
        self.mismatchCount = mismatchCount
    }


}




public class TtsSettings: Codable {





    /** ID of the global default TTS engine */
    public var defaultEngine: String?
    /** The list of default overrides for specific languages */
    public var languageOverrides: [LanguageOverride]?

    public init(defaultEngine: String?, languageOverrides: [LanguageOverride]?) {
        self.defaultEngine = defaultEngine
        self.languageOverrides = languageOverrides
    }


}




public class TtsVoiceEntity: Codable {















    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** The gender of the TTS voice */
    public var gender: String?
    /** The language supported by the TTS voice */
    public var language: String?
    /** Ths TTS engine this voice belongs to */
    public var engine: TtsEngineEntity?
    /** The voice is the default voice for its language */
    public var isDefault: Bool?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, gender: String?, language: String?, engine: TtsEngineEntity?, isDefault: Bool?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.gender = gender
        self.language = language
        self.engine = engine
        self.isDefault = isDefault
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case gender
        case language
        case engine
        case isDefault
        case selfUri
    }


}




public class TtsVoiceEntityListing: Codable {





















    public var entities: [TtsVoiceEntity]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var previousUri: String?
    public var nextUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [TtsVoiceEntity]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, previousUri: String?, nextUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.previousUri = previousUri
        self.nextUri = nextUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class TwitterDataIngestionRuleVersionResponse: Codable {







    public enum Status: String, Codable { 
        case active = "Active"
        case deleted = "Deleted"
        case error = "Error"
        case paused = "Paused"
        case pending = "Pending"
        case systemPaused = "SystemPaused"
    }















    /** ID of the data ingestion rule. */
    public var _id: String?
    /** The name of the data ingestion rule. */
    public var name: String?
    /** A description of the data ingestion rule. */
    public var _description: String?
    /** The status of the data ingestion rule. */
    public var status: Status?
    /** The version number of the data ingestion rule. */
    public var version: Int?
    /** Timestamp indicating when the data ingestion rule was created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** Timestamp indicating when the data ingestion rule was last updated. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** The platform of the data ingestion rule. */
    public var platform: String?
    /** ISO 3166-1 alpha-2 country codes where Data Ingestion Rules should apply. Defaults to worldwide. */
    public var countries: [String]?
    /** Search terms for X (formally Twitter). */
    public var searchTerms: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, _description: String?, status: Status?, version: Int?, dateCreated: Date?, dateModified: Date?, platform: String?, countries: [String]?, searchTerms: String?, selfUri: String?) {
        self._id = _id
        self.name = name
        self._description = _description
        self.status = status
        self.version = version
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.platform = platform
        self.countries = countries
        self.searchTerms = searchTerms
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case _description = "description"
        case status
        case version
        case dateCreated
        case dateModified
        case platform
        case countries
        case searchTerms
        case selfUri
    }


}




public class TypingSetting: Codable {



    /** Should typing indication Events be sent */
    public var on: SettingDirection?

    public init(on: SettingDirection?) {
        self.on = on
    }


}




public class UpdateAlternativeShiftBuSettingsRequest: Codable {









    /** The granularity at which alternative shifts is allowed. An empty list as the wrapped value will indicate alternative shifts is disabled */
    public var enabledGranularities: ListWrapperAlternativeShiftBuSettingsGranularity?
    /** The minimum number of minutes before the start of a shift that an alternative shift can be automatically approved */
    public var minMinutesBeforeStartTime: Int?
    /** Categories of activities that are required to remain at the same time slot for the alternative shifts offered. An empty list indicates no retained activities */
    public var retainedActivityCategories: ListWrapperAlternativeShiftBuSettingsActivityCategory?
    /** Version metadata for this business unit's alternative shift settings */
    public var metadata: WfmVersionedEntityMetadata?

    public init(enabledGranularities: ListWrapperAlternativeShiftBuSettingsGranularity?, minMinutesBeforeStartTime: Int?, retainedActivityCategories: ListWrapperAlternativeShiftBuSettingsActivityCategory?, metadata: WfmVersionedEntityMetadata?) {
        self.enabledGranularities = enabledGranularities
        self.minMinutesBeforeStartTime = minMinutesBeforeStartTime
        self.retainedActivityCategories = retainedActivityCategories
        self.metadata = metadata
    }


}



/** Update coaching appointment request */

public class UpdateCoachingAppointmentRequest: Codable {













    public enum Status: String, Codable { 
        case scheduled = "Scheduled"
        case inProgress = "InProgress"
        case completed = "Completed"
    }









    /** The name of coaching appointment. */
    public var name: String?
    /** The description of coaching appointment. */
    public var _description: String?
    /** The date/time the coaching appointment starts. Times will be rounded down to the minute. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateStart: Date?
    /** The duration of coaching appointment in minutes. */
    public var lengthInMinutes: Int?
    /** IDs of conversations associated with this coaching appointment. */
    public var conversationIds: [String]?
    /** IDs of documents associated with this coaching appointment. */
    public var documentIds: [String]?
    /** The status of the coaching appointment. */
    public var status: Status?
    /** The Workforce Management schedule the appointment is associated with. */
    public var wfmSchedule: WfmScheduleReference?
    /** The list of external links related to the appointment */
    public var externalLinks: [String]?
    /** The location of the appointment */
    public var location: String?
    /** Whether to share the insight data */
    public var shareInsightsData: Bool?

    public init(name: String?, _description: String?, dateStart: Date?, lengthInMinutes: Int?, conversationIds: [String]?, documentIds: [String]?, status: Status?, wfmSchedule: WfmScheduleReference?, externalLinks: [String]?, location: String?, shareInsightsData: Bool?) {
        self.name = name
        self._description = _description
        self.dateStart = dateStart
        self.lengthInMinutes = lengthInMinutes
        self.conversationIds = conversationIds
        self.documentIds = documentIds
        self.status = status
        self.wfmSchedule = wfmSchedule
        self.externalLinks = externalLinks
        self.location = location
        self.shareInsightsData = shareInsightsData
    }

    public enum CodingKeys: String, CodingKey { 
        case name
        case _description = "description"
        case dateStart
        case lengthInMinutes
        case conversationIds
        case documentIds
        case status
        case wfmSchedule
        case externalLinks
        case location
        case shareInsightsData
    }


}




public class UpdateContactColumnActionSettings: Codable {



    public enum UpdateOption: String, Codable { 
        case _set = "Set"
        case increment = "Increment"
        case decrement = "Decrement"
        case currentTime = "CurrentTime"
    }

    /** A mapping of contact columns to their new values. */
    public var properties: [String:String]?
    /** The type of update to make to the specified contact column(s). */
    public var updateOption: UpdateOption?

    public init(properties: [String:String]?, updateOption: UpdateOption?) {
        self.properties = properties
        self.updateOption = updateOption
    }


}




public class UpdateMuAgentWorkPlanRequest: Codable {







    /** The agent id for whom the work plan is updated */
    public var userId: String?
    /** The current work plan ID for the agent */
    public var workPlanId: ValueWrapperString?
    /** The list of work plan overrides for the agent */
    public var workPlanOverrides: WorkPlanOverrideListWrapperWorkPlanOverrideRequest?

    public init(userId: String?, workPlanId: ValueWrapperString?, workPlanOverrides: WorkPlanOverrideListWrapperWorkPlanOverrideRequest?) {
        self.userId = userId
        self.workPlanId = workPlanId
        self.workPlanOverrides = workPlanOverrides
    }


}




public class UpdatePlanningGroupRequest: Codable {









    /** The name of the planning group */
    public var name: String?
    /** Set of route paths to associate with the planning group */
    public var routePaths: SetWrapperRoutePathRequest?
    /** The ID of the service goal template to associate with this planning group */
    public var serviceGoalTemplateId: String?
    /** Version metadata for the planning group */
    public var metadata: WfmVersionedEntityMetadata?

    public init(name: String?, routePaths: SetWrapperRoutePathRequest?, serviceGoalTemplateId: String?, metadata: WfmVersionedEntityMetadata?) {
        self.name = name
        self.routePaths = routePaths
        self.serviceGoalTemplateId = serviceGoalTemplateId
        self.metadata = metadata
    }


}




public class UpdateScheduleUploadResponse: Codable {









    /** The key to pass to the secondary request to start processing of the upload */
    public var uploadKey: String?
    /** The url to which to PUT the upload body */
    public var url: String?
    /** Required headers for the PUT request to the url */
    public var headers: [String:String]?
    /** Always null. Defines the schema of the json body to be PUT to the url. The json body should be gzip encoded before uploading */
    public var uploadBodySchema: UpdateScheduleUploadSchema?

    public init(uploadKey: String?, url: String?, headers: [String:String]?, uploadBodySchema: UpdateScheduleUploadSchema?) {
        self.uploadKey = uploadKey
        self.url = url
        self.headers = headers
        self.uploadBodySchema = uploadBodySchema
    }


}




public class UpdateStaffingGroupRequest: Codable {









    /** The name of the staffing group */
    public var name: String?
    /** The set of user Ids to associate with the staffing group */
    public var userIds: SetWrapperString?
    /** The set of planning group Ids to associate with the staffing group */
    public var planningGroupIds: SetWrapperString?
    /** Version metadata for the staffing group */
    public var metadata: WfmVersionedEntityMetadata?

    public init(name: String?, userIds: SetWrapperString?, planningGroupIds: SetWrapperString?, metadata: WfmVersionedEntityMetadata?) {
        self.name = name
        self.userIds = userIds
        self.planningGroupIds = planningGroupIds
        self.metadata = metadata
    }


}




public class UpdateTimeOffLimitRequest: Codable {





    /** The default time off limit value in minutes per granularity */
    public var defaultLimitMinutes: Int?
    /** Version metadata for the time off limit */
    public var metadata: WfmVersionedEntityMetadata?

    public init(defaultLimitMinutes: Int?, metadata: WfmVersionedEntityMetadata?) {
        self.defaultLimitMinutes = defaultLimitMinutes
        self.metadata = metadata
    }


}




public class UpdateTimeOffPlanManagementUnitAssociation: Codable {



    /** The IDs of staffing groups to which this time-off plan applies. If not defined, the plan is applied to the management unit */
    public var staffingGroupIds: SetWrapperString?

    public init(staffingGroupIds: SetWrapperString?) {
        self.staffingGroupIds = staffingGroupIds
    }


}




public class UpdateVerifierRequest: Codable {







    /** The name of the verifier. */
    public var name: String?
    /** Indicates whether this verifier will be enabled. */
    public var enabled: Bool?
    /** Indicates whether this will be the default verifier. */
    public var _default: Bool?

    public init(name: String?, enabled: Bool?, _default: Bool?) {
        self.name = name
        self.enabled = enabled
        self._default = _default
    }

    public enum CodingKeys: String, CodingKey { 
        case name
        case enabled
        case _default = "default"
    }


}




public class UrlResponse: Codable {



    public var url: String?

    public init(url: String?) {
        self.url = url
    }


}




public class UserActivityQuery: Codable {




    public enum GroupBy: String, Codable { 
        case userid = "userId"
    }


    public enum Order: String, Codable { 
        case asc = "asc"
        case desc = "desc"
        case unordered = "unordered"
    }

    /** List of requested metrics */
    public var metrics: [UserActivityQueryMetric]?
    /** Dimension(s) to group by */
    public var groupBy: [GroupBy]?
    /** Filter to return a subset of observations. Expresses boolean logical predicates as well as dimensional filters */
    public var filter: UserActivityQueryFilter?
    /** Sort the result set in ascending/descending order. Default is ascending */
    public var order: Order?

    public init(metrics: [UserActivityQueryMetric]?, groupBy: [GroupBy]?, filter: UserActivityQueryFilter?, order: Order?) {
        self.metrics = metrics
        self.groupBy = groupBy
        self.filter = filter
        self.order = order
    }


}




public class UserActivityQueryClause: Codable {

    public enum ModelType: String, Codable { 
        case and = "and"
        case or = "or"
    }



    /** Boolean operation to apply to the provided predicates */
    public var type: ModelType?
    /** Like a three-word sentence: (attribute-name) (operator) (target-value). */
    public var predicates: [UserActivityQueryPredicate]?

    public init(type: ModelType?, predicates: [UserActivityQueryPredicate]?) {
        self.type = type
        self.predicates = predicates
    }


}




public class UserAggregateQueryResponse: Codable {





    /** A mapping from system presence to a list of organization presence ids */
    public var systemToOrganizationMappings: [String:[String]]?
    public var results: [UserAggregateDataContainer]?

    public init(systemToOrganizationMappings: [String:[String]]?, results: [UserAggregateDataContainer]?) {
        self.systemToOrganizationMappings = systemToOrganizationMappings
        self.results = results
    }


}




public class UserAggregationView: Codable {

    public enum Target: String, Codable { 
        case tagentroutingstatus = "tAgentRoutingStatus"
        case torganizationpresence = "tOrganizationPresence"
        case tsystempresence = "tSystemPresence"
    }



    public enum Function: String, Codable { 
        case rangebound = "rangeBound"
    }



    /** Target metric name */
    public var target: Target?
    /** A unique name for this view. Must be distinct from other views and built-in metric names. */
    public var name: String?
    /** Type of view you wish to create */
    public var function: Function?
    /** Range of numbers for slicing up data */
    public var range: AggregationRange?

    public init(target: Target?, name: String?, function: Function?, range: AggregationRange?) {
        self.target = target
        self.name = name
        self.function = function
        self.range = range
    }


}



/** Details for a UserApp */

public class UserApp: Codable {











    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The name of the userApp, used to distinguish this userApp from others of the same type. */
    public var name: String?
    /** Integration Type for the userApp */
    public var integrationType: IntegrationType?
    public var config: UserAppConfigurationInfo?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, integrationType: IntegrationType?, config: UserAppConfigurationInfo?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.integrationType = integrationType
        self.config = config
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case integrationType
        case config
        case selfUri
    }


}




public class UserBestPointsItem: Codable {

    public enum GranularityType: String, Codable { 
        case daily = "Daily"
        case weekly = "Weekly"
        case monthly = "Monthly"
    }









    /** Best points aggregation interval granularity */
    public var granularityType: GranularityType?
    /** Gamification points */
    public var points: Int?
    /** Start workday of the best points aggregation interval. Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd */
    public var dateStartWorkday: Date?
    /** End workday of the best points aggregation interval. Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd */
    public var dateEndWorkday: Date?
    /** The rank of this user */
    public var rank: Int?

    public init(granularityType: GranularityType?, points: Int?, dateStartWorkday: Date?, dateEndWorkday: Date?, rank: Int?) {
        self.granularityType = granularityType
        self.points = points
        self.dateStartWorkday = dateStartWorkday
        self.dateEndWorkday = dateEndWorkday
        self.rank = rank
    }


}




public class UserConversationsEventMediaSummary: Codable {





    public var contactCenter: UserConversationsEventMediaSummaryDetail?
    public var enterprise: UserConversationsEventMediaSummaryDetail?

    public init(contactCenter: UserConversationsEventMediaSummaryDetail?, enterprise: UserConversationsEventMediaSummaryDetail?) {
        self.contactCenter = contactCenter
        self.enterprise = enterprise
    }


}




public class UserConversationsEventMediaSummaryDetail: Codable {





    public var active: Int64?
    public var acw: Int64?

    public init(active: Int64?, acw: Int64?) {
        self.active = active
        self.acw = acw
    }


}




public class UserConversationsEventUserConversationSummary: Codable {

















    public var userId: String?
    public var call: UserConversationsEventMediaSummary?
    public var callback: UserConversationsEventMediaSummary?
    public var email: UserConversationsEventMediaSummary?
    public var message: UserConversationsEventMediaSummary?
    public var chat: UserConversationsEventMediaSummary?
    public var socialExpression: UserConversationsEventMediaSummary?
    public var video: UserConversationsEventMediaSummary?

    public init(userId: String?, call: UserConversationsEventMediaSummary?, callback: UserConversationsEventMediaSummary?, email: UserConversationsEventMediaSummary?, message: UserConversationsEventMediaSummary?, chat: UserConversationsEventMediaSummary?, socialExpression: UserConversationsEventMediaSummary?, video: UserConversationsEventMediaSummary?) {
        self.userId = userId
        self.call = call
        self.callback = callback
        self.email = email
        self.message = message
        self.chat = chat
        self.socialExpression = socialExpression
        self.video = video
    }


}




public class UserDetailQueryClause: Codable {

    public enum ModelType: String, Codable { 
        case and = "and"
        case or = "or"
    }



    /** Boolean operation to apply to the provided predicates */
    public var type: ModelType?
    /** Like a three-word sentence: (attribute-name) (operator) (target-value). */
    public var predicates: [UserDetailQueryPredicate]?

    public init(type: ModelType?, predicates: [UserDetailQueryPredicate]?) {
        self.type = type
        self.predicates = predicates
    }


}




public class UserDetailsQuery: Codable {









    public enum Order: String, Codable { 
        case asc = "asc"
        case desc = "desc"
        case unordered = "unordered"
    }







    /** Specifies the date and time range of data being queried. Conversations MUST have started within this time range to potentially be included within the result set. Intervals are represented as an ISO-8601 string. For example: YYYY-MM-DDThh:mm:ss/YYYY-MM-DDThh:mm:ss */
    public var interval: String?
    /** Filters that target the users to retrieve data for */
    public var userFilters: [UserDetailQueryFilter]?
    /** Filters that target system and organization presence-level data */
    public var presenceFilters: [PresenceDetailQueryFilter]?
    /** Filters that target agent routing status-level data */
    public var routingStatusFilters: [RoutingStatusDetailQueryFilter]?
    /** Sort the result set in ascending/descending order. Default is ascending */
    public var order: Order?
    /** Include faceted search and aggregate roll-ups of presence data in your search results. This does not function as a filter, but rather, summary data about the presence results matching your filters */
    public var presenceAggregations: [AnalyticsQueryAggregation]?
    /** Include faceted search and aggregate roll-ups of agent routing status data in your search results. This does not function as a filter, but rather, summary data about the agent routing status results matching your filters */
    public var routingStatusAggregations: [AnalyticsQueryAggregation]?
    /** Page size and number to control iterating through large result sets. Default page size is 25 */
    public var paging: PagingSpec?

    public init(interval: String?, userFilters: [UserDetailQueryFilter]?, presenceFilters: [PresenceDetailQueryFilter]?, routingStatusFilters: [RoutingStatusDetailQueryFilter]?, order: Order?, presenceAggregations: [AnalyticsQueryAggregation]?, routingStatusAggregations: [AnalyticsQueryAggregation]?, paging: PagingSpec?) {
        self.interval = interval
        self.userFilters = userFilters
        self.presenceFilters = presenceFilters
        self.routingStatusFilters = routingStatusFilters
        self.order = order
        self.presenceAggregations = presenceAggregations
        self.routingStatusAggregations = routingStatusAggregations
        self.paging = paging
    }


}




public class UserGreetingEventGreetingOwner: Codable {



    public var _id: String?

    public init(_id: String?) {
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
    }


}




public class UserLicensesEntityListing: Codable {











    public var entities: [UserLicenses]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var pageCount: Int?

    public init(entities: [UserLicenses]?, pageSize: Int?, pageNumber: Int?, total: Int64?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.pageCount = pageCount
    }


}




public class UserProfilesInDateRange: Codable {









    /** The query agent */
    public var user: UserReference?
    /** Start workday used as the date range. Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd */
    public var dateStartWorkday: Date?
    /** End workday used as the date range. Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd */
    public var dateEndWorkday: Date?
    /** The list of profiles of the agent */
    public var profiles: [ProfileWithDateRange]?

    public init(user: UserReference?, dateStartWorkday: Date?, dateEndWorkday: Date?, profiles: [ProfileWithDateRange]?) {
        self.user = user
        self.dateStartWorkday = dateStartWorkday
        self.dateEndWorkday = dateEndWorkday
        self.profiles = profiles
    }


}




public class UserProfilesInDateRangeRequest: Codable {





    /** Start work day in ISO-8601 format used in the date range. */
    public var startWorkday: String?
    /** End work day in ISO-8601 format used in the date range. */
    public var endWorkday: String?

    public init(startWorkday: String?, endWorkday: String?) {
        self.startWorkday = startWorkday
        self.endWorkday = endWorkday
    }


}




public class UserQueueEntityListing: Codable {





















    public var entities: [UserQueue]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var previousUri: String?
    public var nextUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [UserQueue]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, previousUri: String?, nextUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.previousUri = previousUri
        self.nextUri = nextUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class UserScheduleContainer: Codable {







    /** The reference time zone used for the management unit */
    public var managementUnitTimeZone: String?
    /** References to all published week schedules overlapping the start/end date query parameters */
    public var publishedSchedules: [WeekScheduleReference]?
    /** Map of user id to user schedule */
    public var userSchedules: [String:UserSchedule]?

    public init(managementUnitTimeZone: String?, publishedSchedules: [WeekScheduleReference]?, userSchedules: [String:UserSchedule]?) {
        self.managementUnitTimeZone = managementUnitTimeZone
        self.publishedSchedules = publishedSchedules
        self.userSchedules = userSchedules
    }


}




public class UserScheduleFullDayTimeOffMarker: Codable {













    /** The date associated with the time off request that this marker corresponds to.  Date only, in ISO-8601 format. */
    public var managementUnitDate: String?
    /** The id for the activity code.  Look up a map of activity codes with the activities route */
    public var activityCodeId: String?
    /** Whether this is paid time off */
    public var isPaid: Bool?
    /** The length in minutes of this time off marker */
    public var lengthInMinutes: Int?
    /** The description associated with the time off request that this marker corresponds to */
    public var _description: String?
    /** If marked true for updating an existing full day time off marker, it will be deleted */
    public var delete: Bool?

    public init(managementUnitDate: String?, activityCodeId: String?, isPaid: Bool?, lengthInMinutes: Int?, _description: String?, delete: Bool?) {
        self.managementUnitDate = managementUnitDate
        self.activityCodeId = activityCodeId
        self.isPaid = isPaid
        self.lengthInMinutes = lengthInMinutes
        self._description = _description
        self.delete = delete
    }

    public enum CodingKeys: String, CodingKey { 
        case managementUnitDate
        case activityCodeId
        case isPaid
        case lengthInMinutes
        case _description = "description"
        case delete
    }


}




public class UserStationChangeTopicUserStation: Codable {







    public var _id: String?
    public var name: String?
    public var associatedUser: UserStationChangeTopicUser?

    public init(_id: String?, name: String?, associatedUser: UserStationChangeTopicUser?) {
        self._id = _id
        self.name = name
        self.associatedUser = associatedUser
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case associatedUser
    }


}




public class UserStationChangeTopicUserStations: Codable {



    public var associatedStation: UserStationChangeTopicUserStation?

    public init(associatedStation: UserStationChangeTopicUserStation?) {
        self.associatedStation = associatedStation
    }


}




public class UserTimeOffIntegrationStatusResponse: Codable {



    public enum IntegrationStatus: String, Codable { 
        case processing = "Processing"
        case error = "Error"
        case automaticallyComplete = "AutomaticallyComplete"
        case manuallyComplete = "ManuallyComplete"
    }



    /** The time off request associated with this integration status */
    public var timeOffRequest: TimeOffRequestReference?
    /** The value of integration status for the time off request */
    public var integrationStatus: IntegrationStatus?
    /** The user to whom the time off request belongs */
    public var user: UserReference?

    public init(timeOffRequest: TimeOffRequestReference?, integrationStatus: IntegrationStatus?, user: UserReference?) {
        self.timeOffRequest = timeOffRequest
        self.integrationStatus = integrationStatus
        self.user = user
    }


}




public class UserTimeOffIntegrationStatusResponseListing: Codable {



    public var entities: [UserTimeOffIntegrationStatusResponse]?

    public init(entities: [UserTimeOffIntegrationStatusResponse]?) {
        self.entities = entities
    }


}




public class UserTokensTopicUriReference: Codable {





    /** The ID of the resource */
    public var _id: String?
    /** The name of the resource */
    public var name: String?

    public init(_id: String?, name: String?) {
        self._id = _id
        self.name = name
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
    }


}




public class Utterance: Codable {



    /** Utterance text */
    public var utteranceText: String?

    public init(utteranceText: String?) {
        self.utteranceText = utteranceText
    }


}




public class V2ConversationMessageTypingEventForUserTopicConversationEventTyping: Codable {

    public enum ModelType: String, Codable { 
        case on = "On"
    }



    public var type: ModelType?
    public var duration: Int64?

    public init(type: ModelType?, duration: Int64?) {
        self.type = type
        self.duration = duration
    }


}




public class V2ConversationMessageTypingEventForUserTopicConversationNormalizedMessage: Codable {



    public enum ModelType: String, Codable { 
        case event = "Event"
    }



    public enum Direction: String, Codable { 
        case inbound = "Inbound"
        case outbound = "Outbound"
    }

    public var channel: V2ConversationMessageTypingEventForUserTopicConversationMessagingChannel?
    public var type: ModelType?
    public var events: [V2ConversationMessageTypingEventForUserTopicConversationMessageEvent]?
    public var direction: Direction?

    public init(channel: V2ConversationMessageTypingEventForUserTopicConversationMessagingChannel?, type: ModelType?, events: [V2ConversationMessageTypingEventForUserTopicConversationMessageEvent]?, direction: Direction?) {
        self.channel = channel
        self.type = type
        self.events = events
        self.direction = direction
    }


}




public class V2ConversationMessageTypingEventForWorkflowTopicConversationRecipientAdditionalIdentifier: Codable {

    public enum ModelType: String, Codable { 
        case deployment = "Deployment"
        case subject = "Subject"
        case unknown = "Unknown"
    }



    public var type: ModelType?
    public var value: String?

    public init(type: ModelType?, value: String?) {
        self.type = type
        self.value = value
    }


}




public class V2FlowExecutionDataFlowidTopicFlowExecutionHistory: Codable {



























    public enum MessageType: String, Codable { 
        case unknown = "unknown"
        case sms = "sms"
        case twitter = "twitter"
        case facebook = "facebook"
        case instagram = "instagram"
        case line = "line"
        case whatsapp = "whatsapp"
        case webmessaging = "webmessaging"
        case _open = "open"
    }







    /** The execution identifier which represents this unique instance of the flow that ran. */
    public var executionId: String?
    /** The Genesys Cloud conversation identifier associated with this flow instance execution data. */
    public var conversationId: String?
    /** The division identifier for the division associated with the flow for this flow instance. */
    public var divisionId: String?
    /** The end date time for this flow instance execution data. */
    public var endDateTime: Date?
    /** The public endpoint a user can use to retrieve the full historical log from the service. */
    public var endpoint: String?
    /** If the flow invoked error handling, an array of errors. */
    public var errors: [V2FlowExecutionDataFlowidTopicFlowErrorWarningInfo]?
    /** An array of execution items that describe what happened when an Architect flow action container ran such as a flow, task, state or bot. */
    public var execution: [V2FlowExecutionDataFlowidTopicFlowExecutionItem]?
    /** Provides information about why a flow ended. */
    public var flowExitReason: String?
    /** The flow identifier for this flow instance execution data.  This is the identifier of the flow configuration that users load up in Architect. */
    public var flowId: String?
    /** Whether the flow that ran for this flow instance execution data was in debug mode. */
    public var flowIsDebug: Bool?
    /** If true, the execution items in this event have been truncated to be deliverable. */
    public var executionItemsTruncated: Bool?
    /** The flow type of the Architect flow that was run. */
    public var flowType: String?
    /** The version of the flow for this flow instance execution data. Typically this is a numeric value like 1.0 represented as a string but can also be 'debug' */
    public var flowVersion: String?
    /** If applicable, the type of message platform from which the message originated. */
    public var messageType: MessageType?
    public var invokingContext: V2FlowExecutionDataFlowidTopicInvokingContextInfo?
    /** The start date time for this flow instance execution data. */
    public var startDateTime: Date?
    /** If the flow encountered a warning during execution, this is an array of the warnings. */
    public var warnings: [V2FlowExecutionDataFlowidTopicFlowErrorWarningInfo]?

    public init(executionId: String?, conversationId: String?, divisionId: String?, endDateTime: Date?, endpoint: String?, errors: [V2FlowExecutionDataFlowidTopicFlowErrorWarningInfo]?, execution: [V2FlowExecutionDataFlowidTopicFlowExecutionItem]?, flowExitReason: String?, flowId: String?, flowIsDebug: Bool?, executionItemsTruncated: Bool?, flowType: String?, flowVersion: String?, messageType: MessageType?, invokingContext: V2FlowExecutionDataFlowidTopicInvokingContextInfo?, startDateTime: Date?, warnings: [V2FlowExecutionDataFlowidTopicFlowErrorWarningInfo]?) {
        self.executionId = executionId
        self.conversationId = conversationId
        self.divisionId = divisionId
        self.endDateTime = endDateTime
        self.endpoint = endpoint
        self.errors = errors
        self.execution = execution
        self.flowExitReason = flowExitReason
        self.flowId = flowId
        self.flowIsDebug = flowIsDebug
        self.executionItemsTruncated = executionItemsTruncated
        self.flowType = flowType
        self.flowVersion = flowVersion
        self.messageType = messageType
        self.invokingContext = invokingContext
        self.startDateTime = startDateTime
        self.warnings = warnings
    }


}




public class V2FlowExecutionDataFlowidTopicFlowExecutionItem: Codable {

















    /** The type of executionItem that was executed. */
    public var objectType: String?
    /** If applicable, the actionId, menuId or taskId for the executionItem. */
    public var objectId: String?
    /** If applicable, the identifier of the OutputPath that was taken. */
    public var outputPathId: String?
    /** If applicable, the executionId for the executionItem. */
    public var executionId: String?
    /** This is the starting time of the executionItem. */
    public var startDateTime: Date?
    /** Event generated when a Flow's Execution History is received and logged. */
    public var error: V2FlowExecutionDataFlowidTopicFlowErrorWarningInfo?
    /** Event generated when a Flow's Execution History is received and logged. */
    public var warning: V2FlowExecutionDataFlowidTopicFlowErrorWarningInfo?
    /** If applicable, the language tag associated set by the execution. */
    public var languageTag: String?

    public init(objectType: String?, objectId: String?, outputPathId: String?, executionId: String?, startDateTime: Date?, error: V2FlowExecutionDataFlowidTopicFlowErrorWarningInfo?, warning: V2FlowExecutionDataFlowidTopicFlowErrorWarningInfo?, languageTag: String?) {
        self.objectType = objectType
        self.objectId = objectId
        self.outputPathId = outputPathId
        self.executionId = executionId
        self.startDateTime = startDateTime
        self.error = error
        self.warning = warning
        self.languageTag = languageTag
    }


}



/** This contains contextual information about an invoking entity. */

public class V2FlowExecutionDataFlowidTopicInvokingProcessAutomationContext: Codable {





    /** The identifier of the process automation trigger that invoked this flow. */
    public var triggerId: String?
    /** The name of the process automation trigger that invoked this flow. */
    public var triggerName: String?

    public init(triggerId: String?, triggerName: String?) {
        self.triggerId = triggerId
        self.triggerName = triggerName
    }


}




public class V2MobiusAlertsTopicAlertNotificationRecipient: Codable {







    public var userId: String?
    public var displayName: String?
    public var contactAddress: String?

    public init(userId: String?, displayName: String?, contactAddress: String?) {
        self.userId = userId
        self.displayName = displayName
        self.contactAddress = contactAddress
    }


}




public class V2MobiusAlertsTopicCondition: Codable {







    public enum ModelType: String, Codable { 
        case and = "And"
        case or = "Or"
        case not = "Not"
        case unknown = "Unknown"
    }

    public var _id: UUID?
    public var clauses: [V2MobiusAlertsTopicCondition]?
    public var predicates: [V2MobiusAlertsTopicConditionRulePredicate]?
    public var type: ModelType?

    public init(_id: UUID?, clauses: [V2MobiusAlertsTopicCondition]?, predicates: [V2MobiusAlertsTopicConditionRulePredicate]?, type: ModelType?) {
        self._id = _id
        self.clauses = clauses
        self.predicates = predicates
        self.type = type
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case clauses
        case predicates
        case type
    }


}




public class V2MobiusRulesTopicConditionRulePredicate: Codable {







    public enum MetricType: String, Codable { 
        case interval = "Interval"
        case instance = "Instance"
        case unknown = "Unknown"
    }

    public enum MetricValueType: String, Codable { 
        case count = "Count"
        case percentage = "Percentage"
        case average = "Average"
        case timer = "Timer"
        case observation = "Observation"
        case min = "Min"
        case max = "Max"
        case unknown = "Unknown"
    }





    public enum MediaType: String, Codable { 
        case voice = "Voice"
        case chat = "Chat"
        case email = "Email"
        case callback = "Callback"
        case message = "Message"
        case screenshare = "Screenshare"
        case cobrowse = "Cobrowse"
        case unknown = "Unknown"
    }



    public enum ComparisonOperator: String, Codable { 
        case gt = "Gt"
        case gte = "Gte"
        case lt = "Lt"
        case lte = "Lte"
        case eq = "Eq"
        case ne = "Ne"
        case unknown = "Unknown"
    }

    public var _id: UUID?
    public var entity: V2MobiusRulesTopicEntityProperties?
    public var metric: String?
    public var metricType: MetricType?
    public var metricValueType: MetricValueType?
    public var value: Double?
    public var status: String?
    public var mediaType: MediaType?
    public var topic: String?
    public var comparisonOperator: ComparisonOperator?

    public init(_id: UUID?, entity: V2MobiusRulesTopicEntityProperties?, metric: String?, metricType: MetricType?, metricValueType: MetricValueType?, value: Double?, status: String?, mediaType: MediaType?, topic: String?, comparisonOperator: ComparisonOperator?) {
        self._id = _id
        self.entity = entity
        self.metric = metric
        self.metricType = metricType
        self.metricValueType = metricValueType
        self.value = value
        self.status = status
        self.mediaType = mediaType
        self.topic = topic
        self.comparisonOperator = comparisonOperator
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case entity
        case metric
        case metricType
        case metricValueType
        case value
        case status
        case mediaType
        case topic
        case comparisonOperator
    }


}




public class V2MobiusRulesTopicEntityProperties: Codable {

    public enum EntityType: String, Codable { 
        case organization = "Organization"
        case user = "User"
        case queue = "Queue"
        case group = "Group"
        case edge = "Edge"
        case team = "Team"
        case teamMembers = "TeamMembers"
    }









    public var entityType: EntityType?
    public var user: V2MobiusRulesTopicAlertingAddressableEntityRef?
    public var group: V2MobiusRulesTopicAlertingAddressableEntityRef?
    public var queue: V2MobiusRulesTopicAlertingAddressableEntityRef?
    public var team: V2MobiusRulesTopicAlertingAddressableEntityRef?

    public init(entityType: EntityType?, user: V2MobiusRulesTopicAlertingAddressableEntityRef?, group: V2MobiusRulesTopicAlertingAddressableEntityRef?, queue: V2MobiusRulesTopicAlertingAddressableEntityRef?, team: V2MobiusRulesTopicAlertingAddressableEntityRef?) {
        self.entityType = entityType
        self.user = user
        self.group = group
        self.queue = queue
        self.team = team
    }


}




public class V2QueueObservationMetricGroup: Codable {





    public var group: [String:String]?
    public var data: V2QueueObservationMetricData?

    public init(group: [String:String]?, data: V2QueueObservationMetricData?) {
        self.group = group
        self.data = data
    }


}




public class V2SessionConversationsSummarySettingsPreviewEventConversationFollowupAction: Codable {







    public var text: String?
    public var _description: String?
    public var score: Double?

    public init(text: String?, _description: String?, score: Double?) {
        self.text = text
        self._description = _description
        self.score = score
    }

    public enum CodingKeys: String, CodingKey { 
        case text
        case _description = "description"
        case score
    }


}




public class V2StaSentimentOverallTopicOverallSentimentMessage: Codable {













    public var conversationId: String?
    public var sentimentOverallScore: Double?
    public var sentimentTrendScore: Double?
    public var queueIds: [String]?
    public var divisionIds: [String]?
    public var flowIds: [String]?

    public init(conversationId: String?, sentimentOverallScore: Double?, sentimentTrendScore: Double?, queueIds: [String]?, divisionIds: [String]?, flowIds: [String]?) {
        self.conversationId = conversationId
        self.sentimentOverallScore = sentimentOverallScore
        self.sentimentTrendScore = sentimentTrendScore
        self.queueIds = queueIds
        self.divisionIds = divisionIds
        self.flowIds = flowIds
    }


}




public class V2StaTopicsDetectedTopicTopicDetected: Codable {







    public var participant: String?
    public var topicId: String?
    public var topicName: String?

    public init(participant: String?, topicId: String?, topicName: String?) {
        self.participant = participant
        self.topicId = topicId
        self.topicName = topicName
    }


}




public class V2WemEngagementCelebrationUpdatesTopicEngagementCelebration: Codable {









    public enum ModelType: String, Codable { 
        case unknown = "UNKNOWN"
        case recognition = "RECOGNITION"
        case contestComplete = "CONTEST_COMPLETE"
    }







    public var _id: UUID?
    public var recipient: V2WemEngagementCelebrationUpdatesTopicUserId?
    public var createdBy: V2WemEngagementCelebrationUpdatesTopicUserId?
    public var dateCreated: String?
    public var type: ModelType?
    public var title: String?
    public var note: String?
    public var sourceEntity: V2WemEngagementCelebrationUpdatesTopicSourceEntity?

    public init(_id: UUID?, recipient: V2WemEngagementCelebrationUpdatesTopicUserId?, createdBy: V2WemEngagementCelebrationUpdatesTopicUserId?, dateCreated: String?, type: ModelType?, title: String?, note: String?, sourceEntity: V2WemEngagementCelebrationUpdatesTopicSourceEntity?) {
        self._id = _id
        self.recipient = recipient
        self.createdBy = createdBy
        self.dateCreated = dateCreated
        self.type = type
        self.title = title
        self.note = note
        self.sourceEntity = sourceEntity
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case recipient
        case createdBy
        case dateCreated
        case type
        case title
        case note
        case sourceEntity
    }


}




public class V2WemEngagementCelebrationUpdatesTopicSourceEntity: Codable {



    public enum ModelType: String, Codable { 
        case unknown = "UNKNOWN"
        case thankYou = "THANK_YOU"
        case congratulations = "CONGRATULATIONS"
        case highPerformance = "HIGH_PERFORMANCE"
        case companyValues = "COMPANY_VALUES"
        case competition = "COMPETITION"
        case race = "RACE"
        case raffle = "RAFFLE"
        case teamGoal = "TEAM_GOAL"
    }



    public var _id: UUID?
    public var type: ModelType?
    public var contestCompleteData: V2WemEngagementCelebrationUpdatesTopicContestCompleteData?

    public init(_id: UUID?, type: ModelType?, contestCompleteData: V2WemEngagementCelebrationUpdatesTopicContestCompleteData?) {
        self._id = _id
        self.type = type
        self.contestCompleteData = contestCompleteData
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case type
        case contestCompleteData
    }


}




public class ValidationResult: Codable {







    /** Separator valid in the upload */
    public var separatorValid: Bool?
    /** File encoding valid for the upload */
    public var fileEncodingValid: Bool?
    /** List of errors for the upload */
    public var errors: [ValidationError]?

    public init(separatorValid: Bool?, fileEncodingValid: Bool?, errors: [ValidationError]?) {
        self.separatorValid = separatorValid
        self.fileEncodingValid = fileEncodingValid
        self.errors = errors
    }


}




public class ValueWrapperBuShortTermForecastReference: Codable {



    /** The value for the associated field */
    public var value: BuShortTermForecastReference?

    public init(value: BuShortTermForecastReference?) {
        self.value = value
    }


}




public class ValueWrapperLocalDate: Codable {



    /** The value for the associated field. Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd */
    public var value: Date?

    public init(value: Date?) {
        self.value = value
    }


}




public class ValueWrapperPlanningPeriodSettings: Codable {



    /** The value for the associated field */
    public var value: PlanningPeriodSettings?

    public init(value: PlanningPeriodSettings?) {
        self.value = value
    }


}




public class VisibilityCondition: Codable {

    public enum CombiningOperation: String, Codable { 
        case and = "AND"
        case or = "OR"
    }



    public var combiningOperation: CombiningOperation?
    /** A list of strings, each representing the location in the form of the Answer Option to depend on. In the format of \"/form/questionGroup/{questionGroupIndex}/question/{questionIndex}/answer/{answerIndex}\" or, to assume the current question group, \"../question/{questionIndex}/answer/{answerIndex}\". Note: Indexes are zero-based */
    public var predicates: [JSON]?

    public init(combiningOperation: CombiningOperation?, predicates: [JSON]?) {
        self.combiningOperation = combiningOperation
        self.predicates = predicates
    }


}




public class VoicemailCopyRecord: Codable {







    /** The user that the voicemail message was copied to/from */
    public var user: User?
    /** The group that the voicemail message was copied to/from */
    public var group: Group?
    /** The date when the voicemail was copied. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var date: Date?

    public init(user: User?, group: Group?, date: Date?) {
        self.user = user
        self.group = group
        self.date = date
    }


}




public class VoicemailEndDetailEventTopicVoicemailEndEvent: Codable {









    public enum DisconnectType: String, Codable { 
        case unknown = "UNKNOWN"
        case endpoint = "ENDPOINT"
        case client = "CLIENT"
        case system = "SYSTEM"
        case transfer = "TRANSFER"
        case error = "ERROR"
        case peer = "PEER"
        case other = "OTHER"
        case spam = "SPAM"
        case timeout = "TIMEOUT"
        case transportFailure = "TRANSPORT_FAILURE"
        case conferenceTransfer = "CONFERENCE_TRANSFER"
        case consultTransfer = "CONSULT_TRANSFER"
        case forwardTransfer = "FORWARD_TRANSFER"
        case noAnswerTransfer = "NO_ANSWER_TRANSFER"
        case notAvailableTransfer = "NOT_AVAILABLE_TRANSFER"
        case uncallable = "UNCALLABLE"
        case dndEndpoint = "DND_ENDPOINT"
        case dndTransfer = "DND_TRANSFER"
        case inactivity = "INACTIVITY"
        case sessionExpired = "SESSION_EXPIRED"
    }

    public enum MediaType: String, Codable { 
        case unknown = "UNKNOWN"
        case voice = "VOICE"
        case chat = "CHAT"
        case email = "EMAIL"
        case callback = "CALLBACK"
        case cobrowse = "COBROWSE"
        case video = "VIDEO"
        case screenshare = "SCREENSHARE"
        case message = "MESSAGE"
        case internalmessage = "INTERNALMESSAGE"
    }



    public enum Direction: String, Codable { 
        case unknown = "UNKNOWN"
        case inbound = "INBOUND"
        case outbound = "OUTBOUND"
    }

















    public var eventTime: Int64?
    public var conversationId: String?
    public var participantId: String?
    public var sessionId: String?
    public var disconnectType: DisconnectType?
    public var mediaType: MediaType?
    public var provider: String?
    public var direction: Direction?
    public var ani: String?
    public var dnis: String?
    public var userId: String?
    public var queueId: String?
    public var divisionId: String?
    public var voicemailDurationMs: Int64?
    public var conversationExternalContactIds: [String]?
    public var conversationExternalOrganizationIds: [String]?

    public init(eventTime: Int64?, conversationId: String?, participantId: String?, sessionId: String?, disconnectType: DisconnectType?, mediaType: MediaType?, provider: String?, direction: Direction?, ani: String?, dnis: String?, userId: String?, queueId: String?, divisionId: String?, voicemailDurationMs: Int64?, conversationExternalContactIds: [String]?, conversationExternalOrganizationIds: [String]?) {
        self.eventTime = eventTime
        self.conversationId = conversationId
        self.participantId = participantId
        self.sessionId = sessionId
        self.disconnectType = disconnectType
        self.mediaType = mediaType
        self.provider = provider
        self.direction = direction
        self.ani = ani
        self.dnis = dnis
        self.userId = userId
        self.queueId = queueId
        self.divisionId = divisionId
        self.voicemailDurationMs = voicemailDurationMs
        self.conversationExternalContactIds = conversationExternalContactIds
        self.conversationExternalOrganizationIds = conversationExternalOrganizationIds
    }


}




public class VoicemailMessagesTopicOwner: Codable {



    public var _id: String?

    public init(_id: String?) {
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
    }


}




public class VoicemailOrganizationPolicy: Codable {























    /** Whether voicemail is enabled for this organization */
    public var enabled: Bool?
    /** The organization's default number of seconds to ring a user's phone before a call is transferred to voicemail */
    public var alertTimeoutSeconds: Int?
    /** The configuration for user PINs to access their voicemail from a phone */
    public var pinConfiguration: PINConfiguration?
    /** The extension for voicemail retrieval.  The default value is *86. */
    public var voicemailExtension: String?
    /** If this is true, a PIN is required when accessing a user's voicemail from a phone. */
    public var pinRequired: Bool?
    /** Whether user should be prompted with a confirmation prompt when connecting to a Group Ring call */
    public var interactiveResponseRequired: Bool?
    /** Whether email notifications are sent for new voicemails in the organization. If false, new voicemail email notifications are not be sent for the organization overriding any user or group setting. */
    public var sendEmailNotifications: Bool?
    /** Whether to include the voicemail transcription in the notification email */
    public var includeEmailTranscriptions: Bool?
    /** Removes any PII from emails. This overrides any analogous group configuration value. This is always true if HIPAA is enabled or unknown for an organization. */
    public var disableEmailPii: Bool?
    /** Default value for the maximum length of time in seconds of a recorded voicemail */
    public var maximumRecordingTimeSeconds: Int?
    /** The date the policy was last modified. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var modifiedDate: Date?

    public init(enabled: Bool?, alertTimeoutSeconds: Int?, pinConfiguration: PINConfiguration?, voicemailExtension: String?, pinRequired: Bool?, interactiveResponseRequired: Bool?, sendEmailNotifications: Bool?, includeEmailTranscriptions: Bool?, disableEmailPii: Bool?, maximumRecordingTimeSeconds: Int?, modifiedDate: Date?) {
        self.enabled = enabled
        self.alertTimeoutSeconds = alertTimeoutSeconds
        self.pinConfiguration = pinConfiguration
        self.voicemailExtension = voicemailExtension
        self.pinRequired = pinRequired
        self.interactiveResponseRequired = interactiveResponseRequired
        self.sendEmailNotifications = sendEmailNotifications
        self.includeEmailTranscriptions = includeEmailTranscriptions
        self.disableEmailPii = disableEmailPii
        self.maximumRecordingTimeSeconds = maximumRecordingTimeSeconds
        self.modifiedDate = modifiedDate
    }


}




public class VoicemailSearchRequest: Codable {

    public enum SortOrder: String, Codable { 
        case asc = "ASC"
        case desc = "DESC"
        case score = "SCORE"
    }













    /** The sort order for results */
    public var sortOrder: SortOrder?
    /** The field in the resource that you want to sort the results by */
    public var sortBy: String?
    /** The number of results per page */
    public var pageSize: Int?
    /** The page of resources you want to retrieve */
    public var pageNumber: Int?
    /** Multi-value sort order, list of multiple sort values */
    public var sort: [SearchSort]?
    /** Provides more details about a specified resource */
    public var expand: [String]?
    public var query: [VoicemailSearchCriteria]?

    public init(sortOrder: SortOrder?, sortBy: String?, pageSize: Int?, pageNumber: Int?, sort: [SearchSort]?, expand: [String]?, query: [VoicemailSearchCriteria]?) {
        self.sortOrder = sortOrder
        self.sortBy = sortBy
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.sort = sort
        self.expand = expand
        self.query = query
    }


}




public class WebChatDeploymentEntityListing: Codable {







    public var total: Int64?
    public var entities: [WebChatDeployment]?
    public var selfUri: String?

    public init(total: Int64?, entities: [WebChatDeployment]?, selfUri: String?) {
        self.total = total
        self.entities = entities
        self.selfUri = selfUri
    }


}




public class WebChatGuestMediaRequestEntityList: Codable {



    public var entities: [WebChatGuestMediaRequest]?

    public init(entities: [WebChatGuestMediaRequest]?) {
        self.entities = entities
    }


}




public class WebChatMessage: Codable {











    public enum BodyType: String, Codable { 
        case standard = "standard"
        case notice = "notice"
        case memberJoin = "member-join"
        case memberLeave = "member-leave"
        case mediaRequest = "media-request"
    }





    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** The identifier of the conversation */
    public var conversation: WebChatConversation?
    /** The member who sent the message */
    public var sender: WebChatMemberInfo?
    /** The message body. */
    public var body: String?
    /** The purpose of the message within the conversation, such as a standard text entry versus a greeting. */
    public var bodyType: BodyType?
    /** The timestamp of the message, in ISO-8601 format */
    public var timestamp: Date?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, conversation: WebChatConversation?, sender: WebChatMemberInfo?, body: String?, bodyType: BodyType?, timestamp: Date?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.conversation = conversation
        self.sender = sender
        self.body = body
        self.bodyType = bodyType
        self.timestamp = timestamp
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case conversation
        case sender
        case body
        case bodyType
        case timestamp
        case selfUri
    }


}




public class WebChatRoutingTarget: Codable {

    public enum TargetType: String, Codable { 
        case queue = "QUEUE"
    }









    /** The target type of the routing target, such as 'QUEUE'. */
    public var targetType: TargetType?
    /** The target of the route, in the format appropriate given the 'targetType'. */
    public var targetAddress: String?
    /** The list of skill names to use for routing. */
    public var skills: [String]?
    /** The language name to use for routing. */
    public var language: String?
    /** The priority to assign to the conversation for routing. */
    public var priority: Int64?

    public init(targetType: TargetType?, targetAddress: String?, skills: [String]?, language: String?, priority: Int64?) {
        self.targetType = targetType
        self.targetAddress = targetAddress
        self.skills = skills
        self.language = language
        self.priority = priority
    }


}




public class WebChatSettings: Codable {



    public var requireDeployment: Bool?

    public init(requireDeployment: Bool?) {
        self.requireDeployment = requireDeployment
    }


}




public class WebDeploymentsDeploymentTopicWebMessagingDeploymentChangeEventBody: Codable {





    public enum Status: String, Codable { 
        case pending = "Pending"
        case active = "Active"
        case inactive = "Inactive"
        case error = "Error"
        case deleting = "Deleting"
    }

    public var _id: String?
    public var configuration: WebDeploymentsDeploymentTopicWebMessagingConfigChangeEventBody?
    public var status: Status?

    public init(_id: String?, configuration: WebDeploymentsDeploymentTopicWebMessagingConfigChangeEventBody?, status: Status?) {
        self._id = _id
        self.configuration = configuration
        self.status = status
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case configuration
        case status
    }


}



/** Channel-specific information that describes the message and the message channel/provider. */

public class WebMessagingChannel: Codable {









    /** Information about the recipient the message is received from. */
    public var from: WebMessagingRecipient?
    /** Information about the recipient the message is sent to. */
    public var to: WebMessagingRecipient?
    /** When the message was processed by Genesys Cloud. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var time: Date?
    /** Unique provider ID of the message. */
    public var messageId: String?

    public init(from: WebMessagingRecipient?, to: WebMessagingRecipient?, time: Date?, messageId: String?) {
        self.from = from
        self.to = to
        self.time = time
        self.messageId = messageId
    }


}




public class WebMessagingOfferFields: Codable {





    /** Text value to be used when inviting a visitor to engage with a web messaging offer. */
    public var offerText: String?
    /** Flow to be invoked, overrides default flow when specified. */
    public var architectFlow: AddressableEntityRef?

    public init(offerText: String?, architectFlow: AddressableEntityRef?) {
        self.offerText = offerText
        self.architectFlow = architectFlow
    }


}




public class WebMessagingOfferProperties: Codable {



    /** Text value to be used when inviting a visitor to engage with a web messaging offer. */
    public var offerText: String?

    public init(offerText: String?) {
        self.offerText = offerText
    }


}




public class WeekSchedule: Codable {























    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The URI for this object */
    public var selfUri: String?
    /** First day of this week schedule in yyyy-MM-dd format */
    public var weekDate: String?
    /** Description of the week schedule */
    public var _description: String?
    /** Whether the week schedule is published */
    public var published: Bool?
    /** Summary of the results from the schedule run */
    public var generationResults: WeekScheduleGenerationResult?
    /** Short term forecast associated with this schedule */
    public var shortTermForecast: ShortTermForecastReference?
    /** Version metadata for this work plan */
    public var metadata: WfmVersionedEntityMetadata?
    /** User schedules in the week */
    public var userSchedules: [String:UserSchedule]?
    /** Headcount information for the week schedule */
    public var headcountForecast: HeadcountForecast?
    /** Version of agent schedules in the week schedule */
    public var agentSchedulesVersion: Int?

    public init(_id: String?, selfUri: String?, weekDate: String?, _description: String?, published: Bool?, generationResults: WeekScheduleGenerationResult?, shortTermForecast: ShortTermForecastReference?, metadata: WfmVersionedEntityMetadata?, userSchedules: [String:UserSchedule]?, headcountForecast: HeadcountForecast?, agentSchedulesVersion: Int?) {
        self._id = _id
        self.selfUri = selfUri
        self.weekDate = weekDate
        self._description = _description
        self.published = published
        self.generationResults = generationResults
        self.shortTermForecast = shortTermForecast
        self.metadata = metadata
        self.userSchedules = userSchedules
        self.headcountForecast = headcountForecast
        self.agentSchedulesVersion = agentSchedulesVersion
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
        case weekDate
        case _description = "description"
        case published
        case generationResults
        case shortTermForecast
        case metadata
        case userSchedules
        case headcountForecast
        case agentSchedulesVersion
    }


}




public class WeekScheduleGenerationResult: Codable {









    /** Whether the schedule generation failed */
    public var failed: Bool?
    /** ID of the schedule run */
    public var runId: String?
    /** Warning messages from the schedule run. This will be available only when requesting information for a single week schedule */
    public var agentWarnings: [ScheduleGenerationWarning]?
    /** Count of warning messages from the schedule run. This will be available only when requesting multiple week schedules */
    public var agentWarningCount: Int?

    public init(failed: Bool?, runId: String?, agentWarnings: [ScheduleGenerationWarning]?, agentWarningCount: Int?) {
        self.failed = failed
        self.runId = runId
        self.agentWarnings = agentWarnings
        self.agentWarningCount = agentWarningCount
    }


}




public class WeekShiftTradeResponse: Codable {





    /** The shift trade details */
    public var trade: ShiftTradeResponse?
    /** A preview of what the schedule would look like if the shift trade is approved plus any violations */
    public var matchReview: ShiftTradeMatchReviewResponse?

    public init(trade: ShiftTradeResponse?, matchReview: ShiftTradeMatchReviewResponse?) {
        self.trade = trade
        self.matchReview = matchReview
    }


}




public class WfmAdherenceExplanationJobCompleteTopicAdherenceExplanationChangedNotification: Codable {









    public enum ModelType: String, Codable { 
        case late = "Late"
    }

    public enum Status: String, Codable { 
        case pending = "Pending"
        case approved = "Approved"
        case denied = "Denied"
    }











    public var _id: String?
    public var agent: WfmAdherenceExplanationJobCompleteTopicUserReference?
    public var managementUnit: WfmAdherenceExplanationJobCompleteTopicManagementUnit?
    public var businessUnit: WfmAdherenceExplanationJobCompleteTopicBusinessUnit?
    public var type: ModelType?
    public var status: Status?
    public var startDate: Date?
    public var lengthMinutes: Int64?
    public var notes: String?
    public var reviewedBy: WfmAdherenceExplanationJobCompleteTopicUserReference?
    public var reviewedDate: Date?

    public init(_id: String?, agent: WfmAdherenceExplanationJobCompleteTopicUserReference?, managementUnit: WfmAdherenceExplanationJobCompleteTopicManagementUnit?, businessUnit: WfmAdherenceExplanationJobCompleteTopicBusinessUnit?, type: ModelType?, status: Status?, startDate: Date?, lengthMinutes: Int64?, notes: String?, reviewedBy: WfmAdherenceExplanationJobCompleteTopicUserReference?, reviewedDate: Date?) {
        self._id = _id
        self.agent = agent
        self.managementUnit = managementUnit
        self.businessUnit = businessUnit
        self.type = type
        self.status = status
        self.startDate = startDate
        self.lengthMinutes = lengthMinutes
        self.notes = notes
        self.reviewedBy = reviewedBy
        self.reviewedDate = reviewedDate
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case agent
        case managementUnit
        case businessUnit
        case type
        case status
        case startDate
        case lengthMinutes
        case notes
        case reviewedBy
        case reviewedDate
    }


}




public class WfmAdherenceExplanationJobCompleteTopicManagementUnit: Codable {



    public var _id: String?

    public init(_id: String?) {
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
    }


}




public class WfmAgentScheduleUpdateTopicUserReference: Codable {



    public var _id: String?

    public init(_id: String?) {
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
    }


}




public class WfmBuIntradayDataUpdateTopicBuIntradayResult: Codable {









    public enum Categories: String, Codable { 
        case forecastData = "ForecastData"
        case scheduleData = "ScheduleData"
        case performancePredictionData = "PerformancePredictionData"
    }







    public var startDate: Date?
    public var endDate: Date?
    public var intervalLengthMinutes: Int64?
    public var intradayDataGroupings: [WfmBuIntradayDataUpdateTopicBuIntradayDataGroup]?
    public var categories: [Categories]?
    public var noDataReason: String?
    public var schedule: WfmBuIntradayDataUpdateTopicBuScheduleReference?
    public var shortTermForecast: WfmBuIntradayDataUpdateTopicBuShortTermForecastReference?

    public init(startDate: Date?, endDate: Date?, intervalLengthMinutes: Int64?, intradayDataGroupings: [WfmBuIntradayDataUpdateTopicBuIntradayDataGroup]?, categories: [Categories]?, noDataReason: String?, schedule: WfmBuIntradayDataUpdateTopicBuScheduleReference?, shortTermForecast: WfmBuIntradayDataUpdateTopicBuShortTermForecastReference?) {
        self.startDate = startDate
        self.endDate = endDate
        self.intervalLengthMinutes = intervalLengthMinutes
        self.intradayDataGroupings = intradayDataGroupings
        self.categories = categories
        self.noDataReason = noDataReason
        self.schedule = schedule
        self.shortTermForecast = shortTermForecast
    }


}




public class WfmBuIntradayDataUpdateTopicIntradayPerformancePredictionData: Codable {







    public var serviceLevelPercent: Double?
    public var averageSpeedOfAnswerSeconds: Double?
    public var occupancyPercent: Double?

    public init(serviceLevelPercent: Double?, averageSpeedOfAnswerSeconds: Double?, occupancyPercent: Double?) {
        self.serviceLevelPercent = serviceLevelPercent
        self.averageSpeedOfAnswerSeconds = averageSpeedOfAnswerSeconds
        self.occupancyPercent = occupancyPercent
    }


}




public class WfmBuScheduleRunTopicBuScheduleRun: Codable {







    public enum State: String, Codable { 
        case _none = "None"
        case queued = "Queued"
        case scheduling = "Scheduling"
        case canceled = "Canceled"
        case failed = "Failed"
        case complete = "Complete"
    }













    public var _id: String?
    public var percentComplete: Double?
    public var intradayRescheduling: Bool?
    public var state: State?
    public var weekCount: Int64?
    public var schedule: WfmBuScheduleRunTopicBuScheduleReference?
    public var schedulingCanceledBy: WfmBuScheduleRunTopicUserReference?
    public var schedulingCompletedTime: String?
    public var messageCount: Int64?
    public var messageSeverityCounts: [WfmBuScheduleRunTopicSchedulerMessageSeverityCount]?

    public init(_id: String?, percentComplete: Double?, intradayRescheduling: Bool?, state: State?, weekCount: Int64?, schedule: WfmBuScheduleRunTopicBuScheduleReference?, schedulingCanceledBy: WfmBuScheduleRunTopicUserReference?, schedulingCompletedTime: String?, messageCount: Int64?, messageSeverityCounts: [WfmBuScheduleRunTopicSchedulerMessageSeverityCount]?) {
        self._id = _id
        self.percentComplete = percentComplete
        self.intradayRescheduling = intradayRescheduling
        self.state = state
        self.weekCount = weekCount
        self.schedule = schedule
        self.schedulingCanceledBy = schedulingCanceledBy
        self.schedulingCompletedTime = schedulingCompletedTime
        self.messageCount = messageCount
        self.messageSeverityCounts = messageSeverityCounts
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case percentComplete
        case intradayRescheduling
        case state
        case weekCount
        case schedule
        case schedulingCanceledBy
        case schedulingCompletedTime
        case messageCount
        case messageSeverityCounts
    }


}




public class WfmBuScheduleRunTopicBuSchedulingRunProgressNotification: Codable {

    public enum Status: String, Codable { 
        case processing = "Processing"
        case complete = "Complete"
        case canceled = "Canceled"
        case error = "Error"
    }





    public var status: Status?
    public var operationId: String?
    public var result: WfmBuScheduleRunTopicBuScheduleRun?

    public init(status: Status?, operationId: String?, result: WfmBuScheduleRunTopicBuScheduleRun?) {
        self.status = status
        self.operationId = operationId
        self.result = result
    }


}




public class WfmBuScheduleTopicWfmVersionedEntityMetadata: Codable {







    public var version: Int64?
    public var modifiedBy: WfmBuScheduleTopicUserReference?
    public var dateModified: Date?

    public init(version: Int64?, modifiedBy: WfmBuScheduleTopicUserReference?, dateModified: Date?) {
        self.version = version
        self.modifiedBy = modifiedBy
        self.dateModified = dateModified
    }


}




public class WfmBuShortTermForecastCopyCompleteTopicBuShortTermForecast: Codable {





    public enum CreationMethod: String, Codable { 
        case _import = "Import"
        case importedHistoricalWeightedAverage = "ImportedHistoricalWeightedAverage"
        case historicalWeightedAverage = "HistoricalWeightedAverage"
        case advanced = "Advanced"
    }





















    public var _id: String?
    public var weekDate: String?
    public var creationMethod: CreationMethod?
    public var _description: String?
    public var legacy: Bool?
    public var referenceStartDate: Date?
    public var sourceDays: [WfmBuShortTermForecastCopyCompleteTopicForecastSourceDayPointer]?
    public var modifications: [WfmBuShortTermForecastCopyCompleteTopicBuForecastModification]?
    public var timeZone: String?
    public var planningGroupsVersion: Int64?
    public var weekCount: Int64?
    public var metadata: WfmBuShortTermForecastCopyCompleteTopicWfmVersionedEntityMetadata?
    public var canUseForScheduling: Bool?

    public init(_id: String?, weekDate: String?, creationMethod: CreationMethod?, _description: String?, legacy: Bool?, referenceStartDate: Date?, sourceDays: [WfmBuShortTermForecastCopyCompleteTopicForecastSourceDayPointer]?, modifications: [WfmBuShortTermForecastCopyCompleteTopicBuForecastModification]?, timeZone: String?, planningGroupsVersion: Int64?, weekCount: Int64?, metadata: WfmBuShortTermForecastCopyCompleteTopicWfmVersionedEntityMetadata?, canUseForScheduling: Bool?) {
        self._id = _id
        self.weekDate = weekDate
        self.creationMethod = creationMethod
        self._description = _description
        self.legacy = legacy
        self.referenceStartDate = referenceStartDate
        self.sourceDays = sourceDays
        self.modifications = modifications
        self.timeZone = timeZone
        self.planningGroupsVersion = planningGroupsVersion
        self.weekCount = weekCount
        self.metadata = metadata
        self.canUseForScheduling = canUseForScheduling
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case weekDate
        case creationMethod
        case _description = "description"
        case legacy
        case referenceStartDate
        case sourceDays
        case modifications
        case timeZone
        case planningGroupsVersion
        case weekCount
        case metadata
        case canUseForScheduling
    }


}




public class WfmBuShortTermForecastCopyCompleteTopicBuShortTermForecastNotification: Codable {

    public enum Status: String, Codable { 
        case processing = "Processing"
        case complete = "Complete"
        case canceled = "Canceled"
        case error = "Error"
    }





    public var status: Status?
    public var result: WfmBuShortTermForecastCopyCompleteTopicBuShortTermForecast?
    public var operationId: String?

    public init(status: Status?, result: WfmBuShortTermForecastCopyCompleteTopicBuShortTermForecast?, operationId: String?) {
        self.status = status
        self.result = result
        self.operationId = operationId
    }


}




public class WfmBuShortTermForecastGenerateProgressTopicBuForecastModification: Codable {

    public enum ModelType: String, Codable { 
        case minimumPerInterval = "MinimumPerInterval"
        case maximumPerInterval = "MaximumPerInterval"
        case setValuePerInterval = "SetValuePerInterval"
        case changeValuePerInterval = "ChangeValuePerInterval"
        case changePercentPerInterval = "ChangePercentPerInterval"
        case setValueOverRange = "SetValueOverRange"
        case changeValueOverRange = "ChangeValueOverRange"
        case setValuesForIntervalSet = "SetValuesForIntervalSet"
        case setMultiGranularityValuesForIntervalSet = "SetMultiGranularityValuesForIntervalSet"
    }





    public enum Metric: String, Codable { 
        case offered = "Offered"
        case averageHandleTimeSeconds = "AverageHandleTimeSeconds"
    }

    public enum LegacyMetric: String, Codable { 
        case averageAfterCallWorkTimeSeconds = "AverageAfterCallWorkTimeSeconds"
        case averageHandleTimeSeconds = "AverageHandleTimeSeconds"
        case averageTalkTimeSeconds = "AverageTalkTimeSeconds"
        case offered = "Offered"
    }

















    public var type: ModelType?
    public var startIntervalIndex: Int64?
    public var endIntervalIndex: Int64?
    public var metric: Metric?
    public var legacyMetric: LegacyMetric?
    public var value: Double?
    public var values: [WfmBuShortTermForecastGenerateProgressTopicModificationIntervalOffsetValue]?
    public var secondaryValues: [WfmBuShortTermForecastGenerateProgressTopicModificationIntervalOffsetValue]?
    public var enabled: Bool?
    public var granularity: String?
    public var secondaryGranularity: String?
    public var displayGranularity: String?
    public var planningGroupIds: [String]?

    public init(type: ModelType?, startIntervalIndex: Int64?, endIntervalIndex: Int64?, metric: Metric?, legacyMetric: LegacyMetric?, value: Double?, values: [WfmBuShortTermForecastGenerateProgressTopicModificationIntervalOffsetValue]?, secondaryValues: [WfmBuShortTermForecastGenerateProgressTopicModificationIntervalOffsetValue]?, enabled: Bool?, granularity: String?, secondaryGranularity: String?, displayGranularity: String?, planningGroupIds: [String]?) {
        self.type = type
        self.startIntervalIndex = startIntervalIndex
        self.endIntervalIndex = endIntervalIndex
        self.metric = metric
        self.legacyMetric = legacyMetric
        self.value = value
        self.values = values
        self.secondaryValues = secondaryValues
        self.enabled = enabled
        self.granularity = granularity
        self.secondaryGranularity = secondaryGranularity
        self.displayGranularity = displayGranularity
        self.planningGroupIds = planningGroupIds
    }


}




public class WfmBuShortTermForecastGenerateProgressTopicModificationIntervalOffsetValue: Codable {





    public var intervalIndex: Int64?
    public var value: Double?

    public init(intervalIndex: Int64?, value: Double?) {
        self.intervalIndex = intervalIndex
        self.value = value
    }


}




public class WfmBuShortTermForecastGenerateProgressTopicWfmVersionedEntityMetadata: Codable {







    public var version: Int64?
    public var modifiedBy: WfmBuShortTermForecastGenerateProgressTopicUserReference?
    public var dateModified: Date?

    public init(version: Int64?, modifiedBy: WfmBuShortTermForecastGenerateProgressTopicUserReference?, dateModified: Date?) {
        self.version = version
        self.modifiedBy = modifiedBy
        self.dateModified = dateModified
    }


}




public class WfmBuShortTermForecastUpdateCompleteTopicBuShortTermForecast: Codable {





    public enum CreationMethod: String, Codable { 
        case _import = "Import"
        case importedHistoricalWeightedAverage = "ImportedHistoricalWeightedAverage"
        case historicalWeightedAverage = "HistoricalWeightedAverage"
        case advanced = "Advanced"
    }





















    public var _id: String?
    public var weekDate: String?
    public var creationMethod: CreationMethod?
    public var _description: String?
    public var legacy: Bool?
    public var referenceStartDate: Date?
    public var sourceDays: [WfmBuShortTermForecastUpdateCompleteTopicForecastSourceDayPointer]?
    public var modifications: [WfmBuShortTermForecastUpdateCompleteTopicBuForecastModification]?
    public var timeZone: String?
    public var planningGroupsVersion: Int64?
    public var weekCount: Int64?
    public var metadata: WfmBuShortTermForecastUpdateCompleteTopicWfmVersionedEntityMetadata?
    public var canUseForScheduling: Bool?

    public init(_id: String?, weekDate: String?, creationMethod: CreationMethod?, _description: String?, legacy: Bool?, referenceStartDate: Date?, sourceDays: [WfmBuShortTermForecastUpdateCompleteTopicForecastSourceDayPointer]?, modifications: [WfmBuShortTermForecastUpdateCompleteTopicBuForecastModification]?, timeZone: String?, planningGroupsVersion: Int64?, weekCount: Int64?, metadata: WfmBuShortTermForecastUpdateCompleteTopicWfmVersionedEntityMetadata?, canUseForScheduling: Bool?) {
        self._id = _id
        self.weekDate = weekDate
        self.creationMethod = creationMethod
        self._description = _description
        self.legacy = legacy
        self.referenceStartDate = referenceStartDate
        self.sourceDays = sourceDays
        self.modifications = modifications
        self.timeZone = timeZone
        self.planningGroupsVersion = planningGroupsVersion
        self.weekCount = weekCount
        self.metadata = metadata
        self.canUseForScheduling = canUseForScheduling
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case weekDate
        case creationMethod
        case _description = "description"
        case legacy
        case referenceStartDate
        case sourceDays
        case modifications
        case timeZone
        case planningGroupsVersion
        case weekCount
        case metadata
        case canUseForScheduling
    }


}




public class WfmBuShortTermForecastUpdateCompleteTopicBuShortTermForecastNotification: Codable {

    public enum Status: String, Codable { 
        case processing = "Processing"
        case complete = "Complete"
        case canceled = "Canceled"
        case error = "Error"
    }





    public var status: Status?
    public var result: WfmBuShortTermForecastUpdateCompleteTopicBuShortTermForecast?
    public var operationId: String?

    public init(status: Status?, result: WfmBuShortTermForecastUpdateCompleteTopicBuShortTermForecast?, operationId: String?) {
        self.status = status
        self.result = result
        self.operationId = operationId
    }


}




public class WfmBulkShiftTradeStateUpdateNotificationTopicBulkShiftTradeStateUpdateResult: Codable {



    public enum State: String, Codable { 
        case unmatched = "Unmatched"
        case matched = "Matched"
        case approved = "Approved"
        case denied = "Denied"
        case expired = "Expired"
        case canceled = "Canceled"
    }





    public enum FailureReason: String, Codable { 
        case initiatingAgentScheduleNotFound = "InitiatingAgentScheduleNotFound"
        case initiatingAgentShiftNotFound = "InitiatingAgentShiftNotFound"
        case receivingAgentNotFound = "ReceivingAgentNotFound"
        case receivingAgentScheduleNotFound = "ReceivingAgentScheduleNotFound"
        case receivingAgentShiftNotFound = "ReceivingAgentShiftNotFound"
        case scheduleNotPublished = "ScheduleNotPublished"
        case transitionNotAllowed = "TransitionNotAllowed"
    }



    public var _id: String?
    public var state: State?
    public var reviewedBy: WfmBulkShiftTradeStateUpdateNotificationTopicUserReference?
    public var reviewedDate: Date?
    public var failureReason: FailureReason?
    public var metadata: WfmBulkShiftTradeStateUpdateNotificationTopicWfmVersionedEntityMetadata?

    public init(_id: String?, state: State?, reviewedBy: WfmBulkShiftTradeStateUpdateNotificationTopicUserReference?, reviewedDate: Date?, failureReason: FailureReason?, metadata: WfmBulkShiftTradeStateUpdateNotificationTopicWfmVersionedEntityMetadata?) {
        self._id = _id
        self.state = state
        self.reviewedBy = reviewedBy
        self.reviewedDate = reviewedDate
        self.failureReason = failureReason
        self.metadata = metadata
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case state
        case reviewedBy
        case reviewedDate
        case failureReason
        case metadata
    }


}




public class WfmBulkShiftTradeStateUpdateNotificationTopicBulkShiftTradeStateUpdateResultListing: Codable {



    public var entities: [WfmBulkShiftTradeStateUpdateNotificationTopicBulkShiftTradeStateUpdateResult]?

    public init(entities: [WfmBulkShiftTradeStateUpdateNotificationTopicBulkShiftTradeStateUpdateResult]?) {
        self.entities = entities
    }


}




public class WfmBusinessUnitReference: Codable {





    /** The ID of the business unit */
    public var _id: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, selfUri: String?) {
        self._id = _id
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
    }


}




public class WfmHistoricalAdherenceQuery: Codable {













    /** Beginning of the date range to query in ISO-8601 format */
    public var startDate: Date?
    /** End of the date range to query in ISO-8601 format. If it is not set, end date will be set to current time */
    public var endDate: Date?
    /** The time zone, in olson format, to use in defining days when computing adherence. The results will be returned as UTC timestamps regardless of the time zone input. */
    public var timeZone: String?
    /** The userIds to report on. If null or not set, adherence will be computed for all the users in management unit or requested teamIds */
    public var userIds: [String]?
    /** Whether user exceptions should be returned as part of the results */
    public var includeExceptions: Bool?
    /** The teamIds to report on. If null or not set, adherence will be computed for requested users if applicable or otherwise all users in the management unit. Note: If teamIds is also specified, only adherence for users in the requested teams will be returned */
    public var teamIds: [String]?

    public init(startDate: Date?, endDate: Date?, timeZone: String?, userIds: [String]?, includeExceptions: Bool?, teamIds: [String]?) {
        self.startDate = startDate
        self.endDate = endDate
        self.timeZone = timeZone
        self.userIds = userIds
        self.includeExceptions = includeExceptions
        self.teamIds = teamIds
    }


}




public class WfmHistoricalAdherenceQueryForUsers: Codable {











    /** Beginning of the date range to query in ISO-8601 format */
    public var startDate: Date?
    /** End of the date range to query in ISO-8601 format. If it is not set, end date will be set to current time */
    public var endDate: Date?
    /** The time zone, in olson format, to use in defining days when computing adherence. The results will be returned as UTC timestamps regardless of the time zone input. */
    public var timeZone: String?
    /** The userIds to report on */
    public var userIds: [String]?
    /** Whether user exceptions should be returned as part of the results */
    public var includeExceptions: Bool?

    public init(startDate: Date?, endDate: Date?, timeZone: String?, userIds: [String]?, includeExceptions: Bool?) {
        self.startDate = startDate
        self.endDate = endDate
        self.timeZone = timeZone
        self.userIds = userIds
        self.includeExceptions = includeExceptions
    }


}




public class WfmHistoricalDataImportPurgeCompleteTopicHistoricalDataPurgeRequestComplete: Codable {



    public enum State: String, Codable { 
        case unknown = "Unknown"
        case processing = "Processing"
        case complete = "Complete"
        case error = "Error"
    }





    public var _id: String?
    public var state: State?
    public var entities: [WfmHistoricalDataImportPurgeCompleteTopicHistoricalDataDeleteEntity]?
    public var disallowedEntities: [WfmHistoricalDataImportPurgeCompleteTopicHistoricalDataDisallowedDeleteEntity]?

    public init(_id: String?, state: State?, entities: [WfmHistoricalDataImportPurgeCompleteTopicHistoricalDataDeleteEntity]?, disallowedEntities: [WfmHistoricalDataImportPurgeCompleteTopicHistoricalDataDisallowedDeleteEntity]?) {
        self._id = _id
        self.state = state
        self.entities = entities
        self.disallowedEntities = disallowedEntities
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case state
        case entities
        case disallowedEntities
    }


}




public class WfmHistoricalShrinkageRequest: Codable {







    public enum Granularity: String, Codable { 
        case daily = "Daily"
        case weekly = "Weekly"
    }

    /** Beginning of the date range to query in ISO-8601 format */
    public var startDate: Date?
    /** End of the date range to query in ISO-8601 format. If it is not set, end date will be set to current time */
    public var endDate: Date?
    /** The time zone, in olson format, to use in defining days when computing shrinkage for requested granularity. If it is not set, the business unit time zone will be used. The results will be returned as UTC timestamps regardless of the time zone input. */
    public var timeZone: String?
    /** Shrinkage aggregation interval granularity. */
    public var granularity: Granularity?

    public init(startDate: Date?, endDate: Date?, timeZone: String?, granularity: Granularity?) {
        self.startDate = startDate
        self.endDate = endDate
        self.timeZone = timeZone
        self.granularity = granularity
    }


}




public class WfmIntegrationListing: Codable {



    public var entities: [WfmIntegrationResponse]?

    public init(entities: [WfmIntegrationResponse]?) {
        self.entities = entities
    }


}




public class WfmIntegrationsHrisTimeOffTypesJobTopicErrorBody: Codable {









    public var status: Int64?
    public var code: String?
    public var message: String?
    public var messageParams: [String:String]?

    public init(status: Int64?, code: String?, message: String?, messageParams: [String:String]?) {
        self.status = status
        self.code = code
        self.message = message
        self.messageParams = messageParams
    }


}




public class WfmIntradayDataUpdateTopicIntradayHistoricalAgentData: Codable {





    public var onQueueTimeSeconds: Double?
    public var interactingTimeSeconds: Double?

    public init(onQueueTimeSeconds: Double?, interactingTimeSeconds: Double?) {
        self.onQueueTimeSeconds = onQueueTimeSeconds
        self.interactingTimeSeconds = interactingTimeSeconds
    }


}




public class WfmIntradayPlanningGroupListing: Codable {



    public enum NoDataReason: String, Codable { 
        case noPublishedSchedule = "NoPublishedSchedule"
        case noSourceForecast = "NoSourceForecast"
    }

    public var entities: [ForecastPlanningGroupResponse]?
    /** The reason there was no data for the request */
    public var noDataReason: NoDataReason?

    public init(entities: [ForecastPlanningGroupResponse]?, noDataReason: NoDataReason?) {
        self.entities = entities
        self.noDataReason = noDataReason
    }


}




public class WfmMoveAgentsCompleteTopicWfmMoveAgentData: Codable {



    public enum Result: String, Codable { 
        case alreadyMoved = "AlreadyMoved"
        case destinationBusinessUnitAgentLimitExceeded = "DestinationBusinessUnitAgentLimitExceeded"
        case destinationManagementUnitAgentLimitExceeded = "DestinationManagementUnitAgentLimitExceeded"
        case destinationManagementUnitDoesNotExist = "DestinationManagementUnitDoesNotExist"
        case moveSuccessful = "MoveSuccessful"
        case movingToDifferentManagementUnit = "MovingToDifferentManagementUnit"
        case nothingToDo = "NothingToDo"
        case sourceManagementUnitNotAuthorized = "SourceManagementUnitNotAuthorized"
    }

    public var user: WfmMoveAgentsCompleteTopicUserReference?
    public var result: Result?

    public init(user: WfmMoveAgentsCompleteTopicUserReference?, result: Result?) {
        self.user = user
        self.result = result
    }


}




public class WfmUpdateAgentDetailsTopicWfmUpdateAgentDetailsComplete: Codable {

    public enum Status: String, Codable { 
        case processing = "Processing"
        case complete = "Complete"
        case canceled = "Canceled"
        case error = "Error"
    }

    public var status: Status?

    public init(status: Status?) {
        self.status = status
    }


}




public class WfmUserNotificationTopicAdherenceExplanationNotification: Codable {













    public enum Status: String, Codable { 
        case pending = "Pending"
        case approved = "Approved"
        case denied = "Denied"
    }

    public enum ModelType: String, Codable { 
        case late = "Late"
    }



    public var _id: String?
    public var agent: WfmUserNotificationTopicUserReference?
    public var managementUnit: WfmUserNotificationTopicManagementUnit?
    public var businessUnit: WfmUserNotificationTopicBusinessUnit?
    public var startDate: Date?
    public var lengthMinutes: Int64?
    public var status: Status?
    public var type: ModelType?
    public var notes: String?

    public init(_id: String?, agent: WfmUserNotificationTopicUserReference?, managementUnit: WfmUserNotificationTopicManagementUnit?, businessUnit: WfmUserNotificationTopicBusinessUnit?, startDate: Date?, lengthMinutes: Int64?, status: Status?, type: ModelType?, notes: String?) {
        self._id = _id
        self.agent = agent
        self.managementUnit = managementUnit
        self.businessUnit = businessUnit
        self.startDate = startDate
        self.lengthMinutes = lengthMinutes
        self.status = status
        self.type = type
        self.notes = notes
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case agent
        case managementUnit
        case businessUnit
        case startDate
        case lengthMinutes
        case status
        case type
        case notes
    }


}




public class WfmVersionedEntityMetadata: Codable {











    /** The version of the associated entity.  Used to prevent conflicts on concurrent edits */
    public var version: Int?
    /** The user who last modified the associated entity. The id may be 'System' if it was an automated process */
    public var modifiedBy: UserReference?
    /** The date the associated entity was last modified. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** The user who created the associated entity, if available. The id may be 'System' if it was an automated process */
    public var createdBy: UserReference?
    /** The date the associated entity was created, if available. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?

    public init(version: Int?, modifiedBy: UserReference?, dateModified: Date?, createdBy: UserReference?, dateCreated: Date?) {
        self.version = version
        self.modifiedBy = modifiedBy
        self.dateModified = dateModified
        self.createdBy = createdBy
        self.dateCreated = dateCreated
    }


}




public class WfmUserNotificationTopicBusinessUnit: Codable {



    public var _id: String?

    public init(_id: String?) {
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
    }


}




public class WfmUserScheduleAdherenceUpdatedMuTopicRealTimeAdherenceExplanation: Codable {







    public enum Status: String, Codable { 
        case pending = "Pending"
        case approved = "Approved"
        case denied = "Denied"
    }

    public var _id: String?
    public var startDate: Date?
    public var lengthMinutes: Int64?
    public var status: Status?

    public init(_id: String?, startDate: Date?, lengthMinutes: Int64?, status: Status?) {
        self._id = _id
        self.startDate = startDate
        self.lengthMinutes = lengthMinutes
        self.status = status
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case startDate
        case lengthMinutes
        case status
    }


}




public class WfmUserScheduleAdherenceUpdatedMuTopicUserNextActivityReminder: Codable {





    public var activityCategory: String?
    public var startDate: Date?

    public init(activityCategory: String?, startDate: Date?) {
        self.activityCategory = activityCategory
        self.startDate = startDate
    }


}




public class WfmUserScheduleAdherenceUpdatedTeamTopicActivityCodeReference: Codable {





    public var _id: String?
    public var secondaryPresences: [WfmUserScheduleAdherenceUpdatedTeamTopicSecondaryPresenceReference]?

    public init(_id: String?, secondaryPresences: [WfmUserScheduleAdherenceUpdatedTeamTopicSecondaryPresenceReference]?) {
        self._id = _id
        self.secondaryPresences = secondaryPresences
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case secondaryPresences
    }


}




public class WfmUserScheduleAdherenceUpdatedTeamTopicUriReference: Codable {





    /** The ID of the resource */
    public var _id: String?
    /** The name of the resource */
    public var name: String?

    public init(_id: String?, name: String?) {
        self._id = _id
        self.name = name
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
    }


}




public class WfmUserScheduleAdherenceUpdatedTopicUserReference: Codable {



    public var _id: String?

    public init(_id: String?) {
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
    }


}




public class WhatsAppEmbeddedSignupIntegrationActivationRequest: Codable {











    /** The globally unique identifier for the object. */
    public var _id: String?
    /** WhatsApp Integration name */
    public var name: String?
    /** Phone number to associate with the WhatsApp integration */
    public var phoneNumber: String?
    /** Specify the two-step verification PIN for that phone number */
    public var pin: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, phoneNumber: String?, pin: String?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.phoneNumber = phoneNumber
        self.pin = pin
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case phoneNumber
        case pin
        case selfUri
    }


}




public class WhatsAppIdentityResolutionConfig: Codable {









    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The division to use when performing identity resolution. */
    public var division: WritableStarrableDivision?
    /** Whether the channel should resolve identities */
    public var resolveIdentities: Bool?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, division: WritableStarrableDivision?, resolveIdentities: Bool?, selfUri: String?) {
        self._id = _id
        self.division = division
        self.resolveIdentities = resolveIdentities
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case division
        case resolveIdentities
        case selfUri
    }


}




public class WhatsAppIntegration: Codable {













    public enum Status: String, Codable { 
        case active = "Active"
        case inactive = "Inactive"
        case error = "Error"
        case starting = "Starting"
        case incomplete = "Incomplete"
        case deleting = "Deleting"
        case deletionFailed = "DeletionFailed"
        case failed = "Failed"
    }













    public enum ActivationStatusCode: String, Codable { 
        case codeSent = "CodeSent"
        case waitRequired = "WaitRequired"
        case activationFailed = "ActivationFailed"
        case codeConfirmed = "CodeConfirmed"
        case confirmationFailed = "ConfirmationFailed"
        case resendCode = "ResendCode"
    }



    public enum CreateStatus: String, Codable { 
        case initiated = "Initiated"
        case completed = "Completed"
        case error = "Error"
    }







    /** A unique Integration Id. */
    public var _id: String?
    /** The name of the WhatsApp integration. */
    public var name: String?
    /** Defines the SupportedContent profile configured for an integration */
    public var supportedContent: SupportedContentReference?
    public var messagingSetting: MessagingSettingReference?
    /** The phone number associated to the WhatsApp integration. */
    public var phoneNumber: String?
    /** The list of available WhatsApp phone numbers for this account. Please select one phone number from this list to use with the created integration. */
    public var availablePhoneNumbers: WhatsAppAvailablePhoneNumberDetailsListing?
    /** The status of the WhatsApp Integration */
    public var status: Status?
    /** The recipient associated to the WhatsApp Integration. This recipient is used to associate a flow to an integration */
    public var recipient: DomainEntityRef?
    /** Date this Integration was created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** Date this Integration was last modified. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** User reference that created this Integration */
    public var createdBy: DomainEntityRef?
    /** User reference that last modified this Integration */
    public var modifiedBy: DomainEntityRef?
    /** Version number required for updates. */
    public var version: Int?
    /** The status code of WhatsApp Integration activation process */
    public var activationStatusCode: ActivationStatusCode?
    /** The error information of WhatsApp Integration activation process */
    public var activationErrorInfo: ErrorBody?
    /** Status of asynchronous create operation */
    public var createStatus: CreateStatus?
    /** Error information returned, if createStatus is set to Error */
    public var createError: ErrorBody?
    /** The WhatsApp Business Account Id (WABA Id) */
    public var whatsAppBusinessAccountId: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, supportedContent: SupportedContentReference?, messagingSetting: MessagingSettingReference?, phoneNumber: String?, availablePhoneNumbers: WhatsAppAvailablePhoneNumberDetailsListing?, status: Status?, recipient: DomainEntityRef?, dateCreated: Date?, dateModified: Date?, createdBy: DomainEntityRef?, modifiedBy: DomainEntityRef?, version: Int?, activationStatusCode: ActivationStatusCode?, activationErrorInfo: ErrorBody?, createStatus: CreateStatus?, createError: ErrorBody?, whatsAppBusinessAccountId: String?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.supportedContent = supportedContent
        self.messagingSetting = messagingSetting
        self.phoneNumber = phoneNumber
        self.availablePhoneNumbers = availablePhoneNumbers
        self.status = status
        self.recipient = recipient
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.createdBy = createdBy
        self.modifiedBy = modifiedBy
        self.version = version
        self.activationStatusCode = activationStatusCode
        self.activationErrorInfo = activationErrorInfo
        self.createStatus = createStatus
        self.createError = createError
        self.whatsAppBusinessAccountId = whatsAppBusinessAccountId
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case supportedContent
        case messagingSetting
        case phoneNumber
        case availablePhoneNumbers
        case status
        case recipient
        case dateCreated
        case dateModified
        case createdBy
        case modifiedBy
        case version
        case activationStatusCode
        case activationErrorInfo
        case createStatus
        case createError
        case whatsAppBusinessAccountId
        case selfUri
    }


}




public class WhatsAppIntegrationRequest: Codable {















    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The name of the WhatsApp Integration */
    public var name: String?
    /** Defines the SupportedContent profile configured for an integration */
    public var supportedContent: SupportedContentReference?
    /** Defines the message settings to be applied for this integration */
    public var messagingSetting: MessagingSettingRequestReference?
    /** The phone number associated to the whatsApp integration */
    public var phoneNumber: String?
    /** The waba(WhatsApp Business Manager) certificate associated to the WhatsApp integration phone number */
    public var wabaCertificate: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, supportedContent: SupportedContentReference?, messagingSetting: MessagingSettingRequestReference?, phoneNumber: String?, wabaCertificate: String?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.supportedContent = supportedContent
        self.messagingSetting = messagingSetting
        self.phoneNumber = phoneNumber
        self.wabaCertificate = wabaCertificate
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case supportedContent
        case messagingSetting
        case phoneNumber
        case wabaCertificate
        case selfUri
    }


}




public class WidgetDeployment: Codable {















    public enum ClientType: String, Codable { 
        case v1 = "v1"
        case v2 = "v2"
        case v1Http = "v1-http"
        case thirdParty = "third-party"
    }





    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** A human-readable description of this Deployment. */
    public var _description: String?
    /** When true, the customer members starting a chat must be authenticated by supplying their JWT to the create operation. */
    public var authenticationRequired: Bool?
    /** When true, all create chat operations using this Deployment will be rejected. */
    public var disabled: Bool?
    /** The URI of the Inbound Chat Flow to run when new chats are initiated under this Deployment. */
    public var flow: DomainEntityRef?
    /** The list of domains that are approved to use this Deployment; the list will be added to CORS headers for ease of web use. */
    public var allowedDomains: [String]?
    /** The type of display widget for which this Deployment is configured, which controls the administrator settings shown. */
    public var clientType: ClientType?
    /** The client configuration options that should be made available to the clients of this Deployment. */
    public var clientConfig: WidgetClientConfig?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, _description: String?, authenticationRequired: Bool?, disabled: Bool?, flow: DomainEntityRef?, allowedDomains: [String]?, clientType: ClientType?, clientConfig: WidgetClientConfig?, selfUri: String?) {
        self._id = _id
        self.name = name
        self._description = _description
        self.authenticationRequired = authenticationRequired
        self.disabled = disabled
        self.flow = flow
        self.allowedDomains = allowedDomains
        self.clientType = clientType
        self.clientConfig = clientConfig
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case _description = "description"
        case authenticationRequired
        case disabled
        case flow
        case allowedDomains
        case clientType
        case clientConfig
        case selfUri
    }


}




public class WorkPlan: Codable {

























































    public enum ShiftStartVarianceType: String, Codable { 
        case shiftStart = "ShiftStart"
        case shiftStartAndPaidDuration = "ShiftStartAndPaidDuration"
    }













    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** Whether the work plan is enabled for scheduling */
    public var enabled: Bool?
    /** Whether the work plan is valid or not */
    public var valid: Bool?
    /** Whether the weekly paid time constraint is enabled for this work plan */
    public var constrainWeeklyPaidTime: Bool?
    /** Whether the weekly paid time constraint is flexible for this work plan */
    public var flexibleWeeklyPaidTime: Bool?
    /** Exact weekly paid time in minutes for this work plan. Used if flexibleWeeklyPaidTime == false */
    public var weeklyExactPaidMinutes: Int?
    /** Minimum weekly paid time in minutes for this work plan. Used if flexibleWeeklyPaidTime == true */
    public var weeklyMinimumPaidMinutes: Int?
    /** Maximum weekly paid time in minutes for this work plan. Used if flexibleWeeklyPaidTime == true */
    public var weeklyMaximumPaidMinutes: Int?
    /** Whether paid time granularity is constrained for this work plan */
    public var constrainPaidTimeGranularity: Bool?
    /** Granularity in minutes allowed for shift paid time in this work plan. Used if constrainPaidTimeGranularity == true */
    public var paidTimeGranularityMinutes: Int?
    /** Whether the minimum time between shifts constraint is enabled for this work plan */
    public var constrainMinimumTimeBetweenShifts: Bool?
    /** Minimum time between shifts in minutes defined in this work plan. Used if constrainMinimumTimeBetweenShifts == true */
    public var minimumTimeBetweenShiftsMinutes: Int?
    /** Maximum number days in a week allowed to be scheduled for this work plan */
    public var maximumDays: Int?
    /** Minimum amount of consecutive non working minutes per week that agents who are assigned this work plan are allowed to have off */
    public var minimumConsecutiveNonWorkingMinutesPerWeek: Int?
    /** Whether to constrain the maximum consecutive working weekends */
    public var constrainMaximumConsecutiveWorkingWeekends: Bool?
    /** The maximum number of consecutive weekends that agents who are assigned to this work plan are allowed to work */
    public var maximumConsecutiveWorkingWeekends: Int?
    /** The minimum number of days that agents assigned to a work plan must work per week */
    public var minimumWorkingDaysPerWeek: Int?
    /** Whether to constrain the maximum consecutive working days */
    public var constrainMaximumConsecutiveWorkingDays: Bool?
    /** The maximum number of consecutive days that agents assigned to this work plan are allowed to work. Used if constrainMaximumConsecutiveWorkingDays == true */
    public var maximumConsecutiveWorkingDays: Int?
    /** The time period in minutes for the duration between the start times of two consecutive working days */
    public var minimumShiftStartDistanceMinutes: Int?
    /** Minimum days off in the planning period */
    public var minimumDaysOffPerPlanningPeriod: Int?
    /** Maximum days off in the planning period */
    public var maximumDaysOffPerPlanningPeriod: Int?
    /** Minimum paid minutes in the planning period */
    public var minimumPaidMinutesPerPlanningPeriod: Int?
    /** Maximum paid minutes in the planning period */
    public var maximumPaidMinutesPerPlanningPeriod: Int?
    /** Whether to constrain the maximum working weekends in the planning period */
    public var constrainMaximumWorkingWeekendsPerPlanningPeriod: Bool?
    /** Maximum working weekends in the planning period */
    public var maximumWorkingWeekendsPerPlanningPeriod: Int?
    /** Optional days to schedule for this work plan */
    public var optionalDays: SetWrapperDayOfWeek?
    /** This constraint ensures that an agent starts each workday within a user-defined time threshold */
    public var shiftStartVarianceType: ShiftStartVarianceType?
    /** Variance in minutes among start times of shifts in this work plan */
    public var shiftStartVariances: ListWrapperShiftStartVariance?
    /** Shifts in this work plan */
    public var shifts: [WorkPlanShift]?
    /** Agents in this work plan */
    public var agents: [DeletableUserReference]?
    /** Number of agents in this work plan */
    public var agentCount: Int?
    /** Version metadata for this work plan */
    public var metadata: WfmVersionedEntityMetadata?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, enabled: Bool?, valid: Bool?, constrainWeeklyPaidTime: Bool?, flexibleWeeklyPaidTime: Bool?, weeklyExactPaidMinutes: Int?, weeklyMinimumPaidMinutes: Int?, weeklyMaximumPaidMinutes: Int?, constrainPaidTimeGranularity: Bool?, paidTimeGranularityMinutes: Int?, constrainMinimumTimeBetweenShifts: Bool?, minimumTimeBetweenShiftsMinutes: Int?, maximumDays: Int?, minimumConsecutiveNonWorkingMinutesPerWeek: Int?, constrainMaximumConsecutiveWorkingWeekends: Bool?, maximumConsecutiveWorkingWeekends: Int?, minimumWorkingDaysPerWeek: Int?, constrainMaximumConsecutiveWorkingDays: Bool?, maximumConsecutiveWorkingDays: Int?, minimumShiftStartDistanceMinutes: Int?, minimumDaysOffPerPlanningPeriod: Int?, maximumDaysOffPerPlanningPeriod: Int?, minimumPaidMinutesPerPlanningPeriod: Int?, maximumPaidMinutesPerPlanningPeriod: Int?, constrainMaximumWorkingWeekendsPerPlanningPeriod: Bool?, maximumWorkingWeekendsPerPlanningPeriod: Int?, optionalDays: SetWrapperDayOfWeek?, shiftStartVarianceType: ShiftStartVarianceType?, shiftStartVariances: ListWrapperShiftStartVariance?, shifts: [WorkPlanShift]?, agents: [DeletableUserReference]?, agentCount: Int?, metadata: WfmVersionedEntityMetadata?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.enabled = enabled
        self.valid = valid
        self.constrainWeeklyPaidTime = constrainWeeklyPaidTime
        self.flexibleWeeklyPaidTime = flexibleWeeklyPaidTime
        self.weeklyExactPaidMinutes = weeklyExactPaidMinutes
        self.weeklyMinimumPaidMinutes = weeklyMinimumPaidMinutes
        self.weeklyMaximumPaidMinutes = weeklyMaximumPaidMinutes
        self.constrainPaidTimeGranularity = constrainPaidTimeGranularity
        self.paidTimeGranularityMinutes = paidTimeGranularityMinutes
        self.constrainMinimumTimeBetweenShifts = constrainMinimumTimeBetweenShifts
        self.minimumTimeBetweenShiftsMinutes = minimumTimeBetweenShiftsMinutes
        self.maximumDays = maximumDays
        self.minimumConsecutiveNonWorkingMinutesPerWeek = minimumConsecutiveNonWorkingMinutesPerWeek
        self.constrainMaximumConsecutiveWorkingWeekends = constrainMaximumConsecutiveWorkingWeekends
        self.maximumConsecutiveWorkingWeekends = maximumConsecutiveWorkingWeekends
        self.minimumWorkingDaysPerWeek = minimumWorkingDaysPerWeek
        self.constrainMaximumConsecutiveWorkingDays = constrainMaximumConsecutiveWorkingDays
        self.maximumConsecutiveWorkingDays = maximumConsecutiveWorkingDays
        self.minimumShiftStartDistanceMinutes = minimumShiftStartDistanceMinutes
        self.minimumDaysOffPerPlanningPeriod = minimumDaysOffPerPlanningPeriod
        self.maximumDaysOffPerPlanningPeriod = maximumDaysOffPerPlanningPeriod
        self.minimumPaidMinutesPerPlanningPeriod = minimumPaidMinutesPerPlanningPeriod
        self.maximumPaidMinutesPerPlanningPeriod = maximumPaidMinutesPerPlanningPeriod
        self.constrainMaximumWorkingWeekendsPerPlanningPeriod = constrainMaximumWorkingWeekendsPerPlanningPeriod
        self.maximumWorkingWeekendsPerPlanningPeriod = maximumWorkingWeekendsPerPlanningPeriod
        self.optionalDays = optionalDays
        self.shiftStartVarianceType = shiftStartVarianceType
        self.shiftStartVariances = shiftStartVariances
        self.shifts = shifts
        self.agents = agents
        self.agentCount = agentCount
        self.metadata = metadata
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case enabled
        case valid
        case constrainWeeklyPaidTime
        case flexibleWeeklyPaidTime
        case weeklyExactPaidMinutes
        case weeklyMinimumPaidMinutes
        case weeklyMaximumPaidMinutes
        case constrainPaidTimeGranularity
        case paidTimeGranularityMinutes
        case constrainMinimumTimeBetweenShifts
        case minimumTimeBetweenShiftsMinutes
        case maximumDays
        case minimumConsecutiveNonWorkingMinutesPerWeek
        case constrainMaximumConsecutiveWorkingWeekends
        case maximumConsecutiveWorkingWeekends
        case minimumWorkingDaysPerWeek
        case constrainMaximumConsecutiveWorkingDays
        case maximumConsecutiveWorkingDays
        case minimumShiftStartDistanceMinutes
        case minimumDaysOffPerPlanningPeriod
        case maximumDaysOffPerPlanningPeriod
        case minimumPaidMinutesPerPlanningPeriod
        case maximumPaidMinutesPerPlanningPeriod
        case constrainMaximumWorkingWeekendsPerPlanningPeriod
        case maximumWorkingWeekendsPerPlanningPeriod
        case optionalDays
        case shiftStartVarianceType
        case shiftStartVariances
        case shifts
        case agents
        case agentCount
        case metadata
        case selfUri
    }


}




public class WorkPlanActivity: Codable {

































    /** ID of the activity code associated with this activity */
    public var activityCodeId: String?
    /** Description of the activity */
    public var _description: String?
    /** Length of the activity in minutes */
    public var lengthMinutes: Int?
    /** Whether the start time of the activity is relative to the start time of the shift it belongs to */
    public var startTimeIsRelativeToShiftStart: Bool?
    /** Whether the start time of the activity is flexible */
    public var flexibleStartTime: Bool?
    /** Earliest activity start in offset minutes relative to shift start time if startTimeIsRelativeToShiftStart == true else its based on midnight. Used if flexibleStartTime == true */
    public var earliestStartTimeMinutes: Int?
    /** Latest activity start in offset minutes relative to shift start time if startTimeIsRelativeToShiftStart == true else its based on midnight. Used if flexibleStartTime == true */
    public var latestStartTimeMinutes: Int?
    /** Exact activity start in offset minutes relative to shift start time if startTimeIsRelativeToShiftStart == true else its based on midnight. Used if flexibleStartTime == false */
    public var exactStartTimeMinutes: Int?
    /** Increment in offset minutes that would contribute to different possible start times for the activity */
    public var startTimeIncrementMinutes: Int?
    /** Whether the activity is paid */
    public var countsAsPaidTime: Bool?
    /** Whether the activity duration is counted towards contiguous work time */
    public var countsAsContiguousWorkTime: Bool?
    /** The minimum duration between shift start and shift item (e.g., break or meal) start in minutes */
    public var minimumLengthFromShiftStartMinutes: Int?
    /** The minimum duration between shift item (e.g., break or meal) end and shift end in minutes */
    public var minimumLengthFromShiftEndMinutes: Int?
    /** ID of the activity. This is required only for the case of updating an existing activity */
    public var _id: String?
    /** If marked true for updating an existing activity, the activity will be permanently deleted */
    public var delete: Bool?
    /** ID of the activity in the context of work plan validation */
    public var validationId: String?

    public init(activityCodeId: String?, _description: String?, lengthMinutes: Int?, startTimeIsRelativeToShiftStart: Bool?, flexibleStartTime: Bool?, earliestStartTimeMinutes: Int?, latestStartTimeMinutes: Int?, exactStartTimeMinutes: Int?, startTimeIncrementMinutes: Int?, countsAsPaidTime: Bool?, countsAsContiguousWorkTime: Bool?, minimumLengthFromShiftStartMinutes: Int?, minimumLengthFromShiftEndMinutes: Int?, _id: String?, delete: Bool?, validationId: String?) {
        self.activityCodeId = activityCodeId
        self._description = _description
        self.lengthMinutes = lengthMinutes
        self.startTimeIsRelativeToShiftStart = startTimeIsRelativeToShiftStart
        self.flexibleStartTime = flexibleStartTime
        self.earliestStartTimeMinutes = earliestStartTimeMinutes
        self.latestStartTimeMinutes = latestStartTimeMinutes
        self.exactStartTimeMinutes = exactStartTimeMinutes
        self.startTimeIncrementMinutes = startTimeIncrementMinutes
        self.countsAsPaidTime = countsAsPaidTime
        self.countsAsContiguousWorkTime = countsAsContiguousWorkTime
        self.minimumLengthFromShiftStartMinutes = minimumLengthFromShiftStartMinutes
        self.minimumLengthFromShiftEndMinutes = minimumLengthFromShiftEndMinutes
        self._id = _id
        self.delete = delete
        self.validationId = validationId
    }

    public enum CodingKeys: String, CodingKey { 
        case activityCodeId
        case _description = "description"
        case lengthMinutes
        case startTimeIsRelativeToShiftStart
        case flexibleStartTime
        case earliestStartTimeMinutes
        case latestStartTimeMinutes
        case exactStartTimeMinutes
        case startTimeIncrementMinutes
        case countsAsPaidTime
        case countsAsContiguousWorkTime
        case minimumLengthFromShiftStartMinutes
        case minimumLengthFromShiftEndMinutes
        case _id = "id"
        case delete
        case validationId
    }


}




public class WorkPlanBidListResponse: Codable {



    public var entities: [WorkPlanBid]?

    public init(entities: [WorkPlanBid]?) {
        self.entities = entities
    }


}




public class WorkPlanConstraintMessage: Codable {

    public enum ModelType: String, Codable { 
        case activityEarliestStartTimeMinutesFromMidnight = "ActivityEarliestStartTimeMinutesFromMidnight"
        case activityEarliestStartTimeMinutesFromShiftStart = "ActivityEarliestStartTimeMinutesFromShiftStart"
        case activityLatestStartTimeMinutesFromMidnight = "ActivityLatestStartTimeMinutesFromMidnight"
        case activityLatestStartTimeMinutesFromShiftStart = "ActivityLatestStartTimeMinutesFromShiftStart"
        case activityMaximumLengthFromShiftEndMinutes = "ActivityMaximumLengthFromShiftEndMinutes"
        case activityMinimumLengthFromShiftEndMinutes = "ActivityMinimumLengthFromShiftEndMinutes"
        case activityMinimumLengthFromShiftStartMinutes = "ActivityMinimumLengthFromShiftStartMinutes"
        case activityStartTimeIncrementInMinutes = "ActivityStartTimeIncrementInMinutes"
        case planningPeriodMaximumDaysOff = "PlanningPeriodMaximumDaysOff"
        case planningPeriodMaximumPaidTimeMinutes = "PlanningPeriodMaximumPaidTimeMinutes"
        case planningPeriodMaximumWorkingWeekends = "PlanningPeriodMaximumWorkingWeekends"
        case planningPeriodMinimumDaysOff = "PlanningPeriodMinimumDaysOff"
        case planningPeriodMinimumPaidTimeMinutes = "PlanningPeriodMinimumPaidTimeMinutes"
        case shiftDayOffRule = "ShiftDayOffRule"
        case shiftEarliestStartTimeMinutesFromMidnight = "ShiftEarliestStartTimeMinutesFromMidnight"
        case shiftEarliestStopTimeMinutesFromMidnight = "ShiftEarliestStopTimeMinutesFromMidnight"
        case shiftLatestStartTimeMinutesFromMidnight = "ShiftLatestStartTimeMinutesFromMidnight"
        case shiftLatestStopTimeMinutesFromMidnight = "ShiftLatestStopTimeMinutesFromMidnight"
        case shiftMaximumContiguousTimeMinutes = "ShiftMaximumContiguousTimeMinutes"
        case shiftMaximumCountPerPlanningPeriod = "ShiftMaximumCountPerPlanningPeriod"
        case shiftMaximumPaidTimeMinutes = "ShiftMaximumPaidTimeMinutes"
        case shiftMinimumContiguousTimeMinutes = "ShiftMinimumContiguousTimeMinutes"
        case shiftMinimumCountPerPlanningPeriod = "ShiftMinimumCountPerPlanningPeriod"
        case shiftMinimumPaidTimeMinutes = "ShiftMinimumPaidTimeMinutes"
        case shiftStartTimeIncrementInMinutes = "ShiftStartTimeIncrementInMinutes"
        case shiftStartVarianceMaximumVarianceMinutes = "ShiftStartVarianceMaximumVarianceMinutes"
        case shiftStartVariancePaidDuration = "ShiftStartVariancePaidDuration"
        case workPlanMaximumConsecutiveWorkingDays = "WorkPlanMaximumConsecutiveWorkingDays"
        case workPlanMaximumConsecutiveWorkingWeekends = "WorkPlanMaximumConsecutiveWorkingWeekends"
        case workPlanMaximumWeeklyPaidTimeMinutes = "WorkPlanMaximumWeeklyPaidTimeMinutes"
        case workPlanMaximumWorkingDaysPerWeek = "WorkPlanMaximumWorkingDaysPerWeek"
        case workPlanMinimumConsecutiveNonWorkingTimePerWeekMinutes = "WorkPlanMinimumConsecutiveNonWorkingTimePerWeekMinutes"
        case workPlanMinimumInterShiftTimeMinutes = "WorkPlanMinimumInterShiftTimeMinutes"
        case workPlanMinimumShiftStartDistanceMinutes = "WorkPlanMinimumShiftStartDistanceMinutes"
        case workPlanMinimumWeeklyPaidTimeMinutes = "WorkPlanMinimumWeeklyPaidTimeMinutes"
        case workPlanMinimumWorkingDaysPerWeek = "WorkPlanMinimumWorkingDaysPerWeek"
        case workPlanOptionalDays = "WorkPlanOptionalDays"
        case workPlanPaidTimeGranularityMinutes = "WorkPlanPaidTimeGranularityMinutes"
    }



    /** Type of the work plan constraint in this message */
    public var type: ModelType?
    /** Arguments of the message that provide information about the constraint that is being conflicted with, such as the value of the constraint */
    public var arguments: [WorkPlanValidationMessageArgument]?

    public init(type: ModelType?, arguments: [WorkPlanValidationMessageArgument]?) {
        self.type = type
        self.arguments = arguments
    }


}




public class WorkPlanRotationAgentResponse: Codable {







    /** The user associated with this work plan rotation */
    public var user: UserReference?
    /** The date range to which this agent is effective in the work plan rotation */
    public var dateRange: DateRangeWithOptionalEnd?
    /** Start position of the work plan in the pattern for this agent in the work plan rotation. Position value starts from 0 */
    public var position: Int?

    public init(user: UserReference?, dateRange: DateRangeWithOptionalEnd?, position: Int?) {
        self.user = user
        self.dateRange = dateRange
        self.position = position
    }


}




public class WorkPlanRotationResponse: Codable {



















    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** Whether the work plan rotation is enabled for scheduling */
    public var enabled: Bool?
    /** The date range to which this work plan rotation applies */
    public var dateRange: DateRangeWithOptionalEnd?
    /** Pattern with ordered list of work plans that rotate on a weekly basis */
    public var pattern: WorkPlanPatternResponse?
    /** Number of agents in this work plan rotation */
    public var agentCount: Int?
    /** Agents in this work plan rotation. Populate with expand=agents for GET WorkPlanRotationsList (defaults to empty list) */
    public var agents: [WorkPlanRotationAgentResponse]?
    /** Version metadata for this work plan rotation */
    public var metadata: WfmVersionedEntityMetadata?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, enabled: Bool?, dateRange: DateRangeWithOptionalEnd?, pattern: WorkPlanPatternResponse?, agentCount: Int?, agents: [WorkPlanRotationAgentResponse]?, metadata: WfmVersionedEntityMetadata?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.enabled = enabled
        self.dateRange = dateRange
        self.pattern = pattern
        self.agentCount = agentCount
        self.agents = agents
        self.metadata = metadata
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case enabled
        case dateRange
        case pattern
        case agentCount
        case agents
        case metadata
        case selfUri
    }


}




public class WorkPlanShift: Codable {









































    public enum DayOffRule: String, Codable { 
        case nextDayOff = "NextDayOff"
        case previousDayOff = "PreviousDayOff"
    }











    /** Name of the shift */
    public var name: String?
    /** Days of the week applicable for this shift */
    public var days: SetWrapperDayOfWeek?
    /** Whether the start time of the shift is flexible */
    public var flexibleStartTime: Bool?
    /** Exact start time of the shift defined as offset minutes from midnight. Used if flexibleStartTime == false */
    public var exactStartTimeMinutesFromMidnight: Int?
    /** Earliest start time of the shift defined as offset minutes from midnight. Used if flexibleStartTime == true */
    public var earliestStartTimeMinutesFromMidnight: Int?
    /** Latest start time of the shift defined as offset minutes from midnight. Used if flexibleStartTime == true */
    public var latestStartTimeMinutesFromMidnight: Int?
    /** Whether the latest stop time constraint for the shift is enabled.  Deprecated, use constrainLatestStopTime instead */
    public var constrainStopTime: Bool?
    /** Whether the latest stop time constraint for the shift is enabled */
    public var constrainLatestStopTime: Bool?
    /** Latest stop time of the shift defined as offset minutes from midnight. Used if constrainStopTime == true */
    public var latestStopTimeMinutesFromMidnight: Int?
    /** Whether the earliest stop time constraint for the shift is enabled */
    public var constrainEarliestStopTime: Bool?
    /** This is the earliest time a shift can end */
    public var earliestStopTimeMinutesFromMidnight: Int?
    /** Increment in offset minutes that would contribute to different possible start times for the shift. Used if flexibleStartTime == true */
    public var startIncrementMinutes: Int?
    /** Whether the paid time setting for the shift is flexible */
    public var flexiblePaidTime: Bool?
    /** Exact paid time in minutes configured for the shift. Used if flexiblePaidTime == false */
    public var exactPaidTimeMinutes: Int?
    /** Minimum paid time in minutes configured for the shift. Used if flexiblePaidTime == true */
    public var minimumPaidTimeMinutes: Int?
    /** Maximum paid time in minutes configured for the shift. Used if flexiblePaidTime == true */
    public var maximumPaidTimeMinutes: Int?
    /** Whether the contiguous time constraint for the shift is enabled */
    public var constrainContiguousWorkTime: Bool?
    /** Minimum contiguous time in minutes configured for the shift. Used if constrainContiguousWorkTime == true */
    public var minimumContiguousWorkTimeMinutes: Int?
    /** Maximum contiguous time in minutes configured for the shift. Used if constrainContiguousWorkTime == true */
    public var maximumContiguousWorkTimeMinutes: Int?
    /** Whether day off rule is enabled */
    public var constrainDayOff: Bool?
    /** The day off rule for agents to have next day off or previous day off. used if constrainDayOff = true */
    public var dayOffRule: DayOffRule?
    /** Planning period constraints */
    public var planningPeriodConstraints: PlanningPeriodShiftConstraints?
    /** Activities configured for this shift */
    public var activities: [WorkPlanActivity]?
    /** ID of the shift. This is required only for the case of updating an existing shift */
    public var _id: String?
    /** If marked true for updating an existing shift, the shift will be permanently deleted */
    public var delete: Bool?
    /** ID of shift in the context of work plan validation */
    public var validationId: String?

    public init(name: String?, days: SetWrapperDayOfWeek?, flexibleStartTime: Bool?, exactStartTimeMinutesFromMidnight: Int?, earliestStartTimeMinutesFromMidnight: Int?, latestStartTimeMinutesFromMidnight: Int?, constrainStopTime: Bool?, constrainLatestStopTime: Bool?, latestStopTimeMinutesFromMidnight: Int?, constrainEarliestStopTime: Bool?, earliestStopTimeMinutesFromMidnight: Int?, startIncrementMinutes: Int?, flexiblePaidTime: Bool?, exactPaidTimeMinutes: Int?, minimumPaidTimeMinutes: Int?, maximumPaidTimeMinutes: Int?, constrainContiguousWorkTime: Bool?, minimumContiguousWorkTimeMinutes: Int?, maximumContiguousWorkTimeMinutes: Int?, constrainDayOff: Bool?, dayOffRule: DayOffRule?, planningPeriodConstraints: PlanningPeriodShiftConstraints?, activities: [WorkPlanActivity]?, _id: String?, delete: Bool?, validationId: String?) {
        self.name = name
        self.days = days
        self.flexibleStartTime = flexibleStartTime
        self.exactStartTimeMinutesFromMidnight = exactStartTimeMinutesFromMidnight
        self.earliestStartTimeMinutesFromMidnight = earliestStartTimeMinutesFromMidnight
        self.latestStartTimeMinutesFromMidnight = latestStartTimeMinutesFromMidnight
        self.constrainStopTime = constrainStopTime
        self.constrainLatestStopTime = constrainLatestStopTime
        self.latestStopTimeMinutesFromMidnight = latestStopTimeMinutesFromMidnight
        self.constrainEarliestStopTime = constrainEarliestStopTime
        self.earliestStopTimeMinutesFromMidnight = earliestStopTimeMinutesFromMidnight
        self.startIncrementMinutes = startIncrementMinutes
        self.flexiblePaidTime = flexiblePaidTime
        self.exactPaidTimeMinutes = exactPaidTimeMinutes
        self.minimumPaidTimeMinutes = minimumPaidTimeMinutes
        self.maximumPaidTimeMinutes = maximumPaidTimeMinutes
        self.constrainContiguousWorkTime = constrainContiguousWorkTime
        self.minimumContiguousWorkTimeMinutes = minimumContiguousWorkTimeMinutes
        self.maximumContiguousWorkTimeMinutes = maximumContiguousWorkTimeMinutes
        self.constrainDayOff = constrainDayOff
        self.dayOffRule = dayOffRule
        self.planningPeriodConstraints = planningPeriodConstraints
        self.activities = activities
        self._id = _id
        self.delete = delete
        self.validationId = validationId
    }

    public enum CodingKeys: String, CodingKey { 
        case name
        case days
        case flexibleStartTime
        case exactStartTimeMinutesFromMidnight
        case earliestStartTimeMinutesFromMidnight
        case latestStartTimeMinutesFromMidnight
        case constrainStopTime
        case constrainLatestStopTime
        case latestStopTimeMinutesFromMidnight
        case constrainEarliestStopTime
        case earliestStopTimeMinutesFromMidnight
        case startIncrementMinutes
        case flexiblePaidTime
        case exactPaidTimeMinutes
        case minimumPaidTimeMinutes
        case maximumPaidTimeMinutes
        case constrainContiguousWorkTime
        case minimumContiguousWorkTimeMinutes
        case maximumContiguousWorkTimeMinutes
        case constrainDayOff
        case dayOffRule
        case planningPeriodConstraints
        case activities
        case _id = "id"
        case delete
        case validationId
    }


}




public class WorkPlanValidationRequest: Codable {

























































    public enum ShiftStartVarianceType: String, Codable { 
        case shiftStart = "ShiftStart"
        case shiftStartAndPaidDuration = "ShiftStartAndPaidDuration"
    }











    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** Whether the work plan is enabled for scheduling */
    public var enabled: Bool?
    /** Whether the work plan is valid or not */
    public var valid: Bool?
    /** Whether the weekly paid time constraint is enabled for this work plan */
    public var constrainWeeklyPaidTime: Bool?
    /** Whether the weekly paid time constraint is flexible for this work plan */
    public var flexibleWeeklyPaidTime: Bool?
    /** Exact weekly paid time in minutes for this work plan. Used if flexibleWeeklyPaidTime == false */
    public var weeklyExactPaidMinutes: Int?
    /** Minimum weekly paid time in minutes for this work plan. Used if flexibleWeeklyPaidTime == true */
    public var weeklyMinimumPaidMinutes: Int?
    /** Maximum weekly paid time in minutes for this work plan. Used if flexibleWeeklyPaidTime == true */
    public var weeklyMaximumPaidMinutes: Int?
    /** Whether paid time granularity is constrained for this work plan */
    public var constrainPaidTimeGranularity: Bool?
    /** Granularity in minutes allowed for shift paid time in this work plan. Used if constrainPaidTimeGranularity == true */
    public var paidTimeGranularityMinutes: Int?
    /** Whether the minimum time between shifts constraint is enabled for this work plan */
    public var constrainMinimumTimeBetweenShifts: Bool?
    /** Minimum time between shifts in minutes defined in this work plan. Used if constrainMinimumTimeBetweenShifts == true */
    public var minimumTimeBetweenShiftsMinutes: Int?
    /** Maximum number days in a week allowed to be scheduled for this work plan */
    public var maximumDays: Int?
    /** Minimum amount of consecutive non working minutes per week that agents who are assigned this work plan are allowed to have off */
    public var minimumConsecutiveNonWorkingMinutesPerWeek: Int?
    /** Whether to constrain the maximum consecutive working weekends */
    public var constrainMaximumConsecutiveWorkingWeekends: Bool?
    /** The maximum number of consecutive weekends that agents who are assigned to this work plan are allowed to work */
    public var maximumConsecutiveWorkingWeekends: Int?
    /** The minimum number of days that agents assigned to a work plan must work per week */
    public var minimumWorkingDaysPerWeek: Int?
    /** Whether to constrain the maximum consecutive working days */
    public var constrainMaximumConsecutiveWorkingDays: Bool?
    /** The maximum number of consecutive days that agents assigned to this work plan are allowed to work. Used if constrainMaximumConsecutiveWorkingDays == true */
    public var maximumConsecutiveWorkingDays: Int?
    /** The time period in minutes for the duration between the start times of two consecutive working days */
    public var minimumShiftStartDistanceMinutes: Int?
    /** Minimum days off in the planning period */
    public var minimumDaysOffPerPlanningPeriod: Int?
    /** Maximum days off in the planning period */
    public var maximumDaysOffPerPlanningPeriod: Int?
    /** Minimum paid minutes in the planning period */
    public var minimumPaidMinutesPerPlanningPeriod: Int?
    /** Maximum paid minutes in the planning period */
    public var maximumPaidMinutesPerPlanningPeriod: Int?
    /** Whether to constrain the maximum working weekends in the planning period */
    public var constrainMaximumWorkingWeekendsPerPlanningPeriod: Bool?
    /** Maximum working weekends in the planning period */
    public var maximumWorkingWeekendsPerPlanningPeriod: Int?
    /** Optional days to schedule for this work plan */
    public var optionalDays: SetWrapperDayOfWeek?
    /** This constraint ensures that an agent starts each workday within a user-defined time threshold */
    public var shiftStartVarianceType: ShiftStartVarianceType?
    /** Variance in minutes among start times of shifts in this work plan */
    public var shiftStartVariances: ListWrapperShiftStartVariance?
    /** Shifts in this work plan */
    public var shifts: [WorkPlanShift]?
    /** Agents in this work plan */
    public var agents: [DeletableUserReference]?
    /** Number of agents in this work plan */
    public var agentCount: Int?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, enabled: Bool?, valid: Bool?, constrainWeeklyPaidTime: Bool?, flexibleWeeklyPaidTime: Bool?, weeklyExactPaidMinutes: Int?, weeklyMinimumPaidMinutes: Int?, weeklyMaximumPaidMinutes: Int?, constrainPaidTimeGranularity: Bool?, paidTimeGranularityMinutes: Int?, constrainMinimumTimeBetweenShifts: Bool?, minimumTimeBetweenShiftsMinutes: Int?, maximumDays: Int?, minimumConsecutiveNonWorkingMinutesPerWeek: Int?, constrainMaximumConsecutiveWorkingWeekends: Bool?, maximumConsecutiveWorkingWeekends: Int?, minimumWorkingDaysPerWeek: Int?, constrainMaximumConsecutiveWorkingDays: Bool?, maximumConsecutiveWorkingDays: Int?, minimumShiftStartDistanceMinutes: Int?, minimumDaysOffPerPlanningPeriod: Int?, maximumDaysOffPerPlanningPeriod: Int?, minimumPaidMinutesPerPlanningPeriod: Int?, maximumPaidMinutesPerPlanningPeriod: Int?, constrainMaximumWorkingWeekendsPerPlanningPeriod: Bool?, maximumWorkingWeekendsPerPlanningPeriod: Int?, optionalDays: SetWrapperDayOfWeek?, shiftStartVarianceType: ShiftStartVarianceType?, shiftStartVariances: ListWrapperShiftStartVariance?, shifts: [WorkPlanShift]?, agents: [DeletableUserReference]?, agentCount: Int?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.enabled = enabled
        self.valid = valid
        self.constrainWeeklyPaidTime = constrainWeeklyPaidTime
        self.flexibleWeeklyPaidTime = flexibleWeeklyPaidTime
        self.weeklyExactPaidMinutes = weeklyExactPaidMinutes
        self.weeklyMinimumPaidMinutes = weeklyMinimumPaidMinutes
        self.weeklyMaximumPaidMinutes = weeklyMaximumPaidMinutes
        self.constrainPaidTimeGranularity = constrainPaidTimeGranularity
        self.paidTimeGranularityMinutes = paidTimeGranularityMinutes
        self.constrainMinimumTimeBetweenShifts = constrainMinimumTimeBetweenShifts
        self.minimumTimeBetweenShiftsMinutes = minimumTimeBetweenShiftsMinutes
        self.maximumDays = maximumDays
        self.minimumConsecutiveNonWorkingMinutesPerWeek = minimumConsecutiveNonWorkingMinutesPerWeek
        self.constrainMaximumConsecutiveWorkingWeekends = constrainMaximumConsecutiveWorkingWeekends
        self.maximumConsecutiveWorkingWeekends = maximumConsecutiveWorkingWeekends
        self.minimumWorkingDaysPerWeek = minimumWorkingDaysPerWeek
        self.constrainMaximumConsecutiveWorkingDays = constrainMaximumConsecutiveWorkingDays
        self.maximumConsecutiveWorkingDays = maximumConsecutiveWorkingDays
        self.minimumShiftStartDistanceMinutes = minimumShiftStartDistanceMinutes
        self.minimumDaysOffPerPlanningPeriod = minimumDaysOffPerPlanningPeriod
        self.maximumDaysOffPerPlanningPeriod = maximumDaysOffPerPlanningPeriod
        self.minimumPaidMinutesPerPlanningPeriod = minimumPaidMinutesPerPlanningPeriod
        self.maximumPaidMinutesPerPlanningPeriod = maximumPaidMinutesPerPlanningPeriod
        self.constrainMaximumWorkingWeekendsPerPlanningPeriod = constrainMaximumWorkingWeekendsPerPlanningPeriod
        self.maximumWorkingWeekendsPerPlanningPeriod = maximumWorkingWeekendsPerPlanningPeriod
        self.optionalDays = optionalDays
        self.shiftStartVarianceType = shiftStartVarianceType
        self.shiftStartVariances = shiftStartVariances
        self.shifts = shifts
        self.agents = agents
        self.agentCount = agentCount
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case enabled
        case valid
        case constrainWeeklyPaidTime
        case flexibleWeeklyPaidTime
        case weeklyExactPaidMinutes
        case weeklyMinimumPaidMinutes
        case weeklyMaximumPaidMinutes
        case constrainPaidTimeGranularity
        case paidTimeGranularityMinutes
        case constrainMinimumTimeBetweenShifts
        case minimumTimeBetweenShiftsMinutes
        case maximumDays
        case minimumConsecutiveNonWorkingMinutesPerWeek
        case constrainMaximumConsecutiveWorkingWeekends
        case maximumConsecutiveWorkingWeekends
        case minimumWorkingDaysPerWeek
        case constrainMaximumConsecutiveWorkingDays
        case maximumConsecutiveWorkingDays
        case minimumShiftStartDistanceMinutes
        case minimumDaysOffPerPlanningPeriod
        case maximumDaysOffPerPlanningPeriod
        case minimumPaidMinutesPerPlanningPeriod
        case maximumPaidMinutesPerPlanningPeriod
        case constrainMaximumWorkingWeekendsPerPlanningPeriod
        case maximumWorkingWeekendsPerPlanningPeriod
        case optionalDays
        case shiftStartVarianceType
        case shiftStartVariances
        case shifts
        case agents
        case agentCount
        case selfUri
    }


}




public class WorkbinChangeListing: Codable {











    public var entities: [WorkitemsChangeWorkbinDelta]?
    public var nextUri: String?
    public var selfUri: String?
    public var previousUri: String?
    public var after: String?

    public init(entities: [WorkitemsChangeWorkbinDelta]?, nextUri: String?, selfUri: String?, previousUri: String?, after: String?) {
        self.entities = entities
        self.nextUri = nextUri
        self.selfUri = selfUri
        self.previousUri = previousUri
        self.after = after
    }


}




public class WorkbinVersion: Codable {



















    /** The globally unique identifier for the object. */
    public var _id: String?
    /** Workbin name */
    public var name: String?
    /** The division to which this entity belongs. */
    public var division: Division?
    /** Workbin description */
    public var _description: String?
    /** The creation date of the Workbin. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** The modified date of the Workbin. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** The id of the User who modified the Workbin. */
    public var modifiedBy: UserReference?
    /** Version */
    public var version: Int?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, division: Division?, _description: String?, dateCreated: Date?, dateModified: Date?, modifiedBy: UserReference?, version: Int?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.division = division
        self._description = _description
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.modifiedBy = modifiedBy
        self.version = version
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case division
        case _description = "description"
        case dateCreated
        case dateModified
        case modifiedBy
        case version
        case selfUri
    }


}




public class WorkbinVersionListing: Codable {











    public var entities: [WorkbinVersion]?
    public var nextUri: String?
    public var selfUri: String?
    public var previousUri: String?
    public var after: String?

    public init(entities: [WorkbinVersion]?, nextUri: String?, selfUri: String?, previousUri: String?, after: String?) {
        self.entities = entities
        self.nextUri = nextUri
        self.selfUri = selfUri
        self.previousUri = previousUri
        self.after = after
    }


}




public class WorkdayMetric: Codable {















    /** Gamification metric */
    public var metric: Metric?
    /** Current objective for this metric */
    public var objective: Objective?
    /** Gamification points earned for this metric */
    public var points: Int?
    /** The maximum Gamification points a user may earn for this metric */
    public var maxPoints: Int?
    /** Value of this metric */
    public var value: Double?
    /** List of schedule activity events for punctuality metrics */
    public var punctualityEvents: [PunctualityEvent]?
    /** List of evaluations for quality evaluation score metrics */
    public var evaluationDetails: [QualityEvaluationScoreItem]?

    public init(metric: Metric?, objective: Objective?, points: Int?, maxPoints: Int?, value: Double?, punctualityEvents: [PunctualityEvent]?, evaluationDetails: [QualityEvaluationScoreItem]?) {
        self.metric = metric
        self.objective = objective
        self.points = points
        self.maxPoints = maxPoints
        self.value = value
        self.punctualityEvents = punctualityEvents
        self.evaluationDetails = evaluationDetails
    }


}




public class WorkdayMetricListing: Codable {



    public var entities: [WorkdayMetric]?

    public init(entities: [WorkdayMetric]?) {
        self.entities = entities
    }


}




public class WorkdayValuesTrendItem: Codable {





    /** The workday for the metric value. Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd */
    public var dateWorkday: Date?
    /** The metric value */
    public var value: Double?

    public init(dateWorkday: Date?, value: Double?) {
        self.dateWorkday = dateWorkday
        self.value = value
    }


}




public class WorkitemDateBasedRule: Codable {





    public enum ModelType: String, Codable { 
        case onCreate = "OnCreate"
        case onAttributeChange = "OnAttributeChange"
        case date = "Date"
    }









    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** The type of the rule. */
    public var type: ModelType?
    /** The rules action. If the condition criteria is met this action will be executed. */
    public var action: WorkitemRuleAction?
    /** The Worktype containing the rule. */
    public var worktype: WorktypeReference?
    /** The rules condition. If the condition criteria is met the rules action will be executed. */
    public var condition: WorkitemDateBasedCondition?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, type: ModelType?, action: WorkitemRuleAction?, worktype: WorktypeReference?, condition: WorkitemDateBasedCondition?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.type = type
        self.action = action
        self.worktype = worktype
        self.condition = condition
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case type
        case action
        case worktype
        case condition
        case selfUri
    }


}




public class WorkitemDateBasedRuleListing: Codable {











    public var entities: [WorkitemDateBasedRule]?
    public var nextUri: String?
    public var selfUri: String?
    public var previousUri: String?
    public var after: String?

    public init(entities: [WorkitemDateBasedRule]?, nextUri: String?, selfUri: String?, previousUri: String?, after: String?) {
        self.entities = entities
        self.nextUri = nextUri
        self.selfUri = selfUri
        self.previousUri = previousUri
        self.after = after
    }


}




public class WorkitemFilter: Codable {



    public enum ModelType: String, Codable { 
        case string = "String"
        case int = "Int"
    }

    public enum Operator: String, Codable { 
        case eq = "EQ"
        case neq = "NEQ"
        case gt = "GT"
        case lt = "LT"
        case gte = "GTE"
        case lte = "LTE"
        case _in = "IN"
        case contains = "CONTAINS"
        case between = "BETWEEN"
        case beginsWith = "BEGINS_WITH"
    }



    /** Attribute name. */
    public var name: String?
    /** Attribute type. */
    public var type: ModelType?
    /** Filter operator. */
    public var _operator: Operator?
    /** List of values to be used in the filter. */
    public var values: [String]?

    public init(name: String?, type: ModelType?, _operator: Operator?, values: [String]?) {
        self.name = name
        self.type = type
        self._operator = _operator
        self.values = values
    }

    public enum CodingKeys: String, CodingKey { 
        case name
        case type
        case _operator = "operator"
        case values
    }


}




public class WorkitemFlowReference: Codable {







    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case selfUri
    }


}




public class WorkitemManualAssign: Codable {



    /** The globally unique identifier for this user. */
    public var _id: String?

    public init(_id: String?) {
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
    }


}




public class WorkitemOnAttributeChangeCondition: Codable {

    public enum Attribute: String, Codable { 
        case statusid = "statusId"
    }





    /** The name of the workitem attribute whose change will be evaluated as part of the rule. */
    public var attribute: Attribute?
    /** The new value of the attribute. If the attribute is updated to this value this part of the condition will be met. */
    public var newValue: String?
    /** The old value of the attribute. If the attribute was updated from this value this part of the condition will be met. */
    public var oldValue: String?

    public init(attribute: Attribute?, newValue: String?, oldValue: String?) {
        self.attribute = attribute
        self.newValue = newValue
        self.oldValue = oldValue
    }


}




public class WorkitemOnCreateRuleCreate: Codable {



    /** The name of the rule. */
    public var name: String?

    public init(name: String?) {
        self.name = name
    }


}




public class WorkitemOnCreateRuleUpdate: Codable {



    /** The name of the rule. */
    public var name: String?

    public init(name: String?) {
        self.name = name
    }


}




public class WorkitemQueryJobError: Codable {





    /** System defined error code for the error. */
    public var code: String?
    /** Error message for the failed job. */
    public var message: String?

    public init(code: String?, message: String?) {
        self.code = code
        self.message = message
    }


}




public class WorkitemQueryJobQueryFiltersCriteria: Codable {

    public enum Operator: String, Codable { 
        case and = "AND"
        case or = "OR"
    }



    /** Query filter logical operator to join predicates. */
    public var _operator: Operator?
    /** Query filter predicates. Number of predicates within the query filter should be between 1 and 5. */
    public var predicates: [WorkitemQueryJobQueryFiltersPredicate]?

    public init(_operator: Operator?, predicates: [WorkitemQueryJobQueryFiltersPredicate]?) {
        self._operator = _operator
        self.predicates = predicates
    }

    public enum CodingKeys: String, CodingKey { 
        case _operator = "operator"
        case predicates
    }


}




public class WorkitemQueryJobResponse: Codable {



    public enum State: String, Codable { 
        case queued = "Queued"
        case running = "Running"
        case succeeded = "Succeeded"
        case failed = "Failed"
    }









    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The state of the query job */
    public var state: State?
    /** The date the job was started. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateStarted: Date?
    /** The date the job finished. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateFinished: Date?
    /** The error associated with the query job, if the state is Failed */
    public var error: WorkitemQueryJobError?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, state: State?, dateStarted: Date?, dateFinished: Date?, error: WorkitemQueryJobError?, selfUri: String?) {
        self._id = _id
        self.state = state
        self.dateStarted = dateStarted
        self.dateFinished = dateFinished
        self.error = error
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case state
        case dateStarted
        case dateFinished
        case error
        case selfUri
    }


}




public class WorkitemRuleAction: Codable {

    public enum ModelType: String, Codable { 
        case launchFlow = "LaunchFlow"
    }

    public var type: ModelType?

    public init(type: ModelType?) {
        self.type = type
    }


}




public class WorkitemStatus: Codable {





    public enum Category: String, Codable { 
        case _open = "Open"
        case inProgress = "InProgress"
        case waiting = "Waiting"
        case closed = "Closed"
        case unknown = "Unknown"
    }

















    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** The Category of the Status. */
    public var category: Category?
    /** The Statuses the Status can transition to. */
    public var destinationStatuses: [WorkitemStatusReference]?
    /** The description of the Status. */
    public var _description: String?
    /** Default destination status to which this Status will transition to if auto status transition enabled. */
    public var defaultDestinationStatus: WorkitemStatusReference?
    /** Delay in seconds for auto status transition */
    public var statusTransitionDelaySeconds: Int?
    /** Time is represented as an ISO-8601 string without a timezone. For example: HH:mm:ss.SSS */
    public var statusTransitionTime: String?
    /** The Worktype containing the Status. */
    public var worktype: WorktypeReference?
    /** Terminate workitem on selection of status. Applicable only for statuses in the Closed category. */
    public var autoTerminateWorkitem: Bool?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, category: Category?, destinationStatuses: [WorkitemStatusReference]?, _description: String?, defaultDestinationStatus: WorkitemStatusReference?, statusTransitionDelaySeconds: Int?, statusTransitionTime: String?, worktype: WorktypeReference?, autoTerminateWorkitem: Bool?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.category = category
        self.destinationStatuses = destinationStatuses
        self._description = _description
        self.defaultDestinationStatus = defaultDestinationStatus
        self.statusTransitionDelaySeconds = statusTransitionDelaySeconds
        self.statusTransitionTime = statusTransitionTime
        self.worktype = worktype
        self.autoTerminateWorkitem = autoTerminateWorkitem
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case category
        case destinationStatuses
        case _description = "description"
        case defaultDestinationStatus
        case statusTransitionDelaySeconds
        case statusTransitionTime
        case worktype
        case autoTerminateWorkitem
        case selfUri
    }


}




public class WorkitemStatusListing: Codable {







    public var total: Int64?
    public var entities: [WorkitemStatus]?
    public var selfUri: String?

    public init(total: Int64?, entities: [WorkitemStatus]?, selfUri: String?) {
        self.total = total
        self.entities = entities
        self.selfUri = selfUri
    }


}




public class Wrapup: Codable {















    /** The user configured wrap up code id. */
    public var code: String?
    /** The user configured wrap up code name. */
    public var name: String?
    /** Text entered by the agent to describe the call or disposition. */
    public var notes: String?
    /** List of tags selected by the agent to describe the call or disposition. */
    public var tags: [String]?
    /** The length of time in seconds that the agent spent doing after call work. */
    public var durationSeconds: Int?
    /** The timestamp when the wrapup was finished. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var endTime: Date?
    /** Indicates if this is a pending save and should not require a code to be specified.  This allows someone to save some temporary wrapup that will be used later. */
    public var provisional: Bool?

    public init(code: String?, name: String?, notes: String?, tags: [String]?, durationSeconds: Int?, endTime: Date?, provisional: Bool?) {
        self.code = code
        self.name = name
        self.notes = notes
        self.tags = tags
        self.durationSeconds = durationSeconds
        self.endTime = endTime
        self.provisional = provisional
    }


}




public class WorkitemWrapup: Codable {











    /** Workitem that the wrapup code has been added to. */
    public var workitem: WorkitemReference?
    /** The wrapup code used in the workitem. */
    public var wrapupCode: WrapupIdReference?
    /** The user who added the wrapup code to the workitem. */
    public var modifiedBy: UserReference?
    /** The user for whom wrapup code was added. This may be the same as modifiedBy. */
    public var user: UserReference?
    /** The modified date of the Workitem when the wrapup code was added. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?

    public init(workitem: WorkitemReference?, wrapupCode: WrapupIdReference?, modifiedBy: UserReference?, user: UserReference?, dateModified: Date?) {
        self.workitem = workitem
        self.wrapupCode = wrapupCode
        self.modifiedBy = modifiedBy
        self.user = user
        self.dateModified = dateModified
    }


}




public class WorkitemsAttributeChangeBoolean: Codable {





    /** New property value */
    public var newValue: Bool?
    /** Old property value */
    public var oldValue: Bool?

    public init(newValue: Bool?, oldValue: Bool?) {
        self.newValue = newValue
        self.oldValue = oldValue
    }


}




public class WorkitemsAttributeChangeWorkitemStatusCategory: Codable {

    public enum NewValue: String, Codable { 
        case _open = "Open"
        case inProgress = "InProgress"
        case waiting = "Waiting"
        case closed = "Closed"
        case unknown = "Unknown"
    }

    public enum OldValue: String, Codable { 
        case _open = "Open"
        case inProgress = "InProgress"
        case waiting = "Waiting"
        case closed = "Closed"
        case unknown = "Unknown"
    }

    /** New property value */
    public var newValue: NewValue?
    /** Old property value */
    public var oldValue: OldValue?

    public init(newValue: NewValue?, oldValue: OldValue?) {
        self.newValue = newValue
        self.oldValue = oldValue
    }


}




public class WorkitemsAttributeChangeWrapupDelta: Codable {





    /** New property value */
    public var newValue: WrapupDelta?
    /** Old property value */
    public var oldValue: WrapupDelta?

    public init(newValue: WrapupDelta?, oldValue: WrapupDelta?) {
        self.newValue = newValue
        self.oldValue = oldValue
    }


}




public class WorkitemsChangeWorkbinDelta: Codable {







    /** Version */
    public var version: Int?
    /** modifiedBy */
    public var modifiedBy: UserReference?
    /** The changes that originated this version */
    public var delta: WorkbinDelta?

    public init(version: Int?, modifiedBy: UserReference?, delta: WorkbinDelta?) {
        self.version = version
        self.modifiedBy = modifiedBy
        self.delta = delta
    }


}




public class WorkitemsEventsNotificationDelta: Codable {

    public enum Op: String, Codable { 
        case add = "add"
        case remove = "remove"
        case replace = "replace"
        case unknown = "unknown"
    }







    public var op: Op?
    public var field: String?
    public var oldValue: String?
    public var newValue: String?

    public init(op: Op?, field: String?, oldValue: String?, newValue: String?) {
        self.op = op
        self.field = field
        self.oldValue = oldValue
        self.newValue = newValue
    }


}




public class WorkitemsEventsNotificationSession: Codable {

    public enum ModelType: String, Codable { 
        case unknown = "Unknown"
        case agent = "Agent"
        case queueAssignment = "QueueAssignment"
        case directAssignment = "DirectAssignment"
        case agentComplete = "AgentComplete"
    }



    public enum Status: String, Codable { 
        case unknown = "Unknown"
        case active = "Active"
        case completed = "Completed"
    }







    public var type: ModelType?
    public var _id: UUID?
    public var status: Status?
    public var dateSessionStart: String?
    public var dateSessionEnd: String?
    public var assignmentSegments: [WorkitemsEventsNotificationAssignmentSegment]?

    public init(type: ModelType?, _id: UUID?, status: Status?, dateSessionStart: String?, dateSessionEnd: String?, assignmentSegments: [WorkitemsEventsNotificationAssignmentSegment]?) {
        self.type = type
        self._id = _id
        self.status = status
        self.dateSessionStart = dateSessionStart
        self.dateSessionEnd = dateSessionEnd
        self.assignmentSegments = assignmentSegments
    }

    public enum CodingKeys: String, CodingKey { 
        case type
        case _id = "id"
        case status
        case dateSessionStart
        case dateSessionEnd
        case assignmentSegments
    }


}




public class WorkitemsEventsNotificationWorkitem: Codable {





























    public enum StatusCategory: String, Codable { 
        case unknown = "Unknown"
        case _open = "Open"
        case inProgress = "InProgress"
        case waiting = "Waiting"
        case closed = "Closed"
    }

















    public enum Operation: String, Codable { 
        case unknown = "unknown"
        case add = "add"
        case edit = "edit"
        case delete = "delete"
        case view = "view"
        case upload = "upload"
        case download = "download"
        case activate = "activate"
        case deactivate = "deactivate"
        case purge = "purge"
        case processed = "processed"
        case published = "published"
        case assigned = "assigned"
        case unassigned = "unassigned"
        case reset = "reset"
        case reassigned = "reassigned"
        case reassign = "reassign"
        case archive = "archive"
        case unarchive = "unarchive"
        case reschedule = "reschedule"
    }





    public enum AssignmentState: String, Codable { 
        case unknown = "Unknown"
        case idle = "Idle"
        case acdStarted = "AcdStarted"
        case alerting = "Alerting"
        case alertTimeout = "AlertTimeout"
        case declined = "Declined"
        case connected = "Connected"
        case disconnected = "Disconnected"
        case parked = "Parked"
        case held = "Held"
        case acdCancelled = "AcdCancelled"
        case terminated = "Terminated"
        case acdExpired = "AcdExpired"
    }





























    public var _id: String?
    public var name: String?
    public var typeId: String?
    public var _description: String?
    public var languageId: String?
    public var priority: Int64?
    public var dateCreated: String?
    public var dateModified: String?
    public var dateDue: String?
    public var dateExpires: String?
    public var dateAssignmentStateChanged: String?
    public var durationSeconds: Int64?
    public var ttl: Int64?
    public var statusId: String?
    public var statusCategory: StatusCategory?
    public var dateClosed: String?
    public var workbinId: String?
    public var reporterId: String?
    public var assigneeId: String?
    public var externalContactId: String?
    public var externalTag: String?
    public var wrapupId: String?
    public var modifiedBy: String?
    public var operation: Operation?
    public var changes: [WorkitemsEventsNotificationDelta]?
    public var propertyChanges: [WorkitemsEventsNotificationPropertyChange]?
    public var assignmentState: AssignmentState?
    public var assignmentId: String?
    public var alertTimeoutSeconds: Int64?
    public var queueId: String?
    public var customFields: [String:WorkitemsEventsNotificationCustomAttribute]?
    public var wrapup: WorkitemsEventsNotificationWrapup?
    public var sessions: [WorkitemsEventsNotificationSession]?
    public var skillIds: [UUID]?
    public var scriptId: String?
    public var workbinName: String?
    public var typeName: String?
    public var preferredAgentIds: [UUID]?
    public var divisionId: String?
    public var scoredAgents: [WorkitemsEventsNotificationScoredAgent]?
    public var utilizationLabelId: String?

    public init(_id: String?, name: String?, typeId: String?, _description: String?, languageId: String?, priority: Int64?, dateCreated: String?, dateModified: String?, dateDue: String?, dateExpires: String?, dateAssignmentStateChanged: String?, durationSeconds: Int64?, ttl: Int64?, statusId: String?, statusCategory: StatusCategory?, dateClosed: String?, workbinId: String?, reporterId: String?, assigneeId: String?, externalContactId: String?, externalTag: String?, wrapupId: String?, modifiedBy: String?, operation: Operation?, changes: [WorkitemsEventsNotificationDelta]?, propertyChanges: [WorkitemsEventsNotificationPropertyChange]?, assignmentState: AssignmentState?, assignmentId: String?, alertTimeoutSeconds: Int64?, queueId: String?, customFields: [String:WorkitemsEventsNotificationCustomAttribute]?, wrapup: WorkitemsEventsNotificationWrapup?, sessions: [WorkitemsEventsNotificationSession]?, skillIds: [UUID]?, scriptId: String?, workbinName: String?, typeName: String?, preferredAgentIds: [UUID]?, divisionId: String?, scoredAgents: [WorkitemsEventsNotificationScoredAgent]?, utilizationLabelId: String?) {
        self._id = _id
        self.name = name
        self.typeId = typeId
        self._description = _description
        self.languageId = languageId
        self.priority = priority
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.dateDue = dateDue
        self.dateExpires = dateExpires
        self.dateAssignmentStateChanged = dateAssignmentStateChanged
        self.durationSeconds = durationSeconds
        self.ttl = ttl
        self.statusId = statusId
        self.statusCategory = statusCategory
        self.dateClosed = dateClosed
        self.workbinId = workbinId
        self.reporterId = reporterId
        self.assigneeId = assigneeId
        self.externalContactId = externalContactId
        self.externalTag = externalTag
        self.wrapupId = wrapupId
        self.modifiedBy = modifiedBy
        self.operation = operation
        self.changes = changes
        self.propertyChanges = propertyChanges
        self.assignmentState = assignmentState
        self.assignmentId = assignmentId
        self.alertTimeoutSeconds = alertTimeoutSeconds
        self.queueId = queueId
        self.customFields = customFields
        self.wrapup = wrapup
        self.sessions = sessions
        self.skillIds = skillIds
        self.scriptId = scriptId
        self.workbinName = workbinName
        self.typeName = typeName
        self.preferredAgentIds = preferredAgentIds
        self.divisionId = divisionId
        self.scoredAgents = scoredAgents
        self.utilizationLabelId = utilizationLabelId
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case typeId
        case _description = "description"
        case languageId
        case priority
        case dateCreated
        case dateModified
        case dateDue
        case dateExpires
        case dateAssignmentStateChanged
        case durationSeconds
        case ttl
        case statusId
        case statusCategory
        case dateClosed
        case workbinId
        case reporterId
        case assigneeId
        case externalContactId
        case externalTag
        case wrapupId
        case modifiedBy
        case operation
        case changes
        case propertyChanges
        case assignmentState
        case assignmentId
        case alertTimeoutSeconds
        case queueId
        case customFields
        case wrapup
        case sessions
        case skillIds
        case scriptId
        case workbinName
        case typeName
        case preferredAgentIds
        case divisionId
        case scoredAgents
        case utilizationLabelId
    }


}




public class WorkitemsQueueEventsNotificationCustomAttribute: Codable {

    public enum DataType: String, Codable { 
        case unknown = "unknown"
        case string = "string"
        case number = "number"
        case boolean_ = "boolean$"
        case integer = "integer"
    }



    public var dataType: DataType?
    public var value: String?

    public init(dataType: DataType?, value: String?) {
        self.dataType = dataType
        self.value = value
    }


}




public class WorkitemsQueueEventsNotificationScoredAgent: Codable {





    public var _id: UUID?
    public var score: Int64?

    public init(_id: UUID?, score: Int64?) {
        self._id = _id
        self.score = score
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case score
    }


}




public class WorkitemsUserEventsNotificationDelta: Codable {

    public enum Op: String, Codable { 
        case add = "add"
        case remove = "remove"
        case replace = "replace"
        case unknown = "unknown"
    }







    public var op: Op?
    public var field: String?
    public var oldValue: String?
    public var newValue: String?

    public init(op: Op?, field: String?, oldValue: String?, newValue: String?) {
        self.op = op
        self.field = field
        self.oldValue = oldValue
        self.newValue = newValue
    }


}




public class WorkitemsUserEventsNotificationSession: Codable {

    public enum ModelType: String, Codable { 
        case unknown = "Unknown"
        case agent = "Agent"
        case queueAssignment = "QueueAssignment"
        case directAssignment = "DirectAssignment"
        case agentComplete = "AgentComplete"
    }



    public enum Status: String, Codable { 
        case unknown = "Unknown"
        case active = "Active"
        case completed = "Completed"
    }







    public var type: ModelType?
    public var _id: UUID?
    public var status: Status?
    public var dateSessionStart: String?
    public var dateSessionEnd: String?
    public var assignmentSegments: [WorkitemsUserEventsNotificationAssignmentSegment]?

    public init(type: ModelType?, _id: UUID?, status: Status?, dateSessionStart: String?, dateSessionEnd: String?, assignmentSegments: [WorkitemsUserEventsNotificationAssignmentSegment]?) {
        self.type = type
        self._id = _id
        self.status = status
        self.dateSessionStart = dateSessionStart
        self.dateSessionEnd = dateSessionEnd
        self.assignmentSegments = assignmentSegments
    }

    public enum CodingKeys: String, CodingKey { 
        case type
        case _id = "id"
        case status
        case dateSessionStart
        case dateSessionEnd
        case assignmentSegments
    }


}




public class WorkitemsUserEventsNotificationWorkitem: Codable {





























    public enum StatusCategory: String, Codable { 
        case unknown = "Unknown"
        case _open = "Open"
        case inProgress = "InProgress"
        case waiting = "Waiting"
        case closed = "Closed"
    }

















    public enum Operation: String, Codable { 
        case unknown = "unknown"
        case add = "add"
        case edit = "edit"
        case delete = "delete"
        case view = "view"
        case upload = "upload"
        case download = "download"
        case activate = "activate"
        case deactivate = "deactivate"
        case purge = "purge"
        case processed = "processed"
        case published = "published"
        case assigned = "assigned"
        case unassigned = "unassigned"
        case reset = "reset"
        case reassigned = "reassigned"
        case reassign = "reassign"
        case archive = "archive"
        case unarchive = "unarchive"
        case reschedule = "reschedule"
    }





    public enum AssignmentState: String, Codable { 
        case unknown = "Unknown"
        case idle = "Idle"
        case acdStarted = "AcdStarted"
        case alerting = "Alerting"
        case alertTimeout = "AlertTimeout"
        case declined = "Declined"
        case connected = "Connected"
        case disconnected = "Disconnected"
        case parked = "Parked"
        case held = "Held"
        case acdCancelled = "AcdCancelled"
        case terminated = "Terminated"
        case acdExpired = "AcdExpired"
    }





























    public var _id: String?
    public var name: String?
    public var typeId: String?
    public var _description: String?
    public var languageId: String?
    public var priority: Int64?
    public var dateCreated: String?
    public var dateModified: String?
    public var dateDue: String?
    public var dateExpires: String?
    public var dateAssignmentStateChanged: String?
    public var durationSeconds: Int64?
    public var ttl: Int64?
    public var statusId: String?
    public var statusCategory: StatusCategory?
    public var dateClosed: String?
    public var workbinId: String?
    public var reporterId: String?
    public var assigneeId: String?
    public var externalContactId: String?
    public var externalTag: String?
    public var wrapupId: String?
    public var modifiedBy: String?
    public var operation: Operation?
    public var changes: [WorkitemsUserEventsNotificationDelta]?
    public var propertyChanges: [WorkitemsUserEventsNotificationPropertyChange]?
    public var assignmentState: AssignmentState?
    public var assignmentId: String?
    public var alertTimeoutSeconds: Int64?
    public var queueId: String?
    public var customFields: [String:WorkitemsUserEventsNotificationCustomAttribute]?
    public var wrapup: WorkitemsUserEventsNotificationWrapup?
    public var sessions: [WorkitemsUserEventsNotificationSession]?
    public var skillIds: [UUID]?
    public var scriptId: String?
    public var workbinName: String?
    public var typeName: String?
    public var preferredAgentIds: [UUID]?
    public var divisionId: String?
    public var scoredAgents: [WorkitemsUserEventsNotificationScoredAgent]?
    public var utilizationLabelId: String?

    public init(_id: String?, name: String?, typeId: String?, _description: String?, languageId: String?, priority: Int64?, dateCreated: String?, dateModified: String?, dateDue: String?, dateExpires: String?, dateAssignmentStateChanged: String?, durationSeconds: Int64?, ttl: Int64?, statusId: String?, statusCategory: StatusCategory?, dateClosed: String?, workbinId: String?, reporterId: String?, assigneeId: String?, externalContactId: String?, externalTag: String?, wrapupId: String?, modifiedBy: String?, operation: Operation?, changes: [WorkitemsUserEventsNotificationDelta]?, propertyChanges: [WorkitemsUserEventsNotificationPropertyChange]?, assignmentState: AssignmentState?, assignmentId: String?, alertTimeoutSeconds: Int64?, queueId: String?, customFields: [String:WorkitemsUserEventsNotificationCustomAttribute]?, wrapup: WorkitemsUserEventsNotificationWrapup?, sessions: [WorkitemsUserEventsNotificationSession]?, skillIds: [UUID]?, scriptId: String?, workbinName: String?, typeName: String?, preferredAgentIds: [UUID]?, divisionId: String?, scoredAgents: [WorkitemsUserEventsNotificationScoredAgent]?, utilizationLabelId: String?) {
        self._id = _id
        self.name = name
        self.typeId = typeId
        self._description = _description
        self.languageId = languageId
        self.priority = priority
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.dateDue = dateDue
        self.dateExpires = dateExpires
        self.dateAssignmentStateChanged = dateAssignmentStateChanged
        self.durationSeconds = durationSeconds
        self.ttl = ttl
        self.statusId = statusId
        self.statusCategory = statusCategory
        self.dateClosed = dateClosed
        self.workbinId = workbinId
        self.reporterId = reporterId
        self.assigneeId = assigneeId
        self.externalContactId = externalContactId
        self.externalTag = externalTag
        self.wrapupId = wrapupId
        self.modifiedBy = modifiedBy
        self.operation = operation
        self.changes = changes
        self.propertyChanges = propertyChanges
        self.assignmentState = assignmentState
        self.assignmentId = assignmentId
        self.alertTimeoutSeconds = alertTimeoutSeconds
        self.queueId = queueId
        self.customFields = customFields
        self.wrapup = wrapup
        self.sessions = sessions
        self.skillIds = skillIds
        self.scriptId = scriptId
        self.workbinName = workbinName
        self.typeName = typeName
        self.preferredAgentIds = preferredAgentIds
        self.divisionId = divisionId
        self.scoredAgents = scoredAgents
        self.utilizationLabelId = utilizationLabelId
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case typeId
        case _description = "description"
        case languageId
        case priority
        case dateCreated
        case dateModified
        case dateDue
        case dateExpires
        case dateAssignmentStateChanged
        case durationSeconds
        case ttl
        case statusId
        case statusCategory
        case dateClosed
        case workbinId
        case reporterId
        case assigneeId
        case externalContactId
        case externalTag
        case wrapupId
        case modifiedBy
        case operation
        case changes
        case propertyChanges
        case assignmentState
        case assignmentId
        case alertTimeoutSeconds
        case queueId
        case customFields
        case wrapup
        case sessions
        case skillIds
        case scriptId
        case workbinName
        case typeName
        case preferredAgentIds
        case divisionId
        case scoredAgents
        case utilizationLabelId
    }


}




public class WorkspaceCreate: Codable {







    /** The workspace name */
    public var name: String?
    public var bucket: String?
    public var _description: String?

    public init(name: String?, bucket: String?, _description: String?) {
        self.name = name
        self.bucket = bucket
        self._description = _description
    }

    public enum CodingKeys: String, CodingKey { 
        case name
        case bucket
        case _description = "description"
    }


}




public class Worktype: Codable {



















































    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The name of the Worktype. */
    public var name: String?
    /** The division to which this entity belongs. */
    public var division: Division?
    /** The description of the Worktype. */
    public var _description: String?
    /** The creation date of the Worktype. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** The modified date of the Worktype. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** The default Workbin for Workitems created from the Worktype. */
    public var defaultWorkbin: WorkbinReference?
    /** The default status for Workitems created from the Worktype. */
    public var defaultStatus: WorkitemStatusReference?
    /** The list of possible statuses for Workitems created from the Worktype. */
    public var statuses: [WorkitemStatus]?
    /** The default duration in seconds for Workitems created from the Worktype. */
    public var defaultDurationSeconds: Int?
    /** The default expiration time in seconds for Workitems created from the Worktype. */
    public var defaultExpirationSeconds: Int?
    /** The default due duration in seconds for Workitems created from the Worktype. */
    public var defaultDueDurationSeconds: Int?
    /** The default priority for Workitems created from the Worktype. The valid range is between -25,000,000 and 25,000,000. */
    public var defaultPriority: Int?
    /** The default language for Workitems created from the Worktype. */
    public var defaultLanguage: LanguageReference?
    /** The default time to time to live in seconds for Workitems created from the Worktype. */
    public var defaultTtlSeconds: Int?
    /** The id of the User who modified the Worktype. */
    public var modifiedBy: UserReference?
    /** The default queue for Workitems created from the Worktype. */
    public var defaultQueue: WorkitemQueueReference?
    /** The default skills for Workitems created from the Worktype. */
    public var defaultSkills: [RoutingSkillReference]?
    /** When set to true, Workitems will be sent to the queue of the Worktype as they are created. Default value is false. */
    public var assignmentEnabled: Bool?
    /** The schema defining the custom attributes for Workitems created from the Worktype. */
    public var schema: WorkitemSchema?
    /** The target service level for Workitems created from the Worktype. The default value is 100. */
    public var serviceLevelTarget: Int?
    /** Settings for the worktypes rules. */
    public var ruleSettings: WorkitemRuleSettings?
    /** The flow associated with the Worktype. */
    public var flow: WorkitemFlowReference?
    /** The default script for Workitems created from the Worktype. */
    public var defaultScript: WorkitemScriptReference?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, division: Division?, _description: String?, dateCreated: Date?, dateModified: Date?, defaultWorkbin: WorkbinReference?, defaultStatus: WorkitemStatusReference?, statuses: [WorkitemStatus]?, defaultDurationSeconds: Int?, defaultExpirationSeconds: Int?, defaultDueDurationSeconds: Int?, defaultPriority: Int?, defaultLanguage: LanguageReference?, defaultTtlSeconds: Int?, modifiedBy: UserReference?, defaultQueue: WorkitemQueueReference?, defaultSkills: [RoutingSkillReference]?, assignmentEnabled: Bool?, schema: WorkitemSchema?, serviceLevelTarget: Int?, ruleSettings: WorkitemRuleSettings?, flow: WorkitemFlowReference?, defaultScript: WorkitemScriptReference?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.division = division
        self._description = _description
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.defaultWorkbin = defaultWorkbin
        self.defaultStatus = defaultStatus
        self.statuses = statuses
        self.defaultDurationSeconds = defaultDurationSeconds
        self.defaultExpirationSeconds = defaultExpirationSeconds
        self.defaultDueDurationSeconds = defaultDueDurationSeconds
        self.defaultPriority = defaultPriority
        self.defaultLanguage = defaultLanguage
        self.defaultTtlSeconds = defaultTtlSeconds
        self.modifiedBy = modifiedBy
        self.defaultQueue = defaultQueue
        self.defaultSkills = defaultSkills
        self.assignmentEnabled = assignmentEnabled
        self.schema = schema
        self.serviceLevelTarget = serviceLevelTarget
        self.ruleSettings = ruleSettings
        self.flow = flow
        self.defaultScript = defaultScript
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case division
        case _description = "description"
        case dateCreated
        case dateModified
        case defaultWorkbin
        case defaultStatus
        case statuses
        case defaultDurationSeconds
        case defaultExpirationSeconds
        case defaultDueDurationSeconds
        case defaultPriority
        case defaultLanguage
        case defaultTtlSeconds
        case modifiedBy
        case defaultQueue
        case defaultSkills
        case assignmentEnabled
        case schema
        case serviceLevelTarget
        case ruleSettings
        case flow
        case defaultScript
        case selfUri
    }


}




public class WorktypeDelta: Codable {















































    public var name: WorkitemsAttributeChangeString?
    public var _description: WorkitemsAttributeChangeString?
    public var statuses: WorkitemsAttributeChangeList?
    public var defaultWorkbinId: WorkitemsAttributeChangeString?
    public var defaultDurationSeconds: WorkitemsAttributeChangeInteger?
    public var defaultExpirationSeconds: WorkitemsAttributeChangeInteger?
    public var defaultDueDurationSeconds: WorkitemsAttributeChangeInteger?
    public var defaultPriority: WorkitemsAttributeChangeInteger?
    public var defaultSkillIds: WorkitemsAttributeChangeList?
    public var defaultStatusId: WorkitemsAttributeChangeString?
    public var defaultLanguageId: WorkitemsAttributeChangeString?
    public var defaultTtlSeconds: WorkitemsAttributeChangeInteger?
    public var assignmentEnabled: WorkitemsAttributeChangeBoolean?
    public var defaultQueueId: WorkitemsAttributeChangeString?
    public var schemaId: WorkitemsAttributeChangeString?
    public var schemaVersion: WorkitemsAttributeChangeString?
    public var serviceLevelTarget: WorkitemsAttributeChangeInteger?
    public var dateModified: WorkitemsAttributeChangeInstant?
    public var modifiedBy: WorkitemsAttributeChangeString?
    public var defaultScriptId: WorkitemsAttributeChangeString?
    public var flowId: WorkitemsAttributeChangeString?
    public var ruleSettings: WorkitemsAttributeChangeWorkitemRuleSettings?
    public var unassignedDivisionContactsEnabled: WorkitemsAttributeChangeBoolean?

    public init(name: WorkitemsAttributeChangeString?, _description: WorkitemsAttributeChangeString?, statuses: WorkitemsAttributeChangeList?, defaultWorkbinId: WorkitemsAttributeChangeString?, defaultDurationSeconds: WorkitemsAttributeChangeInteger?, defaultExpirationSeconds: WorkitemsAttributeChangeInteger?, defaultDueDurationSeconds: WorkitemsAttributeChangeInteger?, defaultPriority: WorkitemsAttributeChangeInteger?, defaultSkillIds: WorkitemsAttributeChangeList?, defaultStatusId: WorkitemsAttributeChangeString?, defaultLanguageId: WorkitemsAttributeChangeString?, defaultTtlSeconds: WorkitemsAttributeChangeInteger?, assignmentEnabled: WorkitemsAttributeChangeBoolean?, defaultQueueId: WorkitemsAttributeChangeString?, schemaId: WorkitemsAttributeChangeString?, schemaVersion: WorkitemsAttributeChangeString?, serviceLevelTarget: WorkitemsAttributeChangeInteger?, dateModified: WorkitemsAttributeChangeInstant?, modifiedBy: WorkitemsAttributeChangeString?, defaultScriptId: WorkitemsAttributeChangeString?, flowId: WorkitemsAttributeChangeString?, ruleSettings: WorkitemsAttributeChangeWorkitemRuleSettings?, unassignedDivisionContactsEnabled: WorkitemsAttributeChangeBoolean?) {
        self.name = name
        self._description = _description
        self.statuses = statuses
        self.defaultWorkbinId = defaultWorkbinId
        self.defaultDurationSeconds = defaultDurationSeconds
        self.defaultExpirationSeconds = defaultExpirationSeconds
        self.defaultDueDurationSeconds = defaultDueDurationSeconds
        self.defaultPriority = defaultPriority
        self.defaultSkillIds = defaultSkillIds
        self.defaultStatusId = defaultStatusId
        self.defaultLanguageId = defaultLanguageId
        self.defaultTtlSeconds = defaultTtlSeconds
        self.assignmentEnabled = assignmentEnabled
        self.defaultQueueId = defaultQueueId
        self.schemaId = schemaId
        self.schemaVersion = schemaVersion
        self.serviceLevelTarget = serviceLevelTarget
        self.dateModified = dateModified
        self.modifiedBy = modifiedBy
        self.defaultScriptId = defaultScriptId
        self.flowId = flowId
        self.ruleSettings = ruleSettings
        self.unassignedDivisionContactsEnabled = unassignedDivisionContactsEnabled
    }

    public enum CodingKeys: String, CodingKey { 
        case name
        case _description = "description"
        case statuses
        case defaultWorkbinId
        case defaultDurationSeconds
        case defaultExpirationSeconds
        case defaultDueDurationSeconds
        case defaultPriority
        case defaultSkillIds
        case defaultStatusId
        case defaultLanguageId
        case defaultTtlSeconds
        case assignmentEnabled
        case defaultQueueId
        case schemaId
        case schemaVersion
        case serviceLevelTarget
        case dateModified
        case modifiedBy
        case defaultScriptId
        case flowId
        case ruleSettings
        case unassignedDivisionContactsEnabled
    }


}




public class WrapUpCodeConfig: Codable {



    /** A set of valid Wrap Up Code UUIDs used to optimize a KPI. */
    public var values: [String]?

    public init(values: [String]?) {
        self.values = values
    }


}




public class WrapupDelta: Codable {

    public enum Action: String, Codable { 
        case add = "Add"
        case remove = "Remove"
    }





    public var action: Action?
    public var code: String?
    public var userId: String?

    public init(action: Action?, code: String?, userId: String?) {
        self.action = action
        self.code = code
        self.userId = userId
    }


}

